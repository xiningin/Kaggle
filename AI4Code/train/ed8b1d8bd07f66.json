{"cell_type":{"4a48c4af":"code","1ea12f0d":"code","81697b98":"code","2d897ee6":"code","852fadbc":"code","97bcc947":"code","29f6b680":"code","b470eb96":"code","2b464209":"code","7c2d2af5":"code","acbe9e7b":"code","b4b2d192":"code","7297cc8c":"code","928d4d5a":"code","d5535ad3":"code","70c74807":"code","61c0c3d7":"code","f06ab47f":"code","1a645713":"code","4ffe490d":"code","6948b56b":"markdown","307b4367":"markdown","435c04f8":"markdown","56e5e1f7":"markdown","05e7e628":"markdown","f58f4c9d":"markdown"},"source":{"4a48c4af":"!apt-get install -y -qq glpk-utils\n!pip install chama\n!pip install wntr","1ea12f0d":"import numpy as np\nimport pandas as pd\nimport matplotlib.pylab as plt\nimport chama\nimport wntr\nimport random","81697b98":"import wandb\nimport os\nos.environ[\"WANDB_API_KEY\"] = \"351cc1ebc0d966d49152a4c1937915dd4e7b4ef5\"\n\nwandb.login(key=\"351cc1ebc0d966d49152a4c1937915dd4e7b4ef5\")","2d897ee6":"wandb.init(project = \"Water Network\")","852fadbc":"import time\nimport math","97bcc947":"# Create a water network model\ninp_file = \"\/kaggle\/input\/waternetwork\/Example_1.inp\"\nwater_network = wntr.network.WaterNetworkModel(inp_file)","29f6b680":"# Run trace simulations (one from each junction) and extract data needed for \n# sensor placement optimization. You can run this step once, save the data to a \n# file, and reload the file for sensor placement\n\nscenario_names = water_network.node_name_list\nsim = wntr.sim.EpanetSimulator(water_network)\nsim.run_sim(save_hyd = True)\nwater_network.options.quality.parameter = 'TRACE'\nsignal = pd.DataFrame()\nfor inj_node in scenario_names:\n    # print(inj_node)\n    water_network.options.quality.trace_node = inj_node\n    sim_results = sim.run_sim(use_hyd = True)\n    trace = sim_results.node['quality']\n    trace = trace.stack()\n    trace = trace.reset_index()\n    trace.columns = ['T', 'Node', inj_node]\n    signal = signal.combine_first(trace)\n\n# Define feasible sensors using location, sample times, and detection threshold\nsensor_names = water_network.junction_name_list\nsample_times = np.arange(0, water_network.options.time.duration, water_network.options.time.hydraulic_timestep)\nundetected_impact = sample_times.max()*1.5\n\ndf_dummy = pd.DataFrame({'Scenario': scenario_names,\n                         'Sensor': 'DUMMY_SENSOR_UNDETECTED',\n                         'Impact': undetected_impact})\nthreshold = 1e-5\n# threshold = 20\nsensors = {}\nfor location in sensor_names:\n    position = chama.sensors.Stationary(location)\n    detector = chama.sensors.Point(threshold, sample_times)\n    stationary_pt_sensor = chama.sensors.Sensor(position, detector)\n    sensors[location] = stationary_pt_sensor\n\n# Extract minimum detection time for each scenario-sensor pair\ndet_times = chama.impact.extract_detection_times(signal, sensors)\ndet_time_stats = chama.impact.detection_time_stats(det_times)\nmin_det_time = det_time_stats[['Scenario','Sensor','Min']]\nmin_det_time.rename(columns = {'Min':'Impact'}, inplace = True)","b470eb96":"global l_dummy_scenario\nglobal l_dummy_sensor\nglobal l_dummy_impact\nl_dummy_scenario = df_dummy[\"Scenario\"].tolist()\nl_dummy_sensor = df_dummy[\"Sensor\"].tolist()\nl_dummy_impact = df_dummy[\"Impact\"].tolist()","2b464209":"global min_det_time_scenario\nglobal min_det_time_sensor\nglobal min_det_time_impact\nmin_det_time_scenario = min_det_time[\"Scenario\"].tolist()\nmin_det_time_sensor =  min_det_time[\"Sensor\"].tolist()\nmin_det_time_impact = min_det_time[\"Impact\"].tolist()","7c2d2af5":"def detection_time(impact, selected_sensors):\n    l_scenario = []\n    l_impact = []\n    for index, sensor in enumerate(min_det_time_sensor):\n        if sensor in selected_sensors:\n            l_scenario.append(min_det_time_scenario[index])\n            l_impact.append(min_det_time_impact[index])\n    \n    l_scenario.extend(l_dummy_scenario)\n    l_impact.extend(l_dummy_impact)\n\n    dict_scenario = [math.inf for i in range(len(l_dummy_scenario))]\n    for index, scenario in enumerate(l_scenario):\n        detection_time_per_scenario = l_impact[index]\n        index_dummy = l_dummy_scenario.index(scenario)\n        if detection_time_per_scenario < dict_scenario[index_dummy]:\n            dict_scenario[index_dummy] = detection_time_per_scenario\n    result = np.mean(dict_scenario) \n    return result\n    \n\n## Debug\nresult = detection_time(min_det_time, ['JUNCTION-17', 'JUNCTION-112', 'JUNCTION-120', 'JUNCTION-83', 'JUNCTION-87'])\nprint(result)","acbe9e7b":"# def detection_time_test(impact, selected_sensors):\n#     time_s_test = time.time()\n#     impact_for_selected = impact[impact[\"Sensor\"].isin(selected_sensors)]\n#     impact_for_selected = impact_for_selected.append(df_dummy)\n#     result = impact_for_selected.groupby(\"Scenario\")[\"Impact\"].min().mean() \n#     print(\"Time dataframe detection: \", time.time() - time_s_test)\n#     return result\n    \n\n# ## Debug\n# result = detection_time_test(min_det_time, ['JUNCTION-17', 'JUNCTION-112', 'JUNCTION-120', 'JUNCTION-83', 'JUNCTION-87'])\n# print(result)","b4b2d192":"def covered_scenario(impact, selected_sensors, coverage_time=7200):\n    N = len(sensor_names)\n    _impact = impact.set_index([\"Scenario\", \"Sensor\"])\n    scenario_sensor_pairs = _impact.index.to_list()\n    T = coverage_time\n    y = 0\n\n    for scenario in scenario_names:\n        for ss in selected_sensors:\n            if ((scenario, ss) in scenario_sensor_pairs) and (_impact[\"Impact\"].loc[scenario, ss] <= T):\n                y += 1\n                break\n    result = (N - y) * 288 \/ (N * (N - 1))\n    return result\n\nselected_sensors = [\"JUNCTION-19\", \"JUNCTION-20\", \"JUNCTION-23\", \"JUNCTION-34\", \"JUNCTION-118\"]\nprint(covered_scenario(min_det_time, selected_sensors))","7297cc8c":"class Population:       # qu\u1ea7n th\u1ec3\n    def __init__(self, water_network, size_of_population, num_available_sensors, method, list_individuals) -> None:\n        self.water_network = water_network\n        self.scenario_names = water_network.node_name_list\n        self.sensor_names = water_network.junction_name_list\n        self.num_sensors = len(self.sensor_names)\n        self.size_of_population = size_of_population\n        self.num_available_sensors = num_available_sensors\n        self.method = method\n        self.list_individuals = list_individuals\n        self.best_individual = None\n        self.best_sensors = None\n        self.score = 0\n        self.parents = []\n\n\n    def choosed_sensors(self, individual):      # from idx -> list sensor\n        try:\n            _choosed = [self.sensor_names[i] for i in individual]\n        except:\n            print(individual)\n            input()\n        return _choosed\n\n    # \u0111\u1ed9t bi\u1ebfn\n    def mutate(self, individual):\n        def _mutate():\n            new_sensor = random.choice(range(self.num_sensors))\n            while new_sensor in individual:\n                new_sensor = random.choice(range(self.num_sensors))\n            idx = np.random.randint(len(individual))\n            individual[idx] = new_sensor\n            individual.sort()\n            return individual\n\n        _new = _mutate()\n        return _new\n\n    def evaluate(self):\n        times = np.asarray([ self.method(min_det_time, self.choosed_sensors(individual)) for individual in self.list_individuals])\n        self.score = np.min(times)\n       \n        self.best_individual = self.list_individuals[times.tolist().index(self.score)]\n        \n        self.best_sensors = self.choosed_sensors(self.best_individual)\n        self.parents.append(self.best_individual)\n        if False in (times[0] == times):\n            distances = np.max(times) - times\n        return times \/ np.sum(times)\n\n\n    def select(self, num_parents):\n        fit = self.evaluate()\n        while len(self.parents) < num_parents:\n            idx = np.random.randint(0, self.size_of_population)\n            if fit[idx] > np.random.uniform(0, 1\/self.size_of_population, size=(1,))[0]:\n                self.parents.append(self.list_individuals[idx])\n\n        self.parents = np.asarray(self.parents)\n\n    def crossover(self, p_cross=0.75):\n        def cross():\n            id1, id2 = np.random.choice(len(self.parents), size=2, replace=False)\n            parent1, parent2 = self.parents[id1], self.parents[id2]\n            # print(\"P1:  \", parent1)\n            # print(\"P2:  \", parent2)\n            idx = np.random.choice(range(self.num_available_sensors), size=2, replace=False)\n            start, end = min(idx), max(idx)\n            child = [None] * self.num_available_sensors\n            for i in range(start, end + 1, 1):\n                child[i] = parent1[i]\n\n            pointer = 0\n            for i in range(self.num_available_sensors):\n                if child[i] is None:\n                    while parent2[pointer] in child:\n                        pointer += 1\n                    child[i] = parent2[pointer]\n\n            child.sort()\n            return child\n            \n        children = []\n        count = len(self.parents)\n        for _ in range(self.size_of_population):\n            if np.random.rand() > p_cross:\n                _tmp = random.choice(self.parents)\n                children.append(_tmp)\n                \n            else:\n                child = cross()\n                children.append(child)\n\n        # print(children)\n        return children\n\n    def next_population(self, p_cross=0.75, p_mutate=0.1):\n        _best_individual = self.best_individual\n        \n        _next = []\n        children = self.crossover(p_cross)\n        for child in children:\n            # print(child.selected_sensors)\n            if np.random.rand() < p_mutate:\n                # print(\"mutate\")\n                child_mutate = self.mutate(child)\n                # print(child_mutate)\n                if self.method(min_det_time, self.choosed_sensors(_best_individual))  >  self.method(min_det_time, self.choosed_sensors(child_mutate)):\n                    _next.append(child_mutate)\n                else:\n                    _next.append(_best_individual)\n                    _best_individual = child_mutate\n\n            else:\n                # print(\"un_mutate\")\n                # print(child)\n                if self.method(min_det_time, self.choosed_sensors(_best_individual))  >  self.method(min_det_time, self.choosed_sensors(child)):\n                    _next.append(child)\n                else:\n                    _next.append(_best_individual)\n                    _best_individual = child\n\n        if(self.best_individual not in _next):\n            _next[-1] = self.best_individual\n        return _next\n\n\ndef init_population(water_network, size_of_population, num_available_sensors, method):\n    # kh\u1edfi t\u1ea1o 1 c\u00e1 th\u1ec3 ng\u1eabu nhi\u00ean\n    def init_individual(sensor_names, num_available_sensors):\n        \n        individual = np.random.choice(range(len(sensor_names)), size=num_available_sensors, replace=False)\n        individual.sort()\n        return individual\n\n    sensor_names = water_network.junction_name_list\n    population = []\n    for id in range(0, size_of_population):\n        population.append( init_individual(sensor_names, num_available_sensors) )\n    return Population(water_network, size_of_population, num_available_sensors, method, population )","928d4d5a":"# pop = init_population(water_network, 2000, 5, detection_time)\n# best_sensors = pop.best_sensors","d5535ad3":"# time_s = time.time()\n# pop.select(2000 * 0.15)a\n# print(time.time()- time_s)","70c74807":"# time_s = time.time()\n# children = pop.next_population(0.75, 0.1)\n# print(\"Time next population\", time.time() - time_s)\n# # pop = Population(water_network, size_of_population, num_available_sensors, method, children)","61c0c3d7":"def genetic_algorithm(\n    water_network,\n    size_of_population,\n    num_available_sensors,\n    method,\n    selectivity=0.15,\n    n_iter=2000,\n    p_cross=0.75,\n    p_mut=0.1,\n    print_interval=100,\n    return_history=False,\n    verbose=False,\n):\n    pop = init_population(water_network, size_of_population, num_available_sensors, method)\n    best_sensors = pop.best_sensors\n    score = float(\"inf\")\n    history = []\n    for i in range(n_iter):\n        pop.select(size_of_population * selectivity)\n        # print(pop.parents)\n        history.append(pop.score)\n        wandb.log({\"Score\": pop.score, \"iter\": i})\n        if verbose:\n            print(f\"Generation {i}: {pop.score}\")\n        elif i % print_interval == 0:\n            print(f\"Generation {i}: {pop.score}\")\n        if pop.score < score:\n            best_sensors = pop.best_sensors\n            score = pop.score\n\n        children = pop.next_population(p_cross, p_mut)\n        pop = Population(water_network, size_of_population, num_available_sensors, method, children)\n    if return_history:\n        return best_sensors, score, history\n    return best_sensors, score","f06ab47f":"time_s = time.time()\nbest, score, history = genetic_algorithm(\n    water_network,\n    size_of_population=2000,\n    num_available_sensors=5,\n    method=detection_time,\n    n_iter=1000,\n    print_interval=5,\n    verbose=True,\n    return_history=True\n)\nprint(\"GA time: \", time.time() - time_s)\nplt.plot(range(len(history)), history, color=\"blue\")\nplt.show()","1a645713":"# best, score, history = genetic_algorithm(\n#     water_network,\n#     size_of_population=2000,\n#     num_available_sensors=5,\n#     method=covered_scenario,\n#     n_iter=1000,\n#     print_interval=5,\n#     verbose=True,\n#     return_history=True\n# )\n# plt.plot(range(len(history)), history, color=\"blue\")\n# plt.show()","4ffe490d":"# best, score, history = genetic_algorithm(\n#     water_network,\n#     size_of_population=2000,\n#     num_available_sensors=5,\n#     n_iter=250,\n#     print_interval=5,\n#     verbose=True,\n#     return_history=True\n# )\n# plt.plot(range(len(history)), history, color=\"blue\")\n# plt.show()","6948b56b":"#test","307b4367":"#Input","435c04f8":"#Install and import","56e5e1f7":"#genetic algorithm","05e7e628":"# F1: Maximum dectect node","f58f4c9d":"# Z1: Min_detection_time"}}