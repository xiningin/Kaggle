{"cell_type":{"5911ce54":"code","83f8a31c":"code","5fe4e5bc":"code","7ac3e48a":"code","78ec96cb":"code","2c8bbcb3":"code","77d1531a":"code","6418306f":"code","df42f557":"code","a62799d2":"code","541119ba":"code","d22354d0":"code","34664c81":"code","de4ac009":"code","92c0d6e4":"code","c3e552d1":"code","f8f22c07":"code","4ca82d36":"code","881f1815":"code","a70a3c9e":"code","46c4464e":"code","56112928":"code","5f0587fb":"code","22a831f0":"code","ddfa9c13":"code","19e20358":"code","65380bac":"code","3a4cabd0":"code","f3990665":"code","efa712e8":"code","1e7d345e":"code","52e2406f":"code","3b8fbc3a":"code","5b1aafd6":"code","45449940":"code","a0189691":"code","b722b055":"code","b5425daa":"code","6993319a":"code","baae3189":"code","924f7cf2":"markdown","13a7cc18":"markdown","9776066d":"markdown","1e9b7c77":"markdown","3682d6cb":"markdown","bc4212a1":"markdown","2bf7e40f":"markdown","a208e30d":"markdown","23a4e472":"markdown","7455a7fa":"markdown"},"source":{"5911ce54":"import scipy\nimport math","83f8a31c":"#Import pi constant from both the packages\nfrom scipy.constants import pi\nfrom math import pi\n\nprint(\"sciPy - pi = \",scipy.constants.pi)\nprint(\"math - pi = \",math.pi)","5fe4e5bc":"from scipy.constants import golden\nprint(golden)","7ac3e48a":"help(scipy.constants)","78ec96cb":"scipy.constants.find()","2c8bbcb3":"import scipy.constants\nres = scipy.constants.physical_constants[\"Avogadro constant\"]\nprint(res)","77d1531a":"import scipy.special","6418306f":"help(scipy.special)","df42f557":"# \u043a\u0443\u0431\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043a\u043e\u0440\u0435\u043d\u044c\nfrom scipy.special import cbrt\nres = cbrt([10, 9, 0.1254, 234])\nprint(res)","a62799d2":"# \u042d\u043a\u0441\u043f\u043e\u043d\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f\nfrom scipy.special import exp10\nres = exp10([2, 9])\nprint(res)","541119ba":"# \u042d\u043a\u0441\u043f\u043e\u043d\u0435\u043d\u0446\u0438\u0430\u043b\u044c\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u0438\nfrom scipy.special import exprel\nres = exprel([-0.25, -0.1, 0, 0.1, 0.25])\nprint(res)","d22354d0":"# \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0442\u043e\u0440\u0438\u043a\u0430 \u0441\u043e\u0447\u0435\u0442\u0430\u043d\u0438\u044f\nfrom scipy.special import comb\nres = comb(10, 3, exact = False,repetition=True)\nprint(res)","34664c81":"# \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0442\u043e\u0440\u0438\u044f \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438\nfrom scipy.special import perm\nres = perm(10, 3, exact = True)\nprint(res)","de4ac009":"import scipy.io as sio\nimport numpy as np\n\n# Save a mat file\nvect = np.arange(10)\nsio.savemat('.\/array.mat', {'vect':vect})\n\n# Now Load the File\nmat_file_content = sio.loadmat('.\/array.mat')\nprint(mat_file_content)","92c0d6e4":"import scipy.io as sio\nmat_file_content = sio.whosmat('.\/array.mat')\nprint(mat_file_content)","c3e552d1":"# \u041b\u0438\u043d\u0435\u0439\u043d\u044b\u0435 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f\n\n# importing the scipy and numpy packages\nfrom scipy import linalg\nimport numpy as np\n\n# declaring the numpy arrays\na = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])\nb = np.array([2, 4, -1])\n\n# passing the values to the solve function\nx = linalg.solve(a, b)\n\n# printing the result array\nprint(x)","f8f22c07":"# \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044c\n\n#Declaring the numpy array\nA = np.array([[1,2],[3,4]])\n\n#Passing the values to the det function\nx = linalg.det(A)\n\n#printing the result\nprint(x)","4ca82d36":"# \u0421\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0438 \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \u0432\u0435\u043a\u0442\u043e\u0440\u044b\n\n#Declaring the numpy array\nA = np.array([[1,2],[3,4]])\n\n#Passing the values to the eig function\nl, v = linalg.eig(A)\n\n#printing the result for eigen values\nprint(l)\n\n#printing the result for eigen vectors\nprint(v)","881f1815":"# SVD-\u0440\u0430\u0437\u043b\u043e\u0436\u0435\u043d\u0438\u0435\n\n#Declaring the numpy array\na = np.random.randn(3, 2) + 1.j*np.random.randn(3, 2)\n\n#Passing the values to the eig function\nU, s, Vh = linalg.svd(a)\n\n# printing the result\nprint(U, Vh, s)","a70a3c9e":"\ndef rosen(x):\n    \"\"\"The Rosenbrock function\"\"\"\n    return np.sum(100.0*(x[1:]-x[:-1]**2.0)**2.0 + (1-x[:-1])**2.0, axis=0)","46c4464e":"from mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator, FormatStrFormatter\n\n# \u041d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c 3D \u0433\u0440\u0430\u0444\u0438\u043a\nfig = plt.figure(figsize=[15, 10])\nax = fig.gca(projection='3d')\n\n# \u0417\u0430\u0434\u0430\u0435\u043c \u0443\u0433\u043e\u043b \u043e\u0431\u0437\u043e\u0440\u0430\nax.view_init(45, 30)\n\n# \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0430\nX = np.arange(-2, 2, 0.1)\nY = np.arange(-1, 3, 0.1)\nX, Y = np.meshgrid(X, Y)\nZ = rosen(np.array([X,Y]))\n\n# \u0420\u0438\u0441\u0443\u0435\u043c \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm)\nplt.show()","56112928":"from scipy.optimize import minimize\nx0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen, x0, method='nelder-mead',\n    options={'xtol': 1e-8, 'disp': True})\nprint(res.x)","5f0587fb":"x0 = np.array([1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen, x0, method='powell',\n    options={'xtol': 1e-8, 'disp': True})\nprint(res.x)\n","22a831f0":"def rosen_der (x):\n    xm = x [1: -1]\n    xm_m1 = x [: - 2]\n    xm_p1 = x [2:]\n    der = np.zeros_like (x)\n    der [1: -1] = 200 * (xm-xm_m1 ** 2) - 400 * (xm_p1 - xm ** 2) * xm - 2 * (1-xm)\n    der [0] = -400 * x [0] * (x [1] -x [0] ** 2) - 2 * (1-x [0])\n    der [-1] = 200 * (x [-1] -x [-2] ** 2)\n    return der","ddfa9c13":"res = minimize(rosen, x0, method='BFGS', jac=rosen_der, options={'disp': True})\nprint(res.x)","19e20358":"def rosen_hess(x):\n    x = np.asarray(x)\n    H = np.diag(-400*x[:-1],1) - np.diag(400*x[:-1],-1)\n    diagonal = np.zeros_like(x)\n    diagonal[0] = 1200*x[0]**2-400*x[1]+2\n    diagonal[-1] = 200\n    diagonal[1:-1] = 202 + 1200*x[1:-1]**2 - 400*x[2:]\n    H = H + np.diag(diagonal)\n    return H","65380bac":"res = minimize(rosen, x0, method='Newton-CG', \n               jac=rosen_der, hess=rosen_hess,\n               options={'xtol': 1e-8, 'disp': True})\nprint(res.x)","3a4cabd0":"def func(x):\n   return x*2 + 2 * np.cos(x)","f3990665":"from scipy.optimize import root\nsol = root(func, 0.3)\nprint(sol)","efa712e8":"from scipy import interpolate\nimport matplotlib.pyplot as plt\nx = np.linspace(0, 4, 12)\ny = np.cos(x**2\/3+4)\nprint(x,y)","1e7d345e":"plt.plot(x, y, 'bo')\nplt.show()","52e2406f":"f1 = interpolate.interp1d(x, y,kind = 'linear')\n\nf2 = interpolate.interp1d(x, y, kind = 'cubic')","3b8fbc3a":"xnew = np.linspace(0, 4,30)\n\nplt.plot(x, y, 'bo', xnew, f1(xnew), 'b-', xnew, f2(xnew), 'r-')\n\nplt.legend(['data', 'linear', 'cubic','nearest'], loc = 'best')\n\nplt.show()","5b1aafd6":"# \u043e\u0434\u043d\u043e\u043c\u0435\u0440\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f\nx = np.arange(5, 20)\ny = np.exp(x\/3.0)\nf = interpolate.interp1d(x, y)\nx1 = np.arange(6, 12)\ny1 = f(x1)   # \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u0438, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u0443\u044e `interp1d`\nplt.plot(x, y, 'o', x1, y1, '--')\nplt.show()","45449940":"# \u043c\u043d\u043e\u0433\u043e\u043c\u0435\u0440\u043d\u0430\u044f \u0438\u043d\u0442\u0435\u0440\u043f\u043e\u043b\u044f\u0446\u0438\u044f\nx = np.arange(0,10)\ny = np.arange(10,25)\nx1, y1 = np.meshgrid(x, y)\nz = np.tan(x1+y1)\nf = interpolate.interp2d(x, y, z, kind='cubic')\nx2 = np.arange(2,8)\ny2 = np.arange(15,20)\nz2 = f(x2, y2)\nplt.plot(x, z[0, :], 'ro-', x2, z2[0, :], '--')\nplt.show()","a0189691":"from scipy import stats\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt","b722b055":"help(scipy.stats)","b5425daa":"# \u0433\u0438\u0441\u0442\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043b\u043e\u0442\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f\nsamples = np.random.normal(size=1000)\nbins = np.arange(-4, 5)\nhistogram = np.histogram(samples, bins=bins, density=True)[0]\n\nbins = 0.5*(bins[1:] + bins[:-1])\npdf = stats.norm.pdf(bins)  # norm is a distribution object\n\nplt.plot(bins, histogram) \nplt.plot(bins, pdf) \n","6993319a":"import scipy.integrate\nfrom numpy import exp\nf= lambda x:exp(-x**2)\ni = scipy.integrate.quad(f, 0, 1)\nprint(i)","baae3189":"from math import sqrt\nf = lambda x, y : 16*x*y\ng = lambda x : 0\nh = lambda y : sqrt(1-4*y**2)\ni = scipy.integrate.dblquad(f, 0, 0.5, g, h)\nprint(i)","924f7cf2":"$$\\int_{a}^{b} f(x)dx$$\n\n$$f(x) = e^{-x^2}$$","13a7cc18":"# SciPy Integrate Package","9776066d":"# SciPy LinAlg Package","1e9b7c77":"# SciPy Interpolate Package","3682d6cb":"# SciPy Constants Package","bc4212a1":"# SciPy Special Package","2bf7e40f":"# SciPy Stats Package","a208e30d":"# Scipy IO Package","23a4e472":"$$\\int_{0}^{1\/2} dy \\int_{0}^{\\sqrt{1-4y^2}} 16xy \\:dx$$","7455a7fa":"# SciPy Optimise Package"}}