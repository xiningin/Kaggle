{"cell_type":{"2ad9a146":"code","c1e740eb":"code","c5c56150":"code","ebe27740":"code","ec080b0c":"code","04dfa80c":"code","0a296a44":"code","4a51a0e2":"code","da71b8c5":"code","a14cf593":"code","c24bed5c":"code","220ef19e":"markdown","683bdc9e":"markdown","93eb8d00":"markdown","35fd52cb":"markdown"},"source":{"2ad9a146":"%%writefile score.c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define NF 5000\nint cost[NF][101];\nint fs[NF];\n\nint cf[NF][10];\n\nint loaded=0;\n\nfloat acc[301][301];\n\nvoid precompute_acc() {\n    \nfor(int i=125;i<=300;i++) \n    for(int j=125;j<=300;j++)\n      acc[i][j] = (i-125.0)\/400.0 * pow(i , 0.5 + fabs(i-j) \/ 50 );    \n}\n\nvoid read_fam() {\n  FILE *f;\n  char s[1000];\n  int d[101],fid,n;\n  int *c;\n\n  f=fopen(\"..\/input\/santa-workshop-tour-2019\/family_data.csv\",\"r\");\n  if (fgets(s,1000,f)==NULL)\n    exit(-1);\n\n  for(int i=0;i<5000;i++) {\n    c = &cf[i][0];\n    if (fscanf(f,\"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\",\n               &fid,&c[0],&c[1],&c[2],&c[3],&c[4],&c[5],&c[6],&c[7],&c[8],&c[9],&fs[i])!=12)\n      exit(-1);\n\n    \/\/    printf(\"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\\n\",\n    \/\/fid,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9],fs[i]);\n    n = fs[i];\n\n    for(int j=1;j<=100;j++) {\n      if (j==c[0]) cost[i][j]=0;\n      else if (j==c[1]) cost[i][j]=50;\n      else if (j==c[2]) cost[i][j]=50 + 9 * n;\n      else if (j==c[3]) cost[i][j]=100 + 9 * n;\n      else if (j==c[4]) cost[i][j]=200 + 9 * n;\n      else if (j==c[5]) cost[i][j]=200 + 18 * n;\n      else if (j==c[6]) cost[i][j]=300 + 18 * n;\n      else if (j==c[7]) cost[i][j]=300 + 36 * n;\n      else if (j==c[8]) cost[i][j]=400 + 36 * n;\n      else if (j==c[9]) cost[i][j]=500 + 36 * n + 199 * n;\n      else cost[i][j]=500 + 36 * n + 398 * n;\n    }\n  }\n\n}\n\nfloat max_cost=1000000000;\n\nint day_occ[102];\n\nstatic inline int day_occ_ok(int d) {\n  return !(d <125 || d>300);\n}\n\nfloat score(int *pred) {\n  float r=0;\n    \n  if (!loaded) {\n      read_fam();\n      precompute_acc();\n      loaded = 1;\n  }\n\n  \/\/ validate day occupancy\n  memset(day_occ,0,101*sizeof(int));\n\n  for(int i=0;i<NF;i++) {\n    day_occ[pred[i]]+=fs[i];\n    r+=cost[i][pred[i]];\n  }\n       \n  day_occ[101]=day_occ[100];\n\n  for (int d=1;d<=100;d++) {\n    if (day_occ[d]<125)                                                       \n      r += 100000 * (125 - day_occ[d]);                                      \n    else if (day_occ[d] > 300)                                               \n      r += 100000 * (day_occ[d] - 300);      \n    r += acc[day_occ[d]][day_occ[d+1]];\n  }\n  return r;\n}  \n\nvoid score_bunch(int *pred, int n, float *dest) {\n    for(int i = 0; i < n; ++i) {\n        dest[i] = score(pred + i * NF);\n    }\n}","c1e740eb":"!gcc -O5 -shared -Wl,-soname,score     -o score.so     -fPIC score.c\n!ls -l score.so","c5c56150":"import ctypes\nfrom numpy.ctypeslib import ndpointer\n\nlib = ctypes.CDLL('.\/score.so')\ncost_function = lib.score\ncost_function.restype = ctypes.c_float\ncost_function.argtypes = [ndpointer(ctypes.c_int)]\n\n_bunch_cost_function = lib.score_bunch\n_bunch_cost_function.argtypes = [ndpointer(ctypes.c_int), ctypes.c_int, ndpointer(ctypes.c_float)]\ndef bunch_cost_function(bunch):\n    result = np.zeros(bunch.shape[0], dtype='float32')\n    _bunch_cost_function(bunch, bunch.shape[0], result)\n    return result","ebe27740":"import numpy as np\nimport pandas as pd\nnp.random.seed(666)\n\nfpath = '..\/input\/santa-workshop-tour-2019\/family_data.csv'\ndata = pd.read_csv(fpath, index_col='family_id')\n\nfpath = '\/kaggle\/input\/santa-workshop-tour-2019\/sample_submission.csv'\nsubmission = pd.read_csv(fpath, index_col='family_id')\ndata.head()","ec080b0c":"def iteration(population, costs=None, size_of_population=100, n_of_childs=100):\n    if costs is None:\n        costs = np.array([cost_function(population[i]) for i in range(population.shape[0])])\n    assert costs.shape[0] == population.shape[0]\n    assert population.shape != (5000, 5000)\n\n    parents0 = population[np.random.choice(population.shape[0], n_of_childs)]\n    parents1 = population[np.random.choice(population.shape[0], n_of_childs)]\n    \n    children = crossover(parents0, parents1)\n    children = mutate(children)\n    \n    return selection(population, costs, children, size_of_population)\n","04dfa80c":"def crossover(parents0, parents1):\n    crossover_mask = np.random.choice([False, True], parents0.shape)\n    return np.where(crossover_mask, parents0, parents1)","0a296a44":"matrix = data[['choice_0', 'choice_1', 'choice_2', 'choice_3', 'choice_4',\n       'choice_5', 'choice_6', 'choice_7', 'choice_8', 'choice_9']].to_numpy()\n\nbetter_choices = []\nfor family in range(5000):\n    days = matrix[family]\n    bc = [days for i in range(101)]\n    for di in range(len(days)):\n        bc[days[di]] = days[:di]\n    better_choices.append(bc)\n\n    \ndef mutate_simple(children, indices):\n    families_to_mutate = np.random.choice(5000, indices.shape[0])\n    new_days = np.random.randint(1, 101, size=indices.shape[0])\n    children[indices, families_to_mutate] = new_days\n\n\nbest_possible_days = np.int32(data.choice_0.values)\n    \ndef mutate_improving(children, indices):\n    improvable_families = (children[indices] != best_possible_days)\n    for i in range(indices.shape[0]):\n        family = np.random.choice(np.nonzero(improvable_families[i])[0])\n        children[indices[i]][family] = np.random.choice(better_choices[family][children[indices[i]][family]])\n    \n    \ndef mutate(children):\n    methods = [\n        (mutate_simple, 90),\n        (mutate_improving, 100),\n    ]\n    p = np.random.choice(methods[-1][1], children.shape[0])\n    method_booleans = [p < m[1] for m in methods]\n    method_indices = [\n        np.nonzero(bv)[0]\n        for bv in [method_booleans[0]] + [\n            ~method_booleans[i-1] & method_booleans[i]\n            for i in range(1, len(method_booleans))\n        ]\n    ]\n    for i in range(len(methods)):\n        methods[i][0](children, method_indices[i])\n\n    return children","4a51a0e2":"def selection(population, costs, children, size_of_population):\n#    children_costs = np.array([cost_function(children[i]) for i in range(children.shape[0])])\n    children_costs = bunch_cost_function(children)\n    \n    # throwing away children which are worse than worst of population\n    if population.shape[0] >= size_of_population:\n        good_children = children_costs < costs.max()\n        children_costs = children_costs[good_children]\n        children = children[good_children]\n    \n    new_costs = np.concatenate((costs, children_costs))\n    new_population = np.concatenate((population, children))\n    \n    # sorting by cost\n    indices = np.argsort(new_costs)\n    new_population = new_population[indices]\n    new_costs = new_costs[indices]\n\n    new_population, new_costs = remove_dublicates(new_population, new_costs)\n    new_population = new_population[:size_of_population]\n    new_costs = new_costs[:size_of_population]\n    return new_population, new_costs, children.shape[0]\n\ndef remove_dublicates(new_population, new_costs):\n    # removing dublicates\n    eqsn = np.array([True] * new_population.shape[0])\n    \n    begin = 0\n    d_indices = []\n    for i in range(1, new_population.shape[0]):\n        if new_costs[i] != new_costs[i-1]:\n            d_indices += get_dublicates_indices(new_population, np.arange(begin, i))\n            begin = i\n    d_indices += get_dublicates_indices(new_population, np.arange(begin, new_population.shape[0]))\n    eqsn[d_indices] = False\n    \n    return new_population[eqsn], new_costs[eqsn]\n\ndef get_dublicates_indices(data, indices):\n    not_dublicates = [indices[0]]\n    for i in indices[1:]:\n        if not any([np.array_equal(data[i], data[nd]) for nd in not_dublicates]):\n            not_dublicates.append(i)\n    return [i for i in indices if i not in not_dublicates]","da71b8c5":"population = np.array([np.int32(submission.assigned_day.values)])\n[cost_function(s) for s in population]","a14cf593":"%%time\ncost = np.array([cost_function(population[i]) for i in range(population.shape[0])])\nprint(0, np.sort(cost)[:3], cost.max())\nfor n in range(10000):\n    population, cost, _ = iteration(population, cost, 100, 100)\n    if n % 100 == 0:\n        print(n, np.sort(cost)[:3], cost.max())\n        \nprint(10000, np.sort(cost)[:3], cost.max())","c24bed5c":"submission['assigned_day'] = population[0]\nsubmission.to_csv('submission.csv')\nsubmission","220ef19e":"## Run","683bdc9e":"## Reading data","93eb8d00":"## Algorithm\n\n* Choosing parents randomly with equal probability.\n* crossover (for each family choose day from one of parents with equal probability)\n* mutate children (set random day for random family or set day which reduces preference cost for random family)\n* selection (keep best from initial_population + children, remove dublicates)\n","35fd52cb":"There are some implementation of genetic approach in this competition, but they are not very fast. I really wanted to run 10000 epochs in 120 seconds.\n\nUsing numpy for almost all computations.\n\nUsing fast scoring function from https:\/\/www.kaggle.com\/kernels\/scriptcontent\/24287559\/notebook\n\nWith changes:\n\n    - if (day_occ[d]<125 || day_occ[d]>300) return max_cost;\n    + if (day_occ[d]<125)                                                       \n    +   r += 100000 * (125 - day_occ[d]);                                      \n    + else if (day_occ[d] > 300)                                               \n    +   r += 100000 * (day_occ[d] - 300);"}}