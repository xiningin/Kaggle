{"cell_type":{"98727d3c":"code","149e5aab":"code","5612a491":"code","913c421d":"code","2f9643b1":"code","ddcfd8cd":"code","781231c7":"code","4df26859":"code","175d9dd4":"code","add0b581":"code","b21b54be":"code","1820ad44":"code","b874a55e":"code","fe0da052":"code","622fb63e":"markdown","ba924460":"markdown","60c41add":"markdown","21b1ae80":"markdown","dfc085bf":"markdown","fb5ecaf0":"markdown","2af748bf":"markdown","7f0b7331":"markdown","8886ec58":"markdown","d1578f3d":"markdown","b4ebc68b":"markdown","a6f8bb9f":"markdown","c64ea984":"markdown","268de7fa":"markdown","2fb9591c":"markdown","e73f736e":"markdown","c1bc4644":"markdown","64abf6b5":"markdown"},"source":{"98727d3c":"import pandas as pd\nimport numpy as np\nfrom pandas.io.json import json_normalize\nimport json\nimport os\nimport plotly.plotly as py\nfrom plotly import tools\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\n\ninit_notebook_mode(connected=True)\n\npd.set_option(\"mode.chained_assignment\", None)\n\n# Utilities:\n# Lists of columns per type of item.\ncommon_info = [\"price\", \"name\", \"type\", \"ilvl\", \"identified\"]\nproperties = [\"properties\", \"additionalProperties\"]\nsockets = [\"socketsAmount\", \"links\", \"socketsRed\", \"socketsGreen\", \"socketsBlue\", \"socketsWhite\", \"socketsAbyss\"]\nmods = [\"rarity\", \"implicitMods\", \"explicitMods\"]  # Only items that can have mods have a rarity level.\n# Items that can be altered by the Shaper or the Elder:\ncan_be_altered = [\"shaper\", \"elder\"]\n# Gem items, that can thus be support or vaal:\ngem_info = [\"vaal\", \"support\"]\n\n# Currency exchange rates in Chaos Orbs.\n# Keys follow the same abbreviation patterns of premium stash tabs.\nvalue = {\n    \"chaos\": 1,  # Chaos Orb\n    \"mir\": 32_300,  # Mirror of Kalandra\n    \"exa\": 188,  # Exalted Orb\n    \"master-sextant\": 5,  # Master Cartographer's Sextant\n    \"gcp\": 1.2,  # Gemcutter's Prism\n    \"alch\": 1\/1.7,  # Orb of Alchemy\n    \"fuse\": 1\/2.1,  # Orb of Fusing\n    \"chisel\": 1\/2.1,  # Cartographer's Chisel\n    \"blessed\": 1\/4.5,  # Blessed Orb\n    \"regal\": 1,  # Regal Orb\n    \"regret\": 1\/1.4,  # Orb of Regret\n    \"alt\": 1\/4.6,  # Orb of Alteration\n    \"jew\": 1\/9,  # Jeweller's Orb\n    \"chance\": 1\/13,  # Orb of Chance\n    \"vaal\": 1.7,  # Vaal Orb\n    \"scour\": 1\/2.5,  # Orb of Scouring\n    \"divine\": 24,  # Divine Orb\n    \"chrom\": 1\/4.5,  # Chromatic Orb\n}\n\ndef find_property(value_arr, p_name):\n    \"\"\"Find an item property by its name in an array of property records.\"\"\"\n    for prop in value_arr:\n        if prop.get(\"name\") == p_name:\n            # The value is in a list within a list.\n            return prop.get(\"values\", np.nan)[0][0]\n    return np.nan\n\ndef get_max_links(sockets):\n    \"\"\"Extract the number of maximum linked sockets from the sockets array of an item.\"\"\"\n    groups = {}\n    for socket in sockets:\n        groups.update({socket[\"group\"]: groups.get(socket[\"group\"], 0)+1})\n    \n    return max(groups.values())\n\ndef get_frag_type(x):\n    \"\"\"Return the fragment type of a fragment from its name, provided in group 0 of a re.Match object.\"\"\"\n    return \"Alluring Abyss\" if x.group(0) in [\"Mortal Grief\",\n                                              \"Mortal Hope\",\n                                              \"Mortal Rage\",\n                                              \"Mortal Ignorance\"]\\\n    else \"Apex of Sacrifice\" if x.group(0) in [\"Sacrifice at Dusk\",\n                                               \"Sacrifice at Midnight\",\n                                               \"Sacrifice at Noon\",\n                                               \"Sacrifice at Dawn\"]\\\n    else \"Pale Court\" if x.group(0) in [\"Eber's Key\",\n                                        \"Inya's Key\",\n                                        \"Yriel's Key\",\n                                        \"Volkuur's Key\"]\\\n    else \"Breachstone (Pure)\" if \"Pure Breachstone\" in x.group(0)\\\n    else \"Breachstone\" if \"Breachstone\" in x.group(0)\\\n    else x.group(0)\n\n# Obtain DataFrames containing all stashes from the JSON API outputs.\n# Multiple outputs need to be joined to have a more complete outlook,\n# since the API only provides \"updates\", and whole views of the data.\nn_of_parts = sum([x.find(\"stashes\") > -1 for x in os.listdir(\"..\/input\/\")])\ndfs = []\nfor part_no in range(1, n_of_parts+1):\n    with open(f\"..\/input\/stashes{part_no}.json\", \"r\") as jsn:\n        dfs.append(json_normalize(json.load(jsn),\n                                  record_path=[\"stashes\", \"items\"],\n                                  meta=[[\"stashes\", \"public\"], [\"stashes\", \"league\"]],\n                                  sep=\"_\",\n                                 ))\n\n# Join all parts in one dataframe.\ndf = pd.concat(dfs, ignore_index=True, verify_integrity=True, sort=False)\n\n# Select only public stashes,\n# of non-hardcore Betrayal league,\n# that contain a note (since that's where item prices are indicated).\nitems = df[(df.stashes_public == True) & (df.stashes_league == \"Betrayal\") & (df.note.notna())]\n\n# Reshape unhelpful columns\/values.\nitems.rename(columns={\"frameType\": \"rarity\"}, inplace=True)\nitems[\"rarity\"].replace({\n    0: \"Normal\",\n    1: \"Magic\",\n    2: \"Rare\",\n    3: \"Unique\",\n    4: np.nan,  # Values 4-8 are not useful for our purposes.\n    5: np.nan,\n    6: np.nan,\n    7: np.nan,\n    8: np.nan,\n    9: \"Relic\",\n}, inplace=True)\nitems[\"rarity\"] = items[\"rarity\"].astype(\"category\")\n\nitems.rename(columns={\"typeLine\": \"type\"}, inplace=True)\n\n# Detect item price and convert to Chaos.\n# Temporary Series so that weird pricings like \"1\/2 chaos\" can be converted.\nprice_regex = r\"~(?:price|b\/o) (?P<price>\\d+(\\.\\d+)?(?:\/\\d+(\\.\\d+)?)?) (?P<currency>\" +\\\n               \"|\".join(currency for currency in value.keys()) +\\\n               \")\"\nprice_temp = items[\"note\"].str.extract(price_regex, expand=True)\n\nitems[\"price\"] = price_temp[\"price\"].apply(lambda x: eval(str(x)) if x is not np.nan else 0.) * price_temp[\"currency\"].map(value)\n\n# Clean up \"corrupted\" column: either True or False.\nitems[\"corrupted\"] = items[\"corrupted\"].where(items[\"corrupted\"], other=False).astype(bool)\n\n# Clean up \"duplicated\" column: either True or False and rename to mirrored, as is the in-game denomination.\nitems[\"mirrored\"] = items[\"duplicated\"].where(items[\"duplicated\"], other=False).astype(bool)\n\n# Set veiledMods to show number of unrevealed veiled mods.\n# No indication of veiled remains after all veiled mods are revealed.\nitems[\"veiledMods\"] = items[\"veiledMods\"].map(lambda x: x if x is np.nan else len(x))\n\n# Clean up sockets: number of sockets, largest linked group, number of sockets per colour (R, G, B, W, A)\n# Extract number of total sockets, if applicable.\nitems[\"socketsAmount\"] = items[\"sockets\"].map(lambda x: x if x is np.nan else len(x))\n\n# Extract number of sockets per colour, where applicable.\nsockets_mapping = {\n    \"R\": \"Red\",\n    \"G\": \"Green\",\n    \"B\": \"Blue\",\n    \"W\": \"White\",\n    \"A\": \"Abyss\",\n}\nfor k, v in sockets_mapping.items():\n    items[f\"sockets{v}\"] = items[\"sockets\"].map(\n        lambda x: x if x is np.nan\n        else sum([k in socket.get(\"sColour\", []) for socket in x])\n    )\n\n# Extract highest amount of linked sockets per item.\nitems[\"links\"] = items[\"sockets\"].map(lambda x: x if x is np.nan else get_max_links(x))\n\n# Extract item quality.\nitems[\"quality\"] = items[\"properties\"].apply(lambda x: x if x is np.nan else find_property(x, \"Quality\"))\nitems[\"quality\"] = items[\"quality\"].str.extract(r\"\\+(\\d+)%\", expand=False)\nitems[\"quality\"] = items[\"quality\"].where(items[\"quality\"].notna(), other=0).astype(int)\n\n# Clean up shaper\/elder columns: either True or False.\nitems[\"shaper\"] = items[\"shaper\"].where(items[\"shaper\"], other=False)\nitems[\"elder\"] = items[\"elder\"].where(items[\"elder\"], other=False)\n\n# Include only columns we have a use for.\n# NOTE: several data points and columns pertain to item types that won't be covered in this version of the analysis.\n# More information on how these can be extracted can be found in the V1 of this kernel on Kaggle.\nitems = items[[\n    *common_info, \"quality\", \"corrupted\", \"mirrored\", \"category\",\n    *can_be_altered, *gem_info, \"abyssJewel\", \"talismanTier\",\n    *sockets,\n    *mods, \"craftedMods\", \"veiledMods\", \"enchantMods\", \"utilityMods\",\n    *properties\n]]\n\n# Drop all items for which price values are not available\nitems = items.dropna(subset=(\"price\",))\n\n# Separate dataframes are obtained for each unrelated type of item in the following cells.\n# Only useful columns for each type are kept.","149e5aab":"# Select only resonators from currency.\nresonators = items[items[\"category\"].map(lambda x: \"resonator\" in x.get(\"currency\", []))]\n\n# Extract potency and type\npotency_type = resonators[\"type\"].str.extract(\n    r\"(?P<potency>Primitive|Potent|Powerful|Prime) (?P<type>Alchemical.*|Chaotic.*)\",\n    expand=True,\n)\nresonators[\"potency\"] = potency_type[\"potency\"].astype(\"category\")\nresonators[\"type\"] = potency_type[\"type\"].astype(\"category\")\n\nresonators = resonators[[\"price\", \"potency\", \"type\"]]\n\nsorted_resos = resonators.sort_values([\"type\", \"potency\", \"price\"])\n\nsorted_resos.describe()","5612a491":"reso_types = go.Histogram(x=sorted_resos[\"type\"], y=sorted_resos[\"price\"], name=\"# of resonators per type\")\nreso_prices = go.Histogram(x=sorted_resos[\"type\"], y=sorted_resos[\"price\"], histfunc=\"avg\", name=\"Avg. price per type\")\n\nfigure = tools.make_subplots(rows=2, print_grid=False)\nfigure.append_trace(reso_types, 1, 1)\nfigure.append_trace(reso_prices, 2, 1)\n\nfigure[\"layout\"][\"title\"] = \"Resonators count and price per type\"\nfigure[\"layout\"][\"xaxis1\"][\"visible\"] = False\nfigure[\"layout\"][\"yaxis1\"][\"title\"] = \"Count\"\nfigure[\"layout\"][\"yaxis2\"][\"title\"] = \"Avg. price\"\n\niplot(figure)","913c421d":"reso_potencies = go.Histogram(x=sorted_resos[\"potency\"], y=sorted_resos[\"price\"], name=\"# of resonators per potency class\")\nreso_prices = go.Histogram(x=sorted_resos[\"potency\"], y=sorted_resos[\"price\"], histfunc=\"avg\", name=\"Avg. price per potency class\")\n\nfigure = tools.make_subplots(rows=2, print_grid=False)\nfigure.append_trace(reso_potencies, 1, 1)\nfigure.append_trace(reso_prices, 2, 1)\n\nfigure[\"layout\"][\"title\"] = \"Resonators count and price per potency class\"\nfigure[\"layout\"][\"xaxis1\"][\"visible\"] = False\nfigure[\"layout\"][\"yaxis1\"][\"title\"] = \"Count\"\nfigure[\"layout\"][\"yaxis2\"][\"title\"] = \"Avg. price\"\n\niplot(figure)","2f9643b1":"# Select only fossils from currency.\nfossils = items[items[\"category\"].map(lambda x: \"fossil\" in x.get(\"currency\", []))]\n\nfossils = fossils[[\"price\", \"type\"]]\n\nsorted_fossils = fossils.sort_values([\"type\", \"price\"])\n\nsorted_fossils.describe()","ddcfd8cd":"layout = go.Layout(\n    title=go.layout.Title(text=\"Fossil price ranges\"),\n    yaxis={\"title\": \"Count\"},\n    xaxis={\"title\": \"Price\"},\n)\n\ntrace0 = go.Histogram(x=sorted_fossils[\"price\"], xbins={\"start\": 0})\nfigure = go.Figure(data=[trace0], layout=layout)\n\niplot(figure)","781231c7":"cheap_fossils = sorted_fossils[sorted_fossils[\"price\"] < 20][[\"price\", \"type\"]].sort_values([\"price\"])\n\ncheap_fossil_types = go.Histogram(x=cheap_fossils[\"type\"], y=cheap_fossils[\"price\"], name=\"# of fossils per type\")\ncheap_fossil_prices = go.Histogram(x=cheap_fossils[\"type\"], y=cheap_fossils[\"price\"], histfunc=\"avg\", name=\"Avg. price per fossil type\")\n\nfigure = tools.make_subplots(rows=2, print_grid=False)\nfigure.append_trace(cheap_fossil_types, 1, 1)\nfigure.append_trace(cheap_fossil_prices, 2, 1)\nfigure[\"layout\"][\"title\"] = \"Cheapest fossils per type\"\nfigure[\"layout\"][\"yaxis1\"][\"title\"] = \"Count\"\nfigure[\"layout\"][\"xaxis1\"][\"visible\"] = False\nfigure[\"layout\"][\"yaxis2\"][\"title\"] = \"Avg. price\"\n\niplot(figure)","4df26859":"# Select only fragments from maps.\nfragments = items[items[\"category\"].map(lambda x: \"fragment\" in x.get(\"maps\", [])\n                                        and \"scarab\" not in x.get(\"maps\", []))]\n\n# Move name to name column.\nfragments[\"name\"] = fragments[\"type\"].copy()\n\n# Extract actual type from name.\nfragments[\"type\"] = fragments[\"type\"].str.replace(r\"(.*)\",repl=get_frag_type).astype(\"category\")\n\nfragments = fragments[[\"price\", \"name\", \"type\"]]\n\nsorted_frags = fragments.sort_values([\"type\", \"name\", \"price\"])\n\ncheap_fossil_types = go.Histogram(x=sorted_frags[\"type\"], y=sorted_frags[\"price\"], name=\"# of fragments per type\")\ncheap_fossil_prices = go.Histogram(x=sorted_frags[\"type\"], y=sorted_frags[\"price\"], histfunc=\"avg\", name=\"Avg. price per fragment type\")\n\nfigure = tools.make_subplots(rows=2, print_grid=False)\nfigure.append_trace(cheap_fossil_types, 1, 1)\nfigure.append_trace(cheap_fossil_prices, 2, 1)\n\nfigure[\"layout\"][\"title\"] = \"Fragments count and price per type\"\nfigure[\"layout\"][\"xaxis1\"][\"visible\"] = False\nfigure[\"layout\"][\"yaxis1\"][\"title\"] = \"Count\"\nfigure[\"layout\"][\"yaxis2\"][\"title\"] = \"Avg. price\"\n\niplot(figure)","175d9dd4":"# Select only scarabs from maps.\nscarabs = items[items[\"category\"].map(lambda x: \"scarab\" in x.get(\"maps\", []))]\n\n# Extract rarity and type.\nrarity_type = scarabs[\"type\"].str.extract(\n    r\"(?P<rarity>Rusted|Polished|Gilded) (?P<type>.*)\",\n    expand=True,\n)\nscarabs[\"rarity\"] = rarity_type[\"rarity\"].astype(\"category\")\nscarabs[\"type\"] = rarity_type[\"type\"].astype(\"category\")\n\nscarabs = scarabs[[\"price\", \"rarity\", \"type\"]]\n\nsorted_scarabs = scarabs.sort_values([\"type\", \"rarity\", \"price\"])\n\nsorted_scarabs.describe()","add0b581":"scarabs_rusted = sorted_scarabs[sorted_scarabs[\"rarity\"] == \"Rusted\"]\nscarabs_polished = sorted_scarabs[sorted_scarabs[\"rarity\"] == \"Polished\"]\nscarabs_gilded = sorted_scarabs[sorted_scarabs[\"rarity\"] == \"Gilded\"]\n\nscarab_types_rusted = go.Histogram(x=scarabs_rusted[\"type\"], y=scarabs_rusted[\"price\"], name=\"# of rusted scarabs per type\", marker={\"color\": \"rgb(70, 200, 250)\"})\nscarab_types_polished = go.Histogram(x=scarabs_polished[\"type\"], y=scarabs_polished[\"price\"], name=\"# of polished scarabs per type\", marker={\"color\": \"rgb(70, 150, 250)\"})\nscarab_types_gilded = go.Histogram(x=scarabs_gilded[\"type\"], y=scarabs_gilded[\"price\"], name=\"# of gilded scarabs per type\", marker={\"color\": \"rgb(70, 100, 250)\"})\n\nscarab_prices_rusted = go.Histogram(x=scarabs_rusted[\"type\"], y=scarabs_rusted[\"price\"], histfunc=\"avg\", name=\"Avg. rusted scarab price per type\", marker={\"color\": \"rgb(250, 200, 70)\"})\nscarab_prices_polished = go.Histogram(x=scarabs_polished[\"type\"], y=scarabs_polished[\"price\"], histfunc=\"avg\", name=\"Avg. polished scarab price per type\", marker={\"color\": \"rgb(250, 150, 70)\"})\nscarab_prices_gilded = go.Histogram(x=scarabs_gilded[\"type\"], y=scarabs_gilded[\"price\"], histfunc=\"avg\", name=\"Avg. gilded price per type\", marker={\"color\": \"rgb(250, 100, 70)\"})\n\nfigure = tools.make_subplots(rows=2, print_grid=False)\nfigure.append_trace(scarab_types_rusted, 1, 1)\nfigure.append_trace(scarab_types_polished, 1, 1)\nfigure.append_trace(scarab_types_gilded, 1, 1)\nfigure.append_trace(scarab_prices_rusted, 2, 1)\nfigure.append_trace(scarab_prices_polished, 2, 1)\nfigure.append_trace(scarab_prices_gilded, 2, 1)\n\nfigure[\"layout\"][\"title\"] = \"Scarab count and price per type and rarity\"\nfigure[\"layout\"][\"xaxis1\"][\"visible\"] = False\nfigure[\"layout\"][\"yaxis1\"][\"title\"] = \"Count\"\nfigure[\"layout\"][\"yaxis2\"][\"title\"] = \"Avg. price\"\n\niplot(figure)","b21b54be":"# Select only gems.\ngems = items[items[\"category\"].map(lambda x: \"gems\" in x.keys())]\n\n# Clean up vaal column: either True or False.\ngems[\"vaal\"] = gems[\"vaal\"].map(lambda x: False if x is np.nan else True)\n\n# Extract columns with gem level and whether level is maxed out.\ngems[\"level\"] = gems[\"properties\"].apply(find_property, args=(\"Level\",))\ngems[\"maxLevel\"] = gems[\"level\"].str.contains(r\"Max\")\ngems[\"level\"] = gems[\"level\"].str.extract(r\"(\\d+).*\", expand=False).astype(\"int64\")\n\ngems = gems[[\"price\", \"type\", \"quality\", \"corrupted\", \"level\", \"maxLevel\", *gem_info]]\n\nsorted_gems = gems.sort_values([\"support\", \"type\", \"vaal\", \"price\", \"maxLevel\", \"level\", \"quality\", \"corrupted\"])\n\nactive_gems = sorted_gems[sorted_gems[\"support\"] == False]\n\nactive_gems_cumprice = np.cumsum(active_gems[\"price\"].values)\nactive_gems_cumprice_corrupted = np.cumsum(active_gems[active_gems[\"corrupted\"] == True][\"price\"].values)\nactive_gems_cumprice_not_corrupted = np.cumsum(active_gems[active_gems[\"corrupted\"] == False][\"price\"].values)\n\nag_cumprice_trace = go.Scatter(y=active_gems_cumprice, hoverinfo=\"skip\", name=\"All gems\")\nag_cumprice_trace_corrupted = go.Scatter(y=active_gems_cumprice_corrupted, hoverinfo=\"skip\", name=\"Corrupted gems\")\nag_cumprice_trace_not_corrupted = go.Scatter(y=active_gems_cumprice_not_corrupted, hoverinfo=\"skip\", name=\"Uncorrupted gems\")\n\nlayout = go.Layout(\n    title=go.layout.Title(text=\"Active gem prices\"),\n    yaxis={\"title\": \"Cumulative price\", \"range\": [0, 55_000]},\n    xaxis={\"visible\": False, \"range\": [0, 2250]},\n)\n\nfigure = go.Figure(data=[ag_cumprice_trace, ag_cumprice_trace_corrupted, ag_cumprice_trace_not_corrupted], layout=layout)\n\niplot(figure)","1820ad44":"corrupted_gems = active_gems[active_gems[\"corrupted\"] == True]\nuncorrupted_gems = active_gems[active_gems[\"corrupted\"] == False]\n\ncorr_trace = go.Histogram(x=corrupted_gems[\"level\"], y=corrupted_gems[\"price\"], histfunc=\"avg\", name=\"Corrupted gems\")\nuncorr_trace = go.Histogram(x=uncorrupted_gems[\"level\"], y=uncorrupted_gems[\"price\"], histfunc=\"avg\", name=\"Uncorrupted gems\")\n\nlayout = go.Layout(\n    title=go.layout.Title(text=\"Avg. price of corrupted vs. uncorrupted active gems against level\"),\n    yaxis={\"title\": \"Average price\"},\n    xaxis={\"title\": \"Level\"},\n)\n\nfigure = go.Figure(data=[corr_trace, uncorr_trace], layout=layout)\n\niplot(figure)","b874a55e":"level15_corrupted_gems = corrupted_gems[\n    (~corrupted_gems[\"type\"].str.contains(r\"(?:Portal|Breach|Detonate)\"))\n    & (corrupted_gems[\"level\"] == 15)\n]\n\ntrace = go.Histogram(x=level15_corrupted_gems[\"type\"], y=level15_corrupted_gems[\"price\"], histfunc=\"avg\", name=\"Corrupted gems\")\n\nlayout = go.Layout(\n    title=go.layout.Title(text=\"Avg. price of level 15 corrupted active gems\"),\n    yaxis={\"title\": \"Average price\"},\n    xaxis={\"title\": \"Name\"},\n)\n\nfigure = go.Figure(data=[trace], layout=layout)\n\niplot(figure)","fe0da052":"vaal_roa = corrupted_gems[corrupted_gems[\"type\"] == \"Vaal Rain of Arrows\"]\n\nvaal_roa = vaal_roa.sort_values([\"level\"])\n\nvaal_roa[[\"type\", \"price\", \"quality\", \"level\"]]","622fb63e":"Taken by type alone, resonators aren't all that interesting. The rarity seems to be about equal, but Chaotic Resonators, which allow to simply **reroll properties** on rare items, are **more desirable** since a player won't need to use Orbs of Scouring to empty the item of its properties before rerolling, as opposed to Alchemical Resonators, which only work when starting on a normal rarity (empty) item.","ba924460":"# About the game:\n\n*You can skip this section if you are already familiar with Path of Exile.*\n\nPath of Exile is an Action-RPG where players kill monsters using combinations of abilities and equipments of their choice. These monsters drop an immense variety of items whose properties, called **mods**, are highly randomised and characterise each item to a significant degree.\nFor example, the same type of sword could *roll* mods to add fire damage, or have higher attack speed or accuracy, or any combination of these and thousands of other possible effects.\n\nAll items can be traded with other players and the currency is *not* a single type of coin: other items found in the game called **orbs** can modify items depending on their type, and are also used as currency depending on their rarity and usefulness.\n\nSome mods or combinations thereof are highly sought-after or rare and therefore more valuable. This analysis aims at **finding correlations between** the **properties** of some items and their **value**. The focus here is on **various kinds of simpler items** found in the game, since items like equipment are better tackled in a more specific analysis due to their complexity.\n\n# About the data:\n\nPath of Exile has a very rich, mostly **self-regulated economy governed by supply and demand**. Players can use a variety of instruments, official or third-party, to advertise items they sell or find items to buy. The most direct way to sell items is to put them in a special inventory that players can purchase, called a **public stash**, where they can place the items and determine their price directly from within the game. The data from these public stashes is published by the game in the form of an API, which is what this document uses as a source.\n\nThe data was extracted in the middle of a **seasonal league**, which essentially represents a **self-contained, temporary economy** that lasts several months. Permanent leagues are subject to much more extreme levels of inflation since all seasonal leagues funnel into them when they end, so this analysis will only use data from the standard variety* of the seasonal league active at the time of writing, called *Betrayal*.\n\n\\*: \"Hardcore\" leagues also exist, whose economies behave differently due to the fact that characters who die are forced out of the league. They will not be covered by this analysis.\n\nDate of item data and currency exchange rates extraction: `2019\/02\/04`","60c41add":"## Gems\nGems are the heart of Path of Exile: once equipped on an item with a compatible socket, they **grant the player** character the **abilities** with which to fight.  \nEach gem has a colour which determines the required socket colour and the attribute(s) (strength, dexterity or intelligence) it requires to be used and levelled up.\n\nAbilities are granted by **active gems**, but these can in turn be supported by one or more *support gems* which grant passive upgrades or modifications to damage and other properties of active gems. The only limitation to adding useful support gems is given by the amount of linked sockets in the item.\n\nLet's look at active gems.","21b1ae80":"Several types seem to follow a regularly **linear pattern** in terms of how much rarity impacts the price. A few oddities (such as Polished Perandus Scarabs being apparently worth more than Gilded ones, despite being a straight upgrade of them) can be explained by a lack of sufficient datapoints, but there *are* nevertheless some interesting observations to make.\n\nSome types of scarabs, notably Elder, Reliquary, Shaper, and Torment, have a **notable spike in prices** for the highest rarity compared to both of the lower tiers. These scarab types all have a rather low impact on rewards, but, as with most rewards of the game, the **usefulness scales with the tier of the maps** they are used on; the highest tiers of maps are going to be run by successful players, who can of course afford to buy the highest tier of scarabs, ignoring the lower varieties altogether.  \nPerandus Scarabs are not subject to this spike, but are still part of the low value group: they scale better with rarity, but the overall rewards are somewhat **out of sync with the state of the game**: *large* amounts of Perandus Coins, obtainable almost only through these scarabs, need to be exchanged in order to obtain good rewards, and the rewards themselves are few, highly random and time-consuming to reach, so, in short, nobody bothers much about them, which is a sympthom of the **obsolescence** of this feature, which may need some redesign by the developers.\n\nAnother notable element are **Sulphite Scarabs**: sulphite is a resource used to progress in a parallel infinite dungeon containing unique rewards, the **Delve mine**, and one of the endgame grinds calls for a very deep exploration of it, for which **immense amounts of sulphite are needed**; this explains the value, but not the reason why even the lowest rarity of Sulphite Scarab topples many of the highest rarity of other types.  \nAn explanation for that can be found in the way sulphite scales and in what changes from one tier of rarity to the other: the amount of sulphite obtained depends solely on the tier of the map, while the **rarity of the scarab** itself **only influences the amount of *bonus* sulphite** obtained by the map owner: this means that the rarity of the scarabs has no bearing whatsoever for other members of the party, which makes sulphite rotations (player-organised groups to share each other's maps and resources) accessible even with low tier scarabs: the amount of bonus \"lost\" by not having a higher tier scarab is going to be greatly offset by the sulphite generated from running other party members' maps.","dfc085bf":"We can clearly see that the first seven groups are **both** the **most numerous and** the **least expensive** fossils sold, and that the most expensive ones, the Tangled Fossils, also seem to be the rarest, but this **inverse correlation** between rarity and price **doesn't necessarily hold** for the other groups.\n\nWhy? One likely reason is the fact that certain fossils, **while** being a fairly **common** find, have **desirable properties**. The low rarity prevents them from reaching high prices, but the fact that useful fossils are consumed at a high rate by players \"gambling\" to craft good items puts them at a higher price than fossils with more niche combinations of effects.","fb5ecaf0":"Needless to say, we don't seem to have enough data to work out what's happening at the specific level 15 point. The advertised price for both data points is exactly the same, as are all other variables, which could possibly mean that a player copied another offer blindly or that we have duplicate data (which is unlikely given that we prune duplicate data points when reading the database).\n\nUltimately, this mystery will unfortunately remain unsolved.","2af748bf":"Here we can see that even though the **rarity of the classes varies a lot**, it **only** really **affects the value of Prime Resonators** (the most potent class). Even Primitive Resonators (the least potent, allowing only one fossil) don't distance themselves too much from the two middle classes, which are almost equivalent to each other in value.","7f0b7331":"As we can see, there is much variation between the prices, and even the **75th percentile doesn't** begin to **approach the maximum price**. Let's check the price ranges of the fossils.","8886ec58":"## Resonators\nResonators are interesting items: while rather static on their own, they are used by socketing various **fossils** in them, which determine the effects they have on the items they are used on: they are, for all intents and purposes, **customisable currency** items.\n\nThere are two different kinds: one to *add* properties to an item and one to *change* properties. There are various degrees of **potency** to determine how many fossils can be used, which, especially for the rarest level, are where the real value kicks in. Let's see if the picture fits our expectations.","d1578f3d":"The prices seem to be reasonably varied, but don't have any unexpected spikes: a ramp up in the last quartile, knowing the game, is to be expected: only the highest valued items distinguish themselves from the rest, with the rise in value being steep and sudden rather than gradual.\n\nBut let's examine which types actually rank highest in value to ensure that rarity isn't the only determinant.","b4ebc68b":"The overwhelming **majority** of the fossils are **not worth much** at all, being in the 0 to 9.9 price range. Since we only have few datapoints above that range, let's examine the *cheapest* fossil types instead, up to the price of 19.9 Chaos Orbs.","a6f8bb9f":"## Fragments\nLet's now examine fragments, that is, special maps that have (mostly) predetermined contents. Like regular maps, **fragments can be *played***, yielding special areas that contain monsters and rewards; some types can be combined and some types can be used to augment other maps instead of being played themselves.","c64ea984":"Now this *does* shed some light on it. (Vaal) Rain of Arrows is a gem whose potential has been unlocked during and prior to the Betrayal league through a series of interactions that made it into the main tool of one of the **strongest character builds** of the game. Is there anything special about level 15 in particular? Let's zero in on this specific gem to get a clear picture.","268de7fa":"The couple Apex of Sacrifice and **Alluring Abyss** behaves as expected: the latter **is effectively an upgrade** on the former, and so both rarity and price are higher, although we can see that the **price ascends much more quickly than the rarity**. This may be due to the Apex of Sacrifice being consumed at a very high rate by players: not only does it potentially lead to obtaining Alluring Abyss fragments, but its components can also be **used to increase a map's quality** \u2013 this is also true for the Aluring Abyss, but it is too rare and precious to use this way. The takeaway is that Alluring Abyss pieces are **more often sold instead of used**, compared to Apex pieces which are instead dropped *and* used quite often.\n\n**Breachstones** are overall more valuable, and the **price\/rarity ratio is predictable**, but Pure Breachstone value reaches the uncontested top of all fragments thanks to the high amount of character experience that running them provides. In Path of Exile, even **letting other players run** a map **alongside you** is a **marketable service**, and so the price for sold Pure Breachstones will likely be amortised by buyers willing to share their usage.\n\nThe other notable element is the **Pale Court** which, together with Apex of Sacrifice, Alluring Abyss, and creature Fragments, is a **set of four pieces** which, when used together, give access to a special location and boss fight. Despite Pale Court pieces being tedious to obtain, the **rewards are comparatively meagre**, so the price remains significantly lower than Alluring Abyss pieces.\n\n**Divine Vessels** and Offerings to the Goddess, their drop-rate being solely due to luck (with no particular procedure available to consistently get them), and their usage being lateral in the gameplay, maintain a **steady low price**. Vessels are used to upgrade certain aspects of characters and yield no benefit whatsoever after the desired set of upgrades is obtained, so the **demand will be proportional to the amount of characters** in the league, and the drop-rate is evidently more than enough to ensure that new characters will not impact the prices.  \n**Offering to the Goddess** is used instead to gain access to the Labyrinth, which too provides permanent upgrades to characters in a limited amount, but running the Labyrinth itself is also **crucial for completing endgame grinds** (repetitive challenges some players choose to complete), and this ensures a somewhat higher price.\n\n\"Creature\" Fragments are obtained as rewards from the **four highest-tier bosses** of the map atlas, and are used to **gain access to the final boss** fight(s), which are sought for challenge completion, endgame grinds, and potentially **very valuable rewards** such as the Watcher's Eye (see: section on unique jewels).  \nBy themselves they are not too difficult to obtain for high-level characters, and their drop being guaranteed on completion of the highest tier maps makes for a somewhat common harvest for players who can consistently run those maps.  \nThe prevalence in number of **Hydra fragments** despite the price remaining stable could be a simple fluke, or it may be tied to the Hydra being much less deadly than the other bosses, but the players might not have noticed the peculiar amount of pieces on sale, at least at the time of writing.","2fb9591c":"We can see that the escalation for gem prices is **approximately linear**, especially when considering uncorrupted gems. Corrupted gems, while sometimes having useful effects not otherwise attainable, cannot be further modified, so it makes sense that their price would spike more starkly, effectively multiplying the impact of other desirable or undesirable properties on value.\n\nTo make sure of this and to verify how much corruption actually impacts value relative to other properties, let's compare corrupted and uncorrupted gem values based on their level. The expectation is that low level gems be much less valuable when corrupted, with values skyrocketing when surpassing the usual max level of 20 (which only corruption can potentially increase).","e73f736e":"As expected, level 21 gems are only present in the currupted variety, and have a **very large price difference** from other types; level 20 gems also behave as expected, with uncorrupted gems being worth more (because they can still be corrupted).\n\nThere are, however, two unexpected sights. The least apparent one is that corrupted gems appear to be **similar or higher in value** than uncorrupted ones, despite being unmodifiable, even at levels far from the maximum, specifically in the range of **levels 6 to 12**.  \nA possible explanation includes the possibility that these corrupted gems have high quality, or that corruption resulted in their \"expansion\" into **Vaal Gems**. Vaal Gems contain a special version of the ability that gradually charges up as the player kills monsters; the charges can be released once full to unleash a powerful effect, and the gem also retains the normal version of the ability.\n\nCorruption can also result in the creation of some unique abilities, when applied to certain specific gems. Furthermore, although most gems have a **max level of 20** (21 with successful corruption), there also are rare special gems that don't level up and thus have a **max level of 1**. Such gems include Detonate Mines and Portal, the latter of which, under specific conditions, can also be corrupted into the rare Vaal Breach gem.\n\nBut the elephant in the room is without a doubt the **level 15 spike**, where corrupted gems outprice uncorrupted ones by a very large margin.\n\nLet's zoom in on level 15 gems to check whether this is a quirk of some specific gems rather than an important general pattern.","c1bc4644":"## Scarabs\nA recent addition to the map ecosystem of Path of Exile are **Scarabs**, which can be used to augment maps to **guarantee certain contents** which would otherwise be left to chance or be impossible to obtain.","64abf6b5":"## Fossils\nWe can now examine the prices of fossils as one of the simplest types of items: they have **no features apart from** their **base type**, thus we can immediately infer that it be the only factor of their price, whether through the usefulness of the properties or the rarity of each type, on whose details we unfortunately lack precise data."}}