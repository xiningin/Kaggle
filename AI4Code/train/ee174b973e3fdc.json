{"cell_type":{"aa94d9ba":"code","fa878521":"code","8a89f646":"code","a781b508":"code","f55f2787":"code","bf600aee":"code","5c433a7b":"code","fc592d6b":"code","e440fb41":"code","9bd38a50":"code","1f589a13":"code","9ceec335":"code","15440ece":"code","308eb675":"code","02324474":"code","da90a059":"code","11a10e71":"code","0179440d":"code","ade40216":"code","c04a337d":"code","656e1c3d":"code","416e6f83":"code","c99e175a":"code","b4b70b44":"code","fd62f243":"code","3668e83c":"code","00400d59":"markdown","b906af38":"markdown","e9c473b8":"markdown","bf965448":"markdown","28bf1430":"markdown","a6315b76":"markdown","5ba43ddc":"markdown","8ba3ca87":"markdown","d8b409d4":"markdown","d897146b":"markdown","28db52cd":"markdown","4809d589":"markdown","bbf0be1e":"markdown","425e9c94":"markdown","897326a4":"markdown","3fc6f61a":"markdown","3478cf9d":"markdown","910d5143":"markdown","71f13539":"markdown","4b8b116a":"markdown","a8cfe982":"markdown","bb05d3d4":"markdown","b36b5f9a":"markdown","31dbc2aa":"markdown"},"source":{"aa94d9ba":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom collections import Counter\nimport matplotlib.patches as mpatches\nsns.set_style(\"white\")","fa878521":"plt.rcParams[\"axes.labelsize\"] = 16.\nplt.rcParams[\"xtick.labelsize\"] = 14.\nplt.rcParams[\"ytick.labelsize\"] = 14.\nplt.rcParams[\"legend.fontsize\"] = 12.\nplt.rcParams[\"figure.figsize\"] = [15., 6.]","8a89f646":"battles = pd.read_csv(\"..\/input\/battles.csv\")\ncharacter_deaths = pd.read_csv(\"..\/input\/character-deaths.csv\")\ncharacter_predictions = pd.read_csv(\"..\/input\/character-predictions.csv\")","a781b508":"battles.loc[:, \"defender_count\"] = (4 - battles[[\"defender_1\", \"defender_2\", \"defender_3\", \"defender_4\"]].isnull().sum(axis = 1))\nbattles.loc[:, \"attacker_count\"] = (4 - battles[[\"attacker_1\", \"attacker_2\", \"attacker_3\", \"attacker_4\"]].isnull().sum(axis = 1))\nbattles.loc[:, \"att_comm_count\"] = [len(x) if type(x) == list else np.nan for x in battles.attacker_commander.str.split(\",\")]\ncharacter_predictions.loc[:, \"no_of_books\"] = character_predictions[[x for x in character_predictions.columns if x.startswith(\"book\")]].sum(axis = 1)","f55f2787":"p = battles.groupby('year').sum()[[\"major_death\", \"major_capture\"]].plot.bar(rot = 0)\n_ = p.set(xlabel = \"Year\", ylabel = \"No. of Death\/Capture Events\", ylim = (0, 9)), p.legend([\"Major Deaths\", \"Major Captures\"])","bf600aee":"data = battles.dropna(axis = 0, subset = [[\"attacker_size\", \"defender_size\", \"attacker_outcome\"]]).copy(deep = True)\ncolors = [sns.color_palette()[0] if x == \"win\" else \"lightgray\" for x in data.attacker_outcome.values]\np = data.plot.scatter(\"attacker_size\", \"defender_size\", c = colors, s = 100, lw = 2.)\n_ = p.set(xlabel = \"Attacker Size\", ylabel = \"Defender Size\")","5c433a7b":"p = battles.attacker_count.value_counts().sort_index().plot.bar(rot = 0)\n_ = p.set(xlabel = \"No. of Major Attacker Houses\", ylabel = \"Count\")","fc592d6b":"#Ignoring records where either attacker_king or defender_king is null. Also ignoring one record where both have the same value.\nc = list(Counter([tuple(set(x)) for x in battles.dropna(subset = [\"attacker_king\", \"defender_king\"])[[\"attacker_king\", \"defender_king\"]].values if len(set(x)) > 1]).items())\np = pd.DataFrame(c).sort_values(1).plot.barh(figsize = (10, 6))\n_ = p.set(yticklabels = [\"%s vs. %s\" % (x[0], x[1]) for x in list(zip(*c))[0]], xlabel = \"No. of Battles\"), p.legend(\"\")","e440fb41":"p = sns.boxplot(\"att_comm_count\", \"attacker_king\", data = battles, saturation = .6, fliersize = 10., palette = [\"lightgray\", sns.color_palette()[1], \"grey\", \"darkblue\"])\n_ = p.set(xlabel = \"No. of Attacker Commanders\", ylabel = \"Attacker King\", xticks = range(8))","9bd38a50":"data = battles.groupby(\"region\").sum()[[\"major_death\", \"major_capture\"]]\np = pd.concat([data, battles.region.value_counts().to_frame()], axis = 1).sort_values(\"region\", ascending = False).copy(deep = True).plot.bar(color = [sns.color_palette()[1], \"grey\", \"darkblue\"], rot = 0)\n_ = p.set(xlabel = \"Region\", ylabel = \"No. of Events\"), p.legend([\"Major Deaths\", \"Major Captures\", \"No. of Battles\"], fontsize = 12.)","1f589a13":"data = character_predictions.groupby([\"boolDeadRelations\", \"isAlive\"]).count()[\"S.No\"].unstack().copy(deep = True)\np = data.div(data.sum(axis = 1), axis = 0).plot.barh(stacked = True, rot = 0, width = .5)\n_ = p.set_xlim([0, 1]), p.set(yticklabels = [\"No\", \"Yes\"], xticklabels = \"\", xlabel = \"Proportion of Dead vs. Alive\", ylabel = \"Has Dead Relations\"), p.legend([\"Dead\", \"Alive\"])","9ceec335":"data = character_predictions.groupby([\"no_of_books\", \"isAlive\"]).count()[\"S.No\"].unstack().copy(deep = True)\np = data.div(data.sum(axis = 1), axis = 0).plot.barh(stacked = True, rot = 0, figsize = (15, 8), width = .5)\n_ = p.set(xticklabels = \"\", xlim = [0, 1], ylabel = \"No. of Books\", xlabel = \"Proportion of Dead vs. Alive\"), p.legend([\"Dead\", \"Alive\"], loc = \"upper right\", ncol = 2, borderpad = -.15)","15440ece":"cult = {\n    'Summer Islands': ['summer islands', 'summer islander', 'summer isles'],\n    'Ghiscari': ['ghiscari', 'ghiscaricari',  'ghis'],\n    'Asshai': [\"asshai'i\", 'asshai'],\n    'Lysene': ['lysene', 'lyseni'],\n    'Andal': ['andal', 'andals'],\n    'Braavosi': ['braavosi', 'braavos'],\n    'Dornish': ['dornishmen', 'dorne', 'dornish'],\n    'Myrish': ['myr', 'myrish', 'myrmen'],\n    'Westermen': ['westermen', 'westerman', 'westerlands'],\n    'Westerosi': ['westeros', 'westerosi'],\n    'Stormlander': ['stormlands', 'stormlander'],\n    'Norvoshi': ['norvos', 'norvoshi'],\n    'Northmen': ['the north', 'northmen'],\n    'Free Folk': ['wildling', 'first men', 'free folk'],\n    'Qartheen': ['qartheen', 'qarth'],\n    'Reach': ['the reach', 'reach', 'reachmen'],\n}\n\ndef get_cult(value):\n    value = value.lower()\n    v = [k for (k, v) in cult.items() if value in v]\n    return v[0] if len(v) > 0 else value.title()","308eb675":"character_predictions.loc[:, \"culture\"] = [get_cult(x) for x in character_predictions.culture.fillna(\"\")]\ndata = character_predictions.groupby([\"culture\", \"isAlive\"]).count()[\"S.No\"].unstack().copy(deep = True)\ndata.loc[:, \"total\"]= data.sum(axis = 1)\np = data[data.index != \"\"].sort_values(\"total\")[[0, 1]].plot.barh(stacked = True, rot = 0, figsize = (14, 12),)\n_ = p.set(xlabel = \"No. of Characters\", ylabel = \"Culture\"), p.legend([\"Dead\", \"Alive\"], loc = \"lower right\")","02324474":"data = battles.dropna(subset = [\"attacker_size\", \"defender_size\"]).copy(deep = True)\ndata = pd.concat([(data.attacker_size - data.defender_size).to_frame(), battles[[\"attacker_outcome\"]]], axis = 1, join = \"inner\")\ndata = data[data[0] != 0]\np = data[0].plot.barh(figsize = (12, 8), width = .8, color = [sns.color_palette()[0] if x == \"win\" else sns.color_palette()[2] if x == \"loss\" else \"white\" for x in data.attacker_outcome.values])\n_ = p.legend(handles = [mpatches.Patch(color = sns.color_palette()[0], label = \"Victory\", aa = True), mpatches.Patch(color = sns.color_palette()[2], label = \"Loss\", aa = True)])\n_ = p.axvline(0, color = 'k'), p.set(yticklabels = battles.name.iloc[data.index].values, xlabel = \"Difference in Army Size (attacker_size - defender_size)\", ylabel = \"Battle Name\")","da90a059":"from matplotlib.path import Path\nfrom matplotlib.spines import Spine\nfrom matplotlib.projections.polar import PolarAxes\nfrom matplotlib.projections import register_projection\n\ndef radar_factory(num_vars, frame = \"circle\"):\n    theta = np.linspace(0, 2 * np.pi, num_vars, endpoint = False)\n    theta += np.pi \/ 2\n\n    def draw_poly_patch(self):\n        verts = unit_poly_verts(theta)\n        return plt.Polygon(verts, closed = True, edgecolor = 'k')\n\n    def draw_circle_patch(self):\n        return plt.Circle((0.5, 0.5), 0.5)\n\n    patch_dict = {'polygon': draw_poly_patch, 'circle': draw_circle_patch}\n    if frame not in patch_dict: raise ValueError('unknown value for `frame`: %s' % frame)\n\n    class RadarAxes(PolarAxes):\n        name, RESOLUTION, draw_patch = 'radar', 1, patch_dict[frame]\n\n        def fill(self, *args, **kwargs):\n            closed = kwargs.pop(\"closed\", True)\n            return super(RadarAxes, self).fill(closed = closed, *args, **kwargs)\n\n        def plot(self, *args, **kwargs):\n            lines = super(RadarAxes, self).plot(*args, **kwargs)\n            for line in lines: self._close_line(line)\n\n        def _close_line(self, line):\n            x, y = line.get_data()\n            if x[0] != x[-1]:\n                x = np.concatenate((x, [x[0]]))\n                y = np.concatenate((y, [y[0]]))\n                line.set_data(x, y)\n\n        def set_varlabels(self, labels):\n            self.set_thetagrids(np.degrees(theta), labels)\n\n        def _gen_axes_patch(self):\n            return self.draw_patch()\n\n        def _gen_axes_spines(self):\n            if frame == \"circle\": return PolarAxes._gen_axes_spines(self)\n            spine_type, verts = \"circle\", unit_poly_verts(theta)\n            verts.append(verts[0])\n            path = Path(verts)\n            spine = Spine(self, spine_type, path)\n            spine.set_transform(self.transAxes)\n            return {'polar': spine}\n    register_projection(RadarAxes)\n    return theta\n\ndef unit_poly_verts(theta):\n    x0, y0, r = [0.5] * 3\n    verts = [(r * np.cos(t) + x0, r * np.sin(t) + y0) for t in theta]\n    return verts\n\nkings = list(battles.attacker_king.append(battles.defender_king).fillna(\"Unknown\").unique())\nbattle_types = list(battles.battle_type.fillna(\"Unknown\").str.title().unique())\n\ndef example_data():\n    data = battles[[\"battle_type\", \"attacker_king\", \"defender_king\", \"name\"]].copy(deep = True).fillna(\"Unknown\")\n    data.loc[:, \"battle_type\"] = data.battle_type.fillna(\"Unknown\").str.title()\n    grouped, ret_data = data.groupby([\"attacker_king\", \"battle_type\"]).count()[[\"name\"]], [battle_types]\n    ret_data.append((\"As Attacker King\", [[grouped.loc[(kings[j], battle_types[i])].values[0]\n                                    if (kings[j], battle_types[i]) in grouped.index else 0\n                                    for i in range(len(battle_types))] for j in range(len(kings))]))\n    grouped = data.groupby([\"defender_king\", \"battle_type\"]).count()[[\"name\"]]\n    ret_data.append((\"As Defender King\", [[grouped.loc[(kings[j], battle_types[i])].values[0]\n                                    if (kings[j], battle_types[i]) in grouped.index else 0\n                                    for i in range(len(battle_types))] for j in range(len(kings))]))\n    return ret_data\n\nN = 5\ntheta, data = radar_factory(N, frame = \"polygon\"), example_data()\nspoke_labels, fig = data.pop(0), plt.figure(figsize = (14, 14))\nfig.subplots_adjust(wspace = 0.35, hspace = 0.20, top = 0.85, bottom = 0.05)\ncolors = sns.color_palette() + [\"k\"]\nfor n, (title, case_data) in enumerate(data):\n    ax, _ = fig.add_subplot(2, 2, n + 1, projection = \"radar\"), plt.rgrids([1, 2, 3, 4, 5])\n    ax.set_title(title, weight = \"bold\", position = (0.5, 1.1), horizontalalignment = \"center\", verticalalignment = \"center\", fontsize = 13.)\n    for d, color in zip(case_data, colors):\n        ax.plot(theta, d, color = color)\n        ax.fill(theta, d, facecolor = color, alpha = 0.5)\n    ax.set_varlabels(spoke_labels)\nplt.subplot(2, 2, 1)\nlabels = kings\nlegend = plt.legend(labels, loc = (.95, .95), labelspacing = 0.1)\nplt.setp(legend.get_texts(), fontsize = \"large\")\nplt.figtext(0.5, 0.965, \"Types of Battles Fought By Kings as Attacker\/Defender\", ha = \"center\", color = \"k\", size = 16.)\nplt.show()","11a10e71":"death_preds = character_predictions.copy(deep = True)","0179440d":"from xgboost import plot_importance\nfrom xgboost import XGBClassifier as XGBC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score, roc_curve, log_loss, confusion_matrix, precision_score, recall_score, classification_report, accuracy_score","ade40216":"death_preds.loc[:, \"culture\"] = [get_cult(x) for x in death_preds.culture.fillna(\"\")]\ndeath_preds.loc[:, \"title\"] = pd.factorize(death_preds.title)[0]\ndeath_preds.loc[:, \"culture\"] = pd.factorize(death_preds.culture)[0]\ndeath_preds.loc[:, \"mother\"] = pd.factorize(death_preds.mother)[0]\ndeath_preds.loc[:, \"father\"] = pd.factorize(death_preds.father)[0]\ndeath_preds.loc[:, \"heir\"] = pd.factorize(death_preds.heir)[0]\ndeath_preds.loc[:, \"house\"] = pd.factorize(death_preds.house)[0]\ndeath_preds.loc[:, \"spouse\"] = pd.factorize(death_preds.spouse)[0]\n\ndeath_preds.drop([\"name\", \"alive\", \"pred\", \"plod\", \"isAlive\", \"dateOfBirth\"], 1, inplace = True)\ndeath_preds.columns = map(lambda x: x.replace(\".\", \"\").replace(\"_\", \"\"), death_preds.columns)\ndeath_preds.fillna(value = -1, inplace = True)","c04a337d":"f, ax = plt.subplots(1, 2, figsize = (15, 7))\nf.suptitle(\"Class Distribution\", fontsize = 18.)\n_ = death_preds.actual.value_counts().plot.bar(ax = ax[0], rot = 0, color = (sns.color_palette()[0], sns.color_palette()[2])).set(xticklabels = [\"Alive\", \"Deceased\"])\n_ = death_preds.actual.value_counts().plot.pie(labels = (\"Alive\", \"Deceased\"), autopct = \"%.2f%%\", label = \"\", fontsize = 13., ax = ax[1],\\\ncolors = (sns.color_palette()[0], sns.color_palette()[2]), wedgeprops = {\"linewidth\": 1.5, \"edgecolor\": \"#F7F7F7\"}), ax[1].texts[1].set_color(\"#F7F7F7\"), ax[1].texts[3].set_color(\"#F7F7F7\")","656e1c3d":"X = death_preds[death_preds.actual == 0].sample(350, random_state = 62).append(death_preds[death_preds.actual == 1].sample(350, random_state = 62)).copy(deep = True).astype(np.float64)\nY = X.actual.values\ntX = death_preds[~death_preds.index.isin(X.index)].copy(deep = True).astype(np.float64)\ntY = tX.actual.values\nX.drop([\"SNo\", \"actual\", \"DateoFdeath\"], 1, inplace = True)\ntX.drop([\"SNo\", \"actual\", \"DateoFdeath\"], 1, inplace = True)","416e6f83":"clf_xgb = XGBC(subsample = .8, colsample_bytree = .8, seed = 14, max_depth = 3).fit(X, Y)\npreds_xgb = clf_xgb.predict_proba(tX)\nax = pd.DataFrame(list(clf_xgb.get_booster().get_fscore().items())).set_index(0)\\\n.sort_values(1).plot.barh(figsize = (12, 8))\n_ = ax.set(frame_on = False, ylim = (0, len(clf_xgb.get_booster().get_fscore())), xticklabels = \"\", xlabel = \"\", ylabel = \"\"), ax.legend(\"\")\n_ = plt.title(\"XGB Feature Importance\", fontsize = 18.)","c99e175a":"logreg = LogisticRegression(random_state = 14).fit(X, Y)\npreds_lr = logreg.predict_proba(tX)\n\ndf = pd.DataFrame(list(zip(tX.columns, logreg.coef_[0])))\ndf = df.reindex(df[1].abs().sort_values().index).set_index(0)\nax = df.plot.barh(width = .6, legend = \"\", figsize = (12, 9))\nax.set_title(\"Logistic Regression Coefficients\", y = 1.03, fontsize = 16.)\n_ = ax.set(frame_on = False, xlabel = \"\", xticklabels = \"\", ylabel = \"\")\n\nfor i, label in enumerate(list(df.index)):\n    score = df.loc[label][1]\n    ax.annotate('%.2f' % score, (score + (-.12 if score < 0 else .02), i - .2), fontsize = 10.5)","b4b70b44":"f, ax = plt.subplots(1, 2, figsize = (15, 8))\nf.suptitle(\"Normalized Confusion Matrices\", fontsize = 18.)\ndef make_cm(p, t, axis):\n    cm = confusion_matrix(tY, np.argmax(p, axis = 1))\n    cm = cm.astype('float') \/ cm.sum(axis = 1)[:, np.newaxis]\n    _ = sns.heatmap(cm, square = True, xticklabels = [\"Deceased\", \"Alive\"], annot = True,\n                    annot_kws = {\"fontsize\": 13}, yticklabels = [\"Deceased\", \"Alive\"],\n                    cbar = True, cbar_kws = {\"orientation\": \"horizontal\"}, ax = ax[axis], cmap = \"Blues\").set(\n        xlabel = \"Predicted Class\", ylabel = \"Actual Class\", title = t)\nmake_cm(preds_xgb, \"XGB Classifier\", 0)\nmake_cm(preds_lr, \"Logistic Regression\", 1)","fd62f243":"print(\"XGB Classifier Performance\\n\" + \"=\" * 26 + \"\\n\", classification_report(tY, np.argmax(preds_xgb, axis = 1), target_names = [\"Deceased\", \"Alive\"]))\nprint(\"AUC      : %.4f\" % roc_auc_score(tY, preds_xgb[:, 1]))\nprint(\"Accuracy : %.4f\" % accuracy_score(tY, np.argmax(preds_xgb, axis = 1)))\nprint(\"Log Loss : %.4f\\n\\n\" % log_loss(tY, preds_xgb[:, 1]))\nprint(\"Logistic Regression Performance\\n\" + \"=\" * 31 + \"\\n\", classification_report(tY, np.argmax(preds_lr, axis = 1), target_names = [\"Deceased\", \"Alive\"]))\nprint(\"AUC      : %.4f\" % roc_auc_score(tY, preds_lr[:, 1]))\nprint(\"Accuracy : %.4f\" % accuracy_score(tY, np.argmax(preds_lr, axis = 1)))\nprint(\"Log Loss : %.4f\" % log_loss(tY, preds_lr[:, 1]))","3668e83c":"_ = plt.figure(figsize = (8, 8)), plt.plot(*roc_curve(tY, preds_xgb[:, 1])[:2]), plt.plot(*roc_curve(tY, preds_lr[:, 1])[:2], c = sns.color_palette()[1]), plt.legend([\"XGB Classifier\", \"Logistic Regression\"], loc = \"upper left\")\n_ = plt.plot((0., 1.), (0., 1.), \"--k\", alpha = .7), plt.xlabel(\"False Positive Rate\"), plt.ylabel(\"True Positive Rate\"), plt.title(\"ROC Curves\", fontsize = 16.)","00400d59":"# Predictive Experiment\nI have added this quick predictive experiment to complete the analysis. It does not go into too much depth. However, I will try and add more things as and when I get time.","b906af38":"## New attributes\n1. *defender_count* \u2013 Number of major houses on defending side\n2. *attacker_count* \u2013 Number of major houses on attacking side\n3. *att_comm_count* \u2013 Number of commanders on attacking side\n4. *no_of_books* \u2013 Number of books a character appeared in","e9c473b8":"## Is there a relationship between survival and having dead relations?","bf965448":"## Logistic Regression","28bf1430":"## How many major death\/capture events occur in each region?","a6315b76":"## Is there a class imbalance?\nLet us take a look at the class distribution now.","5ba43ddc":"## How many commanders did armies of different kings have?","8ba3ca87":"## Comparison of XGB Classifier and Logistic Regression","d8b409d4":"# Exploratory Analysis","d897146b":"## Featured in [The Wall Street Journal][1].\n\n  [1]: https:\/\/www.wsj.com\/articles\/fans-geek-out-over-game-of-thrones-data-1499877067","28db52cd":"## XGB Classifier","4809d589":"## How does culture relate to survival?\nFor this, we will rename cultures using (ahem) domain knowledge as many of the culture values map to a single culture.","bbf0be1e":"### Confusion Matrix\nFirst we see the confusion matrices for both models. We will normalize these by their row-wise sums before visualizing.","425e9c94":"### Scorecard\nNext, we see the scorecard of both models. We use the handy `classification_report` and a number of other functions from `sklearn.metrics` to look at different evaluation metrics such as AUC, log loss, and accuracy.","897326a4":"### ROC Curves\nFinally, we look at the ROC curves for both models.","3fc6f61a":"## How does appearing in more books relate to survival?","3478cf9d":"## A bit of preprocessing\nWe quickly convert non-numeric categorical features to numeric. Then we drop some columns and replace missing values with -1.","910d5143":"## Impact of army size on outcome\n[Based on ggplot code from this notebook](https:\/\/github.com\/chrisalbon\/war_of_the_five_kings_dataset\/blob\/master\/exploratory_analysis.ipynb)","71f13539":"The class distribution indicates an imbalance. There are many more characters alive than dead. There are several well-known ways to tackle this problem.\n\nTwo of the simplest ways are undersampling and oversampling. In this case, we will undersample the majority class. We will draw ~70% samples without replacement from the minority *Deceased* class. We will draw an equal number of samples (~350) from the majority *Alive* class.\n\nUsing this train-test split we will build and compare two models: an XGB Classifier model and a Logistic Regression model.","4b8b116a":"## Which pairs fought the most battles?","a8cfe982":"## Major death\/capture events by year","bb05d3d4":"## How often were there more than one major houses on the attacking side?","b36b5f9a":"## Do larger armies necessarily win?\nThe results for this one are, well, weird as you can see.\n\nTo be fair, though, I have only considered battles with valid values for *attacker\\_size* and *defender\\_size*, which reduces the record count to 16 down from 37. I am not a GoT fan (yet) nor have I watched the TV series.\n\nI read about one of the battles with `NaN` *attacker\\_size* on the [GoT Wikia](http:\/\/gameofthrones.wikia.com\/wiki\/Battle_at_the_Mummer's_Ford), wherein the following is stated under the _Forces_ section:\n> A raiding party was reported by the Riverlands smallfolk refugees but the Iron Throne detachment was met by a considerably larger force.\n\nBased on this, if we assumed that *attacker\\_size* was larger, it would count in favor of the position that larger armies are likelier to win. However, we do not have this data for the remaining 20 battles so we cannot say anything conclusively.\n\n**If you are knowledgeable about GoT, do comment below on this.**","31dbc2aa":"## How often did kings fight different types of battles?\nThe data contains four types of battles of which _Pitched Battle_ is the most frequent and _Razing_ the least.\n\nIt turns out that _Ambush_ seems to be Robb Stark's favorite type of attack. All five of his _Ambush_ type battles are against Joffrey\/Tommen Baratheon. Robb Stark has also been a target of an ambush: twice by Balon\/Euron Greyjoy and thrice by Joffrey\/Tommen Baratheon.\n\nBalon\/Euron Greyjoy has fought each type of battle at least once as an attacker while Joffrey\/Tommen Baratheon has done so as a defender.\n\nSee chart below.\n\n*(Using code from matplotlib's radar chart [example](http:\/\/matplotlib.org\/examples\/api\/radar_chart.html).)*"}}