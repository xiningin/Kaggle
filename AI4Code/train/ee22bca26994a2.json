{"cell_type":{"244e7aec":"code","9a9024e6":"code","4634e09a":"code","d92810f3":"code","d758ebf7":"code","6585abfa":"code","d7ede98a":"code","7605088b":"code","bd06b5c4":"code","fe15b501":"code","26477d03":"code","56970b3e":"code","7177100a":"code","05df3713":"code","598611b4":"code","5f2a81bc":"markdown","01cd0fc8":"markdown","3eb9bee6":"markdown","10271311":"markdown","29ad91f0":"markdown","3691dcdc":"markdown","d62e2a56":"markdown","3cd14bf0":"markdown","1a884dca":"markdown","b003f010":"markdown","434da39c":"markdown","a3a71c26":"markdown","9fe8140f":"markdown","4cbd74fb":"markdown","26d80551":"markdown","e5900797":"markdown","6673809b":"markdown","0a839ca5":"markdown","dba4c17d":"markdown"},"source":{"244e7aec":"import warnings\nwarnings.simplefilter('ignore')\nimport pandas as pd\nimport numpy as np\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport gc\nimport multiprocessing\nimport seaborn as sns\npd.set_option('display.max_columns', 83)\npd.set_option('display.max_rows', 83)\nplt.style.use('seaborn')\nimport os\nimport plotly.plotly as py\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\nimport cufflinks\nimport plotly\nimport matplotlib\ninit_notebook_mode()\ncufflinks.go_offline()\ncufflinks.set_config_file(world_readable=True, theme='pearl', offline=True)\nprint(os.listdir(\"..\/input\"))\nfor package in [pd, np, sns, matplotlib, plotly]:\n    print(package.__name__, 'version:', package.__version__)","9a9024e6":"dtypes = {\n        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',\n        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',\n        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',\n        'Census_IsTouchEnabled':                                'int8',\n        'Census_IsPenCapable':                                  'int8',\n        'Wdft_IsGamer':                                         'float16',\n        'Processor':                                            'category',\n        'HasDetections':                                        'int8'\n        }","4634e09a":"def load_dataframe(dataset):\n    usecols = dtypes.keys()\n    if dataset == 'test':\n        usecols = [col for col in dtypes.keys() if col != 'HasDetections']\n    df = pd.read_csv(f'..\/input\/{dataset}.csv', dtype=dtypes, usecols=usecols)\n    return df","d92810f3":"%%time\nwith multiprocessing.Pool() as pool: \n    train, test = pool.map(load_dataframe, [\"train\", \"test\"])","d758ebf7":"fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(18,8))\ntrain['Census_InternalPrimaryDisplayResolutionHorizontal'].value_counts().head(10).plot(kind='barh', ax=axes[0], fontsize=14).set_xlabel('Horizontal Resolution', fontsize=18)\ntrain['Census_InternalPrimaryDisplayResolutionVertical'].value_counts().head(10).plot(kind='barh', ax=axes[1], fontsize=14).set_xlabel('Vertical Resolution', fontsize=18)\naxes[0].invert_yaxis()\naxes[1].invert_yaxis()","6585abfa":"train['ResolutionRatio'] = train['Census_InternalPrimaryDisplayResolutionVertical'] \/ train['Census_InternalPrimaryDisplayResolutionHorizontal']","d7ede98a":"train['ResolutionRatio'].value_counts().head(10).plot(kind='barh', figsize=(14,8), fontsize=14);\nplt.gca().invert_yaxis()","7605088b":"ratios = train['ResolutionRatio'].value_counts().head(6).index\nfig, axes = plt.subplots(nrows=int(len(ratios) \/ 2), ncols=2, figsize=(16,14))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\nfor i in range(len(ratios)):\n    sns.countplot(x='ResolutionRatio', hue='HasDetections', data=train[train['ResolutionRatio'] == ratios[i]], ax=axes[i \/\/ 2,i % 2]);","bd06b5c4":"fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(18,10))\ntrain.loc[train['Census_InternalPrimaryDisplayResolutionVertical'] < 720, 'HasDetections'].value_counts().sort_index().plot(kind='bar', rot=0, ax=axes[0,0]).set_xlabel('SD');\ntrain.loc[(train['Census_InternalPrimaryDisplayResolutionVertical'] >= 720) & (train['Census_InternalPrimaryDisplayResolutionVertical'] < 1080), 'HasDetections'].value_counts().sort_index().plot(kind='bar', rot=0, ax=axes[0,1]).set_xlabel('HD');\ntrain.loc[(train['Census_InternalPrimaryDisplayResolutionVertical'] >= 1080) & (train['Census_InternalPrimaryDisplayResolutionVertical'] < 2160), 'HasDetections'].value_counts().sort_index().plot(kind='bar', rot=0, ax=axes[1,0]).set_xlabel('FullHD');\ntrain.loc[train['Census_InternalPrimaryDisplayResolutionVertical'] >= 2160, 'HasDetections'].value_counts().sort_index().plot(kind='bar', rot=0, ax=axes[1,1]).set_xlabel('4k');","fe15b501":"sd_values = train.loc[train['Census_InternalPrimaryDisplayResolutionVertical'] < 720, 'HasDetections'].value_counts().sort_index().values\nhd_values = train.loc[(train['Census_InternalPrimaryDisplayResolutionVertical'] >= 720) & (train['Census_InternalPrimaryDisplayResolutionVertical'] < 1080), 'HasDetections'].value_counts().sort_index().values\nfullhd_values = train.loc[(train['Census_InternalPrimaryDisplayResolutionVertical'] >= 1080) & (train['Census_InternalPrimaryDisplayResolutionVertical'] < 2160), 'HasDetections'].value_counts().sort_index().values\nk_values = train.loc[train['Census_InternalPrimaryDisplayResolutionVertical'] >= 2160, 'HasDetections'].value_counts().sort_index().values\nx = ['SD', 'HD', 'FullHD', '4k']\ny_0 = [sd_values[0], hd_values[0], fullhd_values[0], k_values[0]]\ny_1 = [sd_values[1], hd_values[1], fullhd_values[1], k_values[1]]\ntrace1 = go.Bar(x=x, y=y_0, name='0 (no detections)')\ntrace2 = go.Bar(x=x, y=y_1, name='1 (has detections)')\ndata = [trace1, trace2]\nlayout = go.Layout(barmode='group')\nfig = go.Figure(data=data, layout=layout)\niplot(fig)","26477d03":"def movingaverage(interval, window_size):\n    window = np.ones(int(window_size))\/float(window_size)\n    return np.convolve(interval, window, 'same')\n\nplot_dict = dict()\nfor i in train['Census_InternalPrimaryDiagonalDisplaySizeInInches'].value_counts().sort_index().index:\n    try:\n        plot_dict[i] = train.loc[train['Census_InternalPrimaryDiagonalDisplaySizeInInches'] == i, 'HasDetections'].value_counts(normalize=True)[1]\n    except:\n        plot_dict[i] = 0.0\nfig, ax1 = plt.subplots(figsize=(16,7))\nax1.set_xlabel('Display Size in inches')\nax1.set_ylabel('Count', color='tab:green')\nax1.hist(plot_dict.keys(), color='tab:green', bins=int(len(plot_dict) \/ 20))\nax1.tick_params(axis='y', labelcolor='tab:green')\nax2 = ax1.twinx()\nax2.set_ylabel('Detection Rate', color='blue')\nax2.plot(plot_dict.keys(), movingaverage(list(plot_dict.values()), int(len(plot_dict) \/ 20)),color='blue', linewidth=2.0)\nax2.tick_params(axis='y', labelcolor='blue')\nplt.show()","56970b3e":"fig, axes = plt.subplots(nrows=int(len(ratios) \/ 2), ncols=2, figsize=(18,16))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\nfor i in range(len(ratios)):\n    train.loc[train['ResolutionRatio'] == ratios[i], 'Wdft_IsGamer'].value_counts(True, dropna=False).plot(kind='bar', rot=0, ax=axes[i \/\/ 2,i % 2], fontsize=14).set_xlabel('Wdft_IsGamer', fontsize=18)\n    axes[i \/\/ 2,i % 2].plot(0, train.loc[(train['ResolutionRatio'] == ratios[i]) & (train['Wdft_IsGamer'] == 0.0), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].plot(1, train.loc[(train['ResolutionRatio'] == ratios[i]) & (train['Wdft_IsGamer'] == 1.0), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].plot(2, train.loc[(train['ResolutionRatio'] == ratios[i]) & (train['Wdft_IsGamer'].isnull()), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24) \n    axes[i \/\/ 2,i % 2].legend(['Detection rate (%)'])\n    axes[i \/\/ 2,i % 2].set_title('Ratio: ' + str(ratios[i]), fontsize=18)\nfig.suptitle('Resolution rate to Wdft_IsGamer interaction', fontsize=18);","7177100a":"fig, axes = plt.subplots(nrows=int(len(ratios) \/ 2), ncols=2, figsize=(18,16))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\nfor i in range(len(ratios)):\n    train.loc[train['ResolutionRatio'] == ratios[i], 'Census_IsTouchEnabled'].value_counts(True, dropna=False).plot(kind='bar', rot=0, ax=axes[i \/\/ 2,i % 2], fontsize=14).set_xlabel('Census_IsTouchEnabled', fontsize=18)\n    axes[i \/\/ 2,i % 2].plot(0, train.loc[(train['ResolutionRatio'] == ratios[i]) & (train['Census_IsTouchEnabled'] == 0), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].plot(1, train.loc[(train['ResolutionRatio'] == ratios[i]) & (train['Census_IsTouchEnabled'] == 1), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].legend(['Detection rate (%)'])\n    axes[i \/\/ 2,i % 2].set_title('Ratio: ' + str(ratios[i]), fontsize=18)\nfig.suptitle('Resolution rate to Census_IsTouchEnabled interaction', fontsize=18);","05df3713":"train['SD'] = (train['Census_InternalPrimaryDisplayResolutionVertical'] < 720).astype('uint8')\ntrain['HD'] = (train['Census_InternalPrimaryDisplayResolutionVertical'].isin(range(720,1080))).astype('int8')\ntrain['FullHD'] = (train['Census_InternalPrimaryDisplayResolutionVertical'].isin(range(1080,2160))).astype('int8')\ntrain['4k'] = (train['Census_InternalPrimaryDisplayResolutionVertical'] >= 2160).astype('uint8')\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(18,12))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\nquals = ['SD', 'HD', 'FullHD', '4k']\naxis_to_processor =  ['x86', 'x64', 'arm64']\nfor i in range(len(quals)):\n    train.loc[train[quals[i]] == 1, 'Processor'].value_counts(True).sort_index(ascending=False).plot(kind='bar', rot=0, fontsize=14, ax=axes[i \/\/ 2, i % 2]).set_xlabel('Processor', fontsize=18);\n    for j in range(len(axis_to_processor)):\n        try:\n            axes[i \/\/ 2,i % 2].plot(j, train.loc[(train[quals[i]] == 1) & (train['Processor'] == axis_to_processor[j]), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n        except:\n            pass\n    axes[i \/\/ 2,i % 2].legend(['Detection rate (%)'])\n    axes[i \/\/ 2,i % 2].set_title('Display quality: ' + quals[i], fontsize=18)","598611b4":"fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(18,12))\nfig.subplots_adjust(wspace=0.2, hspace=0.4)\nfor i in range(len(quals)):\n    train.loc[train[quals[i]] == 1, 'Wdft_IsGamer'].value_counts(True, dropna=False).sort_index().plot(kind='bar', rot=0, fontsize=14, ax=axes[i \/\/ 2, i % 2]).set_xlabel('Wdft_IsGamer', fontsize=18);\n    axes[i \/\/ 2,i % 2].plot(0, train.loc[(train[quals[i]] == 1) & (train['Wdft_IsGamer'] == 0), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].plot(1, train.loc[(train[quals[i]] == 1) & (train['Wdft_IsGamer'] == 1), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].plot(2, train.loc[(train[quals[i]] == 1) & (train['Wdft_IsGamer'].isnull()), 'HasDetections'].value_counts(True, dropna=False)[1], marker='.', color=\"r\", markersize=24)\n    axes[i \/\/ 2,i % 2].legend(['Detection rate (%)'])\n    axes[i \/\/ 2,i % 2].set_title('Display quality: ' + quals[i], fontsize=18)","5f2a81bc":"<a id=\"5\"><\/a>\n## 3.2 Correlation of new feature with HasDetections\n\nNow lets see dependency  between most popular resolution ratios and target value.","01cd0fc8":"<a id=\"12\"><\/a>\n## 4.4 Display quality \/ Wdft_IsGamer","3eb9bee6":"<a id=\"2\"><\/a>\n# 2. Loading data","10271311":"No surprise here - higher display quality owners prefer x64 processors.","29ad91f0":"The better display quality is the higher rate of malware detections.","3691dcdc":"So 4 most popular rations are:\n\n* 0.562011 is (mostly) a low-end laptops ratio (1366 by 768)\n* 0.5625 is 16:9 ratio. Most popular amongst gamers\n* 0.625 is 16:10 ratio. Characteristic of the old displays (https:\/\/en.wikipedia.org\/wiki\/Display_aspect_ratio#4:3_and_16:10)\n* 0.75 is 4:3 ratio. Also really old displays","d62e2a56":"<a id=\"7\"><\/a>\n## 3.4 Display size correlation with HasDetections\n\nHope this plot makes sense. We can see here that the bigger display is the higher detection rate is, but also the distribution density is higher for small screens.","3cd14bf0":"<a id=\"11\"><\/a>\n## 4.3 Display quality \/ Processor architecture","1a884dca":"Same with plotly","b003f010":"I personally don't see any affect of those features interaction on HasDetections.","434da39c":"<a id=\"4\"><\/a>\n## 3.1 New feature - resolution ratio","a3a71c26":"Most popular aspect ratios amongst gamers, according to the data provided, are 0.5625 (16:9) and 0.5649 (which is a 'wrong' [16:9 on laptops](https:\/\/en.wikipedia.org\/wiki\/Graphics_display_resolution#1360_%C3%97_768).)","9fe8140f":"So 'gamers' (0.5625, which is 16:9) have more malware detections than others.\n\nWith next step lets divide all displays into 4 categories: low-definition (SD), high-definition (HD), FullHD and 4k and see detections distribution.\n\n<a id=\"6\"><\/a>\n## 3.3 Correlation between screen quality and HasDetections","4cbd74fb":"Ok, this doesn't tell us really much.\n\nLets create a new feature - ResolutionRation by dividing vertical resolution by horizontal resolution and see what we will have in result.","26d80551":"<a id=\"10\"><\/a>\n## 4.2 Resolution rate \/ Census_IsTouchEnabled\nDoing the same plot for interaction of Resolution rate and Census_IsTouchEnabled features.","e5900797":"<a id=\"3\"><\/a>\n# 3. Analyzing Display features\n\nFirst lets take a look at the most popular display resoultion both vertical and horizontal","6673809b":"# Lets take a look at such features as DisplayResolution and DisplaySizeInInches and see if they might be helpful\n\n**Content:**\n\n1. [Idea description](#1)\n2. [Loading data](#2)\n3. [Analyzing Display features](#3)\n\n    3.1. [New feature - resolution ratio](#4)\n    \n    3.2. [Correlation of new feature with HasDetections](#5)\n    \n    3.3. [Correlation between screen quality and HasDetections](#6)\n    \n    3.4. [Display size correlation with HasDetections](#7)\n4. [Two features interaction](#8)\n\n    4.1. [Resolution Rate \/ Wdft_IsGamer](#9)\n    \n    4.2. [Resolution Rate \/ Census_IsTouchEnabled](#10)\n    \n    4.3. [Display quality \/ Processor architecture](#11)\n    \n    4.4. [Display quality \/ Wdft_IsGamer](#12)\n\n\n<a id=\"1\"><\/a>\n# 1. Idea description\nThe main idea is that PC for a home use, most likely, would have medium to big sizes of displays and at least FullHD resolution. Those are some kind of 'gaming PCs' being used by people mostly for surfing and playing. And this is a kind of people who take less precautions regarding malware. Also the most popular aspect ratio amongst gamers is 16:9 (here is a pretty fresh review: https:\/\/www.gamingscan.com\/best-aspect-ratio-for-gaming\/) so we will take a look at aspect ratio as well by creating a new feature.\n\nOn the other had small-sized displays are mostly used either on laptops and (sometimes) servers. We are going to take a look on them as well.","0a839ca5":"Again no surprise that gamers prefer higher quality displays.","dba4c17d":"<a id=\"8\"><\/a>\n# 4. Two features interaction\n<a id=\"9\"><\/a>\n## 4.1  Resolution Rate \/ Wdft_IsGamer\n\nNext will plot correlation between Display Resolution Rate and feature Wdft_IsGamer also with respect to a detection rate."}}