{"cell_type":{"584e4814":"code","8f12ea37":"code","89f94ff4":"code","6e9a901e":"code","6fa46c13":"code","cf435a09":"code","0c2e7730":"markdown","26a04e6f":"markdown","089bf2cc":"markdown","445159d8":"markdown"},"source":{"584e4814":"import os\nimport time\nfrom pathlib import Path\n\nKAGGLE = Path('\/kaggle\/working').is_dir()","8f12ea37":"%%writefile program.cpp\n\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <stdio.h>\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <dirent.h>\n\nusing namespace std;\n\n\ntemplate <typename T>\nvector<size_t> sort_indexes(const vector<T> &v) {\n\n  vector<size_t> idx(v.size());\n  iota(idx.begin(), idx.end(), 0);\n\n  stable_sort(idx.begin(), idx.end(),\n       [&v](size_t i1, size_t i2) {return v[i1] > v[i2];});\n\n  return idx;\n}\n\ntemplate <typename A, typename B>\nvoid zip(\n    const std::vector<A> &a, \n    const std::vector<B> &b, \n    std::vector<std::pair<A,B>> &zipped)\n{\n    for(size_t i=0; i<a.size(); ++i)\n    {\n        zipped.push_back(std::make_pair(a[i], b[i]));\n    }\n}\n\ntemplate <typename A, typename B>\nvoid unzip(\n    const std::vector<std::pair<A, B>> &zipped, \n    std::vector<A> &a, \n    std::vector<B> &b)\n{\n    for(size_t i=0; i<a.size(); i++)\n    {\n        a[i] = zipped[i].first;\n        b[i] = zipped[i].second;\n    }\n}\n\nbool IsPathExist(const std::string &s)\n{\n  struct stat buffer;\n  return (stat (s.c_str(), &buffer) == 0);\n}\n\nclass Grid {\n    public:\n        int nrows = 0;\n        int ncols = 0;\n        int **mat = NULL;\n        \n        Grid() {}\n    \n        Grid(const Grid& grid) {\n            gridCopy(grid);\n        }\n    \n        void gridCopy(const Grid& grid) {\n            nrows = grid.nrows;\n            ncols = grid.ncols;\n            \n            mat = new int*[nrows];\n            for (int i = 0; i < nrows; ++i) {\n                mat[i] = new int[ncols];\n                for (int j = 0; j < ncols; ++j)\n                    mat[i][j] = grid.mat[i][j];\n            }\n        }\n        \n        Grid(int nr, int nc) {\n            gridBySize(nr,nc);\n        }\n    \n        void gridBySize(int nr, int nc) {\n            nrows = nr;\n            ncols = nc;\n            \n            mat = new int*[nrows];\n            for (int i = 0; i < nrows; ++i) {\n                mat[i] = new int[ncols];\n                for (int j = 0; j < ncols; ++j)\n                    mat[i][j] = -1;\n            }\n        }\n        \n        Grid(std::vector<std::vector<int>> &rows) {\n            nrows = rows.size();\n            ncols = rows[0].size();\n            \n            mat = new int*[nrows];\n            for (int i = 0; i < nrows; ++i) {\n                mat[i] = new int[ncols];\n                for (int j = 0; j < ncols; ++j)\n                    mat[i][j] = rows[i][j];\n            }\n        }\n        \n        void print() {\n            std::cout << \"\\n\";\n            for (int i = 0; i < nrows; ++i) {\n                for (int j = 0; j < ncols; ++j) {\n                    if (mat[i][j] == 0)\n                        std::cout << '.';\n                    else\n                        std::cout << mat[i][j];\n                }\n                std::cout << \"\\n\";\n            }\n        }\n        \n        ~Grid() {\n            clear();\n        }\n    \n        virtual void clear() {\n            if (mat) {\n                for (int i = 0; i < nrows; ++i)\n                    delete mat[i];\n                delete mat;\n            }\n            mat = NULL;\n        }\n        \n        bool operator== (const Grid &ref) const\n        {\n            if ((nrows != ref.nrows) | (ncols != ref.ncols))\n                return false;\n            for (int i = 0; i < nrows; ++i)\n                for (int j = 0; j < ncols; ++j)\n                    if (mat[i][j] != ref.mat[i][j])\n                        return false;\n            return true;\n        }\n        \n        std::string flatten() {\n            std::string out;\n            for (int i = 0; i < nrows; ++i) {\n                out.append(\"|\");\n                for (int j = 0; j < ncols; ++j)\n                    out.append(std::to_string(mat[i][j]));\n            }\n            out.append(\"|\");\n            return out;\n        }\n};\n\nclass Pair {\n    public:\n        Grid *input = NULL;\n        Grid *output = NULL;\n        \n        Pair(Grid *inp, Grid *out) {\n            input = inp;\n            output = out;\n        }\n    \n        Pair() {}\n        \n        void print() {\n            input->print();\n            output->print();\n        }\n    \n        void set_input(Grid *inp) {\n            input = inp;\n        }\n    \n        void set_output(Grid *out) {\n            output = out;\n        }\n        \n        ~Pair() {\n            if (input)\n                delete input;\n            if (output)\n                delete output;\n        }\n};\n\nclass Task {\n    public:\n        std::vector<Pair*> train;\n        std::vector<Pair*> test;\n        \n        void add_train(Pair* pair) {\n            train.push_back(pair);\n        }\n    \n        void add_test(Pair* pair) {\n            test.push_back(pair);\n        }\n    \n        ~Task() {\n            for (Pair* pair : train)\n                delete pair;\n            for (Pair* pair : test)\n                delete pair;\n        }\n};\n\nclass Property : public Grid {\n    public:\n        Property() {}\n        Property(const Grid& grid) : Grid(grid) {}\n        std::string name;\n        virtual void populate(Grid *grid) {}\n        virtual void pre(vector<Property*> props) {}\n        virtual void post(vector<Property*> props) {}\n\n        void calcBackground(Grid* grid) {\n\n            int cnts[10] = {};\n            for (int i = 0; i < grid->nrows; ++i)\n                for (int j = 0; j < grid->ncols; ++j)\n                    cnts[grid->mat[i][j]]++;\n\n            int max_cnt = -1;\n            for (int c = 0; c < 10; ++c)\n                if (cnts[c] > max_cnt) {\n                    max_cnt = cnts[c];\n                    bg[0] = c;\n                }\n        }\n\n        void copyBG(int* bg_in) {\n            for (int i=0; i<10; i++)\n                bg[i] = bg_in[i];\n        }\n\n        bool operator== (const Property &ref) const {\n            return Grid::operator==((const Grid&)ref);\n        }\n\n        int bg[10] {};\n\n        vector<pair<int,int>> dirs = {make_pair(-1,-1),make_pair(-1,0),make_pair(-1,1),make_pair(0,-1),\n                                      make_pair(0,1),make_pair(1,-1),make_pair(1,0),make_pair(1,1)};\n        vector<pair<int,int>> dirs_rook = {make_pair(-1,0),make_pair(0,1),make_pair(1,0),make_pair(0,-1)};\n        vector<pair<int,int>> dirs_row = {make_pair(0,1),make_pair(0,-1)};\n        vector<pair<int,int>> dirs_col = {make_pair(1,0),make_pair(-1,0)};\n        vector<pair<int,int>> dirs_diag1 = {make_pair(1,1),make_pair(-1,-1)};\n        vector<pair<int,int>> dirs_diag2 = {make_pair(1,-1),make_pair(-1,1)};\n};\n\nclass PropBorderType : public Property {\n    public:\n    \n        PropBorderType() {\n            name = \"PropBorderType\";\n        }\n        \n        virtual void populate(Grid *grid) {\n\n            gridBySize(grid->nrows, grid->ncols);\n\n            markCell(grid,0,0,1);\n            markCell(grid,0,ncols-1,2);\n            markCell(grid,nrows-1,0,3);\n            markCell(grid,nrows-1,ncols-1,4);\n            \n            for (int i = 1; i < (nrows-1); ++i) {\n                markCell(grid,i,0,5);\n                markCell(grid,i,ncols-1,6);\n            }\n            for (int j = 1; j < (ncols-1); ++j) {\n                markCell(grid,0,j,7);\n                markCell(grid,nrows-1,j,8);\n            }\n\n            for (int i = 0; i < nrows; ++i)\n                for (int j = 0; j < ncols; ++j)\n                    if (mat[i][j] < 0) mat[i][j] = 0;\n        }\n    \n    private:\n        \n        void markCell(Grid *grid, int i, int j, int col) {\n            if (mat[i][j] >= 0) \n                return;\n            mat[i][j] = col;\n            int c = grid->mat[i][j];\n            for (pair<int,int> p : dirs_rook) {\n                int x = i + p.first;\n                int y = j + p.second;\n                if ((x < 0) || (x >= nrows) || (y < 0) || (y >= ncols))\n                    continue;\n                if (grid->mat[x][y] != c)\n                    continue;\n                markCell(grid, x, y, col);\n            }\n        }\n};\n\n\nclass PropBorderDistance : public Property {\n    public:\n    \n        PropBorderDistance(int max_dist = 100, bool onBG = true) : max_dist{max_dist}, onBG{onBG} {\n            name = \"PropBorderDistance\";\n\n            name += to_string(max_dist);\n            if (onBG)\n                name += \"G\";\n        }\n        \n        virtual void populate(Grid *grid) {\n\n            if (bg[0] == -1)\n                calcBackground(grid);\n\n            nrows = grid->nrows;\n            ncols = grid->ncols;\n            \n            mat = new int*[nrows];\n            for (int i = 0; i < nrows; ++i) {\n                mat[i] = new int[ncols];\n                for (int j = 0; j < ncols; ++j)\n                    mat[i][j] = 0;\n            }\n            \n            for (int i = 0; i < nrows; ++i) {\n                markCell(grid,i,0,1);\n                markCell(grid,i,ncols-1,1);\n            }\n            for (int j = 1; j < (ncols-1); ++j) {\n                markCell(grid,0,j,1);\n                markCell(grid,nrows-1,j,1);\n            }\n            \n            while(search.size() > 0) {\n                std::pair<int,int> p = search.front();\n                search.pop();\n                int depth = mat[p.first][p.second] + 1;\n                if (depth > max_dist) depth = max_dist;\n                markCell(grid,p.first-1,p.second,depth);\n                markCell(grid,p.first+1,p.second,depth);\n                markCell(grid,p.first,p.second-1,depth);\n                markCell(grid,p.first,p.second+1,depth);\n            }\n        }\n    \n    private:\n    \n        std::queue<std::pair<int,int>> search;\n        \n        void markCell(Grid *grid, int i, int j, int depth) {\n            if ((i < 0) | (i >= nrows) | (j < 0) | (j >= ncols))\n                return;\n            if ((!onBG || (grid->mat[i][j] == bg[0])) && (mat[i][j] == 0)) {\n                mat[i][j] = depth;\n                std::pair<int,int> p(i,j);\n                search.push(p);\n            }\n        }\n\n        int max_dist = 0;\n        bool onBG = true;\n};\n\nclass PropHoles : public PropBorderDistance {\n    public:\n        \n        PropHoles() {\n            name = \"PropHoles\";\n        }\n    \n        virtual void populate(Grid *grid) {\n            PropBorderDistance::populate(grid);\n            for (int i = 0; i < nrows; ++i)\n                for (int j = 0; j < ncols; ++j)\n                    if ((mat[i][j] == 0) && (grid->mat[i][j] == 0))\n                        mat[i][j] = 1;\n                    else\n                        mat[i][j] = 0;\n        }\n};\n\nclass PropColor : public Property {\n    public:\n    \n        PropColor () {\n            name = \"PropColor\";\n        }\n    \n        virtual void populate(Grid *grid) {\n            gridCopy(*grid);\n        }\n};\n    \nclass PropModulo : public Property {\n    public:\n    \n        PropModulo(int mod, bool is_row, bool is_col, bool is_rev) : mod{mod}, is_row{is_row}, is_col{is_col}, is_rev(is_rev) {\n            name = \"PropModulo\";\n            name += to_string(mod);\n            if (is_row)\n                name += \"T\";\n            else\n                name += \"F\";\n            if (is_col)\n                name += \"T\";\n            else\n                name += \"F\";\n            if (is_rev)\n                name += \"R\";\n        }\n    \n        virtual void populate(Grid *grid) {\n            gridCopy(*grid);\n            \n            for (int i = 0; i < nrows; ++i)\n                for (int j = 0; j < ncols; ++j) {\n                    mat[i][j] = 0;\n                    int x = i;\n                    int y = j;\n                    if (is_rev) {\n                        x = nrows-1-x;\n                        y = ncols-1-y;\n                    }\n                    if (is_row)\n                        mat[i][j] += mod*(x%mod);\n                    if (is_col)\n                        mat[i][j] += (y%mod);\n                }\n        }\n\n    private:\n        int mod = 2;\n        bool is_row = true;\n        bool is_col = true;\n        bool is_rev = false;\n};\n\n\n\nclass Action {\n    public:\n        std::string name;\n        \n        vector<vector<Grid*>> test_out;\n        vector<string> names_out;\n\n        virtual bool train(Task* task) {}\n        virtual Grid* generate(Grid* grid, int test_id) {}\n};\n\n\nclass Coloring {\n    public:\n        Coloring(std::vector<Property*> props, bool old_post=false) : props {props}, old_post{old_post} {\n            len = props.size();\n            constructor_init();\n        }\n        \n        Coloring(bool old_post=false, int len=1) : old_post{old_post}, len{len} {\n            constructor_init();\n        }\n\n        void constructor_init() {\n            if (len < 2) m_separate = false;\n            if (m_separate)\n                for (int c1=0; c1<10; ++c1) {\n                    for (int c2=0; c2<10; ++c2) {\n                        sep_row[c1][c2] = -1;\n                    }\n                }\n        }\n\n        void init_props(std::vector<Property*> props_in) {\n            props = props_in;\n            init_props_low();\n        }\n\n        void init_props(Grid* grid) {\n            for (Property* prop : props) {\n                prop->clear();\n                prop->populate(grid);\n            }\n            \n            init_props_low();\n        }\n\n        void init_props_low() {\n            for (int i=0; i<3; i++)\n                if (i < len)\n                    mx[i] = 10;\n                else\n                    mx[i] = 1;\n\n            if (train_id == 0) {\n                name = \"\";\n                for (Property* prop : props)\n                    name += prop->name + \";\";\n            }\n        }\n        \n        int getVal(int i=0, int j=0, int z=0) {\n            return (cmap[i][j][z] - 1);\n        }\n    \n        int getVal(int* idx) {\n            return getVal(idx[0],idx[1],idx[2]);\n        }\n    \n        void setVal(int i=0, int j=0, int z=0, int val=0) {\n            cmap[i][j][z] = val + 1;\n        }\n        \n        void finalizeTrain(int id) {\n            if (m_separate && (train_id == 0)) {\n                for (int c3 = 0; c3 < mx[2]; ++c3) {\n                    for (int c2 = 0; c2 < mx[1]; ++c2) {\n                        int found_color = -1;\n                        for (int c1 = 0; c1 < mx[0]; ++c1) {\n                            if (getVal(c1,c2,c3) >= 0) {\n                                if ((found_color >= 0)) {\n                                    m_separate = false;\n                                }\n                                sep_row[c2][c3] = c1;\n                                found_color = c1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        int inferenceSeparate(int i, int j) {\n            int idx0 = props[0]->mat[i][j];\n            int idx1 = props[1]->mat[i][j];\n            int idx2 = 0;\n            if (len == 3)\n                idx2 = props[2]->mat[i][j];\n            \n            int cm = sep_map[idx0];\n            if (cm == -1) return -1;\n            cm = getVal(cm, idx1, idx2);\n            if (cm == -1) return -1;\n            cm = sep_map_rev[cm];\n            \n            return cm;\n        }\n    \n        bool trainSeparate(int i, int j, int c_out) {\n            \n            if (train_id == 0) {\n                bool ret = trainTogether(i,j,c_out);\n                return ret;\n            } else {\n                int cm = inferenceSeparate(i,j);\n                if (cm != c_out) return false;\n                return true;\n            }\n        }\n        \n        bool trainTogether(int i, int j, int c_out) {\n            int cm = get_color_base(i,j);\n            \n            if (cm >= 0) {\n                if (cm != c_out)\n                    return false;\n            } else\n                set_color(i,j,c_out);\n            \n            return true;\n        }\n        \n        bool train(int i, int j, int c_out) {\n            if (m_separate) {\n                bool ret_separate = trainSeparate(i,j,c_out);\n                m_separate = m_separate && ret_separate;\n            }\n            if (m_together) {\n                bool ret_together = trainTogether(i,j,c_out);\n                m_together = m_together && ret_together;\n            }\n            return (m_together || m_separate);\n        }\n        \n        void setTrainId(int id) {\n            train_id = id;\n            if (m_separate) {\n                for (int c=0; c<10; ++c) {\n                    sep_map[c] = -1;\n                    sep_map_rev[c] = -1;\n                }\n\n                if (train_id != 0) {\n                    for (int i=0; i<props[0]->nrows; i++)\n                        for (int j=0; j<props[0]->ncols; j++) {\n                            int idx0 = props[0]->mat[i][j];\n                            int idx1 = props[1]->mat[i][j];\n                            int idx2 = 0;\n                            if (len == 3)\n                                idx2 = props[2]->mat[i][j];\n                            sep_map[idx0] = sep_row[idx1][idx2];\n                        }\n                    \n                    for (int c=0; c<10; ++c) {\n                        if (sep_map[c] >= 0)\n                            sep_map_rev[sep_map[c]] = c;\n                    }\n                }\n            }\n\n        }\n        \n        void printCMap() {\n            if (len <= 2) {\n                for (int c1 = 0; c1 < 10; ++c1) {\n                    for (int c2 = 0; c2 < 10; ++c2) {\n                        int c = getVal(c1,c2);\n                        if (c >= 0)\n                            std::cout << getVal(c1,c2);\n                        else\n                            std::cout << \".\";\n                    }\n                    std::cout << \"\\n\";\n                }\n            } else {\n                for (int c1 = 0; c1 < 10; ++c1) {\n                    std::cout << \"first prop \" << c1 << \"\\n\";\n                    for (int c2 = 0; c2 < 10; ++c2) {\n                        for (int c3 = 0; c3 < 10; ++c3) {\n                            int c = getVal(c1,c2,c3);\n                            if (c >= 0)\n                                std::cout << c;\n                            else\n                                std::cout << \".\";\n                        }\n                        std::cout << \"\\n\";\n                    }\n                    std::cout << \"\\n\";\n                }\n            }\n\n        }\n\n        void post_process() {\n            int cm;\n\n            if (m_separate) {\n                name += \"SEP;\";\n            }\n            \n            int cols[3][10][2][10] = {};\n            int diag[3][10] = {};\n\n            for (int i = 0; i < 3; ++i) {\n                for (int c = 0; c < mx[i]; ++c) {\n                    for (int c1 = 0; c1 < mx[dims[i][0]]; ++c1) {\n                        for (int c2 = 0; c2 < mx[dims[i][1]]; ++c2) {\n                            int idx[3];\n                            idx[i] = c;\n                            idx[dims[i][0]] = c1;\n                            idx[dims[i][1]] = c2;\n                            cm = getVal(idx);\n                            if (cm >= 0) {\n                                cols[i][c][0][c1]++;\n                                cols[i][c][1][c2]++;\n                                if (c1 == c2)\n                                    diag[i][c]++;\n                            }\n                        }\n                    }\n                }\n            }\n            \n            while (true) {\n\n                int max_cnt = 0;\n                for (int i = 0; i < 3; ++i) {\n                    for (int c = 0; c < mx[i]; ++c) {\n                        for (int j = 0; j < 2; ++j) {\n                            for (int c1 = 0; c1 < 10; ++c1) {\n                                int val = cols[i][c][j][c1];\n                                if ((val > max_cnt) && (val < 10)) max_cnt = val;\n                            }\n                        }\n                        int val = diag[i][c];\n                        if ((val > max_cnt) && (val < 10)) max_cnt = val;\n                    }\n                }\n\n                int vals[10][3];\n                bool found = false;\n\n                for (int i = 0; !found && (i < 3); ++i) {\n                    for (int c = 0; !found && (c < mx[i]); ++c) {\n                        for (int j = 0; !found && (j < 2); ++j) {\n                            for (int c1 = 0; !found && (c1 < 10); ++c1) {\n                                int val = cols[i][c][j][c1];\n                                if (val == max_cnt) {\n                                    int idx[3];\n                                    idx[0] = i;\n                                    idx[1] = dims[i][j];\n                                    idx[2] = dims[i][1-j];\n                                    for (int c2 = 0; c2 < 10; ++c2) {\n                                        vals[c2][idx[0]] = c;\n                                        vals[c2][idx[1]] = c1;\n                                        vals[c2][idx[2]] = c2;\n                                    }\n                                    found = true;\n                                }\n                            }\n                        }\n                        int val = diag[i][c];\n                        if (val == max_cnt) {\n                            int idx[3];\n                            idx[0] = i;\n                            idx[1] = dims[i][0];\n                            idx[2] = dims[i][1];\n                            for (int c2 = 0; c2 < 10; ++c2) {\n                                vals[c2][idx[0]] = c;\n                                vals[c2][idx[1]] = c2;\n                                vals[c2][idx[2]] = c2;\n                            }\n                            found = true;\n                        }\n                    }\n                }\n\n                if (!found) break;\n\n                bool any_colored = false;\n\n                int selfColors[2] = {};\n                float cnts[10] = {};\n                for (int i = 0; i < 10; ++i) {\n                    cm = getVal(vals[i][0],vals[i][1],vals[i][2]);\n                    if (cm >= 0) {\n                        selfColors[int(cm == i)]++;\n                        if (vals[i][1] == vals[i][2])\n                            cnts[cm] += 1.0;\n                        else\n                            cnts[cm] += 1.05;\n                    }\n                }\n                int numColors = 0;\n                int freqColor = 0;\n                for (int i = 0; i < 10; ++i) {\n                    if (cnts[i] > cnts[freqColor])\n                        freqColor = i;\n                    numColors += int(cnts[i] > 0);\n                }\n                bool selfColoring = ((selfColors[0] == 0) && (selfColors[1] >= 2)) ||\n                                    ((selfColors[0] == 1) && (selfColors[1] >= 3));\n                for (int i = 0; i < 10; ++i) {\n                    if (getVal(vals[i][0],vals[i][1],vals[i][2]) < 0) {\n                        int col = -1;\n                        if (selfColoring)\n                            col = i;\n                        else if ((numColors <= 2) && (cnts[freqColor] >= 2.0))\n                            col = freqColor;\n                        \n                        if (col >= 0) {\n                            setVal(vals[i][0],vals[i][1],vals[i][2],col);\n                            any_colored = true;\n\n                            for (int j = 0; j < 3; ++j) {\n                                cols[j][vals[i][j]][0][vals[i][dims[j][0]]]++;\n                                cols[j][vals[i][j]][1][vals[i][dims[j][1]]]++;\n                                if (vals[i][dims[j][0]] == vals[i][dims[j][1]])\n                                    diag[j][vals[i][j]]++;\n                            }\n                        }\n                    }\n                }\n\n                if (!any_colored) break;\n            }\n        }\n        \n        void set_color(int i, int j, int val) {\n            int idx0 = props[0]->mat[i][j];\n            int idx1 = 0;\n            int idx2 = 0;\n            if (len >= 2)\n                idx1 = props[1]->mat[i][j];\n            if (len >= 3)\n                idx2 = props[2]->mat[i][j];\n            setVal(idx0,idx1,idx2,val);\n        }\n\n        int get_color(int i, int j) {\n            if (m_separate)\n                return inferenceSeparate(i,j);\n            else\n                return get_color_base(i,j);\n        }\n\n        int get_color_base(int i, int j) {\n            int idx0 = props[0]->mat[i][j];\n            int idx1 = 0;\n            int idx2 = 0;\n            if (len >= 2)\n                idx1 = props[1]->mat[i][j];\n            if (len >= 3)\n                idx2 = props[2]->mat[i][j];\n            return getVal(idx0,idx1,idx2);\n        }\n\n        string name;\n        bool m_separate = true;\n\n    private:\n        int cmap[10][10][10] = {};\n        int mx[3] = {};\n        int dims[3][2] = {{1,2}, {0,2}, {0,1}};\n        int len = 0;\n        int train_id = 0;\n        bool m_together = true;\n        int sep_map[10];\n        int sep_map_rev[10];\n        int sep_row[10][10];\n        bool old_post;\n        std::vector<Property*> props;    \n};\n\n\nTask* parse_file(std::string filepath) {\n    \n    std::ifstream ifs;\n    ifs.open(filepath.c_str(), std::ifstream::in);\n    \n    int cnt = 0;\n    bool char_t = false;\n    bool char_n = false;\n    bool is_train = false;\n    bool is_test = false;\n    bool is_input = false;\n    bool is_output = false;\n    int opened = 0;\n    int opened_curl = 0;\n    \n    std::vector<int> row;\n    std::vector<std::vector<int>> rows;\n    \n    std::vector<Pair> pairs;\n    Pair *pair = NULL;\n    Task *task = new Task();\n    \n    char c = ifs.get();\n    while (ifs.good()) {\n        \n        if ((c == 'e') & char_t)\n            is_test = true;\n        if ((c == 'r') & char_t)\n            is_train = true;\n        \n        if ((c == 'p') & char_n)\n            is_input = true;\n        if ((c == 'p') & char_t)\n            is_output = true;\n        \n        char_t = (c == 't');\n        char_n = (c == 'n');\n        \n        if (c == '{') {\n            opened_curl++;\n            if (opened_curl == 2)\n                pair = new Pair();\n        }\n        if (c == '}') {\n            opened_curl--;\n        }\n        \n        if (c == '[') {\n            opened++;\n        }\n        if (c == ']') {\n            opened--;\n            if (opened == 0) {\n                is_test = false;\n                is_train = false;\n            }\n            if (opened == 1) {\n                Grid *grid = new Grid(rows);\n                \n                if (is_input) {\n                    pair->set_input(grid);\n                \n                    if (is_train)\n                        task->add_train(pair);\n                    if (is_test)\n                        task->add_test(pair);\n                }\n                if (is_output) {\n                    pair->set_output(grid);\n                }\n                \n                rows.clear();\n                \n                is_input = false;\n                is_output = false;\n            }\n            if (opened == 2) {\n                rows.push_back(row);\n                row.clear();\n            }\n        }\n        \n        if ((c >= '0') & (c <= '9')) {\n            row.push_back(int(c) - int('0'));\n        }\n        \n        c = ifs.get();\n        cnt++;\n    }\n\n    ifs.close();\n    \n    return task;\n}\n\nclass PropSet {\n    public:\n        PropSet(vector<Property*> &props) : props{props} {}\n\n        Property* operator[](int index) { \n            return props[index]; \n        }\n\n        void post() {\n\n            int cnts[10] {};\n            for (Property* p : props) {\n                for (int i=0; i<p->nrows; ++i)\n                    for (int j=0; j<p->ncols; ++j)\n                        cnts[p->mat[i][j]]++;\n            }\n\n            num_classes = 0;\n            for (int c=0; c<10; ++c)\n                if (cnts[c] > 0)\n                    num_classes++;\n        }\n\n        vector<Property*> props;\n        int num_classes = 0;\n};\n\nclass PropManager {\n    public:\n\n        PropManager(Task *task) : task{task} {\n            bg = calcBackground(task);\n        }\n\n        void calcBackgroundCount(Grid* grid, int* cnts) {\n            for (int i = 0; i < grid->nrows; ++i)\n                for (int j = 0; j < grid->ncols; ++j)\n                    cnts[grid->mat[i][j]]++;\n        }\n\n        int* calcBackground(Task* task) {\n            int cnts[10] = {};\n\n            for (Pair* pair : task->train)\n                calcBackgroundCount(pair->input, cnts);\n            \n            for (Pair* pair : task->test)\n                calcBackgroundCount(pair->input, cnts);\n\n            int* bg = new int[10] {};\n            \n            std::vector<int> cnts_vec;\n            cnts_vec.assign(cnts, cnts + 10);\n            int k=0;\n            for (auto i: sort_indexes(cnts_vec)) {\n                bg[k] = i;\n                k++;\n            }\n\n            return bg;\n        }\n\n        template<class PType, typename ... Args> void addProperty(Args ... args) {\n\n            vector<Property*> task_props;\n\n            int train_id = 0;\n            for (Pair* pair : task->train) {\n                Property* prop = (Property*) new PType(args...);\n                prop->copyBG(bg);\n                prop->populate(pair->input);\n                task_props.push_back(prop);\n                train_id++;\n            }\n\n            vector<Property*> task_props_test;\n\n            for (Pair* pair : task->test) {\n                Property* prop = (Property*) new PType(args...);\n                prop->copyBG(bg);\n                prop->populate(pair->input);\n                task_props_test.push_back(prop);\n            }\n\n            vector<Property*> task_props_all;\n            for (Property* p : task_props)\n                task_props_all.push_back(p);\n            for (Property* p : task_props_test)\n                task_props_all.push_back(p);\n\n            task_props_all[0]->post(task_props_all);\n\n            if (false) {\n                for (Property* prop : task_props) {\n                    cout << \"DEBUG: \" << prop->name << \"\\n\";\n                    prop->print();\n                }\n                for (Property* prop : task_props_test) {\n                    cout << \"DEBUG TEST: \" << prop->name << \"\\n\";\n                    prop->print();\n                }\n            }\n\n            PropSet prop_set(task_props);\n            prop_set.post();\n            if (prop_set.num_classes == 1) {\n                return;\n            }\n\n            bool different = true;\n            int k=0;\n            for (PropSet saved_props : props) {\n                different = false;\n                int i = 0;\n                for (Property* saved_prop : saved_props.props) {\n                    if (!((*saved_prop) == (*task_props[i]))) {\n                        different = true;\n                        break;\n                    }\n                    i++;\n                }\n                i = 0;\n                for (Property* saved_prop : props_test[k].props) {\n                    if (!((*saved_prop) == (*task_props_test[i]))) {\n                        different = true;\n                        break;\n                    }\n                    i++;\n                }\n                k++;\n                if (!different) {\n                    break;\n                }\n            }\n\n            if (!different) return;\n\n            props.push_back(prop_set);\n            names.push_back(task_props[0]->name);\n            props_test.push_back(PropSet(task_props_test));\n        }\n\n        void print() {\n            for (string name : names)\n                cout << name << \"\\n\";\n        }\n\n        vector<PropSet> props;\n        vector<PropSet> props_test;\n        vector<string> names;\n        Task* task;\n        int* bg = NULL;\n};\n\n\nclass MultiColoring {\n    public:\n        MultiColoring(PropManager *mngr) : mngr{mngr} {\n        }\n        \n        ~MultiColoring() {\n            for (vector<Coloring*> vcol : colorings)\n                for (Coloring* col : vcol)\n                    delete col;\n            \n            for (int i=0; i<3; i++)\n                delete failed[i];\n        }\n\n        void init(int level_in) {\n            \n            level = level_in;\n            vector<Coloring*> colorings_lvl;\n            vector<int> scores_lvl;\n\n            if (level == 0) {\n                for (PropSet vp : mngr->props) {\n                    Coloring* coloring = new Coloring(false, 1);\n                    colorings_lvl.push_back(coloring);\n                    scores_lvl.push_back(vp.num_classes);\n                }\n            } else if (level == 1) {\n                int i=0;\n                for (PropSet vp1 : mngr->props) {\n                    int k=0;\n                    for (PropSet vp2 : mngr->props) {\n                        if (k > i) {\n                            Coloring* coloring = new Coloring(false, 2);\n                            colorings_lvl.push_back(coloring);\n                            scores_lvl.push_back(vp1.num_classes + vp2.num_classes);\n                        }\n                        k++;\n                    }\n                    i++;\n                }\n            } else {\n                int p=0;\n                for (PropSet vp0 : mngr->props) {\n                    int i=0;\n                    for (PropSet vp1 : mngr->props) {\n                        int k=0;\n                        for (PropSet vp2 : mngr->props) {\n                            if ((k > i) && (i > p)) {\n                                Coloring* coloring = new Coloring(false, 3);\n                                colorings_lvl.push_back(coloring);\n                                scores_lvl.push_back(vp0.num_classes + vp1.num_classes + vp2.num_classes);\n                            }\n                            k++;\n                        }\n                        i++;\n                    }\n                    p++;\n                }\n            }\n\n            colorings.push_back(colorings_lvl);\n            scores.push_back(scores_lvl);\n\n            failed[level] = new bool[colorings[level].size()] {};\n        }\n\n        void setId(vector<PropSet> props_in, int id) {\n            if (level == 0) {\n                int i = 0;\n                for (PropSet vp : props_in) {\n                    std::vector<Property*> props;\n                    props.push_back(vp[id]);\n                    colorings[level][i]->init_props(props);\n                    i++;\n                }\n            } else if (level == 1) {\n                int num = 0;\n                int i = 0;\n                for (PropSet vp1 : props_in) {\n                    int k=0;\n                    for (PropSet vp2 : props_in) {\n                        if (k > i) {\n                            std::vector<Property*> props;\n                            props.push_back(vp1[id]);\n                            props.push_back(vp2[id]);\n                            colorings[level][num]->init_props(props);\n                            num++;\n                        }\n                        k++;\n                    }\n                    i++;\n                }\n            } else {\n                int num = 0;\n                int p=0;\n                for (PropSet vp0 : props_in) {\n                    int i = 0;\n                    for (PropSet vp1 : props_in) {\n                        int k=0;\n                        for (PropSet vp2 : props_in) {\n                            if ((k > i) && (i > p)) {\n                                std::vector<Property*> props;\n                                props.push_back(vp0[id]);\n                                props.push_back(vp1[id]);\n                                props.push_back(vp2[id]);\n                                colorings[level][num]->init_props(props);\n                                num++;\n                            }\n                            k++;\n                        }\n                        i++;\n                    }\n                    p++;\n                }\n\n            }\n        }\n\n        void setTrainId(int train_id) {\n            setId(mngr->props, train_id);\n            for (Coloring* col : colorings[level])\n                col->setTrainId(train_id);\n        }\n\n        void setTestId(int test_id) {\n            setId(mngr->props_test, test_id);\n            for (Coloring* col : colorings[level])\n                col->setTrainId(-1);\n        }\n\n        bool train(int i, int j, int c) {\n            int k = -1;\n            bool any_success = false;\n            for (Coloring* colors : colorings[level]) {\n                k++;\n                if (failed[level][k])\n                    continue;\n                bool ret = colors->train(i, j, c);\n                if (!ret) {\n                    failed[level][k] = true;\n                } else any_success = true;\n            }\n            return any_success;\n        }\n\n        void finalizeTrain(int id) {\n            for (Coloring* colors : colorings[level]) {\n                colors->finalizeTrain(id);\n            }\n        }\n\n        bool post_process(Task* task) {\n            vector<int> selected_scores;\n            for (int i=0; i<colorings[level].size(); i++)\n                if (!failed[level][i]) {\n                    Coloring* selected_col = colorings[level][i];\n                    selected_col->post_process();\n                    selected_cols.push_back(selected_col);\n                    selected_scores.push_back(scores[level][i]);\n                }\n            \n            if (selected_cols.size() > 0) {\n                std::vector<std::pair<Coloring*,int>> zipped;\n                zip(selected_cols, selected_scores, zipped);\n\n                std::sort(std::begin(zipped), std::end(zipped), \n                    [&](const auto& a, const auto& b)\n                    {\n                        return a.second < b.second;\n                    });\n\n                unzip(zipped, selected_cols, selected_scores);\n            }\n\n            return (selected_cols.size() > 0);\n        }\n\n        vector<Coloring*> selected_cols;\n\n    private:\n        \n        vector<vector<Coloring*>> colorings;\n        vector<vector<int>> scores;\n        bool* failed[3];\n        int level = 0;\n        \n        PropManager *mngr = NULL;\n};\n\n\nclass ActMultiProps : public Action {\n    public:\n        ActMultiProps(PropManager *mngr) : mngr {mngr} {\n            name = \"ActMultiProps\";\n            colors = new MultiColoring(mngr);\n        }\n        \n        ~ActMultiProps() {\n            delete colors;\n        }\n        \n        bool train(Task* task) {\n\n            for (int level=0; level<3; level++) {\n                \n                colors->init(level);\n                int train_id = 0;\n\n                bool failed = false;\n                for (Pair* pair : task->train) {\n                    if (level == 0)\n                        if ((pair->input->nrows != pair->output->nrows) || (pair->input->ncols != pair->output->ncols))\n                            return false;\n                    \n                    colors->setTrainId(train_id);\n                    \n                    for (int i = 0; i < pair->input->nrows; ++i) {\n                        for (int j = 0; j < pair->input->ncols; ++j) {\n                            int c = pair->output->mat[i][j];\n                            bool ret = colors->train(i, j, c);\n                            if (ret == false) {\n                                failed = true;\n                                break;\n                            }\n                        }\n                        if (failed) break;\n                    }\n                    if (failed) break;\n                    \n                    colors->finalizeTrain(train_id);\n                    \n                    train_id++;\n                }\n                \n                if (!failed) {\n                    bool success = colors->post_process(task);\n                    \n                    if (!success)\n                        continue;\n\n                    success = false;\n                    for (Coloring *col: colors->selected_cols) {\n                        int test_id = 0;\n                        vector<Grid*> out_vec;\n                        for (Pair* pair : task->test) {\n                            Grid* out = generateTest(pair->input, test_id, col);\n                            if (out == NULL) {\n                                for (Grid* gg : out_vec)\n                                    delete gg;\n                                out_vec.clear();\n                                break;\n                            }\n                            out_vec.push_back(out);\n                            test_id++;\n                        }\n                        if (out_vec.size() > 0) {\n                            success = true;\n                            test_out.push_back(out_vec);\n                            names_out.push_back(col->name);\n                        }\n                    }\n\n                    if (success) return true;\n                    else colors->selected_cols.clear();\n                }\n            }\n            \n            return false;\n        }\n\n        Grid* generateTest(Grid* grid, int test_id, Coloring* col) {\n            Grid* out = new Grid(*grid);\n            \n            colors->setTestId(test_id);\n            \n            for (int i = 0; i < grid->nrows; ++i)\n                for (int j = 0; j < grid->ncols; ++j) {\n                    int c = col->get_color(i,j);\n                    if (c < 0) {\n                        delete out;\n                        return NULL;\n                    }\n                    out->mat[i][j] = c;\n                }\n            \n            return out;\n        }\n        \n        Grid* generate(Grid* grid, int test_id) {\n            return NULL;\n        }\n\n    private:\n        PropManager *mngr = NULL;\n        MultiColoring *colors = NULL;\n};\n\n\nint main(int argc, char *argv[]) {\n    \n    bool KAGGLE = IsPathExist(\"\/kaggle\/working\/\");\n    \n    std::string current_exec_name = argv[0];\n    std::vector<std::string> all_args;\n    \n    std::string folder = std::string(\"test\");\n    if (argc > 1) {\n        all_args.assign(argv + 1, argv + argc);\n        folder = all_args[0];\n    } else {\n        if (!KAGGLE) {\n            folder = std::string(\"training\");\n            \/\/folder = std::string(\"evaluation\");\n        }\n    }\n    \n    std::string PATH = \"C:\\\\StudioProjects\\\\ARC\\\\\";\n    std::string PATH_WORK = \"C:\\\\StudioProjects\\\\ARC\\\\\";\n    std::string SPLITTER = \"\\\\\";\n    if (KAGGLE) {\n        PATH = \"\/kaggle\/input\/abstraction-and-reasoning-challenge\/\";\n        PATH_WORK = \"\/kaggle\/working\/\";\n        SPLITTER = \"\/\";\n    }\n    \n    std::cout << \"Start\" << \"\\n\";\n    if (KAGGLE)\n        std::cout << \"Running Kaggle\" << \"\\n\";\n    else\n        std::cout << \"Running Local, folder \" << folder << \"\\n\";\n    \n    std::string path = PATH + folder;\n    std::string sub_path = PATH_WORK + std::string(\"submission.csv\");\n    std::string succ_path = PATH_WORK + std::string(\"success.csv\");\n    \n    std::ofstream ifs_sub;\n    ifs_sub.open(sub_path.c_str(), std::ofstream::out);\n    ifs_sub << \"output_id,output\\n\";\n\n    std::ifstream ifs_succ;\n    ifs_succ.open(succ_path.c_str(), std::ifstream::in);\n    vector<string> succ_ids;\n    std::string line;\n    while (getline(ifs_succ, line)) {\n        succ_ids.push_back(line);\n    }\n    ifs_succ.close();\n\n    std::ofstream ofs_succ;\n    ofs_succ.open(succ_path.c_str(), ios_base::app | std::ofstream::out);\n\n    std::map<std::string,std::string> description;\n    description[std::string(\"3bdb4ada\")]=std::string(\"LATER: grid in grid\");\n    description[std::string(\"63613498\")]=std::string(\"HARD: color sharing between shapes\");\n    description[std::string(\"a5f85a15\")]=std::string(\"TODO: modulo2 column\");\n    description[std::string(\"bda2d7a6\")]=std::string(\"LATER: separate coloring harder case\");\n    description[std::string(\"0692e18c\")]=std::string(\"TODO: zoom-in with reversed colors\");\n    description[std::string(\"1da012fc\")]=std::string(\"HARD: color sharing between shapes\");\n    description[std::string(\"45737921\")]=std::string(\"TODO: property of adjacent color\");\n    description[std::string(\"62ab2642\")]=std::string(\"TODO: smallest and biggest shape property\");\n    description[std::string(\"1caeab9d\")]=std::string(\"LATER: shapes moving\");\n    description[std::string(\"ba97ae07\")]=std::string(\"LATER: need 3 props?\");\n    description[std::string(\"d037b0a7\")]=std::string(\"TODO: neighbor up one prop\");\n    description[std::string(\"f823c43c\")]=std::string(\"TODO: denoising\");\n    description[std::string(\"aedd82e4\")]=std::string(\"TODO: single point shape\");\n    description[std::string(\"0a2355a6\")]=std::string(\"TODO: count holes inside\");\n    description[std::string(\"694f12f3\")]=std::string(\"TODO: shape size, ordered per grid\");\n    description[std::string(\"b230c067\")]=std::string(\"TODO: frequency of appearance of a shape\");\n    description[std::string(\"9565186b\")]=std::string(\"LATER: lvl1 is not enough, need to go into lvl2\");\n    description[std::string(\"150deff5\")]=std::string(\"HARD: fit two shapes into a complex shape\");\n    description[std::string(\"1e0a9b12\")]=std::string(\"LATER: cells moving down\");\n    description[std::string(\"22eb0ac0\")]=std::string(\"TODO: color to the left\/right\");\n    description[std::string(\"25ff71a9\")]=std::string(\"LATER: shapes moving one down\");\n\n\n    DIR *dir;\n    struct dirent *ent;\n    int n_task_ids = 0;\n\n    if ((dir = opendir(path.c_str())) != NULL) {\n        int score[3] = {}; \/\/ correct, error, skipped\n        \n        bool first = true;\n        \n        int* res_train = NULL;\n        int* res_test = NULL;\n        int sz = -1;\n        \n        while ((ent = readdir(dir)) != NULL) {\n            std::string fn = std::string(ent->d_name);\n            if ((fn == std::string(\".\")) | (fn == std::string(\"..\")))\n                continue;\n            \/\/if (fn != std::string(\"9def23fe.json\")) continue;\n            std::string filepath = PATH + folder + SPLITTER + fn;\n            \/\/std::cout << filepath << \"\\n\";\n            Task *task = parse_file(filepath);\n\n            PropManager pm(task);\n            pm.addProperty<PropColor>();\n            pm.addProperty<PropHoles>();\n            pm.addProperty<PropModulo>(2, true, true, false);\n            pm.addProperty<PropBorderType>();            \n            \n            std::vector<Action*> acts {\n                new ActMultiProps(&pm),\n            };\n\n            if (res_train == NULL) res_train = new int[acts.size()] {};\n            if (res_test == NULL) res_test = new int[acts.size()] {};\n            if (sz == -1) sz = acts.size();\n\n            bool* success_train = new bool[acts.size()];\n            bool any_success_train = false;\n            \n            if (first) {\n                std::cout << \"\\n\";\n                for (int a=0; a<acts.size(); ++a)\n                    std::cout << a << \". \" << acts[a]->name << \"\\n\";\n                std::cout << \"\\n\";\n            }\n            \n            for (int a=0; a<acts.size(); ++a) {\n                success_train[a] = acts[a]->train(task);\n                any_success_train = any_success_train || success_train[a];\n            }\n            \n            int test_id = 0;\n            for (Pair* pair : task->test) {\n                \n                vector<Grid*> outputs;\n\n                bool* success_test = new bool[acts.size()] {};\n                bool any_success_test = false;\n\n                n_task_ids++;\n                std::string id_name = fn.substr(0,8) + \"_\" + std::to_string(test_id);\n\n                Grid* out = NULL;\n                int printed = 0;\n                if (pair->output == NULL)\n                    ifs_sub << id_name << \",\";\n\n                for (int a=0; a<acts.size(); ++a) {\n\n                    int p=0;\n                    for (vector<Grid*> out_vec : acts[a]->test_out) {\n                        if (printed < 3) {\n\n                            out = out_vec[test_id];\n                            bool identical = false;\n                            for (Grid* o : outputs)\n                                if (*o == *out) {\n                                    identical = true;\n                                }\n                            if (identical) {\n                                p++;\n                                continue;\n                            }\n\n                            outputs.push_back(out);\n\n                            cout << acts[a]->names_out[p] << \"\\n\";\n                            if (pair->output != NULL) {\n                                bool result = ((*out) == (*pair->output));\n                                if (result && !success_test[a]) {\n                                    success_test[a] = true;\n                                    any_success_test = true;\n                                }\n                            } else {\n                                if (printed > 0) {\n                                    ifs_sub << \" \";\n                                    cout << id_name << \"\\n\";\n                                }\n                                ifs_sub << out->flatten();\n                            }\n                            printed++;\n                            p++;\n                        }\n                    }\n                }\n\n                any_success_train = false;\n                for (int a=0; a<acts.size(); ++a)\n                    any_success_train = any_success_train || success_train[a];\n                \n                if (pair->output == NULL) {\n                    if (printed == 0)\n                        ifs_sub << pair->input->flatten();\n                    ifs_sub << \"\\n\";\n                }\n\n                if (any_success_test) {\n                    if (std::find(succ_ids.begin(), succ_ids.end(), id_name) == succ_ids.end())\n                        ofs_succ << id_name << \"\\n\";\n                } else {\n                    if (std::find(succ_ids.begin(), succ_ids.end(), id_name) != succ_ids.end())\n                        cout << \"achtung: \" << id_name << \"\\n\";\n                }\n                \n                if (any_success_train) {\n                    std::cout << id_name << \" \";\n                    for (int a=0; a<acts.size(); ++a)\n                        std::cout << success_train[a] + success_test[a];\n                    if (any_success_test)\n                        std::cout << \" > PASS    \";\n                    else {\n                        std::cout << \" > FAILED  \";\n                    \n                        map<string,string>::iterator it = description.find(fn.substr(0,8));\n                        if (it != description.end())\n                            cout << \":\" << it->second;\n                    }\n\n                    std::cout << \"\\n\";\n                }\n                \n                if (any_success_test && any_success_train)\n                    score[0]++;\n                if (!any_success_test && any_success_train)\n                    score[1]++;\n                if (!any_success_test && !any_success_train)\n                    score[2]++;\n                \n                for (int a=0; a<acts.size(); ++a) {\n                    res_train[a] += success_train[a];\n                    res_test[a] += success_test[a];\n                }\n\n                test_id++;\n            }\n            \n            for (int a=0; a<acts.size(); ++a) {\n                delete acts[a];\n            }\n            delete success_train;\n            delete task;\n            \n            first = false;\n        }\n        \n        char buffer [50];\n        cout << \"\\n\";\n        cout << \"         \";\n        for (int a=0; a<sz; ++a) {\n            sprintf(buffer,\"%3d\",a);\n            cout << buffer;\n        }\n        cout << \"\\n\";\n        cout << \"train    \";\n        for (int a=0; a<sz; ++a) {\n            sprintf(buffer,\"%3d\",res_train[a]);\n            cout << buffer;\n        }\n        cout << \"\\n\";\n        cout << \"test     \";\n        for (int a=0; a<sz; ++a) {\n            sprintf(buffer,\"%3d\",res_test[a]);\n            cout << buffer;\n        }\n        cout << \"\\n\";\n\n        delete res_train;\n        delete res_test;\n\n        std::cout << \"correct: \" << score[0] << \" error: \" << score[1] << \" skipped: \" << score[2] << \"\\n\";\n        \n        closedir(dir);\n    } else {\n        perror(\"failed to read files\");\n        return 1;\n    }\n    \n    ifs_sub.close();\n    ofs_succ.close();\n\n    cout << \"n_task_ids: \" << n_task_ids << \"\\n\";\n    if ((n_task_ids != 102) && (n_task_ids != 104)) {\n        remove(sub_path.c_str());\n    }\n\n    return 0;\n}\n","89f94ff4":"st = time.time()\nif KAGGLE:\n    print(os.system(\"g++ -pthread -lpthread -O3 -std=c++17 -o main program.cpp 2> error.log\"))\nelse:\n    print(os.system(\"g++ -pthread -lpthread -g -std=c++17 -o main program.cpp 2> error.log\"))\nprint(\"running time:\", time.time()-st)","6e9a901e":"st = time.time()\nif KAGGLE:\n    !.\/main training\nelse:\n    !main.exe training\nprint(\"running time:\", time.time()-st)","6fa46c13":"st = time.time()\nif KAGGLE:\n    !.\/main evaluation\nelse:\n    !main.exe evaluation\nprint(\"running time:\", time.time()-st)","cf435a09":"st = time.time()\nif KAGGLE:\n    !.\/main test\nelse:\n    !main.exe test\nprint(\"running time:\", time.time()-st)","0c2e7730":"# Intro","26a04e6f":"# Compilation and running","089bf2cc":"This is a C++ starter code for the ARC competition. It is my current code minus most of the `Property` and `Action` classes, which I removed in order not to score more than 0.99 (to avoid LB disruption). The whole thing took me 2 weeks to write.\n\nThis is also exactly the code that I run on my local machine for development. Whether we are currently on a local machine or kaggle is controlled by `KAGGLE` boolean variable, the same name both in python and C code. \n\nThe solution is featuring the following approach:\n\n1. Hierarchy of C++ classes covering the necessary model components\n2. The code in this configuration only handles input-output pairs of the same size\n3. One of the main concepts is `Property`. A property object contains a 0-9 integer for each cell. It can be the original color, number of neighbors, whether a cell touches the border and so on. \n4. `Action` class associates output coordinates to the input coordinates, and `Coloring` class is responsible for the mapping of set of properties to output color. The `Coloring` class has a powerful `post_process` method which extrapolates observed colors into un-observed colors.\n5. The code greedily checks all combinations of properties, up to 3 properties per check. It picks the simplest solutions.\n\nGeneral components include the following, if you are developing on C++ too, may be you can pick something useful for yourself:\n\n* How to check if you are on Kaggle\n* Compile with debugging, I can run debug with dbg locally with a command in a shell:\n\n> C:\\WinBuilds\\bin\\gdb.exe -ex run --args C:\\StudioProjects\\ARC\\main.exe evaluation\n\n* Reading and parsing the json files, writing the submission file back. Maximum 3 outputs, only different outputs are allowed. \n* Saving successfully solved tasks into a persistent file. Once solved, a task prints a warning if not solved with the new code iteration.","445159d8":"# Code"}}