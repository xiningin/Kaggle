{"cell_type":{"69f05717":"code","cebe5033":"code","b0822cb3":"code","f632bcf5":"code","c1e8f8a8":"code","22c11a69":"code","cb700dae":"code","ba0c3c8f":"code","b661370e":"code","0b728525":"code","7b3a1f9b":"code","ec70e364":"code","9cfa9dee":"code","08e154cc":"code","9e183408":"code","660b699d":"markdown"},"source":{"69f05717":"import warnings\nwarnings.filterwarnings('ignore')","cebe5033":"import pandas as pd\nimport numpy as np","b0822cb3":"movies = pd.read_csv('..\/input\/movielens-dataset\/movies.csv')\nratings = pd.read_csv('..\/input\/movielens-dataset\/ratings.csv')","f632bcf5":"dataset = pd.merge(movies, ratings, how='left', on='movieId')\ndataset = dataset.fillna(0)","c1e8f8a8":"dataset.tail(6)","22c11a69":"dataset = dataset.drop(['timestamp'], axis=1)","cb700dae":"# shape of the data\nprint('The total number of rows :', dataset.shape[0])\nprint('The total number of columns :', dataset.shape[1])","ba0c3c8f":"# unique users\nprint('Total unique users in the dataset', dataset['userId'].nunique())\n\n# unique movie\nprint('Total unique movie in the dataset', dataset['movieId'].nunique())","b661370e":"import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn import metrics\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error","0b728525":"train_data, test_data = train_test_split(dataset, test_size =.30, random_state=10)\n\nprint(f'Training set has {train_data.shape[0]} rows and {train_data.shape[1]} columns')\nprint(f'Testing set has {test_data.shape[0]} rows and {test_data.shape[1]} columns')","7b3a1f9b":"class popularity_model():\n    def __init__(self, train_data, test_data, user_id, movie_id):\n        self.train_data = train_data\n        self.test_data = test_data\n        self.user_id = user_id\n        self.movie_id = movie_id\n        self.popularity_recommendation = None\n        \n    def fit(self):\n        # counting movies with more ratings from users\n        train_data_grouped = train_data.groupby([self.movie_id]).agg(self.user_id).count().reset_index()\n        train_data_grouped.rename(columns = {'userId': 'score'},inplace=True)\n    \n        # sorting the score column of train_data_grouped in ascending order\n        train_data_sort = train_data_grouped.sort_values(['score', self.movie_id], ascending = [0,1])\n        \n    \n        # recommendation rank based upon score\n        # ranking the highest score with 1 and onwards\n        train_data_sort['Rank'] = train_data_sort['score'].rank(ascending=0, method='first')\n        \n    \n        self.popularity_recommendation = train_data_sort\n        \n    def recommend(self, user_id, n=5):    \n        user_recommendations = self.popularity_recommendation\n        \n        #getting movies that are rated by the given userId \n        movies_already_rated_by_user = self.train_data.loc[self.train_data[self.user_id] == user_id][self.movie_id]  \n       \n        # recommending the movies with the highest ratings that havent been rated by the given user\n        # `~` refers to all the movieId that is not in the variable `movies_already_rated_by_user`\n        user_recommendations = user_recommendations[~user_recommendations[self.movie_id].isin(movies_already_rated_by_user)]\n        \n        \n        #Add user_id column for which the recommendations are being generated\n        user_recommendations['user_id'] = user_id\n    \n        #Bringing the user_id column to the front\n        cols = user_recommendations.columns.tolist()\n        user_recommendations = user_recommendations[cols]\n        return user_recommendations.head(n)\n    ","ec70e364":"pr = popularity_model(train_data=train_data, test_data=test_data, user_id='userId', movie_id='movieId')","9cfa9dee":"# the variable pr has all the highest rated movies\npr.fit()","08e154cc":"result_pop_user1 = pr.recommend(628)\nresult_pop_user1","9e183408":"# train_data.groupby('movieId').agg('userId').count().reset_index(name='userIdCount')","660b699d":"# Popularity Based Model\n\n    The goal of this recommendation model is to first choose the movies with the highest ratings received. \n    Once the popular movies have been extracted, I fetch the movies that havent been rated by the given userId yet.\n    This model suggests those popular movies that have not been rated by an user.\n    Presumably if a movie is not rated  by the user it hasnot been seen y the user as well\n    \n    ^^"}}