{"cell_type":{"9baef9f2":"code","0db9e4b4":"code","6e2adc77":"code","c1938495":"code","dfd24f37":"code","e03ca89f":"code","2fb1c0fd":"code","47deef7c":"code","e3a36e65":"code","b449e123":"code","b8fb1141":"code","c607d658":"code","e6a43f60":"code","945dca2d":"code","8d7d130b":"code","a02820a3":"code","c0b39619":"code","eabc2897":"code","fcbe7555":"code","322ca5e5":"markdown","b8145f11":"markdown","1a586f2a":"markdown","950afa82":"markdown","4b800f87":"markdown","27042236":"markdown","d2426c2e":"markdown","151d02d2":"markdown","af95ae10":"markdown","25b45956":"markdown","c1e9cdec":"markdown"},"source":{"9baef9f2":"import numpy as np\nimport os\nfrom keras import layers\nfrom keras.layers import Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D\nfrom keras.models import Model, load_model\nfrom keras.preprocessing import image\nfrom keras.utils import layer_utils\nfrom keras.utils.data_utils import get_file\nfrom keras.applications.imagenet_utils import preprocess_input\nimport pydot\nfrom IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot\nfrom keras.utils import plot_model\nfrom keras.initializers import glorot_uniform\nimport scipy.misc\nfrom matplotlib.pyplot import imshow\n%matplotlib inline\n\nimport keras.backend as K\nK.set_image_data_format('channels_last')\nK.set_learning_phase(1)","0db9e4b4":"def identity_block(X, f, filters, stage, block):\n    \n    # defining name basis\n    conv_name_base = 'res' + str(stage) + block + '_branch'\n    bn_name_base = 'bn' + str(stage) + block + '_branch'\n\n    # Retrieve Filters\n    F1, F2, F3 = filters\n\n    if K.image_data_format() == 'channels_last':\n        bn_axis = 3\n    else:\n        bn_axis = 1\n    \n    # Save the input value. You'll need this later to add back to the main path. \n    X_shortcut = X\n\n    # First component of main path\n    X = Conv2D(filters=F1, kernel_size=(1, 1), strides=(1, 1), padding='valid', name=conv_name_base + '2a', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=bn_axis, name=bn_name_base + '2a')(X)\n    X = Activation('relu')(X)\n\n    # Second component of main path\n    X = Conv2D(filters=F2, kernel_size=(f, f), strides=(1, 1), padding='same', name=conv_name_base + '2b', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=bn_axis, name=bn_name_base + '2b')(X)\n    X = Activation('relu')(X)\n\n    # Third component of main path\n    X = Conv2D(filters=F3, kernel_size=(1, 1), strides=(1, 1), padding='valid', name=conv_name_base + '2c', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=bn_axis, name=bn_name_base + '2c')(X)\n\n    # Final step: Add shortcut value to main path, and pass it through a RELU activation (\u22482 lines)\n    X = Add()([X, X_shortcut])\n    X = Activation('relu')(X)\n\n    return X","6e2adc77":"def convolutional_block(X, f, filters, stage, block, s=2):\n\n    # defining name basis\n    conv_name_base = 'res' + str(stage) + block + '_branch'\n    bn_name_base = 'bn' + str(stage) + block + '_branch'\n\n    # Retrieve Filters\n    F1, F2, F3 = filters\n\n    # Save the input value\n    X_shortcut = X\n    \n    if K.image_data_format() == 'channels_last':\n        bn_axis = 3\n    else:\n        bn_axis = 1\n        \n    # MAIN PATH   \n    # First component of main path \n    X = Conv2D(filters=F1, kernel_size=(1, 1), strides=(s, s), padding='valid', name=conv_name_base + '2a', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=3, name=bn_name_base + '2a')(X)\n    X = Activation('relu')(X)\n\n    # Second component of main path\n    X = Conv2D(filters=F2, kernel_size=(f, f), strides=(1, 1), padding='same', name=conv_name_base + '2b', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=3, name=bn_name_base + '2b')(X)\n    X = Activation('relu')(X)\n\n    # Third component of main path (\u22482 lines)\n    X = Conv2D(filters=F3, kernel_size=(1, 1), strides=(1, 1), padding='valid', name=conv_name_base + '2c', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=3, name=bn_name_base + '2c')(X)\n\n    # SHORTCUT PATH \n    X_shortcut = Conv2D(filters=F3, kernel_size=(1, 1), strides=(s, s), padding='valid', name=conv_name_base + '1', kernel_initializer=glorot_uniform(seed=0))(X_shortcut)\n    X_shortcut = BatchNormalization(axis=3, name=bn_name_base + '1')(X_shortcut)\n\n    # Final step: Add shortcut value to main path, and pass it through a RELU activation\n    X = Add()([X, X_shortcut])\n    X = Activation('relu')(X)\n\n    return X","c1938495":"def ResNet50(input_shape, classes):\n    \n    # Define the input as a tensor with shape input_shape\n    X_input = Input(input_shape)\n\n    # Zero-Padding\n    X = ZeroPadding2D((3, 3))(X_input)\n\n    # Stage 1\n    X = Conv2D(64, (7, 7), strides=(2, 2), name='conv1', kernel_initializer=glorot_uniform(seed=0))(X)\n    X = BatchNormalization(axis=3, name='bn_conv1')(X)\n    X = Activation('relu')(X)\n    X = MaxPooling2D((3, 3), strides=(2, 2))(X)\n\n    # Stage 2\n    X = convolutional_block(X, f=3, filters=[64, 64, 256], stage=2, block='a', s=1)\n    X = identity_block(X, 3, [64, 64, 256], stage=2, block='b')\n    X = identity_block(X, 3, [64, 64, 256], stage=2, block='c')\n\n    # Stage 3\n    X = convolutional_block(X, f=3, filters=[128, 128, 512], stage=3, block='a', s=2)\n    X = identity_block(X, 3, [128, 128, 512], stage=3, block='b')\n    X = identity_block(X, 3, [128, 128, 512], stage=3, block='c')\n    X = identity_block(X, 3, [128, 128, 512], stage=3, block='d')\n\n    # Stage 4\n    X = convolutional_block(X, f=3, filters=[256, 256, 1024], stage=4, block='a', s=2)\n    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='b')\n    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='c')\n    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='d')\n    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='e')\n    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='f')\n\n    # Stage 5\n    X = X = convolutional_block(X, f=3, filters=[512, 512, 2048], stage=5, block='a', s=2)\n    X = identity_block(X, 3, [512, 512, 2048], stage=5, block='b')\n    X = identity_block(X, 3, [512, 512, 2048], stage=5, block='c')\n\n    # AVGPOOL (\u22481 line). Use \"X = AveragePooling2D(...)(X)\"\n    X = AveragePooling2D(pool_size=(2, 2), padding='same')(X)\n\n    # output layer\n    X = Flatten()(X)\n    X = Dense(classes, activation='softmax', name='fc' + str(classes), kernel_initializer=glorot_uniform(seed=0))(X)\n\n    # Create model\n    model = Model(inputs=X_input, outputs=X, name='ResNet50')\n\n    return model","dfd24f37":"data_dir = '..\/input\/chest-xray-pneumonia\/chest_xray\/'\n\ntest_path = data_dir+'\/test\/'\nvalid_path = data_dir+'\/val\/'\ntrain_path = data_dir+'\/train\/'","e03ca89f":"# Check for number of images\nprint('Train Set')\nprint('Normal : ' , len(os.listdir(train_path+'NORMAL')))\nprint('Pneumonia : ' , len(os.listdir(train_path+'PNEUMONIA')))\n\nprint()\n\nprint('Validation Set')\nprint('Normal : ' , len(os.listdir(valid_path+'NORMAL')))\nprint('Pneumonia : ' , len(os.listdir(valid_path+'PNEUMONIA')))\n\nprint()\n\nprint('Test Set')\nprint('Normal : ' , len(os.listdir(test_path+'NORMAL')))\nprint('Pneumonia : ' , len(os.listdir(test_path+'PNEUMONIA')))","2fb1c0fd":"import matplotlib.pyplot as plt\nfrom matplotlib.image import imread\n\ndim1 = []\ndim2 = []\nfor image_filename in os.listdir(train_path+'PNEUMONIA'):\n    \n    img = imread(train_path+'PNEUMONIA'+'\/'+image_filename)\n    d1 = img.shape[0]\n    d2 = img.shape[1]\n    dim1.append(d1)\n    dim2.append(d2)","47deef7c":"import seaborn as sns\nsns.jointplot(dim1,dim2)","e3a36e65":"import numpy as np\n\nprint('Avg. dim1 = ', np.mean(dim1))\nprint('Avg. dim2 = ', np.mean(dim2))\n\nimage_shape = (825, 1200, 1)","b449e123":"image_size = 224\nn_channels = 1","b8fb1141":"from tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nimage_gen = ImageDataGenerator(rescale = 1.\/255,\n                               shear_range = 0.2,\n                               zoom_range = 0.2,\n                               horizontal_flip = True)","c607d658":"batch_size = 32\n\ntrain_image_gen = image_gen.flow_from_directory(train_path,\n                                                target_size=(image_size,image_size),\n                                                color_mode='grayscale',\n                                                batch_size=batch_size,\n                                                class_mode='categorical')","e6a43f60":"test_image_gen = image_gen.flow_from_directory(test_path,\n                                               target_size=(image_size,image_size),\n                                               color_mode='grayscale',\n                                               batch_size=batch_size,\n                                               class_mode='categorical')","945dca2d":"model = ResNet50(input_shape = (image_size,image_size,n_channels), classes=2)","8d7d130b":"model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])","a02820a3":"model.summary()","c0b39619":"# fit the model\nr = model.fit_generator(train_image_gen,\n                        validation_data=test_image_gen,\n                        epochs=10,\n                        steps_per_epoch=len(train_image_gen),\n                        validation_steps=len(test_image_gen)\n                        )","eabc2897":"import pandas as pd\n\nlosses = pd.DataFrame(model.history.history)\nlosses[['loss','val_loss']].plot()","fcbe7555":"pred_probabilities = model.predict_generator(test_image_gen)\npredictions = pred_probabilities > 0.5","322ca5e5":"## 1. Identity Block","b8145f11":"![](https:\/\/i.stack.imgur.com\/0mE2p.png)","1a586f2a":"\n    CONV2D -> BATCHNORM -> RELU -> MAXPOOL -> CONVBLOCK -> IDBLOCK*2 -> CONVBLOCK -> IDBLOCK*3\n    -> CONVBLOCK -> IDBLOCK*5 -> CONVBLOCK -> IDBLOCK*2 -> AVGPOOL -> TOPLAYER\n\n    Arguments:\n    input_shape -- shape of the images of the dataset\n    classes -- integer, number of classes\n\n    Returns:\n    model -- a Model() instance in Keras\n","950afa82":"\n    Arguments:\n    X -- input tensor of shape (m, n_H_prev, n_W_prev, n_C_prev)\n    f -- integer, specifying the shape of the middle CONV's window for the main path\n    filters -- python list of integers, defining the number of filters in the CONV layers of the main path\n    stage -- integer, used to name the layers, depending on their position in the network\n    block -- string\/character, used to name the layers, depending on their position in the network\n    s -- Integer, specifying the stride to be used\n\n    Returns:\n    X -- output of the convolutional block, tensor of shape (n_H, n_W, n_C)","4b800f87":"## 3. ResNet50 model","27042236":"## 2. Convolutional Block","d2426c2e":"![](https:\/\/miro.medium.com\/max\/1400\/1*hEU7S-EiVqcmtAlj6kgfRA.png)","151d02d2":"![](https:\/\/i.stack.imgur.com\/37qzA.png)","af95ae10":"## 5. Model Evaluation","25b45956":"## 4. Importing Datasets","c1e9cdec":" \n    Arguments:\n    X -- input tensor of shape (m, n_H_prev, n_W_prev, n_C_prev)\n    f -- integer, specifying the shape of the middle CONV's window for the main path\n    filters -- python list of integers, defining the number of filters in the CONV layers of the main path\n    stage -- integer, used to name the layers, depending on their position in the network\n    block -- string\/character, used to name the layers, depending on their position in the network\n\n    Returns:\n    X -- output of the identity block, tensor of shape (n_H, n_W, n_C)\n"}}