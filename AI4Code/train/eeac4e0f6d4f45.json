{"cell_type":{"a2810874":"code","24623c6b":"code","c77e4f21":"code","e4bee4dc":"code","6d99c63f":"code","7cf75466":"code","22149949":"code","2d5d48ea":"code","904f1f00":"code","38637980":"code","5072da73":"code","e1d4e186":"code","bb2ddfdb":"code","5d5175e1":"code","6f01fe5f":"code","29920039":"code","41001877":"code","e818869a":"code","7e646c1d":"code","5b7c40d9":"code","361f1f4d":"code","7d40a0ed":"code","920ca232":"code","912a2f41":"code","77dde2f4":"code","9e0c3af1":"code","59245c48":"code","ef50e230":"code","4c2032bb":"markdown","55c2beb4":"markdown","acb1adaa":"markdown","a41af669":"markdown","b768b69b":"markdown","7f9c08da":"markdown","091204a0":"markdown","531b8572":"markdown","f9e68786":"markdown","748d647b":"markdown","03096049":"markdown","6c34c2fb":"markdown","b2621b67":"markdown","405bb81e":"markdown","20c64e7f":"markdown","9d95a865":"markdown","fae0120a":"markdown","e4f242bc":"markdown","d8459939":"markdown","efe4ee8d":"markdown","f4eef5ca":"markdown","efca04ff":"markdown","477eab0a":"markdown","fd0d8f50":"markdown","d5ee9de3":"markdown","385a340f":"markdown"},"source":{"a2810874":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport altair as alt\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","24623c6b":"!pip install altair pandas_flavor","c77e4f21":"from pandas_flavor import register_dataframe_method,register_series_method\nfrom IPython.core.display import display, HTML\n\n@register_dataframe_method\ndef missing(df):        \n    tmp =  sorted(\n                [(col , str(df[col].dtypes) ,df[col].isna().sum(), np.round( df[col].isna().sum() \/ len(df) * 100,2) ) for col in df.columns if df[col].isna().sum() !=0 ],\n                key = lambda x: x[2], reverse=True)\n    \n    return pd.DataFrame(tmp).rename({0:\"Feature\", 1:\"dtype\", 2:\"count\", 3:\"percent\"},axis=1)  \n\n@register_dataframe_method\ndef get_numeric_df(df):\n    return df.select_dtypes(np.number)\n\n@register_dataframe_method\ndef get_numeric_cols(df):\n    return list(df.select_dtypes(np.number).columns)\n\n@register_dataframe_method\ndef discrete_features_cols(df,thresold):\n#     thresold in number of unique values\n    return [feature for feature in df.columns if len(df[feature].unique()) < thresold]\n\n@register_dataframe_method\ndef discrete_features_df(df,thresold):\n#     thresold in number of unique values\n    return df[ discrete_features_cols(df=df,thresold=thresold) ]\n\n@register_dataframe_method\ndef continuous_features_cols(df,thresold):\n    #     thresold in number of unique values\n    return [feature for feature in df.columns if len(df[feature].unique()) >= thresold]\n\n@register_dataframe_method\ndef continuous_features_df(df,thresold):\n    #     thresold in number of unique values\n    return df[ continuous_features_cols(df=df,thresold=thresold) ]\n\n@register_dataframe_method\ndef dtypes_of_cols(df):\n    return pd.DataFrame(df.dtypes).reset_index().rename(columns={'index':\"Columns\",0: \"dtype\"})\n\n@register_dataframe_method\ndef describe_discrete_cols(df,thresold, ascending=True):\n    \n    values = pd.DataFrame()\n    \n    for col in df.discrete_features_cols(thresold=thresold):\n        values[col] = [df[col].unique(), df[col].nunique()]\n        \n    return values.transpose().sort_values(by = 1,ascending=ascending).rename({0:\"Values\",1:\"cardinality\"},axis=1)\n    \n    \n@register_series_method\ndef IQR_range(df):\n    if isinstance(df, pd.Series):\n        Q3 = np.quantile(df, 0.75)\n        Q1 = np.quantile(df, 0.25)\n        IQR = Q3 - Q1\n\n        lower_range = Q1 - 1.5 * IQR\n        upper_range = Q3 + 1.5 * IQR\n\n        return (lower_range,upper_range)\n    else:\n        assert False, \"df must be of type pandas.Series\"\n        \n@register_dataframe_method\ndef IQR_range(df):\n    if isinstance(df, pd.DataFrame):\n        cols = df.get_numeric_cols()\n        features = {}\n        for i in cols:\n            Q3 = np.quantile(df[i], 0.75)\n            Q1 = np.quantile(df[i], 0.25)\n            IQR = Q3 - Q1\n\n            lower_range = Q1 - 1.5 * IQR\n            upper_range = Q3 + 1.5 * IQR\n\n\n            features[i] = (lower_range,upper_range)\n            \n        return pd.DataFrame.from_dict(features,orient='index').rename({0: 'IQR_Low',1: 'IQR_High'}, axis=1)\n    else:\n        assert False, \"df must be of type pandas.DataFrame\"\n        \n@register_dataframe_method\ndef compare_cols(df,l_feat,r_feat,percent=False):\n    \n#     [L_feat] {R_feat1: agg1, R_feat2: agg2}\n\n    \n    if percent:\n        \n        comp = []\n        for key, val in zip(r_feat,r_feat.values()):\n            tmp = pd.DataFrame()\n            tmp[key + \" \" + val] =  df.groupby(l_feat,sort=True).agg({key: val})\n            tmp[key +\" %\"] = tmp.groupby(level=0).apply(lambda x: np.round(100 * x \/ float(x.sum()),2))\n            \n            comp.append(tmp)\n            \n        return comp\n    \n    else:\n        comp = []\n        for key, val in zip(r_feat,r_feat.values()):\n            tmp = pd.DataFrame()\n            tmp[key + \" \" + val] =  df.groupby(l_feat,sort=True).agg({key: val})           \n            comp.append(tmp)\n            \n        return comp        \n\n    \n@register_series_method\ndef IQR_percent(df):\n    if isinstance(df, pd.Series):\n        \n        lower_range, upper_range = df.IQR_range()\n\n        length = len(df)\n        return np.round((length - df.between(lower_range,upper_range).sum())\/length * 100, 2)\n    else:\n        assert False, \"df must be of type pandas.Series\"\n\n@register_dataframe_method\ndef IQR_percent(df):\n    if isinstance(df, pd.DataFrame):\n        cols = df.get_numeric_cols()\n        features = {}\n        for i in cols:\n            lower_range, upper_range = df[i].IQR_range()\n\n            length = len(df[i])\n            tmp = np.round((length - df[i].between(lower_range,upper_range).sum())\/length * 100, 2)\n            if tmp != 0:\n                features[i] = tmp\n#             features[i] = IQR_percent(df[i])\n            \n        return pd.DataFrame.from_dict(features,orient='index').rename({0: 'Outlier percent'}, axis=1)\n    else:\n        assert False, \"df must be of type pandas.DataFrame\"\n        \n@register_dataframe_method\ndef drop_row_outlier(df, cols, inplace=False):\n#     init empty index\n    indices = pd.Series(np.zeros(len(df), dtype=bool), index=df.index)\n\n    for col in cols:\n        low, top = df[col].IQR_range()\n        indices |= (df[col] > top) | (df[col] < low)\n        \n    \n    return df.drop(df[ indices ].index, inplace=inplace)\n\n@register_series_method\ndef drop_row_outlier(df, inplace=False):\n#     init empty index\n\n    low, top = df.IQR_range()\n        \n    \n    return df.drop(df[ (df > top) | (df < low) ].index, inplace=inplace)\n\n\n@register_dataframe_method\ndef about(df):\n\n    display(HTML('<h1 style=\"color:green\"> <b> Shape of data <\/b> <\/h1>'))\n    print(df.shape)    \n\n    display(HTML('<h1 style=\"color:green\"> <b> Datatypes in data <\/b> <\/h1> '))\n    print(df.dtypes.value_counts(ascending=False))\n\n    display(HTML('<h1 style=\"color:green\"> <b> dtypes of columns <\/b> <\/h1> '))\n    display(df.dtypes_of_cols())\n\n    display(HTML('<h1 style=\"color:green\"> <b> Percentage of missing values <\/b> <\/h1> '))\n    tmp = missing(df)\n    display(tmp) if len(tmp) != 0 else display(HTML(\"<h2> <b> None <b> <\/h2>\"))\n\n    display(HTML('<h1 style=\"color:green\"> <b> Data description <\/b> <\/h1> '))\n    display(df.describe().T)\n    \n    display(HTML('<h1 style=\"color:green\"> <b> Outlier Percentage(IQR) <\/b> <\/h1> '))\n    tmp = df.IQR_percent()\n    display(tmp) if len(tmp) != 0 else display(HTML(\"<h2> <b> None <b> <\/h2>\"))\n\n    display(HTML('<h1 style=\"color:green\"> <b> Example of data <\/b> <\/h1> '))\n    display(df.head())","e4bee4dc":"sns.set(style=\"darkgrid\",font_scale=1.3)\nplt.rcParams['figure.dpi']=100\n\n\nfrom matplotlib.ticker import MaxNLocator\n\ndef srt_reg(y, df,x_size=20,y_size=20,*args,**kwargs):\n    \n    ncols = 3\n    nrows = int(np.ceil(df.shape[1]\/ncols))\n    \n    fig, axes = plt.subplots(nrows, ncols, figsize=(x_size,y_size))\n    axes = axes.flatten()\n\n    for i, j in zip(df.columns, axes):\n\n        sns.regplot(x=i,\n                    y=y,\n                    data=df,\n                    ax=j,\n                    order=3,\n                    ci=None,\n                    color='#e74c3c',\n                    line_kws={'color': 'black'},\n                    scatter_kws={'alpha':0.4},\n                   *args,**kwargs)\n        j.tick_params(labelrotation=45)\n        j.yaxis.set_major_locator(MaxNLocator(nbins=10))\n\n        plt.tight_layout()\n\ndef srt_box(y, df,*args,**kwargs):\n    fig, axes = plt.subplots(19, 3, figsize=(30,30))\n    axes = axes.flatten()\n\n    for i, j in zip(df.columns, axes):\n\n        sortd = df.groupby([i])[y].median().sort_values(ascending=False)\n        sns.boxplot(x=i,\n                    y=y,\n                    data=df,\n                    palette='plasma',\n                    order=sortd.index,\n                    ax=j,\n                    *args,**kwargs)\n        j.tick_params(labelrotation=45)\n        j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n        plt.tight_layout()\n\n\n        \ndef histplt(df,ncols = 3, x_size=30,y_size=30,*args,**kwargs):\n    \n    if len(df.shape) == 1:\n        fig, ax = plt.subplots(figsize=(x_size,y_size))\n        sns.histplot(x=df,ax=ax,*args,**kwargs)\n        [ ax.bar_label(tmp) for tmp in ax.containers]\n        \n        ax.tick_params(labelrotation=45)\n#         plt.tight_layout()\n        \n    else:\n    \n#         ncols = 3\n        nrows = int(np.ceil(df.shape[1]\/ncols))\n\n        fig, axes = plt.subplots(nrows, ncols, \n                                 figsize=(x_size,y_size)\n                                )\n        axes = axes.flatten()\n\n        for i, j in zip(df.columns, axes):\n\n            sns.histplot(data=df, x=i,ax=j,*args,**kwargs)\n            j.tick_params(labelrotation=45)\n            [ j.bar_label(tmp) for tmp in j.containers]\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n        \n\ndef countplt(df,ncols = 3, x_size=30,y_size=30,*args,**kwargs):\n    \n    if len(df.shape) == 1:\n        fig, ax = plt.subplots(figsize=(x_size,y_size))\n        sns.countplot(x=df,ax=ax,*args,**kwargs)\n        [ ax.bar_label(tmp) for tmp in ax.containers]\n        \n        ax.tick_params(labelrotation=45)\n#         plt.tight_layout()\n        \n    else:\n    \n#         ncols = 3\n        nrows = int(np.ceil(df.shape[1]\/ncols))\n\n        fig, axes = plt.subplots(nrows, ncols, \n                                 figsize=(x_size,y_size)\n                                )\n        axes = axes.flatten()\n\n        for i, j in zip(df.columns, axes):\n\n            sns.countplot(data=df, x=i,ax=j,*args,**kwargs)\n            j.tick_params(labelrotation=45)\n            [ j.bar_label(tmp) for tmp in j.containers]\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n\n\n    \n    \ndef barplt(df,y,x_size=30,y_size=30,*args,**kwargs):\n    ncols = 3\n    nrows = int(np.ceil(df.shape[1]\/ncols))\n    \n    fig, axes = plt.subplots(nrows, ncols, \n                             figsize=(x_size,y_size)\n                            )\n    axes = axes.flatten()\n\n    for i, j in zip(df.columns, axes):\n        \n        if i == y:\n            continue\n\n        sns.barplot(data=df,\n                    x=i,\n                    y=y,\n                    ax=j,*args,**kwargs)\n\n        j.tick_params(labelrotation=45)\n        [ j.bar_label(tmp) for tmp in j.containers]\n#         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n        plt.tight_layout()\n    \n    \ndef violinplt(df,y,ncols=3,x_size=30,y_size=30,x_scale = \"linear\", y_scale = \"linear\", *args,**kwargs):\n    \n    \n    nrows = int(np.ceil(df.shape[1]\/ncols))\n    \n    fig, axes = plt.subplots(nrows, ncols, \n                             figsize=(x_size,y_size)\n                            )\n    axes = axes.flatten()\n    \n    if df[y].dtype == 'O':\n\n        for i, j in zip(df.columns, axes):\n\n            if i == y:\n                continue\n\n            sns.violinplot(data=df,\n                        x=y,\n                        y=i,\n                        ax=j,*args,**kwargs)\n            \n            lower_range, upper_range = df[i].IQR_range()\n            outliers = df[(df[i] > upper_range) | (df[i] < lower_range)][i]\n            sns.scatterplot(y=outliers, x=0, marker='D', color='crimson', ax=j)\n            j.tick_params(labelrotation=45)\n\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n        \n        \n    else:\n\n        for i, j in zip(df.columns, axes):\n\n            if i == y:\n                continue\n\n            g = sns.violinplot(data=df,\n                        x=i,\n                        y=y,\n                        ax=j,*args,**kwargs)\n            g.set_xscale(x_scale)\n            g.set_yscale(y_scale)\n            j.tick_params(labelrotation=45)\n\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n        \ndef boxplt(df,y,x_size=30,y_size=30,*args,**kwargs):\n\n    ncols = 3\n    nrows = int(np.ceil(df.shape[1]\/ncols))\n    \n    fig, axes = plt.subplots(nrows, ncols, \n                             figsize=(x_size,y_size)\n                            )\n    axes = axes.flatten()\n    \n    if df[y].dtype == 'O':\n\n        for i, j in zip(df.columns, axes):\n\n            if i == y:\n                continue\n\n            sns.boxplot(data=df,\n                        x=y,\n                        y=i,\n                        ax=j,*args,**kwargs)\n\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n        \n        \n    else:\n\n        for i, j in zip(df.columns, axes):\n\n            if i == y:\n                continue\n\n            sns.boxplot(data=df,\n                        x=i,\n                        y=y,\n                        ax=j,*args,**kwargs)\n\n    #         j.yaxis.set_major_locator(MaxNLocator(nbins=18))\n\n            plt.tight_layout()\n\n\nimport scipy.stats as stats\n\ndef qqplt(df,x_size=30,y_size=30,*args,**kwargs):\n    \n    if len(df.shape) == 1:\n        fig, ax = plt.subplots(figsize=(x_size,y_size))\n        stats.probplot(df,plot=ax, *args,**kwargs)\n        \n#         ax.set_title(label=df.columns)\n        ax.tick_params(labelrotation=45)\n        ax.yaxis.set_major_locator(MaxNLocator(nbins=10))\n\n#         plt.tight_layout()\n        \n    \n    else:\n        ncols = 3\n        nrows = int(np.ceil(df.shape[1]\/ncols))\n\n        fig, axes = plt.subplots(nrows, ncols, figsize=(x_size,y_size))\n        axes = axes.flatten()\n\n        for i, j in zip(df.columns, axes):\n\n            stats.probplot(df[i],plot=j, *args,**kwargs)\n            j.set_title(label=i)\n            j.tick_params(labelrotation=45)\n            j.yaxis.set_major_locator(MaxNLocator(nbins=10))\n\n            plt.tight_layout()","6d99c63f":"df = pd.read_csv(\"..\/input\/customer-personality-analysis\/marketing_campaign.csv\", sep=\"\\t\")\ndf.drop(\"ID\", axis=1, inplace=True)\ndf.about()","7cf75466":"df.dropna(axis = 0, inplace=True)\ndf.drop(\"Dt_Customer\", axis = 1, inplace=True)","22149949":"pd.DataFrame(df.nunique()).sort_values(0).rename({0:\"Unique Values\"}, axis=1)","2d5d48ea":"df.describe_discrete_cols(thresold=50)","904f1f00":"df.drop([\"Z_CostContact\", \"Z_Revenue\"], axis=1, inplace=True)","38637980":"df.continuous_features_cols(thresold=50)","5072da73":"cols = ['Year_Birth','Income']\n\ndf.drop_row_outlier(cols=cols, inplace=True)","e1d4e186":"histplt(df.continuous_features_df(thresold=50), bins= 20, x_size=40, y_size=20)","bb2ddfdb":"df.discrete_features_cols(thresold=50)","5d5175e1":"countplt(df.discrete_features_df(thresold=50), y_size=30)","6f01fe5f":"[ display( *df.compare_cols(  i, {\"Income\": \"median\"})) for i in df.discrete_features_cols(thresold=50) ]","29920039":"feat = df.discrete_features_cols(thresold=50)\nfeat.append(\"Income\")\nbarplt(df[feat], y = \"Income\", x_size=40)","41001877":"violinplt(df[feat], y = \"Income\", ncols=2, x_size=30, y_size=50,)","e818869a":"df.columns","7e646c1d":"# Products vs People\n#  for other people attrs we need to make it discrete\n\npeople_attr = ['Education', 'Marital_Status', 'Kidhome','Teenhome', 'Complain']\nproducts_attr = ['MntWines', 'MntFruits','MntMeatProducts', 'MntFishProducts', 'MntSweetProducts','MntGoldProds']\n\n\ndisplay(HTML('<h1 style=\"color:green;text-align:center\";> Income'))\nplt.show(barplt(df[people_attr+ [\"Income\"]], y = \"Income\", x_size=40, y_size=20))\n\n\nfor product in products_attr:\n    display(HTML(f'<h1 style=\"color:green;text-align:center\";>{product}'))\n    plt.show(barplt(df[people_attr + [ product ]], y = product, x_size=40, y_size=20))\n","5b7c40d9":"df_tmp = df.copy()\n\nfor i in products_attr:\n    df_tmp[i + \" %\"] = df_tmp[i]\/ df_tmp[\"Income\"] * 100\n\nfor product in list(map(lambda orig_string: orig_string + \" %\", products_attr)):\n    display(HTML(f'<h1 style=\"color:green;text-align:center\";>{product}'))\n    plt.show(barplt(df_tmp[people_attr + [ product ]], y = product, x_size=40, y_size=20))","361f1f4d":"people_attr = ['Education', 'Marital_Status', 'Kidhome','Teenhome', 'Complain']\nplace_attr = ['NumWebPurchases', 'NumCatalogPurchases','NumStorePurchases', 'NumWebVisitsMonth']\n\n\nfor place in place_attr:\n    display(HTML(f'<h1 style=\"color:green;text-align:center\";>{place}'))\n    plt.show(barplt(df[people_attr + [ place ]], y = place, x_size=40, y_size=20))","7d40a0ed":"def dashboard(product, selection=['x', 'y']):\n\n    brush = alt.selection_interval(encodings=selection)\n\n    points = alt.Chart(df).mark_point().encode(\n    x=\"Income\",\n#     y=\"MntWines\",\n    y=product,\n    # color=\"Marital_Status\"\n    color = alt.condition(brush, 'Origin:N', alt.value('lightgray'))\n    ).add_selection(\n        brush\n    ).properties(\n        width=1000,\n        height=400\n    )\n    \n    maritial_status= alt.Chart(df).mark_bar().encode(\n        \n#         color='Marital_Status',\n        x='count(Marital_Status)',\n        y=alt.Y('Marital_Status', sort='-x'),\n    ).transform_filter(\n        brush\n    )\n    \n\n    education= alt.Chart(df).mark_bar().encode(\n#         y='Education',\n        y=alt.Y('Education', sort='-x'),\n#         color='Education',\n        x='count(Education)'\n    ).transform_filter(\n        brush\n    )\n\n    kidhome =  alt.Chart(df).mark_bar().encode(\n#         y='Kidhome:N',\n        y=alt.Y('Kidhome:N', sort='-x'),\n        color='Kidhome',\n        x='count(Kidhome)'\n    ).transform_filter(\n        brush\n    )\n\n    teenhome = alt.Chart(df).mark_bar().encode(\n#         y='Teenhome:N',\n        y=alt.Y('Teenhome:N', sort='-x'),\n        color='Teenhome',\n        x='count(Teenhome)'\n    ).transform_filter(\n        brush\n    )\n\n    income = alt.Chart(df).mark_bar().encode(\n        alt.X(\"Income:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n\n\n    deal_purchase = alt.Chart(df).mark_bar().encode(\n        alt.X(\"NumDealsPurchases:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n    # AcceptedCmp1 = alt.Chart(df).mark_bar().encode(\n    #     y='AcceptedCmp1:N',\n    #     color='AcceptedCmp1',\n    #     x='count(AcceptedCmp1)'\n    # ).transform_filter(\n    #     brush\n    # )\n\n    NumWebPurchases = alt.Chart(df).mark_bar().encode(\n        alt.X(\"NumWebPurchases:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n\n    NumCatalogPurchases = alt.Chart(df).mark_bar().encode(\n        alt.X(\"NumCatalogPurchases:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n    NumStorePurchases = alt.Chart(df).mark_bar().encode(\n        alt.X(\"NumStorePurchases:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n    NumWebVisitsMonth = alt.Chart(df).mark_bar().encode(\n        alt.X(\"NumWebVisitsMonth:Q\", bin=True),\n        y='count()',\n    ).transform_filter(\n        brush\n    )\n\n    return (points | income) & (maritial_status | education) & (kidhome | teenhome) & (deal_purchase | NumWebPurchases) & (NumCatalogPurchases | NumStorePurchases | NumWebVisitsMonth)","920ca232":"dashboard(product=\"MntWines\", selection=['y'])","912a2f41":"dashboard(product=\"MntFruits\", selection=['y'])","77dde2f4":"dashboard(product=\"MntMeatProducts\", selection=['y'])","9e0c3af1":"dashboard(product=\"MntMeatProducts\", selection=['y'])","59245c48":"dashboard(product=\"MntSweetProducts\", selection=['y'])","ef50e230":"dashboard(product=\"MntGoldProds\", selection=['y'])","4c2032bb":"## Products vs People attributes\n","55c2beb4":"# Custom Methods","acb1adaa":"# Customer attributes for MntSweetProducts","a41af669":"# Customer attributes for MntGoldProds","b768b69b":"# Importing data and Initial Impressions","7f9c08da":"# Customer attributes for MntWines","091204a0":"**24 rows with Nan for Income, lets drop those**\n\n**also lets drop `Dt_Customer`**","531b8572":"### spent on Products as absolute amount","f9e68786":"## Discrete Features vs Income","748d647b":"## Explore Discrete Features","03096049":"### spent on Products as percentage of income","6c34c2fb":"**lets drop outliers based on Income**","b2621b67":"## Inital Exploration of features","405bb81e":"## Number of purchases at Place vs People Attributes","20c64e7f":"# EDA\n","9d95a865":"## Observations\n**People who spend 25 to 50 on gold are**\n- have income 40k to 70k\n- most are married and graduated\n- No kids at home\n- roughly 50-50 chance of teenage kid at home\n- visit websites a lot\n\n","fae0120a":"# Imports","e4f242bc":"# Dashboard Code","d8459939":"# Customer attributes for MntFishProducts","efe4ee8d":"# Custom methods for plotting","f4eef5ca":"# Customer attributes for MntFruits","efca04ff":"## Observations\nSay you are a company which wants to sell premium wine, the survey of consumers shows as follows\n\n- have income 70k - 85k\n- most are married and hold a Phd\n- No kids or teens at home\n- most have bought wine once or twice in a deal\n- these group are comfortable buying both online and offline\n- most have number of websites as 6 to 7\n","477eab0a":"**we see Z_CostContact \tand Z_Revenue have constant values, lets drop them**","fd0d8f50":"## Explore Continuous features","d5ee9de3":"# Introduction\n\n## Problem Statement\nCustomer Personality Analysis is a detailed analysis of a company\u2019s ideal customers. It helps a business to better understand its customers and makes it easier for them to modify products according to the specific needs, behaviors and concerns of different types of customers. \n\n### Target\nIn this notebook I have tried to explore personality of people and Kinds of people buying categories of products. Feel Free to look at the viz\/ dashboard and draw conclusions, and also let me know in the comments.\n\n## If you liked this notebook drop a like and feel free to critique.\n    \n### Attributes\n\n#### People\n\n- ID: Customer's unique identifier\n- Year_Birth: Customer's birth year\n- Education: Customer's education level\n- Marital_Status: Customer's marital status\n- Income: Customer's yearly household income\n- Kidhome: Number of children in customer's household\n- Teenhome: Number of teenagers in customer's household\n- Dt_Customer: Date of customer's enrollment with the company\n- Recency: Number of days since customer's last purchase\n- Complain: 1 if customer complained in the last 2 years, 0 otherwise\n\n#### Products\n\n- MntWines: Amount spent on wine in last 2 years\n- MntFruits: Amount spent on fruits in last 2 years\n- MntMeatProducts: Amount spent on meat in last 2 years\n- MntFishProducts: Amount spent on fish in last 2 years\n- MntSweetProducts: Amount spent on sweets in last 2 years\n- MntGoldProds: Amount spent on gold in last 2 years\n\n#### Promotion\n\n- NumDealsPurchases: Number of purchases made with a discount\n- AcceptedCmp1: 1 if customer accepted the offer in the 1st campaign, 0 otherwise\n- AcceptedCmp2: 1 if customer accepted the offer in the 2nd campaign, 0 otherwise\n- AcceptedCmp3: 1 if customer accepted the offer in the 3rd campaign, 0 otherwise\n- AcceptedCmp4: 1 if customer accepted the offer in the 4th campaign, 0 otherwise\n- AcceptedCmp5: 1 if customer accepted the offer in the 5th campaign, 0 otherwise\n- Response: 1 if customer accepted the offer in the last campaign, 0 otherwise\n\n#### Place\n\n- NumWebPurchases: Number of purchases made through the company\u2019s web site\n- NumCatalogPurchases: Number of purchases made using a catalogue\n- NumStorePurchases: Number of purchases made directly in stores\n- NumWebVisitsMonth: Number of visits to company\u2019s web site in the last month\n\n","385a340f":"# Customer attributes for MntMeatProducts"}}