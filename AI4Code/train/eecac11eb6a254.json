{"cell_type":{"f034e5a1":"code","8a6d18c6":"code","ea0f6a39":"code","32854b54":"code","9bca08e6":"code","f77fa7b3":"code","6ed038c1":"markdown","1b673787":"markdown","58646678":"markdown","0d2fdb41":"markdown","558becb3":"markdown"},"source":{"f034e5a1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle\nimport random\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8a6d18c6":"from random import random\ndef sample_pdf(a, b, f, n=50):\n    \"\"\"\n    :param a: lower domain\n    :param b: upper domain\n    :param f: Probability Density Function\n    :param n: number of rectangles to simulate\n    :return: a random number from the PDF\n    \"\"\"\n    step = (b-a)\/n\n    r = random()\n    for i in range(n):\n        x = a + step * i\n        y = f(x+0.5*step)\n        if y*step > r:\n            return x + (r\/y)\n        r -= y*step\n    raise ValueError()","ea0f6a39":"def pdf(x):\n    s = 2\n    return (s-abs(x))\/s**2 if -s < x < s else 0\n\n\nplt.figure(figsize = (10,6)) \nline_x = np.linspace(-2.5,2.5,100)\nline_y = np.array([pdf(x) for x in line_x])\nplt.plot(line_x, line_y)\nplt.grid(True, which='both')","32854b54":"def make_boxes(ax, a, b, f, n, facecolor='#ffa6aeaa',\n                     edgecolor='#ab5058', alpha=1):\n\n    boxes = []\n    step = (b - a) \/ n\n    \n    for i in range(n):\n        x = a + i * step\n        rect = Rectangle((x, 0), step, f(x+0.5*step))\n        boxes.append(rect)\n\n    pc = PatchCollection(boxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor)\n\n    ax.add_collection(pc)\n\nfig, ax = plt.subplots(1, figsize = (10,6))\n\nax.plot(line_x, line_y)\nplt.grid(True, which='both')\nmake_boxes(ax, -2, 2, pdf, 10)\nplt.show()","9bca08e6":"def make_boxes(ax, a, b, f, n, facecolor='#ffa6aeaa',\n                     edgecolor='#ab5058', alpha=1):\n\n    fill_boxes = []\n    empty_boxes = []\n    step = (b - a) \/ n\n    \n    r = 0.75\n    \n    for i in range(n):\n        x = a + i * step\n        y = f(x+0.5*step)\n        if r > y*step:\n            rect = Rectangle((x, 0), step, y)\n            fill_boxes.append(rect)\n        elif r > 0:\n            rect = Rectangle((x, 0), r\/y, y)\n            fill_boxes.append(rect)\n            sample = x+r\/y\n            rect = Rectangle((x+r\/y, 0), step-r\/y, y)\n            empty_boxes.append(rect)\n        else:\n            rect = Rectangle((x, 0), step, y)\n            empty_boxes.append(rect)\n   \n        r -= y*step\n\n    ax.add_collection(PatchCollection(fill_boxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor))\n    ax.add_collection(PatchCollection(empty_boxes, facecolor=\"#ffe1e4\", alpha=alpha,\n                         edgecolor=edgecolor))\n    return sample\n    \nfig, ax = plt.subplots(1, figsize = (10,6))\n\nax.plot(line_x, line_y)\nplt.grid(True, which='both')\nsample = make_boxes(ax, -2, 2, pdf, 10)\n\nvar_y = np.linspace(-0.1,0.6,10)\nvar_x = np.array([sample for y in var_y])\nax.plot(var_x, var_y, color='g')\n\nplt.show()","f77fa7b3":"samples = [sample_pdf(-2, 2, pdf, 100) for _ in range(10000)]\n\nplt.figure(figsize = (10,6)) \nplt.hist(samples, bins=50)\nplt.show()","6ed038c1":"We can split the area under the curve into approximate rectangles ","1b673787":"When calculating the last rectangle, it calculates how much of the area of that rectangle can be filled, then finds the width of that area and add it to the sum of width of previous rectangles. That's it, the x location of the green line is the sampled random variable!\n\nWe can give it a run and see if it matches the distribution.","58646678":"Now to sample a random number from it, we have to first generate a random number from a uniform distribution, which is trivial. Say we got 0.75, we would have to find the x location where the area under the curve from -2 to x = 0.75, and the x value is your random variable!\n\nIt looks something like this:","0d2fdb41":"Say you have some probability distribution function, mine looks like this, where area under curve = 1:","558becb3":"So I was playing around with some specific distributions and wanted to generate some random numbers from it, but I didn't find anything on StackOverflow so I had to make one myself, inspired by Rectangular Approximation Method for Integrals!\n\nHere's the function if you are in a hurry, a and b are lower and upper range of the PDF (can't be infinite!), f is the PDF function, and n is the resolution of the approximation, higher requires more compute but more accurate.\n"}}