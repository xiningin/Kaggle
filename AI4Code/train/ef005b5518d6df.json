{"cell_type":{"c31909e1":"code","b3a58a3b":"code","8c816208":"code","8accfe4e":"code","f9476f0f":"code","c614120b":"markdown","54aa1acd":"markdown","94fae388":"markdown","807c9303":"markdown","a551520e":"markdown","e336be0e":"markdown"},"source":{"c31909e1":"%%time\n# In order for Kaggle to time our program, we need to add %%time to the start of our program\ndef sieve(list_of_numbers):\n    is_prime = [True for every_number in list_of_numbers]\n    for index in range(len(list_of_numbers)):\n        for test_index in range(0, index):\n            if list_of_numbers[index] % list_of_numbers[test_index] == 0:\n                is_prime[index] = False\n    return [list_of_numbers[i] for i in range(len(list_of_numbers)) if is_prime[i]]\n\nprint(sieve(range(2, 5001)))","b3a58a3b":"%%time\ndef sieve(list_of_numbers):\n    is_prime = [True for every_number in list_of_numbers]\n    for index in range(len(list_of_numbers)):\n        for test_index in range(index+1, len(list_of_numbers)):\n            if list_of_numbers[test_index] % list_of_numbers[index] == 0:\n                is_prime[test_index] = False\n    return [list_of_numbers[i] for i in range(len(list_of_numbers)) if is_prime[i]]\n\nprint(sieve(range(2, 5001)))","8c816208":"%%time\ndef sieve(list_of_numbers):\n    is_prime = [True for every_number in list_of_numbers]\n    for index in range(len(list_of_numbers)):\n        if is_prime[index] is False:\n            # Skip composite numbers\n            continue\n        for test_index in range(index+1, len(list_of_numbers)):\n            if list_of_numbers[test_index] % list_of_numbers[index] == 0:\n                is_prime[test_index] = False\n    return [list_of_numbers[i] for i in range(len(list_of_numbers)) if is_prime[i]]\n\nprint(sieve(range(2, 5001)))","8accfe4e":"%%time\ndef sieve(list_of_numbers):\n    is_prime = [True for every_number in list_of_numbers]\n    for index in range(len(list_of_numbers)):\n        if (list_of_numbers[index] ** 2) > list_of_numbers[-1]:\n            break\n        if is_prime[index] is False:\n            # Skip composite numbers\n            continue\n        for test_index in range(index+1, len(list_of_numbers)):\n            if list_of_numbers[test_index] % list_of_numbers[index] == 0:\n                is_prime[test_index] = False\n    return [list_of_numbers[i] for i in range(len(list_of_numbers)) if is_prime[i]]\n\nprint(sieve(range(2, 5001)))","f9476f0f":"%%time\ndef sieve(list_of_numbers):\n    is_prime = [True for every_number in list_of_numbers]\n    for index in range(len(list_of_numbers)):\n        if (list_of_numbers[index] ** 2) > list_of_numbers[-1]:\n            break\n        if is_prime[index] is False:\n            # Skip composite numbers\n            continue\n        index_squared = index ** 2\n        for test_index in range(index+1, len(list_of_numbers)):\n            if test_index < index_squared:\n                continue\n            if list_of_numbers[test_index] % list_of_numbers[index] == 0:\n                is_prime[test_index] = False\n    return [list_of_numbers[i] for i in range(len(list_of_numbers)) if is_prime[i]]\n\nprint(sieve(range(2, 5001)))","c614120b":"# Trial Division Method\nUsing trial division, a program goes through each of the numbers it's given and, for each number, tests if it is prime. This is probably the easiest method to use, but it's incredibly slow for larger inputs.\n```\nset \"numbers\" to every number from 2 to 5000\nfor every number \"j\" in \"numbers\":\n    mark j as prime (all composites will be marked as composite later)\n    for every number \"k\" smaller than \"j\":\n        if j is a multiple of k:\n            mark j as composite\n```","54aa1acd":"# Prime sieves\n## What is a prime sieve?\n### First, some vocabulary:\n- prime: an integer that cannot be formed by multiplying two *smaller* integers.\n- composite: an integer that is not prime.\n- prime sieve: a program that takes a list of numbers and outputs only the prime numbers. ","94fae388":"# Basic optimization\nWe only need to mark off multiples of primes, because every composite number is already taken care of by a prime number.\n*In our new implementation, we skip testing by numbers that are composite.*\n```\nset \"numbers\" to every number from 2 to 5000\nfor every number \"j\" in \"numbers\":\n    if \"j\" is composite:\n        skip j\n    for every number greater than \"j\":\n        if that number is a multiple of \"j\":\n            mark that number as composite\nthen, print every number not marked as composite\n```","807c9303":"# Simple Sieve\nInstead of doing a slow operation for every single number, our next attempt marks off multiples of numbers. Here's how it's going to work: we start with two. Then, we mark every multiple of two as composite. Then every multiple of 3. Then 4. And so on.\nSeem a bit boring? *That's because it is.* This method will perform about the same as our first try, but will allow for better optimizations later. It's the beginning of a prime sieve called the Sieve of Eratosthenes. But it's almost as simple as the first. Here's our pseudocode:\n```\nset \"numbers\" to every number from 2 to 5000\nfor every number \"j\" in \"numbers\":\n    for every number greater than \"j\":\n        if that number is a multiple of \"j\":\n            mark that number as composite\nthen, print every number not marked as composite\n```","a551520e":"# Language matters\nFor the purposes of *slight* readability, all the code in this presentation has been written in [Python](python.org). But Python is a slow language. [Here](https:\/\/gist.github.com\/SimonBranch\/048e52274f91c40439eb78e52fb3391a) is an implementation of the final code in Go, which achieves the same result in 1 millisecond. This speedup comes simply from porting the code to a different language\u2014the code is exactly the same.","e336be0e":"# Extra optimization\nNotice that any composite number below 100 must have at least one prime factor below ten (which is the square root of 100). If *n* has no prime factors below 10, *n* must be above 100\u2014it must have at least two prime factors, which are both bigger than 10. So, when the two prime factors are multiplied together, the result must be above 100. Our next version only marks multiples of prime numbers below the square root of 5000.\n```\nset \"numbers\" to every number from 2 to 5000\nfor every number \"j\" in \"numbers\":\n    if \"j\" is bigger than the square root of 5000:\n        break out of the loop\n    if \"j\" is composite:\n        continue\n    for every number greater than \"j\":\n        if that number is a multiple of \"j\":\n            mark that number as composite\nthen, print every number not marked as composite\n```"}}