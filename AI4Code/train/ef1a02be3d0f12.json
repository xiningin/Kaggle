{"cell_type":{"87b313a1":"code","a4ecc38d":"code","4b23ff2a":"code","6bfe7e8a":"code","d4539e66":"code","bf856fe3":"code","9dbc6847":"code","255b3b02":"code","0589dcf8":"code","fe61f883":"code","3ca96972":"code","7c07750c":"code","9ad08c87":"code","ea94f242":"code","222dee8b":"code","10391946":"code","eecfe3fd":"code","d5f1e2f6":"code","3f376df0":"code","d0de16b8":"code","9eae0094":"code","19fccf71":"code","d9f74961":"code","eb270b0a":"markdown","752ad7be":"markdown","0b3bb592":"markdown","c911bce6":"markdown","49fa6c69":"markdown","aa8fa3e7":"markdown","9a3a6b87":"markdown","1e72653f":"markdown","747f8be9":"markdown","a9a4e02c":"markdown","3bace2bd":"markdown","33bc8721":"markdown","c421cea8":"markdown","27bd3ee6":"markdown","d874d121":"markdown","51ee988a":"markdown","ad696095":"markdown","086d212a":"markdown"},"source":{"87b313a1":"# import necessary libraries\nimport keras\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom sklearn.model_selection import train_test_split\n\nimport matplotlib.pyplot as plt","a4ecc38d":"#import digit dataset as train and test set\ntrain=pd.read_csv(\"\/kaggle\/input\/digit-recognizer\/train.csv\")\ntest=pd.read_csv(\"\/kaggle\/input\/digit-recognizer\/test.csv\")","4b23ff2a":"# to see first 5 rows \ntrain.head()","6bfe7e8a":"# seperate target feature as y_train and define x_train set without target feature.\ny_train = train.iloc[:,0:1]\nx_train = train.iloc[:,1:]\n","d4539e66":"# to see shape of the datasets, 1st values in brackets are sample counts and 2nd values are pixels counts\nx_train.shape, y_train.shape, test.shape","bf856fe3":"# View number of dimensions of tensor\n\nprint(x_train.ndim)","9dbc6847":"# View the dimension of tensor\n\nprint(x_train.shape)","255b3b02":"x_train.info(), test.info()","0589dcf8":"# scale the input values to type float32\n\nx_train = x_train.astype('float32')\ntest = test.astype('float32')","fe61f883":"# scale the input values within the interval [0, 1]\n\nx_train \/= 255\ntest \/= 255","3ca96972":"from keras.utils import to_categorical","7c07750c":"y_train = to_categorical(y_train, num_classes=10)","9ad08c87":"y_train[0]","ea94f242":"# seperate dataset with train_test_split\nx_train, x_test, y_train, y_test = train_test_split(x_train, y_train, test_size=0.33, random_state=42)","222dee8b":"from keras.models import Sequential\nfrom keras.layers.core import Dense, Activation\n\n\nmodel = Sequential()\nmodel.add(Dense(100, activation='sigmoid', input_shape=(784,)))\nmodel.add(Dense(90, activation='relu'))\nmodel.add(Dense(80, activation='tanh'))\nmodel.add(Dense(70, activation='sigmoid'))\nmodel.add(Dense(60, activation='relu'))\nmodel.add(Dense(50, activation='tanh'))\nmodel.add(Dense(10, activation='softmax'))\n","10391946":"model.summary()","eecfe3fd":"#sgd = tf.keras.optimizers.SGD(lr=0.001, decay=1e-6, momentum=0.9, nesterov=True)\n\nmodel.compile(loss=\"categorical_crossentropy\",\n              optimizer= \"RMSprop\",\n              metrics = ['accuracy'], run_eagerly=False)","d5f1e2f6":"model.fit(x_train, y_train, batch_size=256, epochs=200)","3f376df0":"test_loss, test_acc = model.evaluate(x_test, y_test)","d0de16b8":"print('Test accuracy:', round(test_acc,4))","9eae0094":"# Plot confusion matrix \n# Note: This code snippet for confusion-matrix is taken directly from the SKLEARN website.\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=30)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('Actual class')\n    plt.xlabel('Predicted class')","19fccf71":"from collections import Counter\nfrom sklearn.metrics import confusion_matrix\nimport itertools\n\n# Predict the values from the validation dataset\nY_pred = model.predict(x_test)\n# Convert predictions classes to one hot vectors \nY_pred_classes = np.argmax(Y_pred, axis = 1) \n# Convert validation observations to one hot vectors\nY_true = np.argmax(y_test, axis = 1) \n# compute the confusion matrix\nconfusion_mtx = confusion_matrix(Y_true, Y_pred_classes) \n# plot the confusion matrix\nplot_confusion_matrix(confusion_mtx, classes = range(10))","d9f74961":"\ntest_result = model.predict(test)\n\n\nresults = np.argmax(test_result,axis = 1) \n\nresults = pd.Series(results,name=\"Label\")\n\n\nsubmission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)\n\nsubmission.to_csv(\"submission_best.csv\",index=False)","eb270b0a":"##  Confusion-matrix \n\n\n\n\n In Machine Learning, a very useful tool to evaluate the model is **Confusion Matrix**.\n\n It is a table with rows and columns that count the predictions in comparison with the real values. \n\n This table can be used to understand the performance of the model. \n\n It is very useful to show explicitly when one class is confused with another. \n\n A confusion matrix for a binary classifier is shown below:-","752ad7be":"We need to see data type of the dataset. Keras needs Dataset as float","0b3bb592":"## Seperate Train Set\nSeperating the train set as train and validation set. \n\nWe will train dataset firstly and then will test it with a validation set.\n","c911bce6":"## ANN Digit Recognizer Dataset with KERAS","49fa6c69":"- To see the effect of the transformation we can see the values before and after applying `to_categorical`:","aa8fa3e7":"### First layer\n\n We explicitly express in the `input_shape` argument of the first layer what the input data is like: a tensor that indicates that we have 784 features of the model.\n\n The tensor is being defined is (None, 784,).","9a3a6b87":"## Sequential class in Keras \n\n\n The main data structure in Keras is the Sequential class, which allows the creation of a basic neural network.\n\n The Sequential class of the Keras library is a wrapper for the sequential neural network model that Keras offers and can be created in the following way:\n\n\n`from keras.models import Sequential`\n\n`model = Sequential()`\n\n The model in Keras is considered as a sequence of layers and each of them gradually \u201cdistills\u201d the input data to obtain the desired output. \n\n In Keras, we can add the required types of layers through the **.add()** method.","1e72653f":" Here, the neural network has been defined as a sequence of 7 layers that are densely connected (or fully connected).\n\n It means that all the neurons in each layer are connected to all the neurons in the next layer.","747f8be9":" Now, our dataset is ready to be fed in the neural network.\n We will program it in Keras in the following section.","a9a4e02c":"We can obtain the number of axes and dimensions of the tensor `train_images` from our previous example as follows:","3bace2bd":"## Defining the model \n\n We can program the model in Keras to recognize the images of digits in the following way:","33bc8721":"Normalizing the data","c421cea8":"![Confusion-Matrix for a Binary Classifier](https:\/\/miro.medium.com\/max\/807\/1*UIFVpCx4h1yW1WqRS-2C2w.png)","27bd3ee6":"### Evaluate model with evaluate() method \n\n\n Our model has been compiled and trained.\n\n Now, we come to the final step.\n\n The model can now be evaluated with the **evaluate()** method as follows:\n\n","d874d121":"We will work on this dataset to recognize digits 0-9","51ee988a":" **True Positives (TP)**, **True Negatives (TN)**, **False Positives (FP)** and **False Negatives (FN)** are the four different possible outcomes of a single prediction for a two-class case with classes \u201c1\u201d (\u201cpositive\u201d) and \u201c0\u201d (\u201cnegative\u201d).\n\n A **False Positive (FP)** is when the outcome is incorrectly classified as positive, when it is in fact negative. A **False Negative (FN)** is when the outcome is incorrectly classified as negative when it is in fact positive. **True Positives (TP)** and **True Negatives (TN)** are obviously correct classifications.\n\n With this confusion matrix, the accuracy can be calculated by adding the values of the diagonal and dividing them by the total:\n\n**Accuracy = (TP + TN) \/ (TP + FP + FN + TN)**\n\n\n There is another metric called **Sensitivity (or recall)** that tells us how well the model avoids false negatives:\n\n**Sensitivity = TP \/ (TP + FN)**\n\n\n From the confusion matrix, several other metrics can be obtained.\n\n But in this case, there are 10 classes instead of 2. So, in this case, Scikit-learn package can be used to evaluate the quality of the model by calculating the confusion matrix.\n\n The following code can be used to generate the confusion-matrix:","ad696095":"##  Accuracy of the model \n\n\n\n Now, I will check the accuracy of the model.\n\n We can print the accuracy as follows:-\n\n","086d212a":"## Model Summary \n\n\n\n Keras provides a very useful method to check the architecture of the model.\n\n It is the **.summary()** method.\n\n We can use this **.summary()** method as follows:"}}