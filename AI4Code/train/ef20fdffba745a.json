{"cell_type":{"c75364fd":"code","d2a3fc8c":"code","2944c841":"code","2a230864":"code","50f5c5eb":"code","757b094b":"code","0f132a28":"code","b1b71db1":"code","a9f27c6f":"code","f8438836":"code","2877c4cd":"code","971f0a69":"code","ec55a782":"code","a2657d87":"code","2ef7fba1":"code","160a6de2":"code","45c75273":"code","7f1864f9":"code","0d4d01bf":"code","ec67f396":"code","c021ab99":"code","fe7eae4d":"code","61456582":"code","b9bce16c":"code","a1d87423":"code","2a45cb09":"code","fd832d86":"code","ccb5b3ef":"code","c58cdf00":"code","4fb5c546":"code","e0a72390":"code","17e01eab":"code","55f05ed8":"code","fbb354c8":"code","5973a323":"code","680cacdf":"code","a712ec3e":"code","a319d635":"code","b3dd55c6":"code","a5ecc492":"code","71aea461":"code","af15ce5a":"code","a24cbffc":"code","aa79c132":"code","13daaf76":"code","f1a709fb":"code","1b093c7c":"code","68830402":"code","9da3ac94":"code","cb3b0b15":"code","47e27e50":"code","0d4a3f75":"code","0f752a76":"markdown","6580a033":"markdown","b9b50a53":"markdown","ef813965":"markdown","91a16b1c":"markdown","2bdb48e4":"markdown","006e6e5c":"markdown","8560b462":"markdown","3f245052":"markdown","e670fa39":"markdown","470f67b8":"markdown","43f2b06c":"markdown","8a532982":"markdown"},"source":{"c75364fd":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\n\n# To show all observations and variables:\npd.set_option('display.max_columns', None);\npd.set_option('display.max_rows', None);\nimport matplotlib.pyplot as plt\n\n# Determining how many decimals will display after commas:\npd.set_option('display.float_format', lambda x: '%.2f' % x)\nimport matplotlib.pyplot as plt","d2a3fc8c":"# Let's read our data set\n\ndf_2010_2011 = pd.read_excel(\"..\/input\/online-retail-ii-data-set-from-ml-repository\/online_retail_II.xlsx\", sheet_name = \"Year 2010-2011\")","2944c841":"# We copy dataset to avoid damaging the data set and we will work on the copy\n\ndf = df_2010_2011.copy()","2a230864":"# Let's check, is there any problem with the copy we will work on ?\n\ndf.head()","50f5c5eb":"# Number of observation\ndf.shape   ","757b094b":"# Last 5 observation\ndf.tail()","0f132a28":"# Let's use a few basic functions to get information about variables.\ndf.info()","b1b71db1":"# Let's ask if there is any missing data anywhere in the data set. There is if it turns True.\n\ndf.isnull().values.any()","a9f27c6f":"#  It shows null values\n\ndf.isnull().sum()","f8438836":"df.head()","2877c4cd":"# Let's look at the variables in the data set\ndf.columns","971f0a69":"# What is the number of unique items? we can look this way\ndf[\"Description\"].nunique()\n\n# If we write this way, it will be easier to read the output\nprint(\"Description : \", df[\"Description\"].nunique())\nprint(\"StockCode : \", df[\"StockCode\"].nunique()) \nprint(\"Invoice : \", df[\"Invoice\"].nunique())","ec55a782":"df[\"Description\"].value_counts().head()","a2657d87":"# Which is the most ordered product?\ndf.groupby(\"Description\").agg({\"Quantity\":\"sum\"}).head() ","2ef7fba1":"clean_df = df.dropna()","160a6de2":"clean_df.head()","45c75273":"clean_df.isnull().values.any()","7f1864f9":"# Missing value addition function, but since we do not have missing values anyway, all will be shown as zero\n\nclean_df.isnull().sum()","0d4d01bf":"# The values starting with C in the invoice variable represent the returned ones\n# It will be useful to remove them because we will collect the values in the invoices as sales.\n# ~ this sign means \"not\" and \"the opposite\".\n\nclean_df = clean_df[~clean_df[\"Invoice\"].str.contains(\"C\", na = False)]","ec67f396":"# Let's see how many observation units are left in the data set after this process.\n\nclean_df.shape","c021ab99":"# We will need the maximum amount of revenue for FRM analysis so we create this variable.\n\nclean_df[\"TotalPrice\"] = clean_df[\"Quantity\"] + clean_df[\"Price\"]","fe7eae4d":"# Let's look at the old and new state of our dataset\ndf.describe().T\n# old version","61456582":"# new version\nclean_df.describe().T","b9bce16c":"import datetime as dt","a1d87423":"clean_df.columns","2a45cb09":"clean_df[\"InvoiceDate\"].max()","fd832d86":"# I create the next day from the last day as the \"last day\" in order to avoid the problem of not being able to select last day's transactions.\n\nlast_time = dt.datetime(2011, 12, 10)\n\n# Let's see if it created\n\nlast_time","ccb5b3ef":"# Type of \"Customer ID\" is float, let's convert this to an integer\n\nclean_df[\"Customer ID\"]= clean_df[\"Customer ID\"].astype(int)\n\nclean_df.head()","c58cdf00":"# Let's create a temporary DataFrame and calculate how many days it takes customers from the last purchase date to the last date.\n\ntemp_df = (last_time - clean_df.groupby(\"Customer ID\").agg({\"InvoiceDate\":\"max\"}))\ntemp_df.head()","4fb5c546":"# Let's change the name of the \"InvoiceDate\" variable to \"Recency\" because it shows us the value of \"Recency\" now.\ntemp_df.rename(columns = {\"InvoiceDate\":\"Recency\"}, inplace = True)\ntemp_df.head()","e0a72390":"# Recency values above are nice, but when dealing with them, day values are enough for us. Let's eliminate the Hour and Minute values.\n# Let's write our own function, access each element of the Recency variable in temp_df and get the days of those.\n# let me create a DataFrame named recency_df to keep these values\nrecency_df = temp_df[\"Recency\"].apply(lambda x: x.days)\n\nrecency_df.head()","17e01eab":"# calculate how many bills a user has, that is how many times they shop\n# Let's create a new df, group it according to the Customer ID, and do it according to the unique values of the \"InvoiceDate\" variable.\n# by the way, for example, if \"unique\" = (0,1,2,3) then \"nunique\" = (4).\nfreq_df = clean_df.groupby(\"Customer ID\").agg({\"InvoiceDate\":\"nunique\"})\n\nfreq_df.rename(columns={\"InvoiceDate\": \"Frequency\"}, inplace = True)\n\nfreq_df.head()\n\n","55f05ed8":"# Let's do it even if we don't use it much\n# Let's groupby according to the customers and save the total purchases of each customer (how many items they bought) in a new DataFrame and see.\n\nmonetary_df = clean_df.groupby(\"Customer ID\").agg({\"TotalPrice\":\"sum\"})\n\nmonetary_df.rename(columns={\"TotalPrice\":\"Monetary\"}, inplace=True)\n\nmonetary_df.head()","fbb354c8":"# Let's check if the 3 DataFrames we created are equal. because they are all customer-based so their numbers must be equal\n\nprint(recency_df.shape, freq_df.shape, monetary_df.shape)","5973a323":"# Let's combine these 3 DataFrames in one DataFrame\n# We say  pd.concat, so merge. Okay, what are you going to put together, give it to me as a list. okay\n# So how do I merge? Combine by column. Then write axis = 1 so that the columns come together like this\nrfm = pd.concat([recency_df, freq_df, monetary_df], axis=1)\n\nrfm.head()","680cacdf":"# Let's create a new variable and call it \"RecencyScore\"\n\n# here is a ranking within itself.\n# We say split into 5, it says give the labels in descending order\n# So if the Recency value is high, give me a value of 1.\n# or give the value 5 if it's 0 or 1\n\nrfm[\"RecencyScore\"] = pd.qcut(rfm[\"Recency\"], 5, labels = [5, 4, 3, 2, 1])\n\nrfm.head()","a712ec3e":"# hey pandas can you get me the \"qcut\" function from pandas? Yes. So what does this function do?\n# \"qcut\" function is used to divide according to quartiles. and the function says I have some expectations from you\n# function says that my first argument must be the variable you want to \"cut\".\n# Give the variable we want to \"cut\", the Recency variable in rfm.\n# then the function says, how many would you divide this value? And \u0131 say 5.\n# You give me a label list and i'll label them according to this label list. ok, i am giving it as a list\n# Well, i want it to be tagged with labels after it is over\n# will give the first value in the label list to the first value it finds when sorted from small to large\n# Our perception of size and size in \"recency\" is different from others\n# The value of 1 in the \"recency\" variable means, \"the customer purchased a day ago, did something good, a 5 points to you\"\n# High values in \"frequency\" and \"monetary\" variables are 5 points for us.\nrfm[\"RecencyScore\"] = pd.qcut(rfm[\"Recency\"], 5, labels = [5, 4 , 3, 2, 1])\n\nrfm[\"FrequencyScore\"]= pd.qcut(rfm[\"Frequency\"].rank(method=\"first\"),5, labels=[1,2,3,4,5])\n\nrfm[\"MonetaryScore\"] = pd.qcut(rfm['Monetary'], 5, labels = [1, 2, 3, 4, 5])\n\nrfm.head()","a319d635":"# rfm scores converted to categorical values and added to df\nrfm[\"RFM_SCORE\"] = (rfm['RecencyScore'].astype(str) + \n                    rfm['FrequencyScore'].astype(str) + \n                    rfm['MonetaryScore'].astype(str))\n\nrfm.head()","b3dd55c6":"# Suppose we want to access the \"Champions\" group. What should we do ?\n# We say choose from your \"rfm df\"\n# rfm []\n# I want to set condition. It says enter a variable for condition and set condition.\n# rfm [rfm [\"RFM_SCORE\"]]\n# ok what's your condition? I say 555. I know you are the \"champion\" class 555\n\nrfm[rfm[\"RFM_SCORE\"]==555].head()\n# Here \"champions\" came ","a5ecc492":"rfm.describe().T","71aea461":"# What do we do if we want to go to \"hibernating\" group?\n\nrfm[rfm[\"RFM_SCORE\"]==111].head()  #  hibernating\n","af15ce5a":"# RFM map was created using Regular Expressions.\n# denotes the first bracket R, the second to F.\n# capturing the mapping process is the 'regex'.\n# We created a dictionary called seg_map, in the form of key-value.\nseg_map = {\n    r'[1-2][1-2]': 'Hibernating',\n    r'[1-2][3-4]': 'At Risk',\n    r'[1-2]5': 'Can\\'t Loose',\n    r'3[1-2]': 'About to Sleep',\n    r'33': 'Need Attention',\n    r'[3-4][4-5]': 'Loyal Customers',\n    r'41': 'Promising',\n    r'51': 'New Customers',\n    r'[4-5][2-3]': 'Potential Loyalists',\n    r'5[4-5]': 'Champions'\n}","a24cbffc":"# Inside RFM \"We created a segment and made this variable by combining 2 strings\"\n\nrfm['Segment'] = rfm['RecencyScore'].astype(str) + rfm['FrequencyScore'].astype(str)\n\nrfm.head()","aa79c132":"# I will apply the regex matches (key-value matches) we wrote above to the Segment here.\n# I say replace. replace a string method.\n# When asked what to change according to, we send the regex map (seg_map)\n# We said rename the values inside the segment. What should I name according to\n\nrfm['Segment'] = rfm['Segment'].replace(seg_map, regex=True)\n\nrfm.head()","13daaf76":"rfm[[\"Segment\",\"Recency\",\"Frequency\", \"Monetary\"]].groupby(\"Segment\").agg([\"mean\",\"median\",\"count\"])\n\n","f1a709fb":"# total number of customers\nrfm.shape[0]   ","1b093c7c":"rfm[rfm[\"Segment\"] == \"Need Attention\"].head()","68830402":"# list customer numbers of new customers\nrfm[rfm[\"Segment\"] == \"New Customers\"].index","9da3ac94":"# for New Customers ;\nnew_customers = pd.DataFrame()\n\nnew_customers[\"NewCustomerID\"] = rfm[rfm[\"Segment\"] == \"New Customers\"].index\n\nnew_customers.to_csv(\"new_customers.csv\")  # df'i kaydet \n\nnew_customers.to_csv('new_customers.csv', index=False)\n\nnew_customers.head()","cb3b0b15":"# For Loyal Customers \n\nloyal_customers = pd.DataFrame()\n\nloyal_customers[\"LoyalCustomersID\"] = rfm[rfm[\"Segment\"] == \"Loyal Customers\"].index\n\nloyal_customers.to_csv('loyal_customers.csv', index=False)\n\nloyal_customers.head()\n\n","47e27e50":"# For At Risk\n\nat_risk = pd.DataFrame()\n\nat_risk[\"AtRiskID\"] = rfm[rfm[\"Segment\"] == \"At Risk\"].index\n\nat_risk.to_csv('at_risk.csv', index=False)\n\nat_risk.head()","0d4a3f75":"rfm[[\"Segment\",\"Recency\",\"Frequency\", \"Monetary\"]].groupby(\"Segment\").agg([\"mean\",\"median\",\"count\"])","0f752a76":"##### Table","6580a033":"##### Currently we have our RFM metrics. Now our goal is to convert these RFM metrics to SCORES.\n##### because when I look at any part of the data, I can't see if the value is big or small, so we will generate scores.","b9b50a53":"> ### <font color='blue'> ***RFM ANALYSIS***<\/font>","ef813965":"\n> ### <font color='blue'> ***RFM Analysis Result Recommendations***<\/font>\n\n***The table is located just below the comments to make it easier to understand the comments.***","91a16b1c":">  # <font color='purple'>*For E-Commerce Company Customer Segmentation and Determining of Marketing Strategies*<\/font> ","2bdb48e4":"> ### <font color='darkred'> ***Loyal Customers;***<\/font>\n\n***The table is located just below the comments to make it easier to understand the comments.***\n\n- There are 820 customers\n\n- Average recency values \u200b\u200b29.\n\n- Shopping frequency 5.\n\n- A group with high income.\n\n- It can be made one of the priority groups in dissatisfaction with the products so that they are not lost.\n\n- They are in the active and high income group. Therefore, on the basis of the popular products they are interested in, they may try to move closer to the upper group with significant discounts on expensive products.\n\n- With the discounts on popular products, this group can keep it more active, that is, it can be effective in increasing the frequency value.\n\n\n> ### <font color='darkred'> ***At Risk;***<\/font>\n\n- There are 594 customers.\n\n- It is a large group that does not earn high income.\n\n-Therefore, time should be spent on them and their potential should be utilized.\n\n- Product expectations, price expectations and, if any, complaints can be heard with a short survey in return for a discount or gift. According to the results of the answers, this group can be divided into groups within itself and applied with different marketing tactics (short-term plan) and the results can be compared in detail and the resulting tactic can be transformed into the marketing strategy (long-term plan) of this group.\n\n\n> ### <font color='darkred'> ***New Customers;***<\/font>\n\n- Understanding this small group will help us to create great value and income for our company.\n\n- There are 42 customers.\n\n- Their frequency value is 1 because they are new, so it is high but it doesn't so much sence.\n\n- When compared to general, it looks like a small and almost ineffective group.\n\n- What makes this group valuable is that it hosts all those customers who create value for us, and the customer candidates we were able to carry until the champions with our directions. It should not be forgotten that new customers are what shape the future of the company and ensure its continuity.\n\n- Starting with what brought them to us, we must discover the factors that keep them with us.\n\n- Advertising is among the largest expense items of a company. What brings them to us can be an important factor in determining our advertising strategies.","006e6e5c":"> ### <font color='blue'> ***Frequency***<\/font>","8560b462":"\n> #####  <font color='darkred'> ****Let's use a few basic functions to get information about variables.****<\/font> ","3f245052":"![shutterstock_263091443-People-Pie-wider-e1499788074769.jpg](attachment:shutterstock_263091443-People-Pie-wider-e1499788074769.jpg)","e670fa39":"> ## <font color='darkred'> *Business Problem*<\/font> \n\n\n**An e-commerce company wants to segment its customers and determine marketing strategies according to these segments.**\n\n**For this, we will define the behavior of customers and create groups according to clustering in these behaviors.**\n\n**In other words, we will put those who display common behaviors in the same groups and we will try to develop sales and marketing techniques specific to these groups.**\n\n\n> ## <font color='darkblue'> *Data Set Story*<\/font> \n\n\nhttps:\/\/archive.ics.uci.edu\/ml\/datasets\/Online+Retail+II\n\n**The data set called Online Retail II includes the sales of a UK based online store between 01\/12\/2009 - 09\/12\/2011.**\n\n**This company sells souvenirs. It can think like promotional products.**\n\n**Most of their customers are wholesalers.**\n\n\n> ## <font color='darkgreen'> *Variables:*<\/font> \n\n\n- **InvoiceNo: Invoice number. Unique number for each transaction, namely the invoice. If this code starts with C, it indicates that the transaction has been canceled.**\n- **StockCode: Product code. Unique number for each product.**\n- **Description: Product name**\n- **Quantity: Number of products. Shows how many products in the invoices have been sold.**\n- **InvoiceDate: Invoice date and time.**\n- **UnitPrice: Product price (sterling)**\n- **CustomerID: Unique customer number**\n- **Country: Country name. The country where the customer lives.**","470f67b8":"##### we can read above as follows.\n\"About to Sleep\"\n    There are 353 customers in the segment.\n    The Recency value of this segment is 52.37. In other words, people in this segment have been absent for about 50 days.\n    These people bought on average 1.16 times\n    And these people left an average of 378.40 income in total.\n\n\"Need Attention\"\n    We have 184 people in this group.\n    These 184 persons average 51.27 days absent\n    Purchased an average of 2.45 units\n    They left us around 724.28\n    \nTHIS QUESTION CAME IN MY MIND. WHAT IS THE OVERALL RATE OF THESE PEOPLE? HOW DO WE CALCULATE THIS?\n    If we divide all of the \"count\" into \"shape\", then we get a proportional value.\n    \n    If we add the median, we can evaluate it with the mean and interpret more accurately. If the differences are small, it is good and realistic.\n    \n\"Champions\"\n    Champions have been absent for an average of 5 days. they are very active\n    There are 632 champions in total. I was wondering the ratio again. I NEED TO PUT RATIO HERE BUT IT WILL BE THE INDEX PROBLEM","43f2b06c":"> ### <font color='blue'> ***Recency***<\/font>","8a532982":"> ### <font color='blue'> ***Monetary***<\/font>"}}