{"cell_type":{"491191d8":"code","eaadff4a":"code","543902a8":"code","b770031d":"code","d0987285":"code","8637b71c":"code","6b992c52":"code","94d89076":"code","99088b0c":"code","71518e8f":"code","227a7b20":"code","6dee70d2":"code","8d3db185":"code","86a9f443":"code","22e6b851":"code","a987d13b":"code","fe0e8ba5":"code","a2bd78e9":"code","3a5d9d79":"code","cace0261":"code","fc52f816":"code","ea43e49a":"code","140a7038":"code","2e28be64":"code","cc9d89fd":"code","880ceb1c":"code","05d57568":"code","4096a752":"code","1e3d4a7f":"code","2b4184df":"code","244e1e71":"code","8b2ffb59":"code","b9398e78":"code","c1d3a17d":"code","53edc45d":"code","56ad877a":"code","fc693d4a":"code","aed1ddbe":"code","e13e109c":"code","83664569":"code","ebfec342":"code","2b5dbeee":"code","e1759cd0":"code","ddc23438":"code","cf3a2511":"code","c9a5922b":"code","8abef010":"code","de711ef3":"code","351bcea5":"code","4fa27665":"code","bc111dd0":"code","0833e9ad":"code","3e043ef4":"code","77910903":"code","6ba4adb9":"code","7cb94191":"code","372785a7":"code","5789b04b":"code","12f84498":"markdown","142bae2b":"markdown","1568ec5e":"markdown","3052f450":"markdown","5e208f9f":"markdown","75b27c13":"markdown","1e54f3c8":"markdown","5df1f361":"markdown","4b3e5bf3":"markdown","9b1a2237":"markdown","cd7eb090":"markdown","410f9558":"markdown","6fae349f":"markdown","da0494d2":"markdown","0ff24862":"markdown","d9a87e3d":"markdown","1b56a3a6":"markdown","99b237a1":"markdown","3eea3f6c":"markdown","61530551":"markdown","e6d400fc":"markdown","0075ea28":"markdown","1f54ae86":"markdown","d7608368":"markdown","da832be9":"markdown","0d26f5a4":"markdown","485cc73a":"markdown","8e528903":"markdown","ab7ce4fb":"markdown","f3644be7":"markdown","d2660bc6":"markdown","05f9245a":"markdown","681f8c08":"markdown","76fca4fc":"markdown","ae668799":"markdown","ea4e268b":"markdown","4f531994":"markdown","046e1d52":"markdown","26cf5e78":"markdown","5fb5a644":"markdown","c70b62ab":"markdown","8bf7d768":"markdown","f60f125b":"markdown","78372d4b":"markdown","1c82a9c8":"markdown","62a00f18":"markdown","d2071b05":"markdown","4c4ad4db":"markdown","d6737bbc":"markdown","9438fd68":"markdown","c146ab3c":"markdown","717e63ad":"markdown","da9b51d4":"markdown","25b17a5e":"markdown","5b5c886f":"markdown","1651f364":"markdown","91a41ef1":"markdown","1aadd108":"markdown","ac8ffb51":"markdown","cfccb3a1":"markdown","e3fc9ff3":"markdown","806dd1ad":"markdown","674e1dba":"markdown","f0ef90bf":"markdown","35c834d6":"markdown","f755435a":"markdown","02572010":"markdown","3c5a3465":"markdown","fe91cd02":"markdown","bfb528d8":"markdown","944323a1":"markdown","bddc1677":"markdown","e654c452":"markdown","bbe4275d":"markdown"},"source":{"491191d8":"import numpy as np \nimport pandas as pd \n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nimport os\nprint(os.listdir(\"..\/input\"))","eaadff4a":"# load data\ntrain_tran = pd.read_csv('..\/input\/train_transaction.csv', index_col='TransactionID')\ntrain_iden = pd.read_csv('..\/input\/train_identity.csv', index_col='TransactionID')\ntest_tran = pd.read_csv('..\/input\/test_transaction.csv', index_col='TransactionID')\ntest_iden = pd.read_csv('..\/input\/test_identity.csv', index_col='TransactionID')\nsample_sub = pd.read_csv('..\/input\/sample_submission.csv', index_col='TransactionID')","543902a8":"# Join training datasets\ntrain = train_tran.merge(train_iden, how='left',left_index=True, right_index=True)\ntrain.shape","b770031d":"train.head()","d0987285":"# Join testing datasets\ntest = test_tran.merge(test_iden, how='left',left_index=True, right_index=True)\ntest.shape","8637b71c":"test.head()","6b992c52":"# get target feature\ny_train = train['isFraud'].copy()\ny_train.shape","94d89076":"y_train.head()","99088b0c":"# get features matrices\nX_train = train.drop('isFraud', axis=1)\nX_test = test.copy()","71518e8f":"del test, train_tran, train_iden, test_tran, test_iden","227a7b20":"f, axes = plt.subplots(1, 3, figsize=(12, 4))\nisFraud = sns.countplot(x='isFraud', data=train, ax=axes[0])\nProductCD = sns.countplot(x='ProductCD', data=train, ax=axes[1])\nDeviceType = sns.countplot(x='DeviceType', data=train, ax=axes[2])\nplt.tight_layout()","6dee70d2":"# First create a dataframe with 2 cols: device info and the count by device\ngroup = pd.DataFrame()\ngroup['DeviceCount'] = train.groupby(['DeviceInfo'])['DeviceInfo'].count()\ngroup['DeviceInfo'] = group.index\n\n# There are too many Devices, so we will subset the top 20\ngroup_top = group.sort_values(by='DeviceCount',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"DeviceInfo\", y=\"DeviceCount\", data=group_top)\nxt = plt.xticks(rotation=60)","8d3db185":"# These cards are encoded as float64, and since there are too many values\n# we will plot this a distributions (x a# xis is just an id)\nf, axes = plt.subplots(4, 1, figsize=(25, 30))\n\nc1 = sns.distplot(train.card1,kde=False, ax=axes[0])\nc2 = sns.distplot(train.card2.dropna(),kde=False, ax=axes[1])\nc3 = sns.distplot(train.card3.dropna(),kde=False, ax=axes[2])\nc5 = sns.distplot(train.card5.dropna(),kde=False, ax=axes[3])","86a9f443":"# Plot IV: cards 4 and 6\nf, axes = plt.subplots(1, 2, figsize=(18, 6))\nsns.set(color_codes=True)\ncard4 = sns.countplot(x='card4', data=train, ax=axes[0])\ncard6 = sns.countplot(x='card6', data=train, ax=axes[1])","22e6b851":"# First create a dataframe with 2 cols: device info and the count by device\ngroup = pd.DataFrame()\ngroup['addr1Count'] = train.groupby(['addr1'])['addr1'].count()\ngroup['addr1'] = group.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top = group.sort_values(by='addr1Count',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"addr1\", y=\"addr1Count\", data=group_top)\nxt = plt.xticks(rotation=60)","a987d13b":"# First create a dataframe with 2 cols: device info and the count by device\ngroup = pd.DataFrame()\ngroup['addr2Count'] = train.groupby(['addr2'])['addr2'].count()\ngroup['addr2'] = group.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top = group.sort_values(by='addr2Count',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"addr2\", y=\"addr2Count\", data=group_top)\nxt = plt.xticks(rotation=60)","fe0e8ba5":"# Let's examine addr2 values\ntrain.addr2.value_counts().head(10)","a2bd78e9":"f, axes = plt.subplots(1, 2, figsize=(18, 12))\n\nsns.set(color_codes=True)\np_email = sns.countplot(y='P_emaildomain', data=train, ax=axes[0])\nr_email = sns.countplot(y='R_emaildomain', data=train, ax=axes[1])\nplt.tight_layout()","3a5d9d79":"print(train.addr1.nunique()) # 332 unique locations\nprint(train.addr2.nunique()) # 74 unique locations\nprint(train.P_emaildomain.nunique()) # 59 unique domains\nprint(train.R_emaildomain.nunique()) # 59 unique domains","cace0261":"# Plot VIII: M1 - M9 variables\nM1_loc = train.columns.get_loc(\"M1\")\nM9_loc = train.columns.get_loc(\"M9\")\ndf_m = train.iloc[:,M1_loc:M9_loc+1] #subset dataframe M1-M9\n\ncols = df_m.columns\nf, axes = plt.subplots(3, 3, figsize=(16, 12))\ncount = 0\nfor i in range(3): # rows loop\n    for j in range(3): # cols loop\n        mplot = sns.countplot(x=cols[count], data=df_m, ax=axes[i,j])\n        count += 1 # to loop over col-names\nplt.tight_layout()","fc52f816":"#Exploration id_12 - id_38\nid12_loc = train.columns.get_loc(\"id_12\")\nid38_loc = train.columns.get_loc(\"id_38\")\ndf_id = train.iloc[:,id12_loc:id38_loc+1] #subset dataframe id12-id19","ea43e49a":"df_id.dtypes","140a7038":"df_id.head(15)","2e28be64":"# First create a dataframe with 2 cols: device info and the count by device\ngroup = pd.DataFrame()\ngroup['id_30Count'] = df_id.groupby(['id_30'])['id_30'].count()\ngroup['id_30'] = group.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top = group.sort_values(by='id_30Count',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"id_30\", y=\"id_30Count\", data=group_top)\nxt = plt.xticks(rotation=60)","cc9d89fd":"# First create a dataframe with 2 cols: device info and the count by device\ngroup = pd.DataFrame()\ngroup['id_31Count'] = df_id.groupby(['id_31'])['id_31'].count()\ngroup['id_31'] = group.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top = group.sort_values(by='id_31Count',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"id_31\", y=\"id_31Count\", data=group_top)\nxt = plt.xticks(rotation=60)","880ceb1c":"# This variable is NOT listed as categorical, but clearly is\nplt.figure(figsize=(10, 5))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.countplot(x='ProductCD', data=train)","05d57568":"# Plot XII: TransactionDT, TransactionAmt\nf, axes = plt.subplots(2, 1, figsize=(15, 10))\n\ndt = sns.distplot(train.TransactionDT,kde=False, ax=axes[0])\nam = sns.distplot(train.TransactionAmt,kde=False, hist_kws={'log':True}, ax=axes[1])","4096a752":"C7_loc = train.columns.get_loc(\"C7\")\nC14_loc = train.columns.get_loc(\"C14\")\ndf_c = train.iloc[:,C7_loc:C14_loc+1] #subset dataframe\n\ncols = df_c.columns\n\nrows = 8\nf, axes = plt.subplots(rows, 1, figsize=(15, 20))\nfor i in range(rows):\n    dp = sns.distplot(df_c[cols[i]],kde=False, hist_kws={'log':True}, ax=axes[i])\nplt.tight_layout()","1e3d4a7f":"D1_loc = train.columns.get_loc(\"D1\")\nD15_loc = train.columns.get_loc(\"D15\")\ndf_d = train.iloc[:,D1_loc:D15_loc+1] #subset dataframe\n\ncols = df_d.columns\nrows = 15\nf, axes = plt.subplots(rows, 1, figsize=(15, 25))\nfor i in range(rows):\n    #d = sns.distplot(df_d[cols[i]].dropna(),kde=False, hist_kws={'log':True}, ax=axes[i])\n    d = sns.distplot(df_d[cols[i]].dropna(), ax=axes[i])\nplt.tight_layout()","2b4184df":"V1_loc = train.columns.get_loc(\"V1\")\nV339_loc = train.columns.get_loc(\"V339\")\ndf = train.iloc[:,V1_loc:V339_loc+1] #subset dataframe\n\ndf.head(20)","244e1e71":"id_01_loc = train.columns.get_loc(\"id_01\")\nid_11_loc = train.columns.get_loc(\"id_11\")\ndf = train.iloc[:,id_01_loc:id_11_loc+1] #subset dataframe\n\ncols = df.columns\nrows = 11\nf, axes = plt.subplots(rows, 1, figsize=(15, 25))\nfor i in range(rows):\n    #d = sns.distplot(df[cols[i]].dropna(),kde=False, ax=axes[i])\n    d = sns.distplot(df[cols[i]].dropna(), ax=axes[i])\nplt.tight_layout()","8b2ffb59":"id_01_loc = train.columns.get_loc(\"id_01\")\nid_11_loc = train.columns.get_loc(\"id_11\")\ndf = train.iloc[:,id_01_loc:id_11_loc+1] #subset dataframe\n\ncols = df.columns\nrows = 11\nf, axes = plt.subplots(rows, 1, figsize=(15, 25))\nfor i in range(rows):\n    d = sns.distplot(df[cols[i]].dropna(),kde=False, hist_kws={'log':True}, ax=axes[i])\nplt.tight_layout()","b9398e78":"f, axes = plt.subplots(1, 3, figsize=(15, 8))\nisFraud = sns.countplot(x='isFraud', data=train, ax=axes[0])\nProductCD = sns.countplot(x='ProductCD', hue=\"isFraud\", data=train, ax=axes[1])\nDeviceType = sns.countplot(x='DeviceType', hue=\"isFraud\", data=train, ax=axes[2])\nplt.tight_layout()","c1d3a17d":"f, axes = plt.subplots(1, 2, figsize=(15, 8))\n\nprops = train.groupby(\"ProductCD\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='bar', stacked='True', ax=axes[0])\n\nprops = train.groupby(\"DeviceType\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='bar', stacked='True', ax=axes[1])","53edc45d":"# Subset dataframe\nfraud = pd.DataFrame()\nis_fraud = train[train['isFraud']==1]\nfraud['DeviceCount'] = is_fraud.groupby(['DeviceInfo'])['DeviceInfo'].count()\nfraud['DeviceInfo'] = fraud.index\n\n# There are too many Devices, so we will subset the top 20\ngroup_top = fraud.sort_values(by='DeviceCount',ascending=False).head(20)\n\nplt.figure(figsize=(25, 10))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=\"DeviceInfo\", y=\"DeviceCount\", data=group_top)\n\nfont_size= {'size': 'x-large'}\nax.set_title(\"Fraud transactions by OS\", **font_size)\nxt = plt.xticks(rotation=60)","56ad877a":"# These cards are encoded as float64, and since there are too many values\n# we will plot this as distributions (x axis is just a class identifier)\n\nis_fraud = train[train['isFraud']==1]\nno_fraud = train[train['isFraud']==0]\n\nf, axes = plt.subplots(4, 1, figsize=(25, 30))\n\nd1 = sns.distplot(no_fraud.card1, color=\"fuchsia\", label=\"No fraud\", ax=axes[0])\nl1 = d1.legend()\nc1 = sns.distplot(is_fraud.card1, color=\"black\", label = \"Fraud\", ax=axes[0])\nl2 = c1.legend()\n\nd2 = sns.distplot(no_fraud.card2.dropna(), color=\"fuchsia\", label=\"No fraud\", ax=axes[1])\nl3 = d2.legend()\nc2 = sns.distplot(is_fraud.card2.dropna(), color=\"black\",  label = \"Fraud\", ax=axes[1])\nl4 = c2.legend()\n\nd3 = sns.distplot(no_fraud.card3.dropna(), color=\"fuchsia\", label=\"No fraud\", ax=axes[2])\nl5 = d3.legend()\nc3 = sns.distplot(is_fraud.card3.dropna(), color=\"black\",  label = \"Fraud\", ax=axes[2])\nl6 = c3.legend()\n\nd5 = sns.distplot(no_fraud.card5.dropna(), color=\"fuchsia\", label=\"No fraud\", ax=axes[3])\nl7 = d5.legend()\nc5 = sns.distplot(is_fraud.card5.dropna(), color=\"black\", label = \"Fraud\", ax=axes[3])\nl8 = c5.legend()","fc693d4a":"f, axes = plt.subplots(1, 2, figsize=(18, 10))\nsns.set(color_codes=True)\ncard4 = sns.countplot(x='card4', hue=\"isFraud\", data=train, ax=axes[0])\ncard6 = sns.countplot(x='card6', hue=\"isFraud\", data=train, ax=axes[1])","aed1ddbe":"f, axes = plt.subplots(1, 2, figsize=(18, 10))\n\nprops = train.groupby(\"card4\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='bar', stacked='True', ax=axes[0])\n\nprops = train.groupby(\"card6\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='bar', stacked='True', ax=axes[1])","e13e109c":"# Subset fraud dataset\naddr = 'addr1'\naddrC = 'addr1Count'\nfraud = pd.DataFrame()\nis_fraud = train[train['isFraud']==1]\nfraud[addrC] = is_fraud.groupby([addr])[addr].count()\nfraud[addr] = fraud.index\n\n# Subset NOT fraud dataset\nNOfraud = pd.DataFrame()\nno_fraud = train[train['isFraud']==0]\nNOfraud[addrC] = no_fraud.groupby([addr])[addr].count()\nNOfraud[addr] = NOfraud.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top_f = fraud.sort_values(by=addrC,ascending=False).head(20)\norder_f = group_top_f.sort_values(by=addrC,ascending=False)[addr]\n\ngroup_top_l = NOfraud.sort_values(by=addrC,ascending=False).head(20)\norder_l = group_top_l.sort_values(by=addrC,ascending=False)[addr]\n\nf, axes = plt.subplots(4, 1, figsize=(18, 20))\n\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=addr, y=addrC, data=group_top_f, order = order_f, ax=axes[0])\nbx = sns.barplot(x=addr, y=addrC, data=group_top_l, order = order_l, ax=axes[1])\n\naz = sns.barplot(x=addr, y=addrC, data=group_top_f, ax=axes[2])\nbz = sns.barplot(x=addr, y=addrC, data=group_top_l, ax=axes[3])\n\nfont_size= {'size': 'x-large'}\nax.set_title(\"Fraud transactions by addr1 (ranked)\", **font_size)\nbx.set_title(\"Legit transactions by addr1 (ranked)\", **font_size)\n\naz.set_title(\"Fraud transactions by addr1\", **font_size)\nbz.set_title(\"Legit transactions by addr1\", **font_size)\n\nxt = plt.xticks(rotation=60)\nplt.tight_layout()","83664569":"# Subset fraud dataset\naddr = 'addr2'\naddrC = 'addr2Count'\nfraud = pd.DataFrame()\nis_fraud = train[train['isFraud']==1]\nfraud[addrC] = is_fraud.groupby([addr])[addr].count()\nfraud[addr] = fraud.index\n\n# Subset NOT fraud dataset\nNOfraud = pd.DataFrame()\nno_fraud = train[train['isFraud']==0]\nNOfraud[addrC] = no_fraud.groupby([addr])[addr].count()\nNOfraud[addr] = NOfraud.index\n\n# There are too many addr, so we will subset the top 20\ngroup_top_f = fraud.sort_values(by=addrC,ascending=False).head(20)\norder_f = group_top_f.sort_values(by=addrC,ascending=False)[addr]\n\ngroup_top_l = NOfraud.sort_values(by=addrC,ascending=False).head(20)\norder_l = group_top_l.sort_values(by=addrC,ascending=False)[addr]\n\nf, axes = plt.subplots(4, 1, figsize=(18, 20))\n\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.barplot(x=addr, y=addrC, data=group_top_f, order = order_f, ax=axes[0])\nbx = sns.barplot(x=addr, y=addrC, data=group_top_l, order = order_l, ax=axes[1])\n\naz = sns.barplot(x=addr, y=addrC, data=group_top_f, ax=axes[2])\nbz = sns.barplot(x=addr, y=addrC, data=group_top_l, ax=axes[3])\n\nfont_size= {'size': 'x-large'}\nax.set_title(\"Fraud transactions by addr1 (ranked)\", **font_size)\nbx.set_title(\"Legit transactions by addr1 (ranked)\", **font_size)\n\naz.set_title(\"Fraud transactions by addr1\", **font_size)\nbz.set_title(\"Legit transactions by addr1\", **font_size)\n\nxt = plt.xticks(rotation=60)\nplt.tight_layout()","ebfec342":"# Get top 10 \norder_p=train.P_emaildomain.value_counts().iloc[:10].index\norder_r=train.R_emaildomain.value_counts().iloc[:10].index\n\nf, axes = plt.subplots(1, 2, figsize=(16, 8))\n\nsns.set(color_codes=True)\np_email = sns.countplot(y='P_emaildomain',  hue=\"isFraud\", data=train, order = order_p, ax=axes[0])\nr_email = sns.countplot(y='R_emaildomain',  hue=\"isFraud\", data=train, order = order_r, ax=axes[1])\nplt.tight_layout()","2b5dbeee":"f, axes = plt.subplots(2, 1, figsize=(12, 20))\n\nprops = train.groupby(\"P_emaildomain\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='barh', stacked='True', ax=axes[0])\n\nprops = train.groupby(\"R_emaildomain\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='barh', stacked='True', ax=axes[1])\n\nplt.tight_layout()","e1759cd0":"M1_loc = train.columns.get_loc(\"M1\")\nM9_loc = train.columns.get_loc(\"M9\")\ndf_m = train.iloc[:,M1_loc:M9_loc+1] #subset dataframe M1-M9\ndf_m['isFraud'] = train.isFraud \n\ncols = df_m.columns\nf, axes = plt.subplots(3, 3, figsize=(16, 12))\ncount = 0\nfor i in range(3): # rows loop\n    for j in range(3): # cols loop\n        mplot = sns.countplot(x=cols[count], hue = 'isFraud', data=df_m, ax=axes[i,j])\n        count += 1 # to loop over col-names\nplt.tight_layout()","ddc23438":"ms = df_m.columns.tolist()\nms.pop()\nrows = len(ms)\nf, axes = plt.subplots(rows, 1, figsize=(12, 20))\nfor i,m in enumerate(ms): \n    props = train.groupby(m)['isFraud'].value_counts(normalize=True).unstack()\n    p = props.plot(kind='barh', stacked='True', ax=axes[i])\nplt.tight_layout()","cf3a2511":"# Subset fraud dataset\naddr = 'id_30'\naddrC = 'id_30Count'\nfraud = pd.DataFrame()\nis_fraud = train[train['isFraud']==1]\nfraud[addrC] = is_fraud.groupby([addr])[addr].count()\nfraud[addr] = fraud.index\n\n# Subset NOT fraud dataset\nNOfraud = pd.DataFrame()\nno_fraud = train[train['isFraud']==0]\nNOfraud[addrC] = no_fraud.groupby([addr])[addr].count()\nNOfraud[addr] = NOfraud.index\n\n# There are too many OS, so we will subset the top 20\ngroup_top_f = fraud.sort_values(by=addrC,ascending=False).head(20)\norder_f = group_top_f.sort_values(by=addrC,ascending=False)[addr]\n\ngroup_top_l = NOfraud.sort_values(by=addrC,ascending=False).head(20)\norder_l = group_top_l.sort_values(by=addrC,ascending=False)[addr]\n\nf, axes = plt.subplots(2, 1, figsize=(18, 20))\n\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\n\nax = sns.barplot(y=addr, x=addrC, data=group_top_f, order = order_f, ax=axes[0])\nbx = sns.barplot(y=addr, x=addrC, data=group_top_l, order = order_l, ax=axes[1])\n\nfont_size= {'size': 'x-large'}\nax.set_title(\"Fraud transactions by OS (ranked)\", **font_size)\nbx.set_title(\"Legit transactions by OS (ranked)\", **font_size)\n\nplt.tight_layout()","c9a5922b":"f, axes = plt.subplots(2, 1, figsize=(12, 20))\n\nprops = train.groupby(\"id_30\")['isFraud'].value_counts(normalize=True).unstack()\nprops = props.sort_values(by=1, ascending = False).head(20) # sort by fraud and get top 20\np = props.plot(kind='barh', stacked='True', ax=axes[0])\n\nprops = train.groupby(\"id_31\")['isFraud'].value_counts(normalize=True).unstack()\nprops = props.sort_values(by=1, ascending = False).head(20) # sort by fraud and get top 20\np = props.plot(kind='barh', stacked='True', ax=axes[1])\n\nplt.tight_layout()","8abef010":"# Let's get the frequency of the cases with higher proportion of Fraud\nprops_30 = train.groupby(\"id_30\")['isFraud'].value_counts(normalize=True).unstack()\nprops_30 = props_30.sort_values(by=1, ascending = False).head(20) # sort by fraud and get top 20\nid_30_top = props_30.index.tolist()\nprops_30_c = train.groupby(\"id_30\")['isFraud'].value_counts()\nprops_30_c.loc[id_30_top]","de711ef3":"props_31 = train.groupby(\"id_31\")['isFraud'].value_counts(normalize=True).unstack()\nprops_31 = props_31.sort_values(by=1, ascending = False).head(20) # sort by fraud and get top 20\nid_31_top = props_31.index.tolist()\nprops_31_c = train.groupby(\"id_31\")['isFraud'].value_counts()\nprops_31_c.loc[id_31_top]","351bcea5":"# This variable is NOT listed as categorical, but clearly is\nplt.figure(figsize=(10, 5))\nsns.set(color_codes=True)\nsns.set(font_scale = 1.3)\nax = sns.countplot(x='ProductCD', hue =\"isFraud\", data=train)","4fa27665":"props = train.groupby(\"ProductCD\")['isFraud'].value_counts(normalize=True).unstack()\np = props.plot(kind='barh', stacked='True')","bc111dd0":"is_fraud = train[train['isFraud']==1]\nno_fraud = train[train['isFraud']==0]\n\nf, axes = plt.subplots(2, 1, figsize=(15, 10))\n\nd1 = sns.distplot(no_fraud.TransactionDT, color=\"fuchsia\", label=\"No fraud\", ax=axes[0])\nl1 = d1.legend()\nd2 = sns.distplot(is_fraud.TransactionDT, color=\"black\", label = \"Fraud\", ax=axes[0])\nl2 = d1.legend()\n\nt1 = sns.distplot(no_fraud.TransactionAmt.apply(np.log2), color=\"fuchsia\", label=\"No fraud\", ax=axes[1])\nl3 = t1.legend()\nt2 = sns.distplot(is_fraud.TransactionAmt.apply(np.log2), color=\"black\", label = \"Fraud\", ax=axes[1])\nl4 = t2.legend()\n\nplt.tight_layout()","0833e9ad":"C7_loc = train.columns.get_loc(\"C7\")\nC14_loc = train.columns.get_loc(\"C14\")\ndf_c = train.iloc[:,C7_loc:C14_loc+1] #subset dataframe\ncols = df_c.columns\n\n# run this to allow np.log to work, i.e., prevent zero division\ndf_c.replace(0, 0.000000001, inplace = True) \n\ndf_c['isFraud'] = train.isFraud \n\nis_fraud = df_c[train['isFraud']==1]\nno_fraud = df_c[train['isFraud']==0]\n\nrows = 8\nf, axes = plt.subplots(rows, 1, figsize=(15, 30))\n\nfor i in range(rows):\n    dp = sns.distplot(no_fraud[cols[i]].apply(np.log), color=\"fuchsia\", ax=axes[i])\n    dp = sns.distplot(is_fraud[cols[i]].apply(np.log), color=\"black\", ax=axes[i])\nplt.tight_layout()","3e043ef4":"D1_loc = train.columns.get_loc(\"D1\")\nD15_loc = train.columns.get_loc(\"D15\")\ndf_d = train.iloc[:,D1_loc:D15_loc+1] #subset dataframe\ncols = df_d.columns\n\n# run this to allow np.log to work, i.e., prevent zero division\ndf_d.replace(0, 0.000000001, inplace = True) \n\ndf_d['isFraud'] = train.isFraud \n\n# log transfrom for visualization\nis_fraud = df_d[train['isFraud']==1].apply(np.log)\nno_fraud = df_d[train['isFraud']==0].apply(np.log)\n\nrows = 15\nf, axes = plt.subplots(rows, 1, figsize=(15, 30))\nfor i in range(rows):\n    dp = sns.distplot(no_fraud[cols[i]].dropna(), color=\"fuchsia\", ax=axes[i])\n    dp = sns.distplot(is_fraud[cols[i]].dropna(), color=\"black\", ax=axes[i])\nplt.tight_layout()","77910903":"id_01_loc = train.columns.get_loc(\"id_01\")\nid_11_loc = train.columns.get_loc(\"id_11\")\ndf = train.iloc[:,id_01_loc:id_11_loc+1] #subset dataframe\ncols = df.columns\n\n# run this to allow np.log to work, i.e., prevent zero division\ndf.replace(0, 0.000000001, inplace = True) \n\ndf['isFraud'] = train.isFraud \n\n# log transfrom for visualization\nis_fraud = df[train['isFraud']==1].apply(np.log)\nno_fraud = df[train['isFraud']==0].apply(np.log)\n\n# run this to avoid runtime error (log is undefined for inf\/NaN values in 'isFraud')\nis_fraud.drop(columns=['isFraud'], inplace=True)\nno_fraud.drop(columns=['isFraud'], inplace=True)\n\nrows = 11\nf, axes = plt.subplots(rows, 1, figsize=(15, 25))\nfor i in range(rows):\n    dp = sns.distplot(no_fraud[cols[i]].dropna(), color=\"fuchsia\", ax=axes[i])\n    dp = sns.distplot(is_fraud[cols[i]].dropna(), color=\"black\", ax=axes[i])\nplt.tight_layout()","6ba4adb9":"id_01_loc = train.columns.get_loc(\"id_01\")\nid_11_loc = train.columns.get_loc(\"id_11\")\ndf = train.iloc[:,id_01_loc:id_11_loc+1] #subset dataframe\ncols = df.columns\n\n# run this to allow np.log to work, i.e., prevent zero division\ndf.replace(0, 0.000000001, inplace = True) \n\ndf['isFraud'] = train.isFraud \n\n# log transfrom for visualization\nis_fraud = df[train['isFraud']==1].apply(np.log)\nno_fraud = df[train['isFraud']==0].apply(np.log)\n","7cb94191":"# Here I subset the dataset by the % difference between Fraud and Not-Fraud transactions\nfrom sklearn import preprocessing\n\n#subset dataframe\nV1_loc = train.columns.get_loc(\"V1\")\nV339_loc = train.columns.get_loc(\"V339\")\ndf = train.iloc[:,V1_loc:V339_loc+1] \ncols = df.columns\n\n#scale values\nscaler = preprocessing.MinMaxScaler()\nscaled_array = scaler.fit_transform(df)\nscaled_df = pd.DataFrame(scaled_array, index=df.index, columns=df.columns)\nscaled_df['isFraud'] = train.isFraud \n\n# compute percentage difference between Fraud\/Not-fraud transactions\ngroup_means=scaled_df.groupby('isFraud').mean()\ngroup_means_t = group_means.transpose()\ngroup_means_t['delta_percentage'] = ((group_means_t.iloc[:,1] - group_means_t.iloc[:,0]) \/ ((group_means_t.iloc[:,1] + group_means_t.iloc[:,0]) \/ 2)) * 100","372785a7":"# Let's limit the plots to the cases where Fraud differs by 100% to Not-Fraud\n# i.e., values that double \nplus_100 = group_means_t[group_means_t[\"delta_percentage\"] >= 100]\nplus_100_index = plus_100.index.tolist()\nlen(plus_100)","5789b04b":"# This will plot and format 52! barplots, so it may take while tu run (few minutes)\ndf['isFraud'] = train.isFraud \ncols = plus_100_index\nrows = 13\ncolumns = 4\nf, axes = plt.subplots(rows, columns, figsize=(20, 35))\ncount = 0\nfor i in range(rows): # rows loop\n    for j in range(columns): # cols loop\n        mplot = sns.barplot(x=\"isFraud\", y=cols[count], data=df, ax=axes[i,j])\n        count += 1 # to loop over col-names\nplt.tight_layout()","12f84498":"**Notes**  \n  \n**ProductCD is 'Production code'**   \n- 'C': has both the highest number AND the highest proportion of Fraud transactions\n- 'W': has a similar frequency of Fraud transactions for a minor proportion of the W class","142bae2b":"**Notes:**\n- In the cases where Fraud\/Not-Fraud differ, the pattern is the same: **Fraud more clustered with a higher peak**, and **Not-Fraud more spread out with longer\/heavier tails**","1568ec5e":"## Plot\/Explore bivariate relationships","3052f450":"**Plot III: cards 1,2,3, and 5**","5e208f9f":"## Plot continuous variables ","75b27c13":"**Plot VII: emaildomains by Fraud status**","1e54f3c8":"**Plot VII notes:**\n- As expected, gmail is at the top.\n- There is one interesting 'anonymous.com' domain","5df1f361":"# Detailed exploration of IEEE-CIS 'Fraud Detection' dataframe\nHere I examine and plot all features\/variables from the training dataset, adding notes for all plots for later development\n\n**This kernel is a bit long, so I'm continuining here with missing values analysis:**  \nhttps:\/\/www.kaggle.com\/pabloinsente\/ieee-missing-nan-values-analysis-and-imputation\n\n## Description variables\/features:\n(https:\/\/www.kaggle.com\/c\/ieee-fraud-detection\/discussion\/101203#latest-583068) \n\n### Transaction Table:\n- TransactionDT: timedelta from a given reference datetime (not an actual timestamp)\n- TransactionAMT: transaction payment amount in USD\n- ProductCD: product code, the product for each transaction\n- card1 - card6: payment card information, such as card type, card category, issue bank, country, etc.\n- addr: address\n- dist: distance\n- P_ and (R__) emaildomain: purchaser and recipient email domain\n- C1-C14: counting, such as how many addresses are found to be associated with the payment card, etc. The actual meaning is masked.\n- D1-D15: timedelta, such as days between previous transaction, etc.\n- M1-M9: match, such as names on card and address, etc.\n- Vxxx: Vesta engineered rich features, including ranking, counting, and other entity relations.\n\n\n### Identity Table:\n- Variables in this table are identity information \u2013 network connection information (IP, ISP, Proxy, etc) and digital signature (UA\/browser\/os\/version, etc) associated with transactions. \n- They're collected by Vesta\u2019s fraud protection system and digital security partners.\n- (The field names are masked and pairwise dictionary will not be provided for privacy protection and contract agreement)","4b3e5bf3":"**Notes:**\n- From V1-V305 & V322-V339 seems to be mostly 0 - 1 values, which may indicate that they are actually a categorical feature \n- From V306-V321 seems to be true continuous variables \n- More interesting insights may come from computing averages by target feature","9b1a2237":"**Plot XIII notes:**\n- All variables follow roughly a log distribution \n- Identity is unclear","cd7eb090":"**Plot II notes:**\n\nThe top devices are:\n1. Windows\n2. iOS\n3. Trident\n4. MacOS","410f9558":"**Plot I:  target, ProductCD, Devicetype, DeviceInfo \/ Target**","6fae349f":"**Plot XI: ProductCD by Fraud status**","da0494d2":"## Plot univariate distributions","0ff24862":"**Plot XV: id_01 - id_11**","d9a87e3d":"**Plot III notes:**  \n- The bulk of the transactions are on card1 and2  \n- Not sure about identity of card3 and card5\n- They may be dollars amount per transaction, or some sort of identifier ","1b56a3a6":"**Notes**\n- **id_30**: Other and Android 5.1.1 have the highest proportion of Fraud, **BUT**  negligible frequency: Other have 6 cases and Android 5.1.1, 101 cases\n- **id_31**: Lanix, Mozilla, comodo, and lanix have really high proportions of 'Fraud', *BUT*, negible frequency: Lanix\/Ilium 1 fraud, Mozilla\/Firefox 5 fraud cases, comodo 2, lanix 1","99b237a1":"**Plot VII: emaildomains**","3eea3f6c":"**Plot IX: id_30**","61530551":"**Plot I:  target, ProductCD, Devicetype, DeviceInfo**\n","e6d400fc":"**Exploration V1 - V339**","0075ea28":"**Plot XII notes:**\n- TransactionDT is evenly distributed, unclear identity\n- Transaction amount follows a log distribution, with a few large outliers","1f54ae86":"**Plot XV notes:**\n- id_02 may be dollar amounts, with log distribution\n- id_01 - id_10 have negative values, but it is unlikely to indicate debt given values\n- id_07 - id_08 are kinda normally distributed","d7608368":"**Notes:**\n- Most fraud transactions come from addr1 204; most not fraud come from 299\n- First 5 addr1 are the same, but in different rank-order","da832be9":"**Notes:**  \n- **'Protonmail.com'**,  **'mail.com'**, **'outlook.es'**, and, **'net.zero'** have a high proportion of Fraud transaction, yet they account for an small total number of fraud transactions","0d26f5a4":"**Plot II: DeviceInfo**","485cc73a":"**Plot XII: TransactionDT, TransactionAmt by Fraud status**","8e528903":"**Plot XIV notes:**\n- D11-D15 have negative values, which may say something about the identity of the feature\n- D9 has a different distribution, kinda binomial\n- The rest roughly a log distribution","ab7ce4fb":"**Plot I notes:**\n- Very unbalance target (isFraud)\n- Very unbalance product type purchase\n- Most purchases are made on desktop devices","f3644be7":"**Plot IX**","d2660bc6":"### Categorical variables according to dataset documentation\n** Categorical Features - Transaction:**  \n- ProductCD\n- card1 - card6\n- addr1, addr2\n- P_emaildomain\n- R_emaildomain\n- M1 - M9\n\n** Categorical Features - Identity:**\n- DeviceType\n- DeviceInfo\n- id_12 - id_38","05f9245a":"**Plot XIV: D1 - D15 by Fraud status**","681f8c08":"**Notes:**\n- Visa has the higher NUMBER of Fraud, but such number is a minor proportion of all VISA transactions\n- Discover has very few Fraud transaction, yet as percentage of all Discover transactions is a bit higher\n- Most Fraud transactions are done with Debit, but there is a higher proportion of Fraud Transactions within Credit ","76fca4fc":"**Notes:**\n- There are so many features with no-identity info that it is hard to get a clear insight. It is clear though that there are A LOT features where Fraud transactions have higher means, which means that these variables are going to be variable for the model to learn to capture Fraud cases","ae668799":"**Plot XI: ProductCD by fraud status as percentage**","ea4e268b":"**Plot XIII: C7 - C14**","4f531994":"**Plot IV notes:**  \n- Card4 refers to visa brand; most transactions are on Visa and Mastercard \n- Card5 refers to type of card; most transactions are debit ","046e1d52":"# III. Explore data: describe variables by target (Fraud\/not Not Fraud)","26cf5e78":"**Plot X notes:**\n- Most transactions are done with Windows 7 and 10, and iOS\n- Most transactions are done with chrome and safari","5fb5a644":"**Plot XV: id_01 - id_11 by fraud status**","c70b62ab":"# II. Explore data: describe single variables","8bf7d768":"**Plot VI: addr2**","f60f125b":"**Plot IV: cards 4 and 6**","78372d4b":"**Notes:**\n- As frequency is hard to catch meaningful differences between classes\n- As percentage there are some interesting patterns on 'M4' where class M2 get the highest proportion of Fraud transactions, or M1 where 'F' doesn't get any Fraud cases","1c82a9c8":"**Plot V-VI notes:**\n- Transactions on addr1 are more evenly distributed\n- Transactions on addr2 has 1 big outlier ","62a00f18":"**Plot VIII: M1 - M9 variables by Fraud status as percentage**","d2071b05":"**Plot IX as percentage**","4c4ad4db":"**Plot VIII: M1 - M9 by Fraud status variables**","d6737bbc":"**Plot X: id_31**","9438fd68":"**Plot VI: addr2**","c146ab3c":"**Notes**\n- Fraud transaction cases come mostly from Windows and iOS devices. This is predictable given the vast majority of all transactions come from those systems. Still, the problem is this feature will still send the signal to the model that Windos\/iOS_Device transactions -> likely fraud relative to other systems\n- Trident OS drop 5 places (3th overall, 8th on Fraud transactions)","717e63ad":"**Notes:**\n- ProductCD: C and S types have the highest number AND proportion of Fraud Transactions\n- DeviceType: mobile has the highest number AND proportion of Fraud Transactions (not by much though)","da9b51d4":"**Plot V: addr1**","25b17a5e":"**Notes** \n- **Main insight**: Fraud transactions tend to be **more spread out over time**, while Not-Fraud transactions tend to be **more clustered around shorter time periods** (from the 0 time-point reference) ","5b5c886f":"**Explore 'V' Features**","1651f364":"**Plot IV as percentage**","91a41ef1":"**Plot XV: id_01 - id_11 \/ SAME as LOG distributions**","1aadd108":"# I. Import data","ac8ffb51":"**Notes:**\n- This is all supossed to be 'counting' data, yet, we get a bunch of negative values\n- The main patter, is that not-fraud transactions have higher values, more tightly concentrated (high kurtosis), while fraud transactions are more evenly spread out (low kurtosis), which means more outliers","cfccb3a1":"**Plot III: cards 1,2,3, and 5**","e3fc9ff3":"## Plot categorical variables","806dd1ad":"**This kernel is a bit long, so I'm continuining here with missing values analysis:**  \nhttps:\/\/www.kaggle.com\/pabloinsente\/ieee-missing-nan-values-analysis-and-imputation","674e1dba":"**Plot VIII notes:**\n- Identity of M1-M9 is still unclear\n- Basically boolean variables; M4 seems to be different","f0ef90bf":"**Plot XIV: D1 - D15**","35c834d6":"**Notes id12-id38**\n- There is a mix of data types\n- Mostly NaN values\n- id30 is OS again\n- id31 is browser\n","f755435a":"**Notes:**\n- **TransactionDT (time delta from some reference time)**: Not-Fraud transactions tend to be more close to the 'Time zero reference' for the transactions; Fraud transactions tend to be a bit more evenly distributed. There is a pick around 0.55\n- **TransanctionAmt (on dollars)**: Not-Fraud transactions are concentrated on the middle of the distribution, while Fraud transactions are a bit more concentrated on the tails (really small or really bit). This makes a lot of intuitive sense: micro-frauds and large-amounts-frauds are more likely. ","02572010":"**Plot XV: id_01 - id_11 by Fraud status**","3c5a3465":"**Plot II: Fraud transactions by OS**","fe91cd02":"**Plot XI: ProductCD**","bfb528d8":"**Notes:**\n- card1, card2 and card3 show similar distribution patterns fraud\/no_fraud\n- card5 reverse proportion around value '225' ","944323a1":"**Plot XIII: C7 - C14 by Fraud status**","bddc1677":"**Plot V: addr1**","e654c452":"**Plot VII: emaildomains by Fraud status as percentage**","bbe4275d":"**Plot I as percentage**"}}