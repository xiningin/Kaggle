{"cell_type":{"4fbe892c":"code","6f5b9b09":"code","42697608":"code","88650e2e":"code","142a4cd2":"code","e68ccbf1":"code","ad2db52d":"code","9cf3d16b":"code","559b6bab":"code","692c97dc":"code","9c743727":"code","7062e72e":"code","b438b508":"code","dd976d2b":"code","0ff77a92":"code","32b4fd90":"code","d3ace880":"code","10c222a4":"code","1bca167b":"code","1c68c582":"code","e16c1a2e":"code","37bbb2ce":"code","b94a1cd9":"code","7b54cef3":"code","d94256ce":"code","2af7cf9a":"code","f6fbf8a1":"code","502b6ac4":"code","dbad3dc3":"code","012e9c24":"code","2ab96664":"code","b65f5d82":"code","1f28a53d":"code","0c7cec4b":"code","0fd1efb5":"code","50568b9a":"code","2534a0d6":"code","55c1fd21":"code","5a8f7a22":"code","e8e8a6d4":"code","7cfc40e2":"code","c393b1da":"code","ccba0064":"code","21598ac3":"code","843bc42f":"code","08a93081":"code","d9281418":"code","ab29a3e5":"markdown","ac5bc461":"markdown","b35fcc2f":"markdown","52aae1aa":"markdown","3303009c":"markdown","79246c94":"markdown","8a97b7ca":"markdown","ff069c80":"markdown","4c4e8dbf":"markdown","78c5cd43":"markdown","4085a409":"markdown","8235b1a8":"markdown","dedd4719":"markdown","1a05e42b":"markdown","ba950ac9":"markdown","57d35e67":"markdown","167d9a47":"markdown","748884e5":"markdown"},"source":{"4fbe892c":"import os\nimport time\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nfrom tqdm import tqdm\nimport math\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\nfrom sklearn.metrics import f1_score, roc_auc_score\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sys import getsizeof\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\nimport string\nfrom string import digits\nimport re\nimport operator \nplt.style.use('seaborn-darkgrid')","6f5b9b09":"# https:\/\/www.kaggle.com\/theoviel\/improve-your-score-with-some-text-preprocessing\ndef load_embed(file):\n    def get_coefs(word,*arr): \n        return word, np.asarray(arr, dtype='float32')\n    \n    if file == '..\/input\/embeddings\/wiki-news-300d-1M\/wiki-news-300d-1M.vec':\n        embeddings_index = dict(get_coefs(*o.split(\" \")) for o in open(file) if len(o)>100)\n    else:\n        embeddings_index = dict(get_coefs(*o.split(\" \")) for o in open(file, encoding='latin'))\n        \n    return embeddings_index","42697608":"# https:\/\/www.kaggle.com\/theoviel\/improve-your-score-with-some-text-preprocessing\ndef build_vocab(texts):\n    sentences = texts.apply(lambda x: x.split()).values\n    vocab = {}\n    for sentence in sentences:\n        for word in sentence:\n            try:\n                vocab[word] += 1\n            except KeyError:\n                vocab[word] = 1\n    return vocab","88650e2e":"# https:\/\/www.kaggle.com\/theoviel\/improve-your-score-with-some-text-preprocessing\ndef check_coverage(vocab, embeddings_index):\n    known_words = {}\n    unknown_words = {}\n    nb_known_words = 0\n    nb_unknown_words = 0\n    for word in vocab.keys():\n        try:\n            known_words[word] = embeddings_index[word]\n            nb_known_words += vocab[word]\n        except:\n            unknown_words[word] = vocab[word]\n            nb_unknown_words += vocab[word]\n            pass\n\n    print('Found embeddings for {:.2%} of vocab'.format(len(known_words) \/ len(vocab)))\n    print('Found embeddings for  {:.2%} of all text'.format(nb_known_words \/ (nb_known_words + nb_unknown_words)))\n    unknown_words = sorted(unknown_words.items(), key=operator.itemgetter(1))[::-1]\n\n    return unknown_words","142a4cd2":"def plot_learning_curve(history,model_info):\n    # summarize history for loss\n    plt.figure(figsize=(9,7))\n    plt.plot(history['loss'])\n    plt.plot(history['val_loss'])\n    plt.title(f'Model {model_info} Loss')\n    plt.ylabel('loss')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'validation'], loc='upper left')\n    plt.savefig(f'Model_{model_info}_Loss.png')\n    \n    # summarize history for accuracy\n    plt.figure(figsize=(9,7))\n    plt.plot(history['acc'])\n    plt.plot(history['val_acc'])\n    plt.title(f'Model {model_info} Accuracy')\n    plt.ylabel('accuracy')\n    plt.xlabel('epoch')\n    plt.legend(['train', 'validation'], loc='upper left')\n    plt.savefig(f'Model_{model_info}_Acc.png')\n    print(f'Model_{model_info}')","e68ccbf1":"def load_combined():\n    train_data = pd.read_csv(\"..\/input\/train.csv\")\n    test_data = pd.read_csv(\"..\/input\/test.csv\")\n    \n    # Get the number of samples in training data :\n    train_size = train_data.shape[0]\n    test_size =  test_data.shape[0]\n    \n    # Combine training and test data :\n    combined = train_data.append(test_data, ignore_index  = True, sort = False)\n    \n    ## fill in nans :\n    combined[\"question_text\"].fillna('NAN', inplace = True)\n    \n    return combined, train_size, test_size\n","ad2db52d":"combined, train_size, test_size = load_combined()","9cf3d16b":"question_text = combined[\"question_text\"].copy()","559b6bab":"%%time\n# Get Words :\ndef get_words(samples):\n    words = set()\n    for sample in samples.values:\n        for word in sample.split():\n            words.add(word)\n    num_words = len(words)\n    print(f'Number of unique words : {num_words}')\n    return words","692c97dc":"num_toxic    = combined[combined['target'] == 1 ].count()[0]\nnum_nontoxic = combined[combined['target'] == 0 ].count()[0]\nprint(f'Number of toxic samples    : {num_toxic}')\nprint(f'Number of nontoxic samples : {num_nontoxic}')\n\nprint(f'{round((num_toxic\/train_size)*100,2)}% of the samples in the training data is Toxic')","9c743727":"# Number of words without processing the dataset :\n_ = get_words(samples = combined[\"question_text\"])","7062e72e":"# Convert text to lowercase :\ncombined[\"question_text\"] = combined[\"question_text\"].apply(lambda x: x.lower())","b438b508":"# Number of words after converting the samples to lower case :\n_ = get_words(samples = combined[\"question_text\"])","dd976d2b":"%%time\n# Process commas :\ncombined[\"question_text\"] = combined[\"question_text\"].apply(lambda x: re.sub(\"'\", '', x)).apply(lambda x: re.sub(\",\", ' COMMA', x))\n\n# Getting rid of punctuation\nexclude = set(string.punctuation)\ncombined[\"question_text\"] = combined[\"question_text\"].apply(lambda x: ''.join(ch for ch in x if ch not in exclude))","0ff77a92":"# Number of words after dealing with punctuation :\n_ = get_words(samples = combined[\"question_text\"])","32b4fd90":"# Getting rid of digits\nremove_digits = str.maketrans('', '', digits)\ncombined[\"question_text\"] = combined[\"question_text\"].apply(lambda x: x.translate(remove_digits))","d3ace880":"# Number of words without digits :\nwords = get_words(samples = combined[\"question_text\"])\nmax_features = len(words)","10c222a4":"# prepare tokenizer\ntokenizer = Tokenizer(num_words = max_features)\ntokenizer.fit_on_texts(combined['question_text'])","1bca167b":"# integer encode the documents\nencoded_samples = tokenizer.texts_to_sequences(combined['question_text'])\ncombined['encoded_samples'] = encoded_samples","1c68c582":"# Get samples length :\ncombined['sample_len'] = combined['encoded_samples'].apply(len)","e16c1a2e":"max_len = combined['sample_len'].max()\nmin_len = combined['sample_len'].min()\navg_len = int(combined['sample_len'].mean())\n\nprint(f'The longest  sample has {max_len} words')\nprint(f'The shortest sample has {min_len} words')\nprint(f'The average number of words in samples is {avg_len}')","37bbb2ce":"empty_samples_idx = combined[combined['sample_len'] <= 0].index\nquestion_text[empty_samples_idx]","b94a1cd9":"oneWord_samples_idx = combined[combined['sample_len'] == 1].index\ntemp = pd.DataFrame({'question_text':question_text[oneWord_samples_idx],\n              'target':combined['target'][oneWord_samples_idx]})\ntemp","7b54cef3":"# Percentage of toxic samples in the dataset :\ntoxic_perc = round((combined['target'].sum()\/train_size)*100,2)\nprint(f'Percentage of toxic samples in the dataset : {toxic_perc}%')","d94256ce":"t = round((temp['target'].sum()\/combined['target'].sum())*100,4)\nprint(f'Percentage of toxic samples with one word only over the other toxic samples : {t}%')","2af7cf9a":"def get_count(df,col,min_len,max_len):\n    return df[(df[col]>=min_len) & (df[col]<=max_len)].count()[0]","f6fbf8a1":"def plot_sample_len(df,col,title = 'Lengths of Samples',sp=10000):\n    # Get the range of lengths and number of samples for each range (for test data)\n    ranges = [(0,5), (6,10), (11,15), (16,20), (21,30), (31,40),\n              (41,50), (51,65), (66,80), (81,100), (101,150) ]\n    range_name = []\n    num_samps_in_range = []\n    for r in ranges:\n        num_samps_in_range.append(\n            get_count(df = df, col = col, min_len=r[0], max_len=r[1]))\n        range_name.append(f'{r[0]} -> {r[1]}')\n\n        # Plot range of lengths and number of samples for each range :\n    fig, ax = plt.subplots(figsize = (18, 10),)\n    ax.set(title = title,\n           xlabel = ' Length (# words)', ylabel = '# Samples')\n\n    r1 = ax.bar(range_name,\n                num_samps_in_range,\n                alpha = 0.9,\n                label = '# Samples')\n    for idx in range(len(ranges)) : \n        if(num_samps_in_range[idx] > 10000):\n            ax.text(range_name[idx],\n                    num_samps_in_range[idx]+(sp),\n                    num_samps_in_range[idx],\n                    horizontalalignment='center',\n                    size='large')\n        else :\n            ax.text(range_name[idx],\n                num_samps_in_range[idx]+100,\n                num_samps_in_range[idx],\n                horizontalalignment='center',\n                size='large')","502b6ac4":"# ranges of sample length for all combined data :\nplot_sample_len(df = combined,col = 'sample_len',\n                title = 'Lengths of All Samples',sp=10000)","dbad3dc3":"# ranges of sample length for training data :\nplot_sample_len(df = combined[:train_size],col = 'sample_len',\n                title = 'Lengths of Training Samples', sp=10000)","012e9c24":"# ranges of sample length for test data :\nplot_sample_len(df = combined[train_size:],col = 'sample_len',\n                title = 'Lengths of Test Samples', sp=500)","2ab96664":"glove = '..\/input\/embeddings\/glove.840B.300d\/glove.840B.300d.txt'\nparagram =  '..\/input\/embeddings\/paragram_300_sl999\/paragram_300_sl999.txt'\nwiki_news = '..\/input\/embeddings\/wiki-news-300d-1M\/wiki-news-300d-1M.vec'","b65f5d82":"%%time\nprint(\"Extracting GloVe embedding ...\")\nembed_glove = load_embed(glove)\nprint(\"Extracting Paragram embedding ...\")\nembed_paragram = load_embed(paragram)\nprint(\"Extracting FastText embedding ...\")\nembed_fasttext = load_embed(wiki_news)\nprint('Done!')","1f28a53d":"vocab = build_vocab(combined['question_text'])","0c7cec4b":"print(\"Glove : \")\noov_glove = check_coverage(vocab, embed_glove)\nprint(\"Paragram : \")\noov_paragram = check_coverage(vocab, embed_paragram)\nprint(\"FastText : \")\noov_fasttext = check_coverage(vocab, embed_fasttext)","0fd1efb5":"# Get : words and thier count and words that appeard only once :\nword_freq  = []\nall_words  = []\nrare_words = []\nfor i,w in enumerate(tokenizer.word_counts):\n    word_freq.append(tokenizer.word_counts[w])\n    all_words.append(w)\n    if(tokenizer.word_counts[w] <= 1):\n        rare_words.append(w)","50568b9a":"num_all_words  = len(all_words)\nnum_rare_words = len(rare_words)\nprint(f'Total number of words                     : {num_all_words}')\nprint(f'Number of words that appeared only once    : {num_rare_words}')\nprint(f'{round((num_rare_words\/num_all_words)*100,2)}% of the words appeared only once')","2534a0d6":"# Sort the words by their frequency :\ncommon_words       = []\ncommon_words_count = []\nfor y,x in sorted(zip(word_freq, all_words),reverse = True):\n    common_words.append(x)\n    common_words_count.append(y)","55c1fd21":"# Plot the most 10 common words :\nfig, ax = plt.subplots(figsize = (18, 10),)\nax.set(title = 'Common Words',\n       xlabel = ' Word', ylabel = 'Count')\n\nr1 = ax.bar(common_words[:10],\n            common_words_count[:10],\n            alpha = 0.9,\n            label = '# Count')\nfor idx in range(10) : \n    ax.text(common_words[idx],\n            common_words_count[idx]+10000,\n            common_words_count[idx],\n            horizontalalignment='center',\n            size='small')","5a8f7a22":"# The most 100 common words :\ntop100Words = pd.DataFrame({'Word':common_words[:100], 'Count':common_words_count[:100]})\nprint('The Top 10 Words :')\ntop100Words.head(10)","e8e8a6d4":"# Get a list of the words in the toxic samples:\ntoxic_samples = list(combined['encoded_samples'][combined['target'] == 1].values)\ntoxic_samples_words = [item for sublist in toxic_samples for item in sublist]\ntoxic_words = list(set(toxic_samples_words))\nprint(f'There are {len(toxic_words)} unique words in the toxic samples')","7cfc40e2":"# Extract non-toxic samples :\nnontoxic_samples = list(combined['encoded_samples'][combined['target'] == 0].values)\n\n# Get all the words in the non-toxic samples : \nnontoxic_samples_words = [item for sublist in nontoxic_samples for item in sublist]\nnontoxic_samples_words = list(set(nontoxic_samples_words))\n\n# Get words that only appeared in toxic samples :\ntoxic_only_words = list(set(toxic_words) - set(nontoxic_samples_words))","c393b1da":"print(f'Words that apeared only in toxic samples are {len(toxic_only_words)} words')","ccba0064":"# Create a dictionary to convert word index into word :\nidx2word = {}\nfor k, v in tokenizer.word_index.items():\n    idx2word[v] = k\n\n# Convert indecies to words :\ntoxic_only_words_idx = toxic_only_words.copy()\ntoxic_only_words = [idx2word[x] for x in toxic_only_words_idx]","21598ac3":"# print some of the words that appeared only in the toxic samples :  \ntemp = pd.DataFrame({ '1-20' :toxic_only_words[:20],\n                      '20-40':toxic_only_words[20:40]})\nprint('Some of the words that appeared only in the toxic samples :')\ntemp","843bc42f":"# Deleting words that appeared only one time\ntoxic_only_words = list(set(toxic_only_words) - set(rare_words))\nprint(f'Number of toxic words after deleting the rare words : {len(toxic_only_words)} words')","08a93081":"# Get top 10 toxic words by their count :\ntemp = pd.DataFrame({'toxic word':toxic_only_words})\ntemp['count'] = temp['toxic word'].apply(lambda x: tokenizer.word_counts[x])\ntemp.sort_values(by=['count'], ascending = False, inplace = True)\ntemp = temp.reset_index(drop = True)[:10]","d9281418":"# Plot the most 10 common toxic words :\nfig, ax = plt.subplots(figsize = (12, 10),)\nax.set(title = 'Common Toxic Words',\n       xlabel = 'Count', ylabel = 'Toxic Word')\n\nr1 = ax.barh(temp['toxic word'][:10],\n            temp['count'][:10],\n            alpha = 0.7,\n            color = '#EF4A6D')\nax.invert_yaxis()\nfor idx in range(10) : \n    ax.text(temp['count'][idx]-0.2,\n            idx,\n            temp['count'][idx],\n            horizontalalignment='right',\n            size='medium')","ab29a3e5":"# Embeddings :","ac5bc461":"## Common and Rare Words :","b35fcc2f":"## Toxic Words :","52aae1aa":"We will find the most common word and thier count, we will also try to find any words that appeared only once .","3303009c":"Now after you got to know more about the data, you can process it the right way so you get better score in this competition.","79246c94":"We will find the words that appeared in the toxic samples :","8a97b7ca":"In this notebook, I will do some processing and some analysis on Quora Insincere Questions Classification dataset.\n\nI will :\n* Get number and percentage of toxic questions.\n* Perform some processing on the data.\n* Get the number of unique words after each processing step\n* Tokenize the data\n* Get the most common words and their counts\n* Plot some graphs to show the common words\n* Do some analysis on the toxic samples\n* Get the toxic words\n\nI hope you get some good ideas after reading this notebook\n\n* If you found this notebook helful, please give it an upvote.\n* If you have any quistion, put it in the comments.","ff069c80":"Wait a minute, is it possible that there is a sample that doesn't have any words?\n\nLet's invistegate that .","4c4e8dbf":"# Conclusion :","78c5cd43":"This plot tells us that we don't need to set the padding length more than 65, but it's better if we set the max padding length to 70 just to be in the safe zone. ","4085a409":"So, there is one sample that is empty, What about samples with only one word ?","8235b1a8":"Wow! \n\nThis is not good at all, if we used this samples to train our model, it will make mistakes in predicting test samples.\n\nWe need to delete these samples, but first, we will make some calculations :","dedd4719":"# Tokenization :","1a05e42b":"# Toxic VS Nontoxic","ba950ac9":"Let's try deleting words that appeared only one time :","57d35e67":"# Some Processing :","167d9a47":"### Top 10 Toxic Words :","748884e5":"# Some Investigation : "}}