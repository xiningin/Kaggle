{"cell_type":{"53e2eef3":"code","20155e6c":"code","43f05f0f":"code","dfe86b2b":"code","55d7da38":"code","7e564903":"code","dd0fa0ab":"code","30e671fe":"code","843163c0":"markdown","7a1327d3":"markdown","7b79722d":"markdown","4289105f":"markdown","ceade388":"markdown","01daa058":"markdown","00c42be4":"markdown"},"source":{"53e2eef3":"from itertools import product\n\nimport pandas as pd\nimport numpy as np\nfrom tqdm.notebook import tqdm\nfrom numba import njit, prange\n\nimport santa_s_2019_faster_cost_function_24_s as utils\nfrom santa_s_2019_faster_cost_function_24_s import build_cost_function","20155e6c":"# Load Data\nbase_path = '\/kaggle\/input\/santa-workshop-tour-2019\/'\nsub_path = '\/kaggle\/input\/santa-ip\/'\ndata = pd.read_csv(base_path + 'family_data.csv', index_col='family_id')\nsubmission = pd.read_csv(sub_path + 'submission.csv', index_col='family_id')\n\n# Build your \"cost_function\"\ncost_function = build_cost_function(data)\n\n# Run it on default submission file\noriginal = submission['assigned_day'].values\noriginal_score = cost_function(original)\n\n%timeit cost_function(original)","43f05f0f":"def stochastic_product_search(top_k, fam_size, original, choice_matrix, \n                              disable_tqdm=False, verbose=10000,\n                              n_iter=500, random_state=2019):\n    \"\"\"\n    original (np.array): The original day assignments.\n    \n    At every iterations, randomly sample fam_size families. Then, given their top_k\n    choices, compute the Cartesian product of the families' choices, and compute the\n    score for each of those top_k^fam_size products.\n    \"\"\"\n    \n    best = original.copy()\n    best_score = cost_function(best)\n    \n    np.random.seed(random_state)\n\n    for i in tqdm(range(n_iter), disable=disable_tqdm):\n        fam_indices = np.random.choice(range(choice_matrix.shape[0]), size=fam_size)\n        changes = np.array(list(product(*choice_matrix[fam_indices, :top_k].tolist())))\n\n        for change in changes:\n            new = best.copy()\n            new[fam_indices] = change\n\n            new_score = cost_function(new)\n\n            if new_score < best_score:\n                best_score = new_score\n                best = new\n        \n        if new_score < best_score:\n            best_score = new_score\n            best = new\n    \n        if verbose and i % verbose == 0:\n            print(f\"Iteration #{i}: Best score is {best_score:.2f}\")\n    \n    print(f\"Final best score is {best_score:.2f}\")\n    return best","dfe86b2b":"choice_matrix = data.loc[:, 'choice_0': 'choice_9'].values","55d7da38":"best = stochastic_product_search(\n    choice_matrix=choice_matrix, \n    top_k=5,\n    fam_size=5, \n    original=original, \n    n_iter=20000,\n    disable_tqdm=False,\n    verbose=2000\n)","7e564903":"best = stochastic_product_search(\n    choice_matrix=choice_matrix, \n    top_k=2,\n    fam_size=12, \n    original=best, \n    n_iter=50000, \n    disable_tqdm=True,\n    verbose=5000\n)","dd0fa0ab":"best = stochastic_product_search(\n    choice_matrix=choice_matrix, \n    top_k=8,\n    fam_size=3, \n    original=best, \n    n_iter=50000, \n    disable_tqdm=False,\n    verbose=5000\n)","30e671fe":"submission['assigned_day'] = best\nfinal_score = cost_function(best)\nsubmission.to_csv(f'submission_{final_score}.csv')","843163c0":"# Save","7a1327d3":"## Round 3","7b79722d":"# About this kernel\n\nIn this kernel I propose a simple algorithm that I came up with to improve the current best LB score. \n\nHere's a simple description of the algorithm, which is defined as `stochastic_product_search`:\n1. Sample a small number of families (e.g. 6 families), call this `fam_size`, or f.\n2. Given their top-k choices (e.g. two most preferred days), you find the cartesian product of those choices.\n3. That will give you k^f (or in the example above 2^6 = 64) possible changes that you can make to your current assignment. For each of those proposed change, you create a `new` assignment by updating your current `best` assignment. If the `new_score` is better than the current `best_score`, update both of those values.\n4. Repeat that for the number of iterations desired, given by parameter `n_iter`.\n\n\n## References\n* (Previous) Best LB score: https:\/\/www.kaggle.com\/ilu000\/greedy-dual-and-tripple-shuffle-with-fast-scoring\n* Current Best LB Score: https:\/\/www.kaggle.com\/vipito\/santa-ip\n* Fast cost function: https:\/\/www.kaggle.com\/xhlulu\/santa-s-2019-faster-cost-function-24-s","4289105f":"# Novel Algorithm","ceade388":"# Usage","01daa058":"## Round 2","00c42be4":"## Round 1"}}