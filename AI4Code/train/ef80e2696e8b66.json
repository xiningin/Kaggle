{"cell_type":{"a6c6579c":"code","42cecb94":"code","f33eb648":"code","d535163e":"code","75d96493":"code","9c670728":"code","937b564e":"code","21a8f21a":"code","da7b3574":"code","fcb03ca3":"code","4ce9f4fa":"code","cafabac4":"code","8b3dcd8e":"code","a1ff82c0":"code","35868409":"code","5fd722f0":"markdown","b0d14123":"markdown","f07c7de8":"markdown","3775ea07":"markdown","5d20c2ee":"markdown","92d2f4cb":"markdown","d1ce9706":"markdown","489aeaa0":"markdown","1f55474c":"markdown","4ba7b3a7":"markdown","62d46e75":"markdown","6c73a30c":"markdown","7087f1aa":"markdown"},"source":{"a6c6579c":"# import resources\n%matplotlib inline\n\nfrom PIL import Image\nfrom io import BytesIO\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport torch\nimport torch.optim as optim\nimport requests\nfrom torchvision import transforms, models","42cecb94":"# get the \"features\" portion of VGG19 (we will not need the \"classifier\" portion)\nvgg = models.vgg19(pretrained=True).features\n\n# freeze all VGG parameters since we're only optimizing the target image\nfor param in vgg.parameters():\n    param.requires_grad_(False)","f33eb648":"# move the model to GPU, if available\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\nvgg.to(device)","d535163e":"def load_image(img_path, max_size=700, shape=None):\n\n    if \"http\" in img_path:\n        response = requests.get(img_path)\n        image = Image.open(BytesIO(response.content)).convert('RGB')\n    else:\n        image = Image.open(img_path).convert('RGB')\n    \n    # large images will slow down processing\n    if max(image.size) > max_size:\n        size = max_size\n    else:\n        size = max(image.size)\n    \n    if shape is not None:\n        size = shape\n        \n    in_transform = transforms.Compose([\n                        transforms.Resize(size),\n                        transforms.ToTensor(),\n                        transforms.Normalize((0.485, 0.456, 0.406), \n                        \n                                             (0.229, 0.224, 0.225))])\n\n    # discard the transparent, alpha channel (that's the :3) and add the batch dimension\n    image = in_transform(image)[:3,:,:].unsqueeze(0)\n    \n    return image","75d96493":"content_image_ = 'https:\/\/images.unsplash.com\/photo-1464278500780-e60893407e29?ixid=MXwxMjA3fDB8MHxzZWFyY2h8Mjd8fGNpdHklMjBzdHJlZXR8ZW58MHx8MHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60'\nstyle_image_ = 'https:\/\/cdn.pixabay.com\/photo\/2015\/12\/15\/05\/43\/starry-night-1093721_960_720.jpg'\n# load in content and style image\ncontent = load_image(content_image_).to(device)\n# Resize style to match content, makes code easier\nstyle = load_image(style_image_, shape=content.shape[-2:]).to(device)","9c670728":"# helper function for un-normalizing an image \n# and converting it from a Tensor image to a NumPy image for display\ndef im_convert(tensor):\n    \"\"\" Display a tensor as an image. \"\"\"\n    \n    image = tensor.to(\"cpu\").clone().detach()\n    image = image.numpy().squeeze()\n    image = image.transpose(1,2,0)\n    image = image * np.array((0.229, 0.224, 0.225)) + np.array((0.485, 0.456, 0.406))\n    image = image.clip(0, 1)\n\n    return image","937b564e":"# display the images\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))\n# content and style ims side-by-side\nax1.imshow(im_convert(content))\nax2.imshow(im_convert(style))","21a8f21a":"def get_features(image, model, layers=None):\n    \n    # Need the layers for the content and style representations of an image\n    if layers is None:\n        layers = {'0': 'conv1_1',\n                  '5': 'conv2_1', \n                  '10': 'conv3_1', \n                  '19': 'conv4_1',\n                  '21': 'conv4_2',  ## content representation\n                  '28': 'conv5_1'}\n        \n    features = {}\n    x = image\n    # model._modules is a dictionary holding each module in the model\n    for name, layer in model._modules.items():\n        x = layer(x)\n        if name in layers:\n            features[layers[name]] = x\n            \n    return features","da7b3574":"def gram_matrix(tensor):\n    \n    ## get the batch_size, depth, height, and width of the Tensor\n    _, d, h, w = tensor.size()\n    ## reshape it, so we're multiplying the features for each channel\n    tensor = tensor.view(d, h * w)\n    ## calculate the gram matrix\n    gram = torch.mm(tensor, tensor.t())\n    \n    return gram ","fcb03ca3":"# get content and style features only once before forming the target image\ncontent_features = get_features(content, vgg)\nstyle_features = get_features(style, vgg)\n\n# calculate the gram matrices for each layer of our style representation\nstyle_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}\n\n# create a third \"target\" image and prep it for change\n# it is a good idea to start off with the target as a copy of our *content* image\n# then iteratively change its style\ntarget = content.clone().requires_grad_(True).to(device)","4ce9f4fa":"# weights for each style layer \n# weighting earlier layers more will result in *larger* style artifacts\n# notice we are excluding `conv4_2` our content representation\nstyle_weights = {'conv1_1': 1.,\n                 'conv2_1': 0.75,\n                 'conv3_1': 0.2,\n                 'conv4_1': 0.2,\n                 'conv5_1': 0.2}\n\ncontent_weight = 1  # alpha\nstyle_weight = 1e6  # beta","cafabac4":"# for displaying the target image, intermittently\nshow_every = 400\n\n# iteration hyperparameters\noptimizer = optim.Adam([target], lr=0.003)\nsteps = 3000  # decide how many iterations to update your image (5000)\n\nfor ii in range(1, steps+1):\n    \n    # get the features from your target image\n    target_features = get_features(target, vgg)\n    \n    # the content loss\n    content_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)\n    \n    # the style loss\n    # initialize the style loss to 0\n    style_loss = 0\n    # then add to it for each layer's gram matrix loss\n    for layer in style_weights:\n        # get the \"target\" style representation for the layer\n        target_feature = target_features[layer]\n        target_gram = gram_matrix(target_feature)\n        _, d, h, w = target_feature.shape\n        # get the \"style\" style representation\n        style_gram = style_grams[layer]\n        # the style loss for one layer, weighted appropriately\n        layer_style_loss = style_weights[layer] * torch.mean((target_gram - style_gram)**2)\n        # add to the style loss\n        style_loss += layer_style_loss \/ (d * h * w)\n        \n    # calculate the *total* loss\n    total_loss = content_weight * content_loss + style_weight * style_loss\n    \n    # update your target image\n    optimizer.zero_grad()\n    total_loss.backward()\n    optimizer.step()\n    \n    # display intermediate images and print the loss\n    if  ii % show_every == 0:\n        print('Total loss: ', total_loss.item())\n        plt.imshow(im_convert(target))\n        plt.show()","8b3dcd8e":"# display content and final, target image\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20, 10))\nax1.imshow(im_convert(content))\nax2.imshow(im_convert(style))\nax3.imshow(im_convert(target))","a1ff82c0":"fig, ax = plt.subplots(figsize=(30,15))\nax.imshow(im_convert(target))","35868409":"from torchvision.utils import save_image\n\ntarget.shape \nimg1 = target \nsave_image(img1, 'img1.png')","5fd722f0":"## VGG19 Layers\n\nTo get the content and style representations of an image, you have to pass an image forward throug the VGG19 network until we get to the desired layer(s) and then get the output from that layer.\n\n![vgg19_convlayers.png](attachment:vgg19_convlayers.png)\n\n\n\n","b0d14123":"## Loss and Weights\n\nIndividual Layer Style Weights\n\nBelow, you are given the option to weight the style representation at each relevant layer. It's suggested that you use a range between 0-1 to weight these layers. By weighting earlier layers (conv1_1 and conv2_1) more, you can expect to get larger style artifacts in your resulting, target image. Should you choose to weight later layers, you'll get more emphasis on smaller features. This is because each layer is a different size and together they create a multi-scale style representation!\n\nContent and Style Weight\n\nwe define an alpha (content_weight) and a beta (style_weight). This ratio will affect how stylized your final image is. It's recommended that you leave the content_weight = 1 and set the style_weight to achieve the ratio you want.","f07c7de8":"### Load in Content and Style Images","3775ea07":"Next, I'm loading in images by file name and forcing the style image to be the same size as the content image.","5d20c2ee":"# Please consider upvote this notebook if you found it helpful!\n","92d2f4cb":"### Content and Style Features","d1ce9706":"## Save the target image","489aeaa0":"## Display the Target Image","1f55474c":"# Style Transfer with Deep Neural Networks\n\nStyle transfer relies on separating the content and style of an image. Given one content image and one style image, we aim to create a new, target image which should contain our desired content and style components:\n\n* objects and their arrangement are similar to that of the content image\n* style, colors, and textures are similar to that of the style image\n\nAn example is shown below, where the content image is of street, and the style image is of starry night. The generated target image still contains the cat but is stylized with the waves, blue and beige colors, and block print textures of the style image!\n\n![q.png](attachment:q.png)\n\n\n## How does it work?\n\nNeural style transfer is an optimization technique used to take three images, a content image, a style reference image (such as an artwork by a famous painter), and the input image you want to style \u2014 and blend them together such that the input image is transformed to look like the content image, but \u201cpainted\u201d in the style of the style image.\n\n\"it is possible to separate the style representation and content representations in a CNN, learnt during a computer vision task.\" \n\nFollowing this concept, First content and style features are extracted and stored. The style image **a** is passed through the network and its style representation **Al** on all layers included are computed and stored.The content image **p** is passed through the network and the content representation **Pl** in one layer is stored. Then a random white noise image **x** is passed through the network and its style features **Gl** and content features **Fl** are computed. On each layer included in the style representation, the element-wise mean squared difference between style features **Gl** and **Al** is computed to give the style loss **Ls**. \nAlso the mean squared difference between **Fl** and **Pl** is computed to give the content loss **Lc**. The total loss **Lt** is then a linear combination between the content and the style loss.Its derivative with respect to the pixel values can be computed using error back-propagation.This gradient is used to iteratively update the image **x** until it simultaneously matches the style features of the style image **a** and the content features of the content image **p**.\n\n# Lets code\n\n we'll use a pre-trained VGG19 Net to extract content or style features from a passed in image. We'll then formalize the idea of content and style losses and use those to iteratively update our target image until we get a result that we want. \n","4ba7b3a7":"## Gram Matrix\nThe output of every convolutional layer is a Tensor with dimensions associated with the batch_size, a depth, d and some height and width (h, w). The Gram matrix of a convolutional layer can be calculated as follows:\n\n* Get the depth, height, and width of a tensor using batch_size, d, h, w = tensor.size()\n* Reshape that tensor so that the spatial dimensions are flattened\n* Calculate the gram matrix by multiplying the reshaped tensor by it's transpose\n\nNote: You can multiply two matrices using torch.mm(matrix1, matrix2).","62d46e75":"## Putting it all Together\nNow that we've written functions for extracting features and computing the gram matrix of a given convolutional layer; let's put all these pieces together! We'll extract our features from our images and calculate the gram matrices for each layer in our style representation.","6c73a30c":"## Updating the Target & Calculating Losses\n\nYou'll decide on a number of steps for which to update your image, this is similar to the training loop that you've seen before, only i am changing my target image and nothing else about VGG19 or any other image. Therefore, the number of steps is really up to you to set! I recommend using at least 2000 steps for good results. But, you may want to start out with fewer steps if you are just testing out different weight values or experimenting with different images.\n\nInside the iteration loop, you'll calculate the content and style losses and update your target image, accordingly.\n\n### Content Loss\n\nThe content loss will be the mean squared difference between the target and content features at layer conv4_2. This can be calculated as follows: \n\n```\ncontent_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)\n```\n\n#### Style Loss\n\nThe style loss is calculated in a similar way, only you have to iterate through a number of layers, specified by name in our dictionary `style_weights`. \n> You'll calculate the gram matrix for the target image, `target_gram` and style image `style_gram` at each of these layers and compare those gram matrices, calculating the `layer_style_loss`. \n> Later, you'll see that this value is normalized by the size of the layer.\n\n#### Total Loss\n\nFinally, you'll create the total loss by adding up the style and content losses and weighting them with your specified alpha and beta!\n\nIntermittently, i will print out this loss; don't be alarmed if the loss is very large. It takes some time for an image's style to change and you should focus on the appearance of your target image rather than any loss value. Still, you should see that this loss decreases over some number of iterations.","7087f1aa":"# Load in VGG19 (features)\n\nVGG19 is split into two portions:\n\n* vgg19.features, which are all the convolutional and pooling layers\n\n* vgg19.classifier, which are the three linear, classifier layers at the end\n\nyou only need the features portion, which you're going to load in and \"freeze\" the weights of, below."}}