{"cell_type":{"3f5ab545":"code","811ce93f":"code","3bcec1b4":"code","8d330f80":"code","adf288d4":"code","a6fcaa6f":"code","4471f5c8":"code","8cfc0045":"code","944bb1f4":"code","e7f0a9bb":"code","16262da1":"code","fe341ee2":"code","46a8d436":"code","066a7aff":"code","f6b8a5e6":"code","49fc98a1":"markdown","0b7510b4":"markdown","db8b4ac1":"markdown","0653ed33":"markdown","4bc2b7b9":"markdown","cccdfc18":"markdown","dd2dc90c":"markdown","fe190844":"markdown","2ce1f69e":"markdown","46953d86":"markdown","816cf2ef":"markdown","fba9400b":"markdown","e80517cb":"markdown","48809520":"markdown","0dc98fdc":"markdown","6b94601f":"markdown","b8d47b2d":"markdown"},"source":{"3f5ab545":"import numpy as np\nimport pandas as pd\nimport os\nimport math\nimport sys\nfrom scipy import misc\nimport tensorflow as tf\nfrom skimage import img_as_float\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.callbacks import ReduceLROnPlateau,ModelCheckpoint\nfrom keras.layers import Dense,Dropout,Conv2D,MaxPooling2D,BatchNormalization,Input,UpSampling2D,Concatenate,Activation,Add,Flatten,Concatenate,Lambda,Reshape,AveragePooling2D\nfrom keras.models import Model\nfrom keras.models import load_model\nfrom keras.models import model_from_json\nfrom keras.optimizers import Adam\nimport keras.metrics\nimport matplotlib.pyplot as plt\nfrom keras import backend as K\n#from keras import Callback\nfrom sklearn.model_selection import train_test_split","811ce93f":"config = tf.ConfigProto()\njit_level = tf.OptimizerOptions.ON_1\nconfig.graph_options.optimizer_options.global_jit_level = jit_level\nsess = tf.Session(config=config)\ntf.keras.backend.set_session(sess)","3bcec1b4":"name_label_dict = {\n0:  'Nucleoplasm',\n1:  'Nuclear membrane',\n2:  'Nucleoli',\n3:  'Nucleoli fibrillar center',\n4:  'Nuclear speckles',\n5:  'Nuclear bodies',\n6:  'Endoplasmic reticulum',\n7:  'Golgi apparatus',\n8:  'Peroxisomes',\n9:  'Endosomes',\n10:  'Lysosomes',\n11:  'Intermediate filaments',\n12:  'Actin filaments',\n13:  'Focal adhesion sites',   \n14:  'Microtubules',\n15:  'Microtubule ends',  \n16:  'Cytokinetic bridge',   \n17:  'Mitotic spindle',\n18:  'Microtubule organizing center',  \n19:  'Centrosome',\n20:  'Lipid droplets',\n21:  'Plasma membrane',   \n22:  'Cell junctions', \n23:  'Mitochondria',\n24:  'Aggresome',\n25:  'Cytosol',\n26:  'Cytoplasmic bodies',   \n27:  'Rods & rings' }","8d330f80":"PATH = '..\/input\/'\nTRAIN = '..\/input\/dadada\/tdd\/train\/'\nTEST = '..\/input\/human-protein-atlas-image-classification\/test\/'\nLABEL = '..\/input\/ce-unet-1\/nntrain.csv'\nSAMPLE = '..\/input\/human-protein-atlas-image-classification\/sample_submission.csv'","adf288d4":"label = pd.read_csv(LABEL)","a6fcaa6f":"train_names = list(set('_'.join((f.split('_'))[:-1]) for f in os.listdir(TRAIN)))\ntest_names = list(set('_'.join((f.split('_'))[:-1]) for f in os.listdir(TEST)))","4471f5c8":"train_data, valid_data = train_test_split(train_names, test_size=0.1, random_state=42)","8cfc0045":"def open_rgby(path,pid): #a function that reads RGBY image\n    colors = ['red','green','blue','yellow']\n    tmp = np.zeros(shape=(512,512,4))\n    for i,color in enumerate(colors) :\n        tmp[:,:,i] = img_as_float(misc.imread(os.path.join(path, str(pid)+'_'+color+'.png')))\n    return tmp","944bb1f4":"def generator(train,label,batch_size) :\n    batch_features = np.zeros((batch_size,512,512,4))\n    batch_labels = np.zeros((batch_size,28))\n    while True :\n        for i in range(batch_size) :\n            idx= np.random.choice(len(train),1)[0]\n            batch_features[i,:,:,:] = open_rgby(TRAIN,train[idx])\n            temp = set([int(i) for i in (label.loc[label['Id']==train[idx]]['Target'].values[0]).split()])\n            batch_labels[i,:] =  np.array([1 if i in temp else 0 for i in range(28)])\n        \n        out = {'main':batch_labels,'encoder':batch_features}\n        yield batch_features,out","e7f0a9bb":"def progressbar(name,i,n):    \n    sys.stdout.write('\\r')\n    sys.stdout.write(name+\": [%-20s] %d%% %d\/%d\" % ('=' * int(20. * (i + 1) \/ n - 1) + '>',\n                                                    int(100. * (i + 1) \/ n) , i,n))\n    sys.stdout.flush()","16262da1":"def padding(tensor,h,w,r):\n    return tf.pad(tensor, tf.constant([[0,0],[h,h], [w,w],[r,r]]), \"CONSTANT\")\n","fe341ee2":"model = load_model('..\/input\/ce-unet-2\/ce_Unet_save28.h5')","46a8d436":"epoch = 4\nhistory = model.fit_generator(generator(train_data,label,4), \n                                  samples_per_epoch=len(train_data)\/\/4, epochs=epoch,\n                                  validation_data=generator(valid_data,label,4),\n                                  validation_steps=len(valid_data)\/\/4,\n                                  callbacks=[ModelCheckpoint('mymodel_valid.h5',monitor='val_loss',save_best_only=True),\n                                  ReduceLROnPlateau(monitor='val_loss',patience=3)])\nmodel.save('ce_Unet_save32.h5')","066a7aff":"model.save('ce_Unet_save32.h5')","f6b8a5e6":"plt.plot(history.history['main_loss'])\nplt.plot(history.history['val_main_loss'])\nplt.savefig(\"ce_Unet_loss_history.png\")","49fc98a1":"thres = [e[1]\/e[0]*0.98 for e in cal]\nprint(thres)","0b7510b4":"pdf = pd.DataFrame(data = {'Id':o,'Target':m,\n                          0:pred[0],1:pred[1],2:pred[2],3:pred[3],\n                          4:pred[4],5:pred[5],6:pred[6],7:pred[7],\n                          8:pred[8],11:pred[11],9:pred[9],10:pred[10],\n                          12:pred[12],13:pred[13],14:pred[14],15:pred[15],\n                          16:pred[16],17:pred[17],18:pred[18],19:pred[19],\n                          20:pred[20],21:pred[21],22:pred[22],23:pred[24],\n                          24:pred[24],25:pred[25],26:pred[26],27:pred[27]\n                          })\npdf = pdf.sort_values(by = ['Id'])","db8b4ac1":"out = []\nbatch_features = np.zeros((1,512,512,4))\ntest_len = len(test_names)\npred = np.zeros((test_len,28))\nfor k in range(test_len):\n    batch_features[:,:,:,:] = open_rgby(TEST,test_names[k])\n    pred[k],l = model.predict(batch_features)\n    \n    outli=''\n    for j in range(28):\n        if(pred[k][j]>thres[j]): \n            outli+=(str(j)+\" \")\n    out.append(outli.strip())\n    progressbar('test predict',k,test_len)","0653ed33":"inp = Input(shape=(512,512,4))\nx = Conv2D(64,(3,3),padding='same')(inp)#256\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nenc1 = MaxPooling2D((2,2),padding='same')(x)\nx = Conv2D(32,(3,3),padding='same')(enc1)#128\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nenc2 = MaxPooling2D((2,2),padding='same')(x)\nx = Conv2D(16,(3,3),padding='same')(enc2)#64\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nenc3 = MaxPooling2D((2,2),padding='same')(x)\nx = Conv2D(16,(3,3),padding='same')(enc3)\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nx = UpSampling2D((2,2))(x)\nx = Conv2D(32,(3,3),padding='same')(x)\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nx = UpSampling2D((2,2))(x)\nx = Conv2D(64,(3,3),padding='same')(x)\nx = BatchNormalization()(x)\nx = Activation('relu')(x)\n\nx = UpSampling2D((2,2))(x)\ndecoder = Conv2D(4,(3,3),activation='sigmoid',padding='same',name='encoder')(x)\n\npadded0 = Lambda(lambda t: padding(t,0,0,30))(inp)\npadded1 = Lambda(lambda t: padding(t,128,128,0))(enc1) #256,256,64\npadded2 = Lambda(lambda t: padding(t,192,192,16))(enc2) #128,128,32\npadded3 = Lambda(lambda t: padding(t,224,224,24))(enc3) #64,64,16\n\nadd = Concatenate()([padded0,padded1,padded2,padded3])\navg = AveragePooling2D((64,64))(add)\nflat = (Flatten())(avg)\ndense1 = (Dense(128, activation='relu'))(flat)\ndense2 = (Dense(64, activation='relu'))(dense1)\nout = (Dense(28, activation='sigmoid',name='main'))(dense2)\n\nmodel = Model(inputs=inp,outputs=[out,decoder])","4bc2b7b9":"pred = (pred).T","cccdfc18":"batch_features = np.zeros((1,512,512,4))\no = []\nm=[]\ntrain_len = len(train_names)\npred = np.zeros((train_len,28))\nfor k in range(train_len):\n    batch_features[:,:,:,:] = open_rgby(TRAIN,train_names[k])\n    pred[k],l = model.predict(batch_features)\n    o.append(train_names[k])\n    m.append(label.loc[label['Id']==o[k],'Target'].values[0])\n    progressbar('thres find',k,train_len)","dd2dc90c":"pdf.mean()","fe190844":"pdf = pd.DataFrame(data = {'Id':test_names,\n                          0:pred[0],1:pred[1],2:pred[2],3:pred[3],\n                          4:pred[4],5:pred[5],6:pred[6],7:pred[7],\n                          8:pred[8],11:pred[11],9:pred[9],10:pred[10],\n                          12:pred[12],13:pred[13],14:pred[14],15:pred[15],\n                          16:pred[16],17:pred[17],18:pred[18],19:pred[19],\n                          20:pred[20],21:pred[21],22:pred[22],23:pred[24],\n                          24:pred[24],25:pred[25],26:pred[26],27:pred[27]\n                          })\npdf = pdf.sort_values(by = ['Id'])\npdf.head()","2ce1f69e":"pdf.to_csv('c_unet_32_raw'+\".csv\", header=True, index=False)","46953d86":"model.compile(optimizer=Adam(),\n              loss={'main':'binary_crossentropy','encoder':'mse'},\n              loss_weights={'main':1,'encoder':0.4},\n              metrics=['acc'])","816cf2ef":"model = load_model('..\/input\/c_Unet_pc\/c_Unet_save.h5',\n                   custom_objects={'padding': padding})","fba9400b":"df = pd.DataFrame(data = {'Id':test_names,'Predicted':out})\ndf = df.sort_values(by = ['Id'])\ndf.head()","e80517cb":"thres = [0.7332285743126011, 0.5805582254419689, 0.6830990579013652, 0.33133608226415084, 0.5892030431602163, \n         0.33554810233834226, 0.30124813610105283, 0.48676254640934774, 0.05069314378334587, 0.07186778056655506,\n         0.07550342306674565, 0.27888409512220735, 0.13545893820158397, 0.16009892984130975, 0.7817713042352804, \n         0.0065349138485544245, 0.04680300266810713, 0.22093092964865113, 0.2273163021918054, 0.30589077523285696,\n         0.07060120899301446, 0.4474626562126171, 0.14693263627129444, 0.002407802767594962, 0.22767899205469075, \n         0.5782695626512265, 0.09819474722240953, 0.10218797941007664]","48809520":"df.to_csv('c_unet_32'+\".csv\", header=True, index=False)","0dc98fdc":"cal=np.zeros((28,2))\nfor index, row in pdf.iterrows():\n    t  = row['Target'].split()\n    for e in t:\n        cal[int(e)][1]+=row[int(e)]\n        cal[int(e)][0]+=1","6b94601f":"pred = (pred).T","b8d47b2d":"cal"}}