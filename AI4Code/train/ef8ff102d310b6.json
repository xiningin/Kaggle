{"cell_type":{"8eb12be9":"code","fc840059":"code","25b82974":"code","a06958c0":"code","a36b0edb":"code","f89876c3":"code","04a89fa4":"code","118bc959":"code","f976b587":"code","a4cb682e":"code","b4e52d4d":"code","97d7e790":"code","4f28e6d0":"code","6a4ab85d":"code","9025c627":"code","58cad0c6":"code","e542f8e0":"code","eba8c553":"code","9f97a3b4":"code","dd33b525":"code","2c0607ee":"code","5852523a":"code","90a19d31":"markdown","153eceeb":"markdown","2bade0c1":"markdown","0368a3c3":"markdown","1c66cf43":"markdown","90aa0072":"markdown","9333bfa7":"markdown","ed8648ce":"markdown","f6f17ae1":"markdown"},"source":{"8eb12be9":"import shapely.geometry as shg\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\n\nrcParams['figure.figsize'] = 8, 8 #makes our plots bigger!\n\ndef areasign(tri):\n    \"\"\"Finds the sign of the area of a closed triangle\n\n    Parameters\n    ----------\n    tri : List\n        List of coordinate tuples in the format\n        [(x, y), (x, y). (x, y), (x, y)]\n        First and last vertex are the same\n    \n    Returns\n    -------\n    int (-1, 1, 0)\n        -1 if the triangle is encoded clockwise\n        1  if the triangle is encoded anti-clockwise\n        0  if the coordinates are a 1d line\n    \"\"\"\n    sumarea = 0\n    for i in range(0, len(tri)-1):\n        xi = tri[i][0]\n        yi = tri[i][1]\n        xj = tri[i+1][0]\n        yj = tri[i+1][1]\n        sumarea = sumarea + ((xi*yj)-(yi*xj))\n        \n    if sumarea == 0: return 0\n    if sumarea < 0:  return -1\n    if sumarea > 0:  return 1\n\ndef create_triangle(test_pt, line_seg):\n    \"\"\" Creates a closed triangle from a test point and a line segment\n    \n    Parameters\n    ----------\n    test_pt : the test point in the format (x, y)\n    line_seg: the line segment in the format [(x, y), (x, y)]\n    \n    Returns\n    -------\n    A triangle consisting of 4 coordinate tuples\n    \"\"\"\n    tri = line_seg.copy()\n    \n    tri.insert(0, test_pt)\n    tri.append(test_pt)\n    \n    return tri\n\ndef line_intersection(line1, line2):\n    \"\"\" Tests whether 2 line segments intersect\n    \n    Parameters\n    ----------\n    line1 : the first line segment in the format [(x, y), (x, y)]\n    line2 : the second line segment in the format [(x, y), (x, y)] \n    \n    Returns\n    -------\n    True if the segmenets intersect,otherwise False\n    \"\"\"\n    \n    #create 4 triangles from the\n    #start and end points of each line and the other line\n    tri1 = create_triangle(line2[0], line1)\n    tri2 = create_triangle(line2[1], line1)\n    tri3 = create_triangle(line1[0], line2)\n    tri4 = create_triangle(line1[1], line2)\n    \n    #Calculate the signs of the  areas of these triangles\n    tri1sign = areasign(tri1)\n    tri2sign = areasign(tri2)\n    tri3sign = areasign(tri3)\n    tri4sign = areasign(tri4)\n    \n    #if the signs are not equal then the lines intersect\n    if ((tri1sign != tri2sign) and (tri3sign != tri4sign)):\n        return True\n    else:\n        return False","fc840059":"# A polygon\np = [(1.0, 1.0), (1.0, 5.0), (5.0, 5.0), (5.0, 1.0), (1.0, 1.0)]\n\n#the test point\ntest_pt = (3, 3)\n\n","25b82974":"# This point lies INSIDE the polygon\nxy = list(zip(*p))\nplt.plot(xy[0], xy[1])\nplt.plot(test_pt[0], test_pt[1], 'ro')\n","a06958c0":"#A halfline is a line segment from our test point to infinity\n#infinity is hard to we just pick a big number\n\nhalf_line = [test_pt, (1000000, 1000001)] \n\n#Why 1000001?\n\n","a36b0edb":"# The half line (truncated here!)\nxy = list(zip(*p))\nplt.plot(xy[0], xy[1])\nplt.plot(test_pt[0], test_pt[1], 'ro')\nplt.plot([3, 25], [3, 26], 'g-')\nplt.text (15, 15, s=\"half line\", rotation = 45, fontsize = 15)","f89876c3":"# To iterate over a polygon we use a loop\n# You might recognise this - it is the same code as as in the Area and Areasign functions\nprint(p)\ncounter = 1\nfor i in range(len(p)-1):\n    print ('Line segment {} is ({}, {})'.format(counter, p[i], p[i+1]))\n    counter = counter + 1","04a89fa4":"10 % 2","118bc959":"10 % 3","f976b587":"11 % 2","a4cb682e":"100 % 2","b4e52d4d":"# Skeleton code for Point in Polygon function\n\n\"\"\"\ndef pointinpolygon(pt, poly):\n    #Create a half-line from the test point to infinity (or big number)\n    \n    #set a counter to 0\n    \n    #loop over the polygon\n        #for each line segment check line intersection\n        #if it intersects add to the counter\n    \n    #check the modulus of counter\n    #if zero return False, otherwise return True\n\"\"\"    ","97d7e790":"from shapely import wkt\nlist_of_polygons = []   #to store the polygons we read in our format\n\nf = open ('..\/input\/vector\/test_polygons1.txt') #Open the file (mine is stored in the subfolder vector)\n\n#iterate over the file\nfor each_line in f: \n    poly = wkt.loads(each_line)           #read WKT format into a Polygon (it recognises the type)\n    print(list(poly.exterior.coords))     #use coords to generate lists in our format\n    list_of_polygons.append(list(poly.exterior.coords))         #add the polygon to our list of polygons\n","4f28e6d0":"display(list_of_polygons)","6a4ab85d":"# And we can do the same with points\n\nlist_of_points = []   #to store the polygons we read in our format\n\nf = open ('..\/input\/vector\/test_points1.txt') \n\n#iterate over the file\nfor each_line in f: \n    pt = wkt.loads(each_line)           \n    print(list(pt.coords))     \n    list_of_points.append(pt.coords[0])  #So we get a list of coordinates","9025c627":"display(list_of_points)","58cad0c6":"#Let's see what we have\n\nfor poly in list_of_polygons:\n    xy = list(zip(*poly))\n    plt.fill(xy[0], xy[1], alpha=0.5)\n    \nfor pt in list_of_points:\n    #print(pt)\n    plt.plot(pt[0], pt[1], 'bx', ms=12)","e542f8e0":"for poly in list_of_polygons:\n    for pt in list_of_points:\n        res = pointinpolygon(pt, poly)\n        #print(res)\n        shppoly = shg.Polygon(poly)\n        shppt = shg.Point(pt)\n        print(res, shppoly.contains(shppt))\n    ","eba8c553":"import fiona                             #a library that reads spatial formats\nfrom shapely.geometry import shape\n\nshapefile_polygons = []                  #a list to store the polygons we load\n\n\nc = fiona.open('..\/input\/shapefiles\/test_polygon_shapefile.shp') #Open the shapefile\n\nfor each_poly in c:\n    geom = shape(each_poly['geometry'])\n    poly_data = each_poly[\"geometry\"][\"coordinates\"][0]  #EXTERIOR RING ONLY\n    poly = shg.Polygon(poly_data)\n    print(poly)\n    #Converts into the same format as the other data\n    shapefile_polygons.append(list(poly.exterior.coords))\n\ndisplay(shapefile_polygons)\n","9f97a3b4":"# And read the points from a shapefile\nshapefile_points = []\n\nc = fiona.open('..\/input\/shapefiles\/test_point_shapefile.shp')\n\nfor each_pt in c:\n    geom = shape(each_pt['geometry'])\n    pt_data = each_pt[\"geometry\"][\"coordinates\"]\n    pt = shg.Point(pt_data)\n    print(pt)\n    shapefile_points.append(pt.coords[0])\n\ndisplay(shapefile_points)","dd33b525":"# and we can plot these out\nplt.gca().set_aspect('equal', adjustable='box')  #To make the x and y axis the same scale\n\nfor poly in shapefile_polygons:\n    xy = list(zip(*poly))\n    plt.fill(xy[0], xy[1], alpha=0.5)\n    \nfor pt in shapefile_points:\n    plt.plot(pt[0], pt[1], 'bx', ms=12)","2c0607ee":"import folium\nimport geopandas as gpd\n\n#read the files using geopandas\npolys=gpd.read_file('..\/input\/shapefiles\/test_polygon_shapefile.shp')\npoints = gpd.read_file('..\/input\/shapefiles\/test_point_shapefile.shp')\n\n#Find the centroid to position the map\ncentroidp = polys.geometry.centroid \n#Convert from CRS British national grid to WGS84\nwgspolys = polys.to_crs(\"EPSG:4326\").to_json()\nwgspoints = points.to_crs(\"EPSG:4326\").to_json()\nwgscentre = centroidp.to_crs(\"EPSG:4326\")\n\nlong = wgscentre.x\nlat = wgscentre.y\n\n#Find spatial mean\nlong = long.mean()\nlat = lat.mean()\n\n#Plot it\nmymap = folium.Map(location=[lat, long], tiles='openstreetmap', zoom_start=13)\nplotpoly =folium.features.GeoJson(wgspolys)\nplotpts = folium.features.GeoJson(wgspoints)\nmymap.add_child(plotpoly)\nmymap.add_child(plotpts)","5852523a":"for poly in list_of_polygons:\n    for pt in list_of_points:\n        res = pointinpolygon(pt, poly)\n        print(res)","90a19d31":"# Point in Polygon\nIn this notebook we\n1. Create a half-line to test point in polygon\n2. Look at how we iterate over a polygon to extract line segments\n3. Create the skeleton of a test for Point in Polygon using line intersection\n4. Copy polygon data files from Canvas and load into Kaggle\n5. Read polygon data from a file\n6. Read a point data from a file\n7. Read Polygon and Point data from Shapefiles","153eceeb":"# READING POLYGON DATA FROM A FILE\n\ntest_polygons1.txt looks like this\n\nPOLYGON((1 1,1 5,5 5,5 1,1 1))\n\nPOLYGON((30 10,40 40,20 40,10 20,30 10))\n\nPOLYGON((2 1,1 4,4 5,3 4,6.5 4,6 5,8.5 2.5,2 1))\n\nThis is a format called Well Known Text - you can find out more here:\n\n[Well Known Text - External Link](https:\/\/en.wikipedia.org\/wiki\/Well-known_text_representation_of_geometry)\n\nThe type of geoemtry comes first, then 2 brackets if a polygon and then x, y pairs are separated by commas.  X andY coordinates are separated by a space.\n\nWe want to convert that into a bunch of polygons in our format eg: \n\n[(1.0, 1.0), (1.0, 5.0), (5.0, 5.0), (5.0, 1.0), (1.0, 1.0)]\n\nTo do this we will use the SHAPELY library that reads WKT","2bade0c1":"# TO DO\n\n1. Complete the Point in Polygon function using the skeleton supplied above\n2. Test the function using simple polygons and test points\n3. Using the code and test data supplied test all the points in the WKT file against the polygon data in WKT\n4. Repeat this for the Shapefile data\n   1. You will need an external loop that manages the points\n   2. And an internal loop that manages the polygons\n   3. Passing a pt and a polygon to the function in turn eg.\n   \n       \n       for pt in points:\n           for poly in polygons:\n               result = point_in_poly(pt, poly)\n            \n5. Devise additional test data to REPORT ON the degenerative cases of the algorithm (when it doesn't work correctly)\n\nYou will need to think about how you convey your results (tables, plots) etc.  You may want to label them in outputs.  Finally, you will need to write a brief report (in Word) that states the problem, the solution, the testing and reports on the degenerative cases.","0368a3c3":"# You should\n1. Copy over the functions for areasign, creating triangles and line intersection created earlier\n2. Follow this notebook to understand core concepts\n3. Complete the Point in Polygon function\n4. Devise any additional test data for your assignment\n5. Complete the report and submit","1c66cf43":"# Fancy plotting those on a real map","90aa0072":"# Is it odd or even?\n\nAny ideas?","9333bfa7":"# So now we have list of points and polygons and we iterate over them to test point in polygon\n# Finally we will load points and polygons from a shapefile and do the same\n\nYou will need to load these 4 files for each shapefile\n* The SHP file\n* the SHX file (the index)\n* the DBF file (the attributes)\n* the prj file (the Projection information)\n\n![image.png](attachment:image.png)","ed8648ce":"# TO TEST POINT in POLYGON WE NEED\n1. Iterate over the polygon\n2. Test each line segment in turn\n3. If there is an intersect then add one to a counter\n4. Test if the sum of intersections is odd or even","f6f17ae1":"The modulus operator \"%\" returns the remainder after integer division 10 \/\/ 3 would give 3 **REMAINDER** 1\n\nIf the modulus of our number and 2 is zero then the number is even\n\nIf the modulus of our number and 2 is 1 then the number is odd\n\nsimples!"}}