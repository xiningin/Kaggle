{"cell_type":{"af257160":"code","190292cb":"code","2f70455d":"code","bd1c7a58":"code","844f2da9":"code","b23bd28e":"code","b063641c":"code","4ca1ccd5":"code","2f40ae54":"code","75758a6f":"code","9df5ac35":"code","deaaa660":"code","f2d5ada3":"code","0f607a80":"code","568f6ad4":"code","d6992fc9":"markdown","8fa98432":"markdown","d3c8c126":"markdown","0e721a29":"markdown","3f164f3f":"markdown","b8d61b2a":"markdown","d26d492d":"markdown","be819b1c":"markdown","c6001c03":"markdown"},"source":{"af257160":"import pandas as pd \nimport numpy as np\nfrom folium.plugins import TimestampedGeoJson,MarkerCluster \ndata=pd.read_csv('..\/input\/Sangam_2019_Hackathon_Data.csv')","190292cb":"import folium\nfrom folium.plugins import TimestampedGeoJson\nimport branca\n\ndef make_map(features,color_man,caption='Temperature For Stations',period='H',f_name='temperature'):\n    print('> Making map...')\n    m = folium.Map(\n    location=[28.457912,77.033994],\n    zoom_start=9,\n    tiles='openstreetmap')\n    if period=='H':\n        TimestampedGeoJson(\n        {'type': 'FeatureCollection',\n        'features': features}\n        , period='PT1H'\n        , add_last_point=True\n        , auto_play=True\n        , loop=False\n        , max_speed=1000\n        , loop_button=True\n        , date_options='YYYY\/MM\/DD HH:MM'\n        , time_slider_drag_update=True\n        ).add_to(m)\n    if period=='D':\n        TimestampedGeoJson(\n        {'type': 'FeatureCollection',\n        'features': features}\n        , period='P1D'\n        , add_last_point=True\n        , auto_play=True\n        , loop=True\n        , max_speed=1000\n        , loop_button=True\n        , date_options='YYYY\/MM\/DD'\n        , time_slider_drag_update=True\n        ).add_to(m)\n        \n        \n        \n    m.fit_bounds(m.get_bounds())\n    \n    color_man.caption = \"{} \".format(f_name)\n    m.add_child(color_man)    \n    print('> Done.')\n    return m\n\n\n\ndef create_geojson_features(df,colorer,feature_name='temperature'):\n    print('> Creating GeoJSON features...')\n    \n    features = []\n    print(colorer)\n    for _, row in df.iterrows():\n        feature = {\n            'type': 'Feature',\n            'geometry': {\n                'type':'Point', \n                'coordinates':[row['longitude'],row['latitude']]\n            },\n            'properties': {\n                'time': row['date_str'],\n                'style': {'color' : colorer(row[feature_name])},\n                'icon': 'circle',\n                'iconstyle':{\n                    'fillColor': colorer(row[feature_name]),\n                    'fillOpacity': 0.8,\n                    'stroke': 'true',\n                    'radius': 16\n                }\n            }\n        }\n        features.append(feature)\n    return features\n\n\ndef questionb1(data=None,frame_level='H',\\\n               device_list=['S3','S5', 'S3', 'S4', 'S1','S10', 'S8', 'S9', 'S6', 'S7'],\\\n               feature_col_name='temperature',\\\n              min_value=25,max_value=38,\n              c_platter=None \n              ):\n    \n    if c_platter is None:\n        colorscale_paletter = branca.colormap.linear.RdBu_09.scale(vmin=min_value,vmax=max_value)\n    else :\n        colorscale_paletter=c_platter\n    if frame_level=='H':\n        data['date_str']=data.svrtime.apply(lambda x :x.split(':')[0]+':00')\n        date_format='YYYY\/MM\/DD HH:MM'\n    if frame_level=='D':\n        data['date_str']=data.svrtime.apply(lambda x :x.split(' ')[0])\n        date_format='YYYY\/MM\/DD HH:MM'\n    temp=data.loc[data.device_id.isin(device_list) & (data.latitude>10) & (data.longitude>50) &(data.latitude<39) ]\\\n    .groupby(by=['device_id','date_str'],as_index=False).agg({'latitude':'mean','longitude':'mean',feature_col_name:'mean'})\n    print(\"Make sure the min and max are proptional for the series {} , the maxium minimum after aggregation is {} , {} we are using vmin {} vmax={} \\n quantiles are {}\"\\\n          .format(feature_col_name,temp[feature_col_name].max(),temp[feature_col_name].min(),min_value,max_value,temp[feature_col_name].quantile([0,0.25,0.5,0.75,0.9])))\n    \n    #print(temp.head())\n    features_collected=create_geojson_features(temp,feature_name=feature_col_name,colorer=colorscale_paletter)\n    #print(features_collected[0:100])\n    mapped=make_map(features=features_collected,color_man=colorscale_paletter,period=frame_level,f_name=feature_col_name)\n    return mapped\n    \n    ","2f70455d":"test_map=questionb1(data,'H',feature_col_name='temperature')\ntest_map","bd1c7a58":"test_map2=questionb1(data,'H',device_list=['M1','M2'],feature_col_name='humidity',max_value=34)\ntest_map2","844f2da9":"test_map3=questionb1(data,'H',device_list=['M1','M2'],feature_col_name='pm01',max_value=44,min_value=13)\ntest_map3","b23bd28e":"test_map4=questionb1(data,'H',device_list=['M1','M2'],feature_col_name='pm25',max_value=55,min_value=8)\ntest_map4","b063641c":"test_map4=questionb1(data,'H',device_list=['S1','S2'],feature_col_name='pm01',max_value=44,min_value=13)\ntest_map4","4ca1ccd5":"data.head().T","2f40ae54":"data['date_str']= data.svrtime.apply(lambda x:x.split(' ')[0])","75758a6f":"data.columns","9df5ac35":"\ndef get_aqi(row):\n    ##\n    #print(row)\n    pm10,pm25,no2,co,nh3=row['pm10'],row['pm25'],row['no2'],row['co'],row['nh3']\n    pm10_res=0\n    pm25_res=0\n    no2_res=0\n    co_res=0\n    nh3_res=0\n    \n    \n    if(pm10<=50):\n        pm10_res=0\n    elif (pm10<=100):\n        pm10_res=1\n    elif (pm10<=250):\n        pm10_res=2\n    elif (pm10<=350):\n        pm10_res=3\n    elif (pm10<=430):\n        pm10_res=4\n    else:\n        pm10_res=5\n    \n    \n    if(pm25<=30):\n        pm25_res=0\n    elif (pm25<=60):\n        pm25_res=1\n    elif (pm25<=90):\n        pm25_res=2\n    elif (pm25<=120):\n        pm25_res=3\n    elif (pm25<=250):\n        pm25_res=4\n    else:\n        pm25_res=5\n    if(no2<=40):\n        no2_res=0\n    elif (no2<=80):\n        no2_res=1\n    elif (no2<=180):\n        no2_res=2\n    elif (no2<=280):\n        no2_res=3\n    elif (no2<=400):\n        no2_res=4\n    else:\n        no2_res=5\n\n    if(co<=1):\n        co_res=0\n    elif (co<=2):\n        co_res=1\n    elif (co<=10):\n        co_res=2\n    elif (co<=17):\n        co_res=3\n    elif (co<=34):\n        co_res=4\n    else:\n        co_res=5\n    if(nh3<=200):\n        nh3_res=0\n    elif (nh3<=400):\n        nh3_res=1\n    elif (nh3<=800):\n        nh3_res=2\n    elif (nh3<=1200):\n        nh3_res=3\n    elif (nh3<=1800):\n        nh3_res=4\n    else:\n        nh3_res=5\n\n    aqi=np.max(np.array([nh3_res,co_res,no2_res,pm25_res,pm10_res]))\n    result={0:'Good',1:'Satisfactory',2:'Moderately polluted',3:'Poor',4:'Very Poor',5:'Severe'}\n    #print(aqi)\n    return aqi\n    return result[aqi]\n\n\n\n\n\ndef aqi_plot(df=data,dev_list=['S3','S5', 'S3', 'S4', 'S1','S10', 'S8', 'S9', 'S6', 'S7']):\n    temp=df.loc[data.device_id.isin(dev_list) & (data.latitude>10) & (data.longitude>50) &(data.latitude<39)]\\\n    .groupby(by=['date_str','device_id','latitude','longitude'],as_index=False).agg(\\\n    {'pm10':'mean','pm25':'mean','no2':'mean','co':'mean','nh3':'mean'})\n    temp['date_str']=temp['date_str'].apply(lambda x:x.split(' ')[0])\n    temp['aqi']=temp[['pm10', 'pm25', 'no2','co', 'nh3']].apply(lambda row:get_aqi(row).astype(float),axis=1)\n    colorscale = branca.colormap.linear.YlOrRd_05.to_step(n=6,data=[0,1,2,3,4,5])\n    feat=create_geojson_features(temp,colorer=colorscale,feature_name='no2')\n    temp['svrtime']=temp.date_str.apply(lambda x : '{} 00:00:00'.format(x))\n    return questionb1(data=temp,frame_level='D',device_list=dev_list,feature_col_name='aqi',min_value=0,max_value=5,c_platter=colorscale)\n    ","deaaa660":"aqi_plot()","f2d5ada3":"from sklearn.preprocessing import LabelEncoder\ndef make_clust_plot(df=data,dev_list=['S3','S5', 'S3', 'S4', 'S1','S10', 'S8', 'S9', 'S6', 'S7'],max_value=40,min_value=24,feature_name='temperature'):\n    temp=df.loc[data.device_id.isin(dev_list) & (data.latitude>10) & (data.longitude>50) &(data.latitude<39)]\\\n    .groupby(by=['date_str','device_id','latitude','longitude'],as_index=False).agg(\\\n    {feature_name:'mean'})\n    temp['date_str']=temp['date_str'].apply(lambda x:x.split(' ')[0])\n    colorscale = branca.colormap.linear.YlOrRd_05.scale(min_value,max_value)\n    device_id_encode=LabelEncoder().fit_transform(temp.device_id)\n    print(temp.device_id.nunique())\n    colorscale_rind = branca.colormap.linear.GnBu_05.to_step(n=temp.device_id.nunique()+1,data=device_id_encode)\n\n    print('> >  >> > > > >> > > Making map > > > > > >> > > >> >> > >')\n    print(\"Make sure the min and max are proptional for the series {} , the maxium minimum after aggregation is {} , {} we are using vmin {} vmax={} \\n quantiles are {}\"\\\n          .format(feature_name,temp[feature_name].max(),temp[feature_name].min(),min_value,max_value,temp[feature_name].quantile([0,0.25,0.5,0.75,0.9])))\n    \n    \n    m = folium.Map(\n    location=[28.457912,77.033994],\n    zoom_start=9,\n    tiles='openstreetmap')##tiles='Cartodb Positron'\n    \n    marker_cluster = MarkerCluster(\n        name='Stations',\n        overlay=True,\n        control=False,\n        icon_create_function=None\n    )\n    print(temp.shape)\n    for k in range(temp.shape[0]):\n        location = temp.latitude[k], temp.longitude[k]\n        \n        \n        marker = folium.CircleMarker(location=location,color=colorscale_rind(device_id_encode[k]) ,\\\n                                     fill_opacity=0.7,\\\n                                     fill_color=colorscale(temp.values[k,4]),fill=True)\n        popup = 'lon:{} lat:{} <br> {} = {} <br>device_id {}'.format(location[1], location[0],feature_name,temp.values[k,4],temp.device_id[k])\n        folium.Popup(popup).add_to(marker)\n        marker_cluster.add_child(marker)\n        \n    marker_cluster.add_to(m)\n    \n    #folium.LayerControl().add_to(m)\n    colorscale.caption = \"Geo Spatial clustering for {} \".format(feature_name)\n    m.add_child(colorscale)  \n    return m\n","0f607a80":"r=make_clust_plot(feature_name='pm25',dev_list=['S3','S2'],max_value=36,min_value=30)\nr","568f6ad4":"q=make_clust_plot(feature_name='humidity',dev_list=['M2'],max_value=36,min_value=30)\nq","d6992fc9":"# Spatial Temporal variation of PM01","8fa98432":"# Air QUALITY INDEX PLOT","d3c8c126":"### AQI","0e721a29":"# Geo Spatial Temporal trend - Temperature","3f164f3f":"# Spatial Temporal variation of PM10","b8d61b2a":"### O3 concerntration is missing which is needed to determine the air quality index \n### So2 concerntration should be calculated via s02_gas paramter","d26d492d":"# Clustering close by GPS sensors on spatial data","be819b1c":"# Spatial Temporal Variation of PM2.5\n\n\n","c6001c03":"# Spatial Temporal Variation of Humidity"}}