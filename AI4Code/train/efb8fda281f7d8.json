{"cell_type":{"cf048bd2":"code","5a8a8383":"code","92efd0e7":"code","7fc80273":"code","f67cbf60":"code","44d87367":"code","8f5993a9":"code","292062f7":"code","cb24e34e":"code","02d14ff8":"code","3a556d19":"code","c6b7d30e":"code","f38898b3":"code","fa50bf01":"code","f67197ae":"code","87351b1c":"code","56c8d922":"code","44107b1d":"code","6e916b3a":"code","8c96371f":"code","5033bca0":"code","0a9d29dd":"code","75bb0ca5":"code","6d4fbfe0":"code","e82140b5":"code","25e30c6d":"code","0e9c46ec":"code","6d185be9":"code","308616af":"markdown","ae713776":"markdown","45edb0ac":"markdown","24b609de":"markdown","c3f40656":"markdown","f8db545f":"markdown","2aed05fd":"markdown","79f62788":"markdown","407a999d":"markdown","ed51c905":"markdown","708214b9":"markdown","a3a509df":"markdown","d1f94786":"markdown","f7df9f82":"markdown","3b61b237":"markdown","849ee570":"markdown","af99aeb2":"markdown","709142bb":"markdown","e5b8539e":"markdown","d299b579":"markdown","3b36129a":"markdown","5f09317f":"markdown","599b032a":"markdown","39b86a8e":"markdown","a4a65284":"markdown","bb29e294":"markdown","cda38709":"markdown","4c2ab84b":"markdown","3ecd53b8":"markdown","ba4aa1a6":"markdown","080d4c11":"markdown","470da133":"markdown","eb8ad387":"markdown","e9b22877":"markdown","933d4e21":"markdown","53b02fe0":"markdown","e63dfc42":"markdown","a700a7e3":"markdown","44ad50e0":"markdown","f586be66":"markdown","4713d872":"markdown","5ee8ba1a":"markdown","39a2654f":"markdown","c3ae0d6a":"markdown","5670cbb5":"markdown","69f193a8":"markdown","64bdfd16":"markdown","649a240e":"markdown","81c8572a":"markdown","c5de4d1f":"markdown","8a1715e6":"markdown"},"source":{"cf048bd2":"!pip install pycaret","5a8a8383":"from pycaret.datasets import get_data\ndataset = get_data('credit')","92efd0e7":"#check the shape of data\ndataset.shape","7fc80273":"data = dataset.sample(frac=0.95, random_state=786).reset_index(drop=True)\ndata_unseen = dataset.drop(data.index).reset_index(drop=True)\n\nprint('Data for Modeling: ' + str(data.shape))\nprint('Unseen Data For Predictions: ' + str(data_unseen.shape))","f67cbf60":"from pycaret.classification import *","44d87367":"exp_clf101 = setup(data = data, target = 'default', session_id=123) ","8f5993a9":"compare_models()","292062f7":"dt = create_model('dt')","cb24e34e":"#trained model object is stored in the variable 'dt'. \nprint(dt)","02d14ff8":"knn = create_model('knn')","3a556d19":"rf = create_model('rf')","c6b7d30e":"tuned_dt = tune_model('dt')","f38898b3":"#tuned model object is stored in the variable 'tuned_dt'. \nprint(tuned_dt)","fa50bf01":"tuned_knn = tune_model('knn')\n","f67197ae":"tuned_rf = tune_model('rf')","87351b1c":"plot_model(tuned_rf, plot = 'auc')\n","56c8d922":"plot_model(tuned_rf, plot = 'pr')","44107b1d":"plot_model(tuned_rf, plot='feature')\n","6e916b3a":"plot_model(tuned_rf, plot = 'confusion_matrix')","8c96371f":"predict_model(tuned_rf);","5033bca0":"final_rf = finalize_model(tuned_rf)","0a9d29dd":"#Final Random Forest model parameters for deployment\nprint(final_rf)","75bb0ca5":"predict_model(final_rf);","6d4fbfe0":"unseen_predictions = predict_model(final_rf, data=data_unseen)\nunseen_predictions.head()\n","e82140b5":"save_model(final_rf,'Final RF Model 20April2020')","25e30c6d":"saved_final_rf = load_model('Final RF Model 20April2020')","0e9c46ec":"new_prediction = predict_model(saved_final_rf, data=data_unseen)","6d185be9":"new_prediction.head()","308616af":"Comparing all models to evaluate performance is the recommended starting point for modeling once the setup is completed (unless you exactly know what kind of model you need, which is often not the case). This function trains all models in the model library and scores them using stratified cross validation for metric evaluation. The output prints a score grid that shows average Accuracy, AUC, Recall, Precision, F1 and Kappa accross the folds (10 by default) of all the available models in the model library.","ae713776":"# Predict on unseen data","45edb0ac":"The predict_model() function is also used to predict on the unseen dataset. The only difference from section 11 above is that this time we will pass the data_unseen parameter. data_unseen is the variable created at the beginning of the tutorial and contains 5% (1200 samples) of the original dataset which was never exposed to PyCaret. (see section 5 for explanation)","24b609de":"# Finalize Model for Deployment","c3f40656":"The tune_model() function is a random grid search of hyperparameters over a pre-defined search space. By default, it is set to optimize Accuracy but this can be changed using optimize parameter. For example: tune_model('dt', optimize = 'AUC') will search for the hyperparameters of a Decision Tree Classifier that results in highest AUC. For the purposes of this example, we have used the default metric Accuracy for the sake of simplicity only. Generally, when the dataset is imbalanced (such as the credit dataset we are working with) Accuracy is not a good metric for consideration. The methodology behind selecting the right metric to evaluate a classifier is beyond the scope of this tutorial but if you would like to learn more about it, you can click here to read an article on how to choose the right evaluation metric.\n\nNotice how the results after tuning have been improved:\n\nDecision Tree Classifier (Before: 0.7294 , After: 0.8199)\nK Neighbors Classifier (Before: 0.7505 , After: 0.7791)\nRandom Forest Classifier (Before: 0.8084 , After: 0.8229)\nMetrics alone are not the only criteria you should consider when finalizing the best model for production. Other factors to consider include training time, standard deviation of kfolds etc. As you progress through the tutorial series we will discuss those factors in detail at the intermediate and expert levels. For now, let's move forward considering the Tuned Random Forest Classifier as our best model for the remainder of this tutorial.","f8db545f":"# Decision Tree Classifier","2aed05fd":"# Create a Model","79f62788":"The Label and Score columns are added onto the data_unseen set. Label is the prediction and score is the probability of the prediction. Notice that predicted results are concatenated to the original dataset while all the transformations are automatically performed in the background.","407a999d":"# K Neighbors Classifier","ed51c905":"# Comparing All Models","708214b9":"To load a saved model at a future date in the same or an alternative environment, we would use PyCaret's load_model() function and then easily apply the saved model on new unseen data for prediction.","a3a509df":"![image.png](attachment:image.png)","d1f94786":"# Plot a Model","f7df9f82":"# K Neighbors Classifier","3b61b237":"Current Docs https:\/\/www.pycaret.org","849ee570":"# Tune a Model","af99aeb2":"The accuracy on test\/hold-out set is 0.8126 compared to 0.8229 achieved on the tuned_rf CV results (in section 9.3 above). This is not a significant difference. If there is a large variation between the test\/hold-out and CV results, then this would normally indicate over-fitting but could also be due to several other factors and would require further investigation. In this case, we will move forward with finalizing the model and predicting on unseen data (the 5% that we had separated in the beginning and never exposed to PyCaret).\n\n(TIP : It's always good to look at the standard deviation of CV results when using create_model().)","709142bb":"# Saving the model","e5b8539e":"we will use a dataset from UCI called Default of Credit Card Clients Dataset. This dataset contains information on default payments, demographic factors, credit data, payment history, and billing statements of credit card clients in Taiwan from April 2005 to September 2005. There are 24,000 samples and 25 features. Short descriptions of each column are as follows:\n\n<li>ID: ID of each client<\/li>\n<li>LIMIT_BAL: Amount of given credit in NT dollars (includes individual and family\/supplementary credit)<\/li>\n<li>SEX: Gender (1=male, 2=female)<\/li>\n<li>EDUCATION: (1=graduate school, 2=university, 3=high school, 4=others, 5=unknown, 6=unknown)<\/li>\n<li>MARRIAGE: Marital status (1=married, 2=single, 3=others)<\/li>\n<li>AGE: Age in years<\/li>\n<li>PAY_0 to PAY_6: Repayment status by n months ago (PAY_0 = last month ... PAY_6 = 6 months ago) (Labels: -1=pay duly, 1=payment delay for one month, 2=payment delay for two months, ... 8=payment delay for eight months, 9=payment delay for nine months and above)<\/li>\n<li>BILL_AMT1 to BILL_AMT6: Amount of bill statement by n months ago ( BILL_AMT1 = last_month .. BILL_AMT6 = 6 months ago)<\/li>\n<li>PAY_AMT1 to PAY_AMT6: Amount of payment by n months ago ( BILL_AMT1 = last_month .. BILL_AMT6 = 6 months ago)<\/li>\n<li>default: Default payment (1=yes, 0=no) Target Column<\/li>\n","d299b579":"# Feature Importance Plot","3b36129a":"Once the setup has been succesfully executed it prints the information grid which contains several important pieces of information. Most of the information is related to the pre-processing pipeline which is constructed when setup() is executed. The majority of these features are out of scope for the purposes of this tutorial however a few important things to note at this stage include:\n\n**session_id** : A pseduo-random number distributed as a seed in all functions for later reproducibility. If no session_id is passed, a random number is automatically generated that is distributed to all functions. In this experiment, the session_id is set as 123 for later reproducibility.\n\n**Target Type** : Binary or Multiclass. The Target type is automatically detected and shown. There is no difference in how the experiment is performed for Binary or Multiclass problems. All functionalities are identical.\n\n**Label Encoded** : When the Target variable is of type string (i.e. 'Yes' or 'No') instead of 1 or 0, it automatically encodes the label into 1 and 0 and displays the mapping (0 : No, 1 : Yes) for reference. In this experiment no label encoding is required since the target variable is of type numeric.\n\n**Original Data** : Displays the original shape of the dataset. In this experiment (22800, 24) means 22,800 samples and 24 features including the target column.\n\n**Missing Values** : When there are missing values in the original data this will show as True. For this experiment there are no missing values in the dataset.\n\n**Numeric Features** : The number of features inferred as numeric. In this dataset, 14 out of 24 features are inferred as numeric.\n\n**Categorical Features** : The number of features inferred as categorical. In this dataset, 9 out of 24 features are inferred as categorical.\n\n**Transformed Train Set** : Displays the shape of the transformed training set. Notice that the original shape of (22800, 24) is transformed into (15959, 91) for the transformed train set and the number of features have increased to 91 from 24 due to categorical encoding\n\n**Transformed Test Set** : Displays the shape of the transformed test\/hold-out set. There are 6841 samples in test\/hold-out set. This split is based on the default value of 70\/30 that can be changed using the train_size parameter in setup.\nNotice how a few tasks that are imperative to perform modeling are automatically handled such as missing value imputation (in this case there are no missing values in the training data, but we still need imputers for unseen data), categorical encoding etc. Most of the parameters in setup() are optional and used for customizing the pre-processing pipeline. These parameters are out of scope for this tutorial but as you progress to the intermediate and expert levels, we will cover them in much greater detail","5f09317f":"Here We will be doing a binary classification, that  is a supervised machine learning technique where the goal is to predict categorical class labels which are discrete and unoredered such as Pass\/Fail, Positive\/Negative, Default\/Not-Default etc. A few real world use cases for classification are listed below:\n\n<li>Medical testing to determine if a patient has a certain disease or not - the classification property is the presence of the disease.<\/li>\n<li>A \"pass or fail\" test method or quality control in factories, i.e. deciding if a specification has or has not been met \u2013 a go\/no-go classification.<\/li>\n<li>Information retrieval, namely deciding whether a page or an article should be in the result set of a search or not \u2013 the classification property is the relevance of the article, or the usefulness to the user.<\/li>\n\nPyCaret's classification module (pycaret.classification) is a supervised machine learning module which is used for classifying the elements into a binary group based on various techniques and algorithms","599b032a":"The setup() function initializes the environment in pycaret and creates the transformation pipeline to prepare the data for modeling and deployment. setup() must be called before executing any other function in pycaret. It takes two mandatory parameters: a pandas dataframe and the name of the target column. All other parameters are optional and are used to customize the pre-processing pipeline (we will see them in later tutorials).\n\nWhen setup() is executed, PyCaret's inference algorithm will automatically infer the data types for all features based on certain properties. The data type should be inferred correctly but this is not always the case. To account for this, PyCaret displays a table containing the features and their inferred data types after setup() is executed. If all of the data types are correctly identified enter can be pressed to continue or quit can be typed to end the expriment. Ensuring that the data types are correct is of fundamental importance in PyCaret as it automatically performs a few pre-processing tasks which are imperative to any machine learning experiment. These tasks are performed differently for each data type which means it is very important for them to be correctly configured.\n\nIn later tutorials we will learn how to overwrite PyCaret's infered data type using the numeric_features and categorical_features parameters in setup()","39b86a8e":"Model finalization is the last step in the experiment. A normal machine learning workflow in PyCaret starts with setup(), followed by comparing all models using compare_models() and shortlisting a few candidate models (based on the metric of interest) to perform several modeling techniques such as hyperparameter tuning, ensembling, stacking etc. This workflow will eventually lead you to the best model for use in making predictions on new and unseen data. The finalize_model() function fits the model onto the complete dataset including the test\/hold-out sample (30% in this case). The purpose of this function is to train the model on the complete dataset before it is deployed in production.","a4a65284":"Notice that the results of unseen_predictions and new_prediction are identical.","bb29e294":"# Precision-Recall Curve","cda38709":"In this tutorial we will learn:\n\n<ul>\n<li>Getting Data: How to import data from PyCaret repository<\/li>\n<li>Setting up Environment: How to setup an experiment in PyCaret and get started with building classification models<\/li>\n<li>Create Model: How to create a model, perform stratified cross validation and evaluate classification metrics<\/li>\n<li>Tune Model: How to automatically tune the hyper-parameters of a classification model<\/li>\n<li>Plot Model: How to analyze model performance using various plots<\/li>\n<li>Finalize Model: How to finalize the best model at the end of the experiment<\/li>\n<li>Predict Model: How to make predictions on new \/ unseen data<\/li>\n<li>Save \/ Load Model: How to save \/ load a model for future use<\/li>\n<li>Read Time : Approx. 30 Minutes<\/li>\n<\/ul>","4c2ab84b":"# Confusion Matrix","3ecd53b8":"Before finalizing the model, it is advisable to perform one final check by predicting the test\/hold-out set and reviewing the evaluation metrics. If you look at the information grid in Section 6 above, you will see that 30% (6,841 samples) of the data has been separated out as test\/hold-out sample. All of the evaluation metrics we have seen above are cross validated results based on the training set (70%) only. Now, using our final trained model stored in the tuned_rf variable we will predict against the hold-out sample and evaluate the metrics to see if they are materially different than the CV results.","ba4aa1a6":"# Random Forest Classifier","080d4c11":"Notice how the AUC in final_rf has increased to 0.8189 from 0.7538, even though the model is the same. This is because the final_rf variable has been trained on the complete dataset including the test\/hold-out set.","470da133":"Before model finalization, the plot_model() function can be used to analyze the performance across different aspects such as AUC, confusion_matrix, decision boundary etc. This function takes a trained model object and returns a plot based on the test \/ hold-out set.\n\nThere are 15 different plots available, please see the plot_model() docstring for the list of available plots.","eb8ad387":"Notice that the mean score of all models matches with the score printed in compare_models(). This is because the metrics printed in the compare_models() score grid are the average scores across all CV folds. Similar to compare_models(), if you want to change the fold parameter from the default value of 10 to a different value then you can use the fold parameter. For Example: create_model('dt', fold = 5) will create a Decision Tree Classifier using 5 fold stratified CV.","e9b22877":"# AUC Plot","933d4e21":"<h1 style ='color:green'>Thanks ...<\/h1>","53b02fe0":"# Tutorial Objective","e63dfc42":"<h1 style = 'color:red'> If You find this Kernel Informational . Please Upvote it.<\/h1>","a700a7e3":"#  Decision Tree Classifier","44ad50e0":"PyCaret is an open source, low-code machine learning library in Python that aims to reduce the cycle time from hypothesis to insights. It enables data scientists and analysts to perform iterative end-to-end data science experiments efficiently and allows them to reach conclusions faster due to far less time spent in coding. PyCaret is essentially a Python wrapper around several machine learning libraries and frameworks such as scikit-learn, XGBoost, Microsoft LightGBM, spaCy and many more.\n\nPyCaret is simple, easy to use and deployment ready. All of the operations performed in a typical experiment are executed and automatically stored in a custom pipeline which is completely orchestrated to manage dependencies. The Pipeline can be saved in a binary format that can be transferred into a different environment to perform experiments at scale.\n\nThe design and simplicity of PyCaret is inspired by the emerging role of citizen data scientists, a term first used by Gartner. Citizen Data Scientists are power users who can perform both simple and moderately sophisticated analytical tasks that would previously have required more expertise. The skills of a seasoned data scientists are often expensive and difficult to come by but citizen data scientists can be an effective way to mitigate this current skills gap and address data related challenges.","f586be66":"When a model is created using the create_model() function it uses the default hyperparameters. In order to tune hyperparameters, the tune_model() function is used. This function automatically tunes the hyperparameters of a model on a pre-defined search space and scores it using stratified cross validation. The output prints a score grid that shows Accuracy, AUC, Recall, Precision, F1 and Kappa by fold.\n\nNote: tune_model() does not take a trained model object as an input. It instead requires a model name to be passed as an abbreviated string similar to how it is passed in create_model(). All other functions in pycaret.classification require a trained model object as an argument","4713d872":"Caution: One final word of caution. Once the model is finalized using finalize_model(), the entire dataset including the test\/hold-out set is used for training. As such, if the model is used for predictions on the hold-out set after finalize_model() is used, the information grid printed will be misleading as you are trying to predict on the same data that was used for modeling.","5ee8ba1a":"Two simple words of code (not even a line) have created over 15 models using 10 fold stratified cross validation and evaluated the 6 most commonly used classification metrics (Accuracy, AUC, Recall, Precision, F1, Kappa). The score grid printed above highlights the highest performing metric for comparison purposes only. The grid by default is sorted using 'Accuracy' (highest to lowest) which can be changed by passing the sort parameter. For example compare_models(sort = 'Recall') will sort the grid by Recall instead of Accuracy. If you want to change the fold parameter from the default value of 10 to a different value then you can use the fold parameter. For example compare_models(fold = 5) will compare all models on 5 fold cross validation. Reducing the number of folds will improve the training time.","39a2654f":"# Pycaret Introduction","c3ae0d6a":"# 1.1 Installing PyCaret","5670cbb5":"# Loading the saved model","69f193a8":"Welcome to the Binary Classification Tutorial (CLF101) - Level Beginner. This tutorial assumes that you are new to PyCaret and looking to get started with Binary Classification using the pycaret.classification Module.","64bdfd16":"We have now finished the experiment by finalizing the tuned_rf model which is now stored in final_rf variable. We have also used the model stored in final_rf to predict data_unseen. This brings us to the end of our experiment, but one question is still to be asked: What happens when you have more new data to predict? Do you have to go through the entire experiment again? The answer is no, PyCaret's inbuilt function save_model() allows you to save the model along with entire transformation pipeline for later use.","649a240e":"Another way to analyze the performance of models is to use the evaluate_model() function which displays a user interface for all of the available plots for a given model. It internally uses the plot_model() function.","81c8572a":"# Predict on test \/ hold-out Sample","c5de4d1f":"While compare_models() is a powerful function and often a starting point in any experiment, it does not return any trained models. PyCaret's recommended experiment workflow is to use compare_models() right after setup to evaluate top performing models and finalize a few candidates for continued experimentation. As such, the function that actually allows to you create a model is unimaginatively called create_model(). This function creates a model and scores it using stratified cross validation. Similar to compare_models(), the output prints a score grid that shows Accuracy, AUC, Recall, Precision, F1 and Kappa by fold.\n\nFor the remaining part of this tutorial, we will work with the below models as our candidate models. The selections are for illustration purposes only and do not necessarily mean they are the top performing or ideal for this type of data.\n\nDecision Tree Classifier ('dt')\nK Neighbors Classifier ('knn')\nRandom Forest Classifier ('rf')\nThere are 18 classifiers available in the model library of PyCaret. Please view the create_model() docstring for the list of all available models.","8a1715e6":"Once the model is loaded in the environment, you can simply use it to predict on any new data using the same predict_model() function. Below we have applied the loaded model to predict the same data_unseen"}}