{"cell_type":{"51dddc95":"code","f41d8ca8":"code","078cc9da":"code","e9d609aa":"code","876f3aa4":"code","2681a379":"code","1385a6db":"code","cc857559":"code","efcb56c1":"code","1a9d62ea":"code","e1c94d01":"code","7e342e4e":"code","eeca4648":"code","1e0da272":"code","2adef009":"code","b2f4a40d":"code","2dfd55c0":"code","736762fe":"code","664f8bad":"code","8e94b4a8":"code","08f1a7a0":"code","16ab0877":"code","15f3d644":"code","f731ccf3":"code","2ded69a0":"markdown","4b3123d9":"markdown","ba734990":"markdown","096aa8bc":"markdown","47339927":"markdown","235ae61c":"markdown","531e71d4":"markdown","73136382":"markdown","e5d1345b":"markdown","e1075e5e":"markdown","79d15284":"markdown","5a78268e":"markdown","d7a149ac":"markdown"},"source":{"51dddc95":"import os\nimport pandas as pd\nimport json\n\n# Increase max # of columns displayed when printing a DataFrame\npd.set_option('display.max_columns', 500)","f41d8ca8":"INPUT_DIR = '..\/input\/CORD-19-research-challenge'\nTASK_DIR = os.path.join(INPUT_DIR, 'Kaggle')\nDATA_DIR = os.path.join(INPUT_DIR, 'document_parses')","078cc9da":"meta = pd.read_csv('..\/input\/CORD-19-research-challenge\/metadata.csv',\n                   low_memory=False) # Mixed data types in cols 1-4","e9d609aa":"meta.shape","876f3aa4":"for i, c in enumerate(meta.columns):\n    print(f'{i:>2d} {c}')","2681a379":"meta.pmc_json_files.notnull().value_counts()","1385a6db":"meta.pdf_json_files.notnull().value_counts()","cc857559":"meta.iloc[0]","efcb56c1":"meta.iloc[0].pmc_json_files","1a9d62ea":"pmc_file = meta.iloc[0].pmc_json_files\nwith open(os.path.join(INPUT_DIR, pmc_file), 'rb') as f:\n    pmc_extract = json.load(f)","e1c94d01":"pmc_extract.keys()","7e342e4e":"pmc_extract['bib_entries']['BIBREF0']","eeca4648":"pmc_extract_df = pd.Series(pmc_extract)","1e0da272":"pmc_extract_df","2adef009":"pdf_list = []\nfor pdf_file in meta[meta.pdf_json_files.notnull()].pdf_json_files[:1000]:\n    # Some entries have multiple paths separated by ';'\n    pdf_file = pdf_file.split(';')[0] # take the first one\n    with open(os.path.join(INPUT_DIR, pdf_file), 'rb') as f:\n        pdf_extract = json.load(f)\n    pdf_list.append(pdf_extract)","b2f4a40d":"full_text_df = pd.DataFrame(pdf_list)","2dfd55c0":"full_text_df.head()","736762fe":"# First entry in the body_text list for first record\nfull_text_df.body_text[0][0]","664f8bad":"# Useful libraries for printing formatted text into Notebooks\nimport html\nfrom IPython.display import HTML","8e94b4a8":"current_section = ''\noutput_html = ''\ntemp_meta = meta[meta.sha == full_text_df.paper_id[0]]\ntitle = temp_meta.title.values[0]\nauthors = temp_meta.authors.values[0]\ndoi = temp_meta.doi.values[0]\noutput_html += f'<h3>{html.escape(title)}<\/h3>'\noutput_html += f'{html.escape(authors)}<br>'\noutput_html += f'<a href=\"{doi}\">{doi}<\/a><br><br>'\nfor item in full_text_df.body_text[0]:\n    section = item['section']\n    if section != current_section:\n        current_section = section\n        output_html += f'<h4>{html.escape(section)}<\/h4><br>'\n    output_html += html.escape(item['text'])\n    output_html += '<br><br>'\ndisplay(HTML(output_html))","08f1a7a0":"pmc_list = []\nfor pmc_file in meta[meta.pmc_json_files.notnull()].pmc_json_files[:1000]:\n    # Some entries have multiple paths separated by ';'\n    pmc_file = pmc_file.split(';')[0] # take the first one\n    with open(os.path.join(INPUT_DIR, pmc_file), 'rb') as f:\n        pmc_extract = json.load(f)\n    pmc_list.append(pmc_extract)\nfull_pmc_df = pd.DataFrame(pmc_list)","16ab0877":"current_section = ''\noutput_html = ''\ntemp_meta = meta[meta.pmcid == full_pmc_df.paper_id[0]]\ntitle = temp_meta.title.values[0]\nauthors = temp_meta.authors.values[0]\ndoi = temp_meta.doi.values[0]\noutput_html += f'<h3>{html.escape(title)}<\/h3>'\noutput_html += f'{html.escape(authors)}<br>'\noutput_html += f'<a href=\"{doi}\">{doi}<\/a><br><br>'\nfor item in full_pmc_df.body_text[0]:\n    section = item['section']\n    if section != current_section:\n        current_section = section\n        output_html += f'<h4>{html.escape(section)}<\/h4><br>'\n    output_html += html.escape(item['text'])\n    output_html += '<br><br>'\ndisplay(HTML(output_html))","15f3d644":"os.listdir(TASK_DIR)","f731ccf3":"sorted(os.listdir(os.path.join(TASK_DIR, 'target_tables')))","2ded69a0":"### Print out PMC extract\n\nThe PMC extract is from PubMed Central, and in this case is more accurate. Note that the `paper_id` in the PMC extracts joins with `pmcid` in metadata.csv, rather than `sha`.","4b3123d9":"Fields are shown below. `title` and `abstract` are useful for quickly filtering on topic.\n\n`pdf_json_files` is the link to the extracted PDF text in JSON format.\n\n`pmc_json_files` is the link to the extracted PubMed Central (see: https:\/\/en.wikipedia.org\/wiki\/PubMed_Central) data which has been enriched.","ba734990":"~49k papers have PDF extracts:","096aa8bc":"By printing out an article we can show how to access the text. We'll take our first article `full_text_df.iloc[0]` and print out the relevant metadata and body text.","47339927":"You can now navigate this as a dictionary:","235ae61c":"###\u00a0Print out PDF extract\n\nFirst we'll take a look at the PDF extract:","531e71d4":"# Tasks\n\nBelow is a quick run through of the new task folder structure:","73136382":"# Metadata\n\nThe metadata CSV is at `..\/input\/CORD-19-research-challenge\/metadata.csv`","e5d1345b":"# Documents\n\nLet's start by loading a single document from a reference in the metadata:","e1075e5e":"To load all the full text into memory, you can do this (example will be only 1000 papers and using the PDF files):","79d15284":"About half (~33.5k) the papers have a PubMed Central (PMC) extract:","5a78268e":"# CORD-19 Updated Data Overview (13 May)\n\nThe new data update makes some big changes to the CORD-19 set that Kagglers have been working with for several weeks.\n\nThis Notebook runs through some of the changes and shows you how to load and work with the data:\n\n1. [**Metadata**](#Metadata)\n2. [**Documents**](#Documents)\n3. [**Tasks**](#Tasks)","d7a149ac":"Or convert to a Pandas Series for convenience (although some cells will contain nested lists \/ dicts)"}}