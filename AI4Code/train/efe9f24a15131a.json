{"cell_type":{"a14b4f4e":"code","28b15e2a":"code","8b5dc81c":"code","14c5ff3a":"code","969d32e3":"code","18010291":"code","3bc61312":"code","9fb1b9e7":"code","49cc7f5c":"code","5f8606c3":"code","4d94c586":"code","1c24ec23":"code","ecee5064":"code","def13c5a":"code","95df3949":"code","dd3ac512":"markdown","1369b003":"markdown","de9bc9da":"markdown","22e95a61":"markdown","fc26f06d":"markdown","2f5c0baa":"markdown","47ec2c86":"markdown","49033d57":"markdown","c3e23bb7":"markdown","2475e24b":"markdown","addeeac6":"markdown","f06e7109":"markdown","ed78ac1f":"markdown","6ce5afca":"markdown","b341a32f":"markdown","31a60356":"markdown","7479b0d8":"markdown","0af29ccc":"markdown","e9a5dbc4":"markdown"},"source":{"a14b4f4e":"# The Python programming language is based on modules, which can be imported in the beginning of every program.\n# Here we will use the following modules for our analysis:\n\n# Standard libraries\nfrom pathlib import Path            # deals with path related tasks, such as constructing new paths from names of files and from other paths and creating files at specific paths.\nimport warnings                     # provides warnings to warn the developer\/user\n# Third party libraries\n# %matplotlib inline  # magic function to present the output of plotting commands inline\nimport matplotlib.pyplot as plt     # cross-platform data visualisation and graphical plotting library\nimport numpy as np                  # important for vector and matrix computations\nimport pandas as pd                 # used to read and modify 'lbeled' data (e.g. table-like structures)\nimport ipywidgets as widgets        # used for interactive HTML widgets\nimport scipy as sp                  # collection of mathematical algorithms and convenience functions built on NumPy\nfrom scipy.signal import find_peaks # function to detect local maxima in a signal\n\nprint('Imports succesful!')","28b15e2a":"# Plot settings\nfig_width, fig_height = 14, 3                   # Standard width and height of figures in inches\nplt.rcParams.update({\n    'font.size': 14,                            # default text size in figures\n    'lines.linewidth': 2,                       # line width in points\n    'lines.markersize': 10,                     # marker size, in points\n    'figure.figsize': (fig_width, fig_height),  # # figure size in inches\n    'figure.autolayout': True,                  # tight layout\n    'axes.spines.right': False,                 # if True, display right axis spine\n    'axes.spines.top': False,                   # if True, display top axis spine\n    'legend.frameon': False,                    # if True, draw the legend on a background patch\n    'legend.loc': 'center left',                # relative location of legend\n})\n\n# Widget settings\nslider_width, slider_height = '800px', '40px'\ndropdown_width, dropdown_height = '200px', '40px'\ninput_width, input_height = '100px', '40px'\n\n# Experiment type\nexperiment_type = 'WingMuscle'\n\n# Separator of text file\nsep = '\\t'","8b5dc81c":"\n# #######################################################\n# FileProperties\n# #######################################################\nclass FileProperties:\n    \"\"\"Class to store properties of each file\"\"\"\n    def __init__(self, experiment_type):\n        \"\"\"Simple init file of the class\n\n        Args:\n            experiment_type (str): Type of experiment. Either 'StretchReceptor' or 'WingMuscle'\n        \"\"\"\n        self.path_to_input_folder = Path()\n        self.analysis_class_list = list()\n        self.experiment_type = experiment_type\n        \n        if self.experiment_type != 'WingMuscle' and self.experiment_type != 'StretchReceptor':\n            warnings.warn(f'experiment_type must be \"WingMuscle\" or \"StretchReceptor\" and not \"{self.experiment_type}\".')\n        \n    def set_input_data(self, path_to_input_folder):  \n        \"\"\"Create widgets to set input data\n\n        Args:\n            path_to_input_folder (Path): path to folder with input data\n        \"\"\"\n        self.path_to_input_folder = path_to_input_folder\n\n        # Look up all text files within this dataset\n        path_to_input_files = self.path_to_input_folder.glob('**\/*.txt')\n    \n        # Check if input files are found\n        if not len(list(path_to_input_files)):\n            warnings.warn(f'No .txt files found. Make sure you have uploaded text file(s) to the right dataset.')\n        \n        # Loop over all input files to create widgets\n        self.file_properties = dict()\n        path_to_files = sorted(list(self.path_to_input_folder.glob('**\/*.txt')))\n        \n        for path_to_file in path_to_files:\n            self.create_file_widget(path_to_file)\n\n    def create_file_widget(self, path_to_file):\n        \"\"\"Create widget to set file properties, calls get_file_properties()\n    \n        Args:\n            path_to_file (Path): path to file\n        \"\"\"        \n        # Define file label based on path_to_file\n        file_label = str(path_to_file)[len(str(self.path_to_input_folder))+1:]\n        \n        # Define angle widget for experiment type\n        if self.experiment_type == 'WingMuscle':\n            angle_widget = widgets.fixed(0)               # Angle is not required for WingMuscle experiment\n            number_widget = widgets.IntText(              # Create IntText to specify number of sections\n                value=3,\n                description='Number of sections',\n                style={'description_width': 'initial'},\n                layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n            )\n        elif self.experiment_type == 'StretchReceptor':\n            angle_widget = widgets.BoundedFloatText(      # Create BoundedFloatText to specify angle\n                value='0',\n                placeholder='Type angle',\n                description='Angle',\n                style={'description_width': 'initial'},\n                layout=widgets.Layout(width=input_width, height=input_height),\n                min=0, max=360, step=5\n            )\n            number_widget = widgets.fixed(1)\n    \n        # Generate user interface to control function arguments: widgets\n        widget = widgets.interactive(\n            self.get_file_properties,                     # Call function which will be controlled\n            file_label=widgets.fixed(file_label),         # The file_label and path_to_file are already known\n            path_to_file=widgets.fixed(path_to_file),\n            use=widgets.Checkbox(                         # Create checkbox to specify whether to use this file\n                value=False,\n                description=file_label,\n                indent=False,\n                layout=widgets.Layout(height=input_height),\n            ),\n            angle=angle_widget,                           # Defined above\n            number_of_sections=number_widget,\n        )\n        \n        # Inspect file\n        self.output = widgets.Output()\n        if self.experiment_type == 'WingMuscle':\n            # Load file\n            df = pd.read_csv(path_to_file, sep=sep, header=0)\n            with self.output:\n                # Plot normalised column data\n                fig, ax = plt.subplots(1, 1)\n                for column in df.columns.values:\n                    if 'time' in column.lower():\n                        # Do not print time for now\n                        continue\n\n                    values = df[column]\n                    values_norm = (values - values.min()) \/ (values.max() - values.min())\n                    ax.plot(df[column], label=column)\n                # # Format\n                ax.set_xlim([df.index.min(), df.index.max()])\n                ax.set_xlabel('Index')\n                ax.set_ylabel('Norm. values')\n    \n        # Display widgets in horizontal format\n        display(widgets.VBox([\n            widgets.HBox(widget.children),\n            self.output,\n        ]))\n        \n    def get_file_properties(self, file_label, path_to_file, use=bool(), angle=float(), number_of_sections=int()):\n        \"\"\"Store the properties of each file.\n        Args:\n            file_label (str): label of each file\n            path_to_file (Path): path to file\n            use (bool): If True, use this file in the analysis\n            angle (float): Corresponding wing stretch angle, only for StretchReceptor\n            number_of_sections (int): Number of sections to be analysed, only for WingMuscle\n\n        Returns:\n            file_properties (dict): dictionary with properties of each file\n        \"\"\"\n        # We create a new dictionary within file_properties for each file and store angle and path_to_file\n        self.file_properties[file_label] = dict()\n        self.file_properties[file_label]['angle'] = angle\n        self.file_properties[file_label]['number_of_sections'] = number_of_sections        \n        self.file_properties[file_label]['path'] = path_to_file\n    \n        # Remove file if usage is set to False\n        if not use:\n            _ = self.file_properties.pop(file_label)\n        \n    def create_analysis_classes(self):\n        \"\"\"Create all analysis classes based on file properties dictionary\"\"\"\n        self.analysis_class_list = list()\n        \n        # Loop over all files\n        for file_label, value_dict in self.file_properties.items():\n            for section_number in range(value_dict['number_of_sections']):\n                file_analysis_class = FileAnalysis(                 # Create class for each file\n                        file_label=file_label,\n                        section_label=str(section_number + 1),      # Start counting from one instead of zero\n                        path_to_data=value_dict['path'],\n                        alpha=value_dict['angle'],\n                        experiment_type=self.experiment_type,\n                        number_of_sections=value_dict['number_of_sections']\n                    )\n                self.analysis_class_list.append(file_analysis_class) # Append to analysis_class_list\n\n        # Check if any FileAnalysis classes are created\n        if not len(self.analysis_class_list):\n            warnings.warn(\"No FileAnalysis classe(s) created. Did you select any file(s)?\")\n        else:\n            print(f'FileAnalysis class succesfullly created for {len(self.analysis_class_list)} class(es).')\n          \n        # Return analysis class list for further usage\n        return self.analysis_class_list\n\n# #######################################################\n# FileAnalysis\n# #######################################################\nclass FileAnalysis:\n    \"\"\"Class to perform the analysis of each file\"\"\"\n    def __init__(self, file_label, section_label, path_to_data, alpha, number_of_sections, experiment_type):\n        \"\"\"\n        Args:\n            file_label (str): label of each file\n            section_label (str): label of each sectio\n            path_to_data (Path): path to file\n            alpha (float): corresponding wing stretch angle, only for 'StretchReceptor'\n            number_of_sections (int): number of sections\n            experiment_type (str): type of experiment. Either 'StretchReceptor' or 'WingMuscle'\n        \"\"\"\n        # Store all initial variables\n        self.file_label = file_label\n        self.section_label = section_label\n        self.path_to_data = Path(path_to_data)\n        self.alpha = alpha\n        self.number_of_sections = number_of_sections\n        self.experiment_type = experiment_type\n        self.chained_assignment_ignore = self.ChainedAssignment()\n\n        # Define caption and path based on experiment type\n        if self.experiment_type == 'WingMuscle':\n            self.caption = widgets.Label(value=f'File {self.file_label} Section {self.section_label}:')\n            self.save_path = file_label.replace('.txt', '').replace('\/', '_') + '_' + section_label\n        elif self.experiment_type == 'StretchReceptor':\n            self.caption = widgets.Label(value=f'File {self.file_label}:')\n            self.save_path = file_label.replace('.txt', '').replace('\/', '_')\n\n\n    # ChainedAssignment\n    class ChainedAssignment:\n        \"\"\"Nested class to suppress 'ChainedAssignment' warnings.\"\"\"\n        def __init__(self, chained=None):\n            acceptable = [None, 'warn', 'raise']\n            assert chained in acceptable, \"chained must be in \" + str(acceptable)\n            self.swcw = chained\n\n        def __enter__(self):\n            self.saved_swcw = pd.options.mode.chained_assignment\n            pd.options.mode.chained_assignment = self.swcw\n            return self\n\n        def __exit__(self, *args):\n            pd.options.mode.chained_assignment = self.saved_swcw\n\n    # ####################################\n    # LOAD DATAFRAME\n    # ####################################\n    def load_data(self):\n        \"\"\"Read .txt file into a pandas DataFrame\"\"\"\n        # Read text file\n        self.df = pd.read_csv(self.path_to_data, sep=sep, header=0)\n        \n        # Calculate initial properties\n        self.time_range = (self.df.index.min(), self.df.index.max())\n        self.dt = self.df.index[1] - self.df.index[0]\n        \n        # Preallocate other dataframes\n        self.df_time = self.df\n\n    # ####################################\n    # SET COLUMN NAMES\n    # ####################################\n    def set_column_names(self, predict=False):\n        \"\"\"The column names in the text file do not necessarily describe the value in the columns.\n        This function creates the widgets to inspect column values and store column name relations.\n\n        Args:\n            predict (bool): If True, predict column names on old column names\n        \"\"\"\n        # Load data again to be sure to have a 'fresh' dataset\n        self.load_data()\n        \n        w_list = list()\n        self.rename_dict = dict()\n    \n        # Set options based on experiment type\n        if self.experiment_type == 'WingMuscle':\n            options = ['', 'Time (s)', 'Time (ms)', 'Signal']\n        elif self.experiment_type == 'StretchReceptor':\n            options = ['', 'Time (s)', 'Time (ms)', 'Stimulus', 'Signal']\n        else:\n            warnings.warn(f'experiment_type \"{self.experiment_type}\" must be \"WingMuscle\" or \"StretchReceptor\"')\n                             \n        for num, old_name in enumerate(self.df.columns):\n            value = ''\n            # Predict column_name based on old_name\n            if predict and self.experiment_type == 'WingMuscle':\n                if 'time' in old_name.lower():\n                    value = 'Time'\n                elif 'Ch1' in old_name:\n                    value = 'Signal'\n                elif 'Ch2' in old_name:\n                    value = 'Stimulus'  if self.experiment_type == 'StretchReceptor' else 'Signal'\n            elif predict and self.experiment_type == 'StretchReceptor':\n                value = ['Time (ms)', 'Signal', 'Stimulus', ''][num]\n                    \n            # Create widget and append to list of widgets\n            w_list.append(\n                widgets.interactive(\n                    self.update_column_name,\n                    old_name=widgets.fixed(old_name),\n                    new_name=widgets.Dropdown(\n                        options=options,\n                        description=old_name,\n                        value=value,\n                        layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                    ),\n                )\n            )\n\n        # Display all widgets in desired layout\n        display(\n            widgets.VBox([\n                self.caption,\n                widgets.HBox([w for w in w_list])\n            ])\n        )\n    \n    def update_column_name(self, old_name=str(), new_name=str()):\n        \"\"\"Store column name relation and inspect column.\n\n        Args\n            old_name (str): old column name\n            new_name (str): new column name\n        \"\"\"\n        # Store column name relation\n        self.rename_dict[old_name] = new_name\n    \n        # Inspect column value\n        values = self.df[old_name]\n        if self.experiment_type == 'WingMuscle':\n            values = values[:1000]  # plot first 1000 values only\n\n        # Inspect columns\n        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(fig_width\/4, fig_height))\n        ax.plot(values, color='steelblue')\n        # # Format\n        ax.set_xlabel('Index')\n        ax.set_ylabel(old_name)\n        ax.set_xlim([values.index.min(), values.index.max()])\n    \n    def rename_columns(self):\n        \"\"\"Actually rename each column\"\"\"\n        # Check column name entries\n        if not len([e for e in self.rename_dict.values() if e != '']):\n            warnings.warn(\"Please set any column names first\")\n            return\n        for key, value in self.rename_dict.items():\n            if 'time' in key.lower() and 'time' not in value.lower():\n                warnings.warn(f\"Please check your column name entry for {key}\")\n                return\n        \n        # Load data again to be sure to have a 'fresh' dataset\n        self.load_data()\n\n        # Loop over old column names\n        for old_name, new_name in self.rename_dict.items():\n            if new_name == '':  # Remove column\n                self.df.drop(columns=old_name, inplace=True, errors='ignore')\n            else:  # Rename column\n                if 'time' in new_name.lower():\n                    if '(ms)' in new_name:\n                        self.df[new_name] *= 1E-3  # Set to seconds\n                    new_name = 'Time'\n                self.df.rename(\n                    columns={old_name: new_name},\n                    inplace=True,\n                    errors='ignore',  # ignore if old_name is not present\n                )\n                \n        # Check if required columns are present\n        if 'Time' not in self.df.columns or 'Signal' not in self.df.columns:\n            warnings.warn(\"Please check the column settings.\")\n                \n        # Set time to dataframe index\n        if 'Time' not in self.df.index.names:\n            self.df.set_index('Time', drop=True, inplace=True)\n            \n    # ####################################\n    # SET TIME RANGE\n    # ####################################\n    def update_time_range(self, time_range=(None, None)):\n        \"\"\"Update requested time range and plot values for corresponding range.\n        \n        Args:\n            time_range (Float, Float): requested time range \n        \"\"\"\n        # Store time range\n        self.time_range = time_range\n        \n        # Plot values for corresponding range\n        df = self.df.loc[self.time_range[0]:self.time_range[1]]         # Get rows within time range\n        \n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        sign_norm = self.normalise(df['Signal'], shift=False)           # Normalise values\n        ax.plot(sign_norm, color='steelblue', label='Signal')\n        if self.experiment_type == 'StretchReceptor':\n            # No Stimulus in WingMuscle experiment\n            stim_norm = self.normalise(df['Stimulus'])                  # Normalise values\n            ax.plot(stim_norm, color='lightcoral', label='Stimulus')\n        # # Format\n        ax.set_xlim([time_range[0], time_range[1]])\n        ax.set_xlabel('Time [s]')\n        ax.set_ylabel('Values (normalised)')\n        ax.legend(bbox_to_anchor=(1, 0.5))\n            \n    def set_time_range(self, value=None):     \n        \"\"\"Create widget to set time range\"\"\"\n        if isinstance(value, type(None)):\n            value = [self.df.index.min(), self.df.index.max()]\n        \n        self.time_range_widget = widgets.interactive(\n            self.update_time_range,                                       # Function call\n            time_range=widgets.FloatRangeSlider(                          # Create FloatRangeSlider\n                value=value,\n                min=self.df.index.min(), max=self.df.index.max(), step=1, # Set slider limits\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time range',\n                continuous_update=False,                                  # Set to False to improve performance\n            ),\n        )\n        display(self.caption,self.time_range_widget)\n        \n    def store_time_range(self):\n        \"\"\"Store time range\"\"\"\n        self.df_time = self.df.loc[self.time_range[0]:self.time_range[1]]\n#         self.dt = self.df_time.index[1] - self.df_time.index[0]         # Update time steps\n    \n    # ####################################\n    # SET STIMULUS ON AND OFFSET\n    # Only for StretchReceptor experiment\n    # ####################################\n    def set_stim_onoffset(self, downsampling_plot=100, downsampling_dt=100, dt_height=4):\n        \"\"\"Create widget to set stimulus start and end\"\"\"\n        self.downsampling_plot = downsampling_plot\n        self.downsampling_dt = downsampling_dt\n        self.dt_height = dt_height\n        \n        if self.experiment_type == 'WingMuscle':\n            # We don't need this function for WingMuscle experiment\n            return\n\n        # Downsample data to speed up query\n        df = self.df_time.iloc[::self.downsampling_dt, :]\n        \n        self.stim_time_range_widget = widgets.interactive(\n            self.update_stim_onoffset,                          # Call function\n            df=widgets.fixed(df),\n            height=widgets.FloatSlider(\n                value=df['Stimulus'].max() * 2\/3,     # By default set threshold to two thirds\n                min=df['Stimulus'].min(), max=df['Stimulus'].max(), step=0.01,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Height'\n            )\n        )\n        display(self.caption, self.stim_time_range_widget)      # Show widget\n    \n    def update_stim_onoffset(self, df, height):\n        \"\"\"Update start and end times of stimulus and plot corresponding results.\n        \n        Args:\n            height (float): minimum height of stimulus to be on \n        \"\"\"\n        # Detect start and end times of stimulus based on changes in time values\n        df_sel = df.query('Stimulus > @height')       # Select rows for which stimulus is above threshold\n        t_sel = df_sel.index.values                             # Extract time stamps of selected rows\n        dt_sel = np.diff(t_sel)                                 # Calculate derivative of time stamps\n        \n        # Detect jumps in derivative of time stamps: where the stimulus stops and starts\n        dt_peak_inds, _ = find_peaks(x=dt_sel, height=self.dt_height)\n#         print(f'dt_height: {self.dt_height}')\n#         plt.figure()\n#         plt.plot(t_sel[1:], dt_sel)\n#         plt.axhline(y=self.dt_height)\n        \n        # Convert peak indices into start and end times\n        self.stim_start_times = [t_sel[0]]                      # Initial value is always a start\n        self.stim_end_times = [t_sel[-1]]                       # Final value is always a end\n        for peak in dt_peak_inds:                               # Loop over peak indices\n            self.stim_start_times.append(t_sel[peak + 1])       # Add next time stamp as start\n            self.stim_end_times.append(t_sel[peak])             # Add time stamp as end\n        self.stim_start_times.sort()                            # Sort the time stamps chronologically\n        self.stim_end_times.sort()\n\n        # Ouput\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(self.df_time['Stimulus'][::self.downsampling_plot], color='steelblue')    # Stimulus in sampled version\n        ax.axhline(y=height, color='k', linestyle='dashed')     # Threshold line\n        # Plot stimulus start and end\n        for stim_start_time, stim_end_time in zip(self.stim_start_times, self.stim_end_times):\n            ax.axvspan(stim_start_time, stim_end_time, color='lightcoral', alpha=0.5, zorder=-10)\n        # # Format\n        ax.set_ylim([df['Stimulus'].min() - 0.01, df['Stimulus'].max() + 0.01])\n        ax.set_xlim([df.index.min(), df.index.max()])\n        ax.set_ylabel('Stimulus')\n        ax.set_xlabel('Time [s]')\n        \n    # ####################################\n    # DETECT PEAKS\n    # ####################################    \n    def set_peaks(self, distance=10):\n        \"\"\"Select correct function\"\"\"\n        self.distance = distance\n        if self.experiment_type == 'WingMuscle':\n            self.set_peaks_wingmuscle()\n        elif self.experiment_type == 'StretchReceptor':\n            self.set_peaks_stretchreceptor()                             \n\n    # Wing Muscle            \n    def set_peaks_wingmuscle(self):\n        \"\"\"Create widget to set peaks in Wing muscle experiment\"\"\"\n        self.depressor_times = list()\n        self.elevator_times = list()\n        self.search_width = 0.005  # seconds\n        \n        # Create widget to plot function\n        self.peaks_widget = widgets.interactive(\n            self.plot_peaks_wingmuscle,\n            time=widgets.FloatSlider(\n                value=(self.time_range[-1] - self.time_range[0])\/2,  # Set initial value halfway\n                min=self.time_range[0], max=self.time_range[-1], step=self.search_width,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time [s]',\n                readout_format='.3f',\n                continuous_update=False,\n            )\n        )\n        # Show widget\n        display(self.caption, self.peaks_widget)  \n        \n        # Create widgets to store time stamps\n        depressor_button = widgets.Button(description=\"Add depressor\")\n        elevator_button = widgets.Button(description=\"Add elevator\")\n        depressor_remove_button = widgets.Button(description=\"Remove depressor\")\n        elevator_remove_button = widgets.Button(description=\"Remove elevator\")\n        remove_all_button = widgets.Button(description=\"Remove all\")\n        self.output = widgets.Output()\n        # Show widgets\n        display(widgets.VBox([\n            widgets.HBox([depressor_button, depressor_remove_button]),\n            widgets.HBox([elevator_button, elevator_remove_button]),\n            remove_all_button,\n            self.output,\n        ]))\n\n        # Link widgets\n        depressor_button.on_click(self.on_depressor_button_clicked)\n        elevator_button.on_click(self.on_elevator_button_clicked)\n        depressor_remove_button.on_click(self.on_depressor_remove_button_clicked)\n        elevator_remove_button.on_click(self.on_elevator_remove_button_clicked)\n        remove_all_button.on_click(self.on_remove_all_button_clicked)\n                \n    def on_depressor_button_clicked(self, b):\n        self.depressor_times.append(self.peak_time)\n        with self.output:\n            print(f\"Depressor stored at {self.peak_time} s\")\n            \n    def on_elevator_button_clicked(self, b):\n        self.elevator_times.append(self.peak_time)\n        with self.output:\n            print(f\"Elevator stored at  {self.peak_time} s\")\n    \n    def on_depressor_remove_button_clicked(self, b):\n        if self.peak_time in self.depressor_times:\n            self.depressor_times.remove(self.peak_time)\n            with self.output:\n                print(f\"Depressor removed at {self.peak_time} s\")\n        else:\n            with self.output:\n                print(f\"No depressor peak stored at {self.peak_time} s\")\n            \n    def on_elevator_remove_button_clicked(self, b):\n        if self.peak_time in self.elevator_times:\n            self.elevator_times.remove(self.peak_time)            \n            with self.output:\n                print(f\"Evelvator removed at {self.peak_time} s\")\n        else:\n            with self.output:\n                print(f\"No elevator peak stored at {self.peak_time} s\")\n                \n    def on_remove_all_button_clicked(self, b):\n        self.elevator_times = list()\n        self.depressor_times = list()\n        with self.output:\n            print(\"Removed all stored spikes.\")\n                      \n    def plot_peaks_wingmuscle(self, time=float()):\n        \"\"\"Inspect signal and plot detected peaks\n        \n        Args:\n            time (float): time stamp of slider \n        \"\"\"\n        # Detect closest peak\n        signal = self.df_time.loc[time-self.search_width:time+self.search_width, 'Signal']\n        self.peak_time = signal.abs().idxmax()\n        if self.peak_time:\n            peak_value = self.df_time.loc[self.peak_time, 'Signal']\n        else:\n            peak_value = None\n        \n        # Plot\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(self.df_time['Signal'], color='steelblue', label='Signal')             # Signal\n        # Indicate search area\n        ax.axvspan(time-self.search_width, time+self.search_width, alpha=0.5, color='lightcoral', zorder=-200)\n        ax.plot(self.peak_time, peak_value, 'o', color='k', alpha=0.5, zorder=20)     # Show value of local peak\n        # Depressor times\n        for depressor_time in self.depressor_times:\n            ax.plot(depressor_time, self.df_time['Signal'][depressor_time], 'v', color='lightcoral')\n        # Elevator times\n        for e_time in self.elevator_times:\n            ax.plot(e_time, self.df_time['Signal'][e_time], '^', color='tab:green')\n        # Format\n        ax.set_xlim(self.time_range)\n        ax.set_xlabel('Time [s]')\n        ax.set_ylabel('Signal')\n       \n    def preprocess_peaks(self):\n        \"\"\"Keep only unique and alternating peak times\"\"\"\n        if len(self.depressor_times) == 0:\n            import random\n            print(f\"{self.file_label} section {self.section_label}: No depressor peaks found; random peaks are created\")\n            self.depressor_times = random.sample(range(10, 30), 5)\n            self.elevator_times = random.sample(range(10, 30), 5)\n            \n        # Get unique peak times\n        depressor_times = sorted(set(self.depressor_times))\n        elevator_times = sorted(set(self.elevator_times))\n\n        # Keep only E peaks that occur after first D peak\n        first_depressor_peak_time = min(depressor_times)\n        elevator_times = [x for x in elevator_times if x > first_depressor_peak_time]\n\n        # Make peak lists same length\n        min_length = min(len(depressor_times), len(elevator_times))\n        self.depressor_times_neat = depressor_times[:min_length]\n        self.elevator_times_neat = elevator_times[:min_length]\n\n        return self.depressor_times_neat, self.elevator_times_neat        \n                             \n# Stretch Receptor\n    def set_peaks_stretchreceptor(self): \n        \"\"\"Create widget to set peaks in Stretch receptor experiment\"\"\"        \n        self.peaks_widget = widgets.interactive(\n            self.update_peaks_stretchreceptor,              # Function call\n            height=widgets.FloatSlider(\n                value=0.5,\n                min=0, max=1, step=0.01,\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Height',\n                readout_format='.3f',\n                continuous_update=False,\n                style={'description_width': 'initial'},\n            ),\n            distance=widgets.fixed(25),\n#             distance=widgets.BoundedIntText(\n#                 value=25,\n#                 min=1, max=10000, step=1,\n#                 layout=widgets.Layout(width=input_width, height=input_height),\n#                 description=f'Distance (index)',\n#                 style={'description_width': 'initial'},\n#             ),\n            time_range=widgets.FloatRangeSlider(                          # Create FloatRangeSlider\n                value=[self.time_range[0], self.time_range[1]],\n                min=self.time_range[0], max=self.time_range[1], step=0.5, # Set slider limits\n                layout=widgets.Layout(width=slider_width, height=slider_height),\n                description=f'Time range (s)',\n                continuous_update=False,                                  # Set to False to improve performance\n                style={'description_width': 'initial'},\n            ),\n        )\n        # Show widgets\n        display(self.caption, self.peaks_widget)\n                             \n    def update_peaks_stretchreceptor(self, height, distance, time_range=(None, None)):\n        \"\"\"Detect peaks and plot corresponding result\n        \n        Args:\n            height (float): threshold for peaks \n            distance (int): minimum distance between peaks (in indices) \n            zoom (bool): If True, plot a zoomed in version \n        \"\"\"\n        # Get normalised values\n        sign_norm = self.normalise(self.df_time['Signal'], shift=False)\n        stim_norm = self.normalise(self.df_time['Stimulus'])\n        \n        # Change to number of dt steps\n        distance_dt = distance\n\n        # Find peaks\n        self.peak_inds, _ = find_peaks(\n            sign_norm.abs().values,\n            height=height, distance=distance_dt\n        )\n        self.peak_times = self.df_time.index[self.peak_inds]                 # Store corresponding times\n        self.peak_values = self.df_time['Signal'].values[self.peak_inds]     # Get peak heights\n        \n        # Set peaks\n        with self.chained_assignment_ignore:\n            self.df_time['peaks'] = 0\n            self.df_time.loc[self.peak_times, 'peaks'] = 1\n        \n        # Plot result\n        fig, ax = plt.subplots(nrows=1, ncols=1)\n        ax.plot(sign_norm, color='steelblue', label='Signal')                           # Signal\n        ax.plot(self.peak_times, sign_norm.values[self.peak_inds],\n                'o', color='lightcoral', zorder=-10)                                    # Peaks\n        ax.plot(stim_norm, color='lightcoral', label='Stimulus', alpha=0.5, zorder=20) # Stimulus\n        ax.axhline(y=height, linestyle='dashed', color='k', alpha=0.5, zorder=5)        # Threshold\n        ax.axhline(y=-height, linestyle='dashed', color='k', alpha=0.5, zorder=5)\n        # # Format\n        ax.set_xlim([time_range[0], time_range[1]])      \n#         if zoom:\n#             ax.set_xlim([self.stim_start_times[0], self.stim_end_times[0]])\n#         else:\n#             ax.set_xlim([self.df_time.index.min(), self.df_time.index.max()])\n        ax.set_ylabel('Signal (normalised)')\n        ax.set_xlabel('Time [s]')\n        ax.legend(bbox_to_anchor=(1, 0.5))\n    \n                             \n    # ####################################\n    # ANALYSE PEAKS\n    # ####################################\n    def analyse_peaks(self, fit_func_name='Exponential'):\n        \"\"\"Select right function\"\"\"\n        if self.experiment_type == 'WingMuscle':\n            pass\n        elif self.experiment_type == 'StretchReceptor':\n            self.analyse_peaks_stretchreceptor(fit_func_name)\n            \n    # Stretch Receptor\n    def analyse_peaks_stretchreceptor(self, fit_func_name):\n        \"\"\"Prepare widget to analyse peaks\"\"\"\n        self.analysis_widgets = list()\n        self.fit_coefficients = list()\n        self.max_frequencies = list()\n        \n        # Create widget to set fit function name\n        if fit_func_name:\n            self.set_fit_func(fit_func_name)\n        else:\n            self.create_fit_func_widget()\n        \n        for num, (stim_start_time, stim_end_time) in enumerate(zip(self.stim_start_times, self.stim_end_times)):\n            # Extract values within stimulus    \n            df = self.df_time.query('@stim_start_time < Time <= @stim_end_time')\n        \n            self.fit_coefficients.append(np.nan)\n            self.max_frequencies.append(np.nan)            \n            self.analysis_widgets.append(\n                self.create_analysis_widget_stretchreceptor(num, stim_start_time, stim_end_time, df)\n            )\n            \n        # Show widgets\n        display(self.caption, widgets.HBox([w for w in self.analysis_widgets]))\n    \n    def create_fit_func_widget(self):\n        w = widgets.interact(\n                self.set_fit_func,\n                fit_func_name=widgets.Dropdown(\n                    options=['Exponential', 'Linear'],\n                    value='Linear',\n                    description='Fit function',\n                    layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                    style={'description_width': 'initial'},\n                )\n        )\n        display(w);\n        \n    def set_fit_func(self, fit_func_name):\n        self.fit_func_name = fit_func_name.lower()\n    \n    def create_analysis_widget_stretchreceptor(self, num, stim_start_time, stim_end_time, df):\n        \"\"\"Create widget to analyse peaks\"\"\"\n#         # Extract values within stimulus    \n#         df = self.df_time.query('@stim_start_time < Time <= @stim_end_time')\n#         df.index -= stim_start_time  # Shift time to start\n            \n        # Create widget\n        analysis_widget = widgets.interactive(\n            self.update_analysis_peaks_stretchreceptor,\n            bin_size=widgets.BoundedFloatText(\n                value=1,\n                min=0.1, max=10.1, step=0.1,\n                layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n                description=f'Bin size (s)',\n            ),\n            df=widgets.fixed(df),\n            num=widgets.fixed(num),\n#             fit_type=widgets.Dropdown(\n#                 options=['Exponential', 'Linear'],\n#                 value='Linear',\n#                 description='Fit function',\n#                 layout=widgets.Layout(width=dropdown_width, height=dropdown_height),\n#                 style={'description_width': 'initial'},\n#             )\n        )\n        \n        return analysis_widget\n    \n    def update_analysis_peaks_stretchreceptor(self, bin_size, df, num):\n        \"\"\"Calculate frequency for bin settings, and plot results\"\"\"\n        # Select peaks within stimulus onset\n        stim_start_time = self.stim_start_times[num]\n        stim_end_time = self.stim_end_times[num]\n        peak_inds = np.asarray(self.peak_inds)\n        peak_times = np.asarray(self.peak_times)\n        mask = (peak_times >= stim_start_time) & (peak_times <= stim_end_time)\n        peak_inds = peak_inds[mask]\n        peak_times = peak_times[mask]\n                \n        # Bin peaks\n        bin_times = np.arange(stim_start_time, stim_end_time + bin_size, bin_size)\n        bin_times -= bin_times % bin_size\n        peak_times_binned = peak_times - peak_times % bin_size  # set bins\n        peak_counts = []\n        for bin_time in bin_times:\n            inds = [e for e in (peak_times_binned) if e == bin_time]\n#             print(f'{bin_time} | {inds} | {len(inds)}')\n            peak_counts.append(len(inds))\n        peak_counts = np.asarray(peak_counts)\n        \n        # Calculate frequency\n        freq = peak_counts \/ bin_size\n        freq_norm = self.normalise(freq)\n        time = bin_times\n        # Extract normalised signal and stimulus\n        signal_norm = self.normalise(df['Signal'], shift=False)\n        stimul_norm = self.normalise(df['Stimulus'])\n        \n        # Check\n#         print('bin_times', bin_times)\n#         print('peak_times_binned', peak_times_binned)\n#         print('peak_counts', peak_counts)\n#         print('freq', freq)\n#         plt.figure()\n#         plt.plot(peak_times_binned, peak_times, '.', alpha=0.2) \n#         plt.figure()\n#         plt.plot(bin_times, peak_counts, '.', alpha=0.2)\n        \n        # Fit frequency to exponential decay and store results\n        if self.fit_func_name == 'exponential':\n            A, K, _, freq_fit, time_fit = self.fit_exp_nonlinear(time, freq)\n            self.fit_coefficients[num] = (K)\n        elif self.fit_func_name == 'linear':\n            A, C, freq_fit, time_fit = self.fit_linear(time, freq)\n            self.fit_coefficients[num] = A\n        self.max_frequencies[num] = max(freq)\n        \n        # Plot\n        fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(fig_width \/ 2, 2*fig_height))\n        axes[0].plot(signal_norm, color='steelblue', label='Signal', alpha=0.5)\n        axes[0].plot(stimul_norm, color='lightcoral', label='Stimulus', alpha=0.5)\n#         axes[0].plot(peak_times, [0.5] * len(peak_times), '.', color='lightcoral', label='Peaks')\n        axes[0].plot(time, freq_norm, '-', color='k', label='Frequency')\n        # # Format\n        axes[0].set_ylabel('Values (normalised)')\n        axes[0].set_xlabel('Time [s]')\n        axes[0].set_xlim([signal_norm.index.min(), signal_norm.index.max()])\n        axes[0].legend(bbox_to_anchor=(1, 0.5))\n        # Fit\n        axes[1].plot(time, freq, color='k', label='Frequency')\n        axes[1].plot(time_fit, freq_fit, color='lightcoral', linestyle='dashed', label='Fit')\n        # # Format\n        axes[1].set_ylabel('Frequency [Hz]')\n        axes[1].set_xlabel('Time [s]')\n        axes[1].set_xlim([signal_norm.index.min(), signal_norm.index.max()])\n        axes[1].legend(bbox_to_anchor=(1, 0.5))\n        \n    # ####################################\n    # Helper functions\n    # ####################################\n    @staticmethod\n    def normalise(values, shift=True):\n        \"\"\"Normalise values between -1 and 1\n\n        Args:\n            values (pd.DataFrame): values to be normalised\n        Returns:\n            pd.DataFrame\n        \"\"\"\n        if shift:\n            return (values - values.min()) \/ (values.max() - values.min())\n        else:\n            return values \/ values.abs().max()\n    \n    @staticmethod\n    def model_func_exp(t, A, K, C):\n        \"\"\"Exponential function\n\n        Args:\n            t (list): time stamps\n            A (float): amplitude\n            K (float): exponential decay coefficient\n            C (float): offset\n\n        Returns:\n            list\n        \"\"\"\n        return A * np.exp(K * t) + C\n    \n    @staticmethod\n    def model_func_lin(t, A, C):\n        \"\"\"Linear function\n        \n        Args:\n            t (array): time stamps\n            A (float): slope\n            C (float): intercept\n        \n        Returns:\n            list\n        \"\"\"\n        t = np.asarray(t)  # Convert to numpy array if t is a list\n        return A * t + C\n        \n    def fit_exp_nonlinear(self, t, y):\n        \"\"\"Fit data to exponential function\n\n        Args:\n            t (list): time stamps\n            y (list): values\n\n        Returns:\n            A (float): amplitude\n            K (float): exponential decay coefficient\n            C (float): offset\n            y_fit (list): fitted function\n        \"\"\"\n        warnings.simplefilter(\"error\", sp.optimize.OptimizeWarning)     # Catch OptimizeWarning as Exception\n        opt_parms = np.nan, np.nan, np.nan                              # Predefine values\n        \n        # Start from maximum value\n        max_ind = np.argmax(y)\n        t = t[max_ind:]\n        y = y[max_ind:]\n        \n        try:\n            # Optimise to exponential function\n            opt_parms, parm_cov = sp.optimize.curve_fit(self.model_func_exp, t, y, maxfev=2000)\n        except sp.optimize.OptimizeWarning:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        except:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        A, K, C = opt_parms\n        \n        y_fit = self.model_func_exp(t, A, K, C)\n        return A, K, C, y_fit, t\n    \n    def fit_linear(self, t, y):\n        \"\"\"Fit data to linear function\n\n        Args:\n            t (list): time stamps\n            y (list): values\n\n        Returns:\n            t (array): time stamps\n            A (float): slope\n            C (float): intercept\n            y_fit (list): fitted function\n        \"\"\"\n        warnings.simplefilter(\"error\", sp.optimize.OptimizeWarning)     # Catch OptimizeWarning as Exception\n        opt_parms = np.nan, np.nan                              # Predefine values\n        try:\n            # Optimise to exponential function\n            opt_parms, parm_cov = sp.optimize.curve_fit(self.model_func_lin, t, y, maxfev=2000)\n        except sp.optimize.OptimizeWarning:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        except:\n            warnings.warn(f'Fit unsuccessful, please try with other bin size.')\n        A, C = opt_parms\n        \n        y_fit = self.model_func_lin(t, A, C)\n        return A, C, y_fit, t\n\nclass WingMuscleAnalysis:\n    \"\"\"Class for specific WingMuscle analysis\"\"\"\n    def __init__(self, analysis_class_list):\n        \"\"\"\n        Args:\n            analysis_class_list (list): list of FileAnalysis classes \n        \"\"\"\n        self.analysis_class_list = analysis_class_list\n        \n        # Get number of sections\n        self.number_of_sections = self.analysis_class_list[0].number_of_sections\n        self.save_path = self.analysis_class_list[0].save_path\n         \n    def combine_peaks(self):\n        \"\"\"Extract peaks from analysis classes in analysis_class_list and combine in numpy array\"\"\"\n        # Extract times from analysis classes\n        self.depressor_times = []\n        self.elevator_times = []\n        for analysis_class in self.analysis_class_list:\n            depressor_times, elevator_times = analysis_class.preprocess_peaks()\n            self.depressor_times.append(depressor_times)\n            self.elevator_times.append(elevator_times)\n       \n        # Combine to numpy array\n        # # Get maximum length\n        max_length = max(map(len, self.depressor_times + self.elevator_times))\n        d = np.empty((len(self.elevator_times), max_length))\n        #d = np.empty((self.number_of_sections, max_length))\n        d[:] = np.NaN\n        e = np.empty((len(self.depressor_times), max_length))\n      #  e = np.empty((self.number_of_sections, max_length))\n        e[:] = np.NaN\n        # # Fill NaN array  \n        for num, (d_time, e_time) in enumerate(zip(self.depressor_times, self.elevator_times)):         \n            d[num, :len(d_time)] = d_time\n            e[num, :len(e_time)] = e_time\n        # Extract d0, d1, e0 and e1 values\n        self.d0, self.d1 = d[:, :-1], d[:, 1:]\n        self.e0, self.e1 = e[:, :-1], e[:, 1:]\n        # Expected values\n        self.wbf = 1 \/ (self.d1 - self.d0)\n        self.pr = (self.e0 - self.d0) \/ (self.d1 - self.d0)\n        \n        \n        # Return\n        return self.d0, self.d1, self.e0, self.e1\n    \n    def check(self, wing_beat_frequency, phase_relation):        \n        \n        # Check input\n        if np.nanmean(wing_beat_frequency) != np.nanmean(self.wbf1) and np.nanmean(wing_beat_frequency) != np.nanmean(self.wbf2):  \n            warnings.warn(\"Please check the equation for the Wing Beat frequency.\")\n        else:\n            warnings.warn(\"The equation for the Wing Beat frequency is correct!\")\n        if np.nanmean(phase_relation) !=  np.nanmean(self.pr1) and np.nanmean(phase_relation) !=  np.nanmean(self.pr2):\n            warnings.warn(\"Please check the equation for the Phase relation.\")\n        else:\n            warnings.warn(\"The equation for the Phase Relations is correct!\")\n            \n    def plot_relation(self, wing_beat_frequency, phase_relation):\n        \"\"\"Plot wing beat frequency to phase relation per section\"\"\"\n        # Check input\n        if wing_beat_frequency.all() != eval('self.wbf').all():\n            warnings.warn(\"Please check the equation for the Wing Beat frequency.\")\n        if phase_relation.all() !=  eval('self.pr').all():\n            warnings.warn(\"Please check the equation for the Phase relation.\")\n                                        \n        # Calculate means\n        wing_beat_frequency_mean = np.nanmean(wing_beat_frequency, axis=1)\n        phase_relation_mean = np.nanmean(phase_relation, axis=1)\n        wing_beat_frequency_std = np.nanstd(wing_beat_frequency, axis=1)\n        phase_relation_std = np.nanstd(phase_relation, axis=1)\n    \n        # Plot wing beat frequency vs phase relation\n        fig, ax = plt.subplots(1, 1, figsize=(fig_width\/2, fig_height))\n        ax.errorbar(wing_beat_frequency_mean, phase_relation_mean, yerr=phase_relation_std, linestyle='none', marker='o')\n        return ax","14c5ff3a":"# This is the path to the dataset\npath_to_input_folder = Path('\/kaggle\/input\/datasetname\/')\n\n# Create class to set file properties\nfp = FileProperties(experiment_type)\nfp.set_input_data(path_to_input_folder)  # Creates widgets to set file properties","969d32e3":"analysis_class_list = fp.create_analysis_classes()","18010291":"for analysis_class in analysis_class_list:\n    analysis_class.load_data()              # This function reads all selected text files","3bc61312":"analysis_class.df.head()","9fb1b9e7":"for analysis_class in analysis_class_list:\n    analysis_class.set_column_names(False)","49cc7f5c":"for analysis_class in analysis_class_list:\n    analysis_class.rename_columns()\n\n# Inspect data\nanalysis_class.df.head()","5f8606c3":"for analysis_class in analysis_class_list:\n    analysis_class.set_time_range()","4d94c586":"for analysis_class in analysis_class_list:\n    analysis_class.store_time_range()","1c24ec23":"for analysis_class in analysis_class_list:\n    analysis_class.set_peaks()","ecee5064":"wing_muscle_analysis = WingMuscleAnalysis(analysis_class_list)\nD0, D1, E0, E1 = wing_muscle_analysis.combine_peaks()","def13c5a":"# Fill in...\nwing_beat_frequency = .......\nphase_relation = ......","95df3949":"# Calculate means\nwing_beat_frequency_mean = np.nanmean(wing_beat_frequency, axis=1)\nphase_relation_mean = np.nanmean(phase_relation, axis=1)\nwing_beat_frequency_std = np.nanstd(wing_beat_frequency, axis=1)\nphase_relation_std = np.nanstd(phase_relation, axis=1)\n    \n# Plot wing beat frequency vs phase relation\nfig, ax = plt.subplots(1, 1, figsize=(fig_width\/2, fig_height))\nax.errorbar(wing_beat_frequency_mean, phase_relation_mean, yerr=phase_relation_std, color='royalblue', linestyle='none', marker='o')     \n\n# Fill in the correct x and y axis labels\nax.set_xlabel('...')\nax.set_ylabel('...');\n\n","dd3ac512":"# Compact Course: Wing Muscle\n\nThis notebook will walk you through the analysis pipeline.\nIn order to work with this notebook, click `Edit` in the upper right corner.\n\nEach code cell needs to be run one by one. For this, you select the cell and press `SHIFT + ENTER`. <br>\nWe have combined all code within a few classes, with functions that you can simple run.\nTherefore, you don't have to pay attention to the actual code (although you are of course free to read it).\n\n**NOTE: Do not change the code!** <br>\nThese changes might mess up the analysis pipeline, requiring you to load a new document and start again.\nYou can perform the analysis using the created controls (so-called widgets).\n\n**Before you start:** check your recorded files. If numbers have a ',' as a decimal point (i.e 11,23) change the comma to a dot (so 11,23 should be changed to 11.23). To do this, use CTRL+h option in your text editor to replace all (repeat this in all files).","1369b003":"Make sure you have set the correct names for all values above, and run the next code cell to actually rename the columns.\nAn example of what the data now looks like will be given.","de9bc9da":"#### Formatting settings\nThen, we define the following formatting settings (mainly aesthetics):","22e95a61":"#### Set data properties\nNow we can run the following code cell after specifying the correct path to the uploaded data (make sure your path has **the correct dataset name** according to the name you chose above).\nAll text files in the input folder are shown.\nUse the checkbox in front of each file name to select which file to be used, and specify the number of sections to be used. Later on, we will select the exact time ranges of these sections.","fc26f06d":"#### Set time range\nIf desired, we can crop the time range of the data, by denoting a start and end time using the slider.\nFor more precision, the slider values can also be adjusted by selecting the start resp. end button and pressing the left\nor right arrow on your keyboard. Additionally, the values can also be set by selecting the numbers right of the slider, typing the desired values and pressing enter.\nThis has to be done for the data of each file.\nMake sure each section has at least multiple wing beats, but we advise to not select more than 2 seconds.","2f5c0baa":"# Imports and definitions\n#### Import packages\nFirst, we import the required python packages by running the following cell:","47ec2c86":"## Input data\nNext, you have to upload your experimental data.\nYou dont need to upload all the traces you recorded, but make sure you upload all the ones you would like to use, especially if you have segments with different flight speeds (wing beat frequencies).\nFor this, click on `Add data` in the top right corner of the Kaggle window.\n<div>\n<img src=\"attachment:8054ecaa-7ca0-424c-bfd7-8052618cfa04.png\" width=\"300\"\/>\n<\/div>\n\nWe will upload a new dataset. For this, click `Upload` in the new screen.\n\n<div>\n<img src=\"attachment:95d5331c-3f57-4d44-ad3a-28f636db705d.png\" width=\"400\"\/>\n<\/div>\n\nAdd the text files you want to use and name the dataset _wingmuscle_. <br>\n**Important:** make sure you give the dataset the correct name. Otherwise you won't be able to read the corresponding files. Finally, click `Create`.\n\n<div>\n<img src=\"attachment:6d77588c-c910-4f49-8f02-413002181c2f.png\" width=\"300\"\/>\n<\/div>\n\nThe result will look something like this:\n\n<div>\n<img src=\"attachment:c959cf8c-bbe7-4f3c-842a-b5b36d47f688.png\" width=\"300\"\/>\n<\/div>","49033d57":"#### Detect spikes\nNext, we want to detect the depressor and elevator in the measured signal. For this, we look for the maximum absolute value within a search range.\nHere, the slider can be used to move the search range (red shaded area) over time. The maximum absolute value within the selected range will be plotted\n(black circle). Subsequently, the detected peak can be stored as a depressor peak or elevator peak by clicked the corresponding `Add depressor` or `Add elevator` button.\nTo remove a stored peak, set the slider such that this peak is selected and press `Remove depressor` or `Remove elevator`.\nRecall that the difference between the depressor (**D**) and elevator (**E**) spikes:\n<div>\n<img src=\"attachment:3fc7f6ee-c325-4a08-9e65-0888e8f5d0a6.png\" width=\"200\"\/>\n<\/div>\n\nNote that the depressor and elevator peaks should be alternating. Only detected spikes will be taken into account in the analysis, so select multiple **sequential** depressor and elevator spikes (at least 3 consecutive cycles of Dep-Elev pairs).","c3e23bb7":"Once you have detected the depressor and elevator spikes, take a prinscreen of the figures above to hand in.","2475e24b":"**Finally you are asked to hand in a short document containing:**\n\n(1) An example segment of your recordings, containing selected depressor and elevator peaks from the plots above. You can take a screenshot of the figure above and then in your editor add a short title and a figure caption to explain the plot.\n\n(2) Your final plot with average phase relationships vs wingbeat frequencies. Write an appropriate figure title and caption describing what is plotted.\n\n(3) Briefly answer the following questions:\n* From your observations: Is the phase between wing depression and elevation depends on the flight speed (frequency)?\n* Will your answer change (and if so, how) if you would calculate the phase between elevation (E) and depression (D) instead of between depression and elevation? Explain briefly how your plot will change if you had calculated E to D instead of D to E.\n","addeeac6":"# Analyse spikes\nFinally, we create the class `WingMuscleAnalysis` that contains specific functions for this experiment. This class reads the information from all `FileAnalysis` classes above, and combined the peak data in the `combine_peaks` function.","f06e7109":"# Prepare analysis\n#### Create an analysis class per File\nAfter we have set the properties for each file, we can start the analysis.\nFor this, we create a `FileAnalysis` class for each file and store these in `analysis_class_list`, so we can easily access them later on.","ed78ac1f":"The `combine_peaks` function has returned four variables: `D0`, `D1`, `E0`, and `E1`. These variables correspond to the first and second of depressor and elevator peaks at each wing beat cycle respectively, as shown above.\n\nIn the next cell, fill in the correct equations for the wing beat frequency and phase relationship. The wing beat frequency is the rate of wingbeat cycles and it will be based on the distance between certain spike events. The phase relationship indicates the time between a depressor and elevator peak within a cycle.\n\nNote: A phase variable describes the relative lag between two type of events and is decribed by a cyclic variable with values ranging from 0 to 1. A value of zero (and also a value of 1) mean \"in-phase\" (the two event types occur simultanously) while a value of 0.5 means \"anti-phase\" (the events are in alternation).","6ce5afca":"#### Load data\nRun the following code cell to read all selected text files. This might take a while...","b341a32f":"The column names in the data do not necessarily describe the value in the columns.\n<br>\nBy running the following code cell, we can inspect the values in each file.\nEach figure shows the column values, the y axis displays the current name.\n<br>\nThe dropdown widgets have to be used to specify the right name for each column.\nNote that column names that are left empty, will be removed later on.","31a60356":"#### Set column names\nThe text file contains a table, with values for specific properties for each timestamp.\nUsing the following cell, we can see what one of these files currently looks like.","7479b0d8":"#### Define functions\nIn addition, we define the following classes that contain all functions we need in this analysis.\n<br>\nIf you want, you can skip reading this code. _(But don't forget to run this code cell.)_","0af29ccc":"Make sure you have set the correct time ranges above, and run the next code cell to store these settings.","e9a5dbc4":"We can now calculate the average wing beat frequency and phase between wing depression and elevation for each flight segment.\nWe then plot the results to examine whether the phase relation remains constant at different flight speeds (wing beat frequencies).\n \nIn the cell below, to complete the plot you are asked to add the correct x and y axis labels."}}