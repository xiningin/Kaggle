{"cell_type":{"e22b54c5":"code","35b0279b":"code","2c6b0e44":"code","70b7cdfc":"code","3bd1fdba":"code","a228635a":"code","a5927e9e":"code","43f726ba":"code","88a65609":"code","5b510375":"code","e9301c1e":"code","c991092e":"code","c4d1bbf8":"code","4d004cff":"code","bb8a3d63":"code","5ca1324a":"markdown","ae1e105e":"markdown","e04bc6ea":"markdown","718519a4":"markdown","0103a045":"markdown","cf4979a2":"markdown","093d5312":"markdown","65a37f12":"markdown"},"source":{"e22b54c5":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport os # processing file path\nimport gzip # unzip the .gz file, not used here\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # data visualization\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nfrom subprocess import check_output\nprint(\"Here are the input datasets: \")\nprint(check_output([\"ls\", \"..\/input\"]).decode(\"utf8\"))\n\nprint(\"Python Version: \")\n!python -V\n# Any results you write to the current directory are saved as output.","35b0279b":"def load_mnist(path, kind='train'):\n\n    \"\"\"Load MNIST data from `path`\"\"\"\n    labels_path = os.path.join(path,'%s-labels-idx1-ubyte'% kind)\n    images_path = os.path.join(path,'%s-images-idx3-ubyte'% kind)\n    \n    with open(labels_path,'rb') as lbpath:\n        labels = np.frombuffer(lbpath.read(), dtype=np.uint8,\n                               offset=8)\n    \n    with open(images_path,'rb') as imgpath:\n        images = np.frombuffer(imgpath.read(), dtype=np.uint8,\n                               offset=16).reshape(len(labels), 784)\n\n    return images, labels","2c6b0e44":"# Cleaning up variables to prevent loading data multiple times (which may cause memory issue)\ntry:\n    del X_train, y_train\n    del X_test, y_test\n    print('Clear previously loaded data.')\nexcept:\n    pass","70b7cdfc":"# Load the data\nX_train, y_train = load_mnist('..\/input', kind='train')\nX_test, y_test = load_mnist('..\/input', kind='t10k')\nm_train = X_train.shape[0]\nm_test = X_test.shape[0]","3bd1fdba":"print(\"X_train shape: \" + str(X_train.shape))\nprint(\"y_train shape: \" + str(y_train.shape))\nprint(\"X_test shape: \" + str(X_test.shape))\nprint(\"y_test shape: \" + str(y_test.shape))\nprint (\"Number of training examples: m_train = \" + str(m_train))\nprint (\"Number of testing examples: m_test = \" + str(m_test))","a228635a":"# random check with nine training examples\nnp.random.seed(0);\nindices = list(np.random.randint(m_train,size=9))\nfor i in range(9):\n    plt.subplot(3,3,i+1)\n    plt.imshow(X_train[indices[i]].reshape(28,28), cmap='gray', interpolation='none')\n    plt.title(\"Index {} Class {}\".format(indices[i], y_train[indices[i]]))\n    plt.tight_layout()","a5927e9e":"# Subsample the data\nm_train = 59000\nm_validation = 1000\n\nmask = list(range(m_train, m_train + m_validation))\nX_val = X_train[mask]\ny_val = y_train[mask]\n\nmask = list(range(m_train))\nX_train = X_train[mask]\ny_train = y_train[mask]\n\nmask = list(range(m_test))\nX_test = X_test[mask]\ny_test = y_test[mask]","43f726ba":"# Reshape data to rows\nX_train = X_train.reshape(m_train, -1)\nX_val = X_val.reshape(m_validation, -1)\nX_test = X_test.reshape(m_test, -1)","88a65609":"print(\"X_train shape: \" + str(X_train.shape))\nprint(\"y_train shape: \" + str(y_train.shape))\nprint(\"X_val shape: \" + str(X_val.shape))\nprint(\"y_val shape: \" + str(y_val.shape))\nprint(\"X_test shape: \" + str(X_test.shape))\nprint(\"y_test shape: \" + str(y_test.shape))\nprint (\"Number of training examples: m_train = \" + str(m_train))\nprint (\"Number of validation examples: m_validation = \" + str(m_validation))\nprint (\"Number of testing examples: m_test = \" + str(m_test))","5b510375":"print(\"Feature Values: \\nFrom \" + str(np.min(X_train)) + \" to \" + str(np.max(X_train)))\nprint(\"Data type: \" + str(X_train.dtype))\nprint(\"\\nLabel Values: \")\nprint(set(list(y_train)))\nprint(\"Data type: \" + str(y_train.dtype))","e9301c1e":"class TwoLayerNet(object):    \n    \"\"\"\n    A two-layer fully-connected neural network. The net has an input dimension of\n    N, a hidden layer dimension of H, and performs classification over C classes.\n    We train the network with a softmax loss function and L2 regularization on the\n    weight matrices. The network uses a ReLU nonlinearity after the first fully\n    connected layer.\n\n    In other words, the network has the following architecture:\n\n    input - fully connected layer - ReLU - fully connected layer - softmax\n\n    The outputs of the second fully-connected layer are the scores for each class.\n    \"\"\"\n\n    def __init__(self, input_size, hidden_size, output_size, std=1e-4): \n        \"\"\"\n        Initialize the model. Weights are initialized to small random values and\n        biases are initialized to zero. Weights and biases are stored in the\n        variable self.params, which is a dictionary with the following keys:\n\n        W1: First layer weights; has shape (D, H)\n        b1: First layer biases; has shape (H,)\n        W2: Second layer weights; has shape (H, C)\n        b2: Second layer biases; has shape (C,)\n\n        Inputs:\n        - input_size: The dimension D of the input data.\n        - hidden_size: The number of neurons H in the hidden layer.\n        - output_size: The number of classes C.\n        \"\"\"\n        self.params = {}    \n        self.params['W1'] = std * np.random.randn(input_size, hidden_size)   \n        self.params['b1'] = np.zeros((1, hidden_size))    \n        self.params['W2'] = std * np.random.randn(hidden_size, output_size)   \n        self.params['b2'] = np.zeros((1, output_size))\n\n    def loss(self, X, y=None, reg=0.0):\n        \"\"\"\n        Compute the loss and gradients for a two layer fully connected neural\n        network.\n\n        Inputs:\n        - X: Input data of shape (N, D). Each X[i] is a training sample.\n        - y: Vector of training labels. y[i] is the label for X[i], and each y[i] is\n          an integer in the range 0 <= y[i] < C. This parameter is optional; if it\n          is not passed then we only return scores, and if it is passed then we\n          instead return the loss and gradients.\n        - reg: Regularization strength.\n\n        Returns:\n        If y is None, return a matrix scores of shape (N, C) where scores[i, c] is\n        the score for class c on input X[i].\n\n        If y is not None, instead return a tuple of:\n        - loss: Loss (data loss and regularization loss) for this batch of training\n          samples.\n        - grads: Dictionary mapping parameter names to gradients of those parameters\n          with respect to the loss function; has the same keys as self.params.\n        \"\"\"\n        # Unpack variables from the params dictionary\n        W1, b1 = self.params['W1'], self.params['b1']\n        W2, b2 = self.params['W2'], self.params['b2']\n        N, D = X.shape\n        \n        # Compute the forward pass\n        scores = None\n        h1 = ReLU(np.dot(X, W1) + b1)      \n        out = np.dot(h1, W2) + b2          \n        scores = out\n        \n        # If the targets are not given then jump out, we're done\n        if y is None:   \n            return scores\n        \n        # Compute the loss\n        scores_max = np.max(scores, axis=1, keepdims=True)    # (N,1)\n        exp_scores = np.exp(scores - scores_max)              # (N,C)\n        probs = exp_scores \/ np.sum(exp_scores, axis=1, keepdims=True)    # (N,C)\n        correct_logprobs = -np.log(probs[range(N), y])        # (N,1)\n        data_loss = np.sum(correct_logprobs) \/ N\n        reg_loss = 0.5 * reg * np.sum(W1*W1) + 0.5 * reg * np.sum(W2*W2)\n        loss = data_loss + reg_loss\n        \n        # Backward pass: compute gradients\n        grads = {}\n        dscores = probs                                 # (N,C)\n        dscores[range(N), y] -= 1\n        dscores \/= N\n        dW2 = np.dot(h1.T, dscores)                     # (H,C)\n        db2 = np.sum(dscores, axis=0, keepdims=True)    # (1,C)\n        dh1 = np.dot(dscores, W2.T)                     # (N,H)\n        dh1[h1 <= 0] = 0\n        dW1 = np.dot(X.T, dh1)                          # (D,H)\n        db1 = np.sum(dh1, axis=0, keepdims=True)        # (1,H)\n        dW2 += reg * W2\n        dW1 += reg * W1\n        \n        grads['W1'] = dW1\n        grads['b1'] = db1\n        grads['W2'] = dW2\n        grads['b2'] = db2\n\n        return loss, grads\n\n    def train(self, X, y, X_val, y_val, learning_rate=1e-3, \n               learning_rate_decay=0.95, reg=1e-5, mu=0.9, num_epochs=10, \n               mu_increase=1.0, batch_size=200, verbose=False):   \n        \"\"\"\n        Train this neural network using stochastic gradient descent.\n\n        Inputs:\n        - X: A numpy array of shape (N, D) giving training data.\n        - y: A numpy array f shape (N,) giving training labels; y[i] = c means that\n          X[i] has label c, where 0 <= c < C.\n        - X_val: A numpy array of shape (N_val, D) giving validation data.\n        - y_val: A numpy array of shape (N_val,) giving validation labels.\n        - learning_rate: Scalar giving learning rate for optimization.\n        - learning_rate_decay: Scalar giving factor used to decay the learning rate\n          after each epoch.\n        - reg: Scalar giving regularization strength.\n        - num_iters: Number of steps to take when optimizing.\n        - batch_size: Number of training examples to use per step.\n        - verbose: boolean; if true print progress during optimization.\n        \"\"\"\n        num_train = X.shape[0]\n        iterations_per_epoch = max(int(num_train \/ batch_size), 1)\n        \n        # Use SGD to optimize the parameters in self.model\n        v_W2, v_b2 = 0.0, 0.0\n        v_W1, v_b1 = 0.0, 0.0\n        loss_history = []\n        train_acc_history = []\n        val_acc_history = []\n\n        for it in range(1, num_epochs * iterations_per_epoch + 1):   \n            X_batch = None   \n            y_batch = None \n            \n            # Create a random minibatch of training data and labels\n            sample_index = np.random.choice(num_train, batch_size, replace=True)   \n            X_batch = X[sample_index, :]          \n            y_batch = y[sample_index]             \n            \n            # Compute loss and gradients using the current minibatch\n            loss, grads = self.loss(X_batch, y=y_batch, reg=reg) \n            loss_history.append(loss)\n            \n            # Use the gradients to update the parameters of the network\n            v_W2 = mu * v_W2 - learning_rate * grads['W2']    \n            self.params['W2'] += v_W2   \n            v_b2 = mu * v_b2 - learning_rate * grads['b2']    \n            self.params['b2'] += v_b2   \n            v_W1 = mu * v_W1 - learning_rate * grads['W1']    \n            self.params['W1'] += v_W1   \n            v_b1 = mu * v_b1 - learning_rate * grads['b1']  \n            self.params['b1'] += v_b1\n            \n            if verbose and it % iterations_per_epoch == 0:    \n            # Every epoch, check train and val accuracy and decay learning rate.\n                epoch = it \/ iterations_per_epoch    \n                train_acc = (self.predict(X_batch) == y_batch).mean()    \n                val_acc = (self.predict(X_val) == y_val).mean()    \n                train_acc_history.append(train_acc)    \n                val_acc_history.append(val_acc)    \n                print(\"epoch %d \/ %d: loss %f, train_acc: %f, val_acc: %f\" % \n                                    (epoch, num_epochs, loss, train_acc, val_acc))\n                \n                # Decay learning rate\n                learning_rate *= learning_rate_decay    \n                mu *= mu_increase\n\n        return {   \n            'loss_history': loss_history,   \n            'train_acc_history': train_acc_history,   \n            'val_acc_history': val_acc_history,\n        }\n\n    def predict(self, X):    \n        \"\"\"\n        Use the trained weights of this two-layer network to predict labels for\n        data points. For each data point we predict scores for each of the C\n        classes, and assign each data point to the class with the highest score.\n\n        Inputs:\n        - X: A numpy array of shape (N, D) giving N D-dimensional data points to\n          classify.\n\n        Returns:\n        - y_pred: A numpy array of shape (N,) giving predicted labels for each of\n        the elements of X. For all i, y_pred[i] = c means that X[i] is predicted\n        to have class c, where 0 <= c < C.\n        \"\"\"\n        y_pred = None    \n        h1 = ReLU(np.dot(X, self.params['W1']) + self.params['b1'])    \n        scores = np.dot(h1, self.params['W2']) + self.params['b2']    \n        y_pred = np.argmax(scores, axis=1)    \n\n        return y_pred\n\ndef ReLU(x):    \n     \n    return np.maximum(0, x)","c991092e":"input_size = X_train.shape[1]\nhidden_size = 10\nnum_classes = 10\nnet = TwoLayerNet(input_size, hidden_size, num_classes)\n\n# Train the network\nstats = net.train(X_train, y_train, X_val, y_val,\n            num_epochs=10, batch_size=1024,\n            learning_rate=7.5e-4, learning_rate_decay=0.95,\n            reg=1.0, verbose=True)\n\n# Predict on the validation set\nval_acc = (net.predict(X_val) == y_val).mean()","c4d1bbf8":"%matplotlib inline\nplt.rcParams['figure.figsize'] = (10.0, 8.0) # set default size of plots\nplt.rcParams['image.interpolation'] = 'nearest'\nplt.rcParams['image.cmap'] = 'gray'\nplt.subplots_adjust(wspace =0, hspace =0.3)\n\n\n# Plot the loss function and train \/ validation accuracies\n\nplt.subplot(2, 1, 1)\nplt.plot(stats['loss_history'])\nplt.title('Loss history')\nplt.xlabel('Iteration')\nplt.ylabel('Loss')\n\nplt.subplot(2, 1, 2)\nplt.plot(stats['train_acc_history'], label='train')\nplt.plot(stats['val_acc_history'], label='val')\nplt.title('Classification accuracy history')\nplt.xlabel('Epoch')\nplt.ylabel('Clasification accuracy')\nplt.legend()\nplt.show()","4d004cff":"# Fine-tune hyperparameters such as learning_rates and regularization_strengths\n# To find the best_net for predicting on the test (It takes about 1~3 minutes depends on CPU)\n# Other hyperparameters: hidden_size \/ num_epochs \/ ...\n\nhidden_size = 10\nnum_classes = 10\n\nresults = {}\nbest_val = -1\nbest_net = None\n\nlearning_rates = np.array([2.5,5,7.5,10])*1e-4\nregularization_strengths = [0.25,0.5,0.75,1]\n\nfor lr in learning_rates:\n    for reg in regularization_strengths:\n        net = TwoLayerNet(input_size, hidden_size, num_classes)\n        stats = net.train(X_train, y_train, X_val, y_val,\n        num_epochs=10, batch_size=1024,\n        learning_rate=lr, learning_rate_decay=0.95,\n        reg= reg, verbose=False)\n        val_acc = (net.predict(X_val) == y_val).mean()\n        if val_acc > best_val:\n            best_val = val_acc\n            best_net = net         \n        results[(lr,reg)] = val_acc\n\n\nfor lr, reg in sorted(results):\n    val_acc = results[(lr, reg)]\n    print('lr %e reg %e val accuracy: %f' % (\n                lr, reg,  val_acc))\n    \nprint('best validation accuracy achieved during cross-validation: %f' % best_val)","bb8a3d63":"# Predict on the test set (using the best_net)\ntest_acc = (best_net.predict(X_test) == y_test).mean()\nprint('Test accuracy: ', test_acc)","5ca1324a":"## Import packages","ae1e105e":"## Load the datasets\nWe haven't use the CSV file because we want to load the dataset using Numpy.  \n**Notice:** If you use the `mnist_reader.py` codes from  [GitHub repository](https:\/\/github.com\/zalandoresearch\/fashion-mnist\/blob\/master\/utils\/mnist_reader.py), it might doesn't work. Because the `.gz` file has been unpacked.","e04bc6ea":"## Implacement TwoLayerNet","718519a4":"## Training and Analysis","0103a045":"## Improve the Net","cf4979a2":"## Implement and apply a Two layer neural network classifier\nCS231n Course Notes Reading List (recommand) :  \n- [Image Classification: Data-driven Approach, k-Nearest Neighbor, train\/val\/test splits](https:\/\/cs231n.github.io\/classification\/)\n- [Linear classification: Support Vector Machine, Softmax](https:\/\/cs231n.github.io\/linear-classify\/)\n- [Optimization: Stochastic Gradient Descent](https:\/\/cs231n.github.io\/optimization-1\/)\n- [Backpropagation, Intuitions](https:\/\/cs231n.github.io\/optimization-2\/)\n- [Neural Networks Part 1: Setting up the Architecture](https:\/\/cs231n.github.io\/neural-networks-1\/) \n- [Neural Networks Part 2: Setting up the Data and the Loss](https:\/\/cs231n.github.io\/neural-networks-2\/)\n- [Neural Networks Part 3: Learning and Evaluation](https:\/\/cs231n.github.io\/neural-networks-3\/)\n\nOr you can run below cells then go back to read the notes while you meet problems, this is part re-inplacement of [CS231n Assignment #1](https:\/\/cs231n.github.io\/assignments2018\/assignment1\/). It's convenient to do on Kaggle without lots of preparation.\n\n### MNIST and Fashion-MNIST dataset\nThe original [MNIST dataset](http:\/\/yann.lecun.com\/exdb\/mnist\/) contains a lot of handwritten digits. Members of the AI\/ML\/Data Science community love this dataset and use it as a benchmark to validate their algorithms. In fact, MNIST is often the first dataset researchers try. *\"If it doesn't work on **MNIST**, it won't work at all\"*, they said. *\"Well, if it does work on MNIST, it may still fail on others.\"*  \nHere are some good reasons for using [Fashion-MNIST dataset](https:\/\/github.com\/zalandoresearch\/fashion-mnist):  \n- MNIST is too easy. Convolutional nets can achieve 99.7% on MNIST. Classic machine learning algorithms can also achieve 97% easily. Check out our side-by-side benchmark for Fashion-MNIST vs. MNIST, and read \"Most pairs of MNIST digits can be distinguished pretty well by just one pixel.\"\n- MNIST is overused. In this April 2017 Twitter thread, Google Brain research scientist and deep learning expert Ian Goodfellow calls for people to move away from MNIST.\n- MNIST can not represent modern CV tasks, as noted in this April 2017 Twitter thread, deep learning expert\/Keras author Fran\u00e7ois Chollet.","093d5312":"## Preprocessing","65a37f12":"| 0           | 1       | 2        | 3     | 4    | 5     | 6     | 7       | 8    | 9          |\n| ----------- | ------- | -------- | ----- | ---- | ----- | ----- | ------- | ---- | ---------- |\n| T-shirt\/top | Trouser | Pullover | Dress | Coat | Sanda | Shirt | Sneaker | Bag  | Ankle boot |\n"}}