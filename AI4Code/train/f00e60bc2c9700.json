{"cell_type":{"46c880cf":"code","54075db8":"code","2b00101c":"code","3f5ffc5c":"code","cc0ddd6b":"code","26fcd8ab":"code","b075e1a3":"code","688482fc":"code","104d570b":"code","d18a0010":"code","34005082":"code","646e1300":"code","a12eefb5":"code","467ede1e":"code","d79d9ab4":"markdown","a16e823e":"markdown","558ce5b6":"markdown","86b5cc91":"markdown","fcb7cf46":"markdown","8ee7a2d5":"markdown"},"source":{"46c880cf":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport time\nimport random \nimport os\nfrom collections import Counter","54075db8":"#read in csv file\ndf_cities = pd.read_csv(\"\/kaggle\/input\/cities10\/cities10.csv\")","2b00101c":"#To show all the cities when visualised as a scatter plot.\nplt.figure(figsize=(15, 10))\nplt.scatter(df_cities.X, df_cities.Y, s=1)\nplt.scatter(df_cities.iloc[0: 1, 1], df_cities.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.title(\"Cities of 10% of dataset\")\nplt.show()","3f5ffc5c":"number_of_cities = max(df_cities.CityId)\nprint(\"Number of cities to visit : \", number_of_cities)","cc0ddd6b":"# Getting Number of Prime Cities\ndef sieve_eratosthenes(n):\n    primes = [False, False] + [True for i in range(n - 1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * 2, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes","26fcd8ab":"primes = np.array(sieve_eratosthenes(number_of_cities)).astype(int)\ndf_cities['Prime'] = primes","b075e1a3":"penalization = 0.1 * (1 - primes) + 1","688482fc":"plt.figure(figsize=(15, 10))\nsns.countplot(df_cities.Prime)\nplt.title(\"Prime repartition : \" + str(Counter(df_cities.Prime)))\nplt.show()","104d570b":"#To show the prime cities when visualised as a scatter plot.\nplt.figure(figsize=(15, 10))\nplt.scatter(df_cities[df_cities['Prime'] == 0].X, df_cities[df_cities['Prime'] == 0].Y, s=1, alpha=0.4)\nplt.scatter(df_cities[df_cities['Prime'] == 1].X, df_cities[df_cities['Prime'] == 1].Y, s=1, alpha=0.6, c='blue')\nplt.scatter(df_cities.iloc[0: 1, 1], df_cities.iloc[0: 1, 2], s=10, c=\"red\")\nplt.grid(False)\nplt.title('Prime Cities')\nplt.show()","d18a0010":"def total_distance(dfcity,path):\n    prev_city = path[0]\n    total_distance = 0\n    step_num = 1\n    for city_num in path[1:]:\n        next_city = city_num\n        total_distance = total_distance + \\\n            np.sqrt(pow((dfcity.X[city_num] - dfcity.X[prev_city]),2) + pow((dfcity.Y[city_num] - dfcity.Y[prev_city]),2)) * \\\n            (1+ 0.1*((step_num % 10 == 0)*int(not(primes[prev_city]))))\n        prev_city = next_city\n        step_num = step_num + 1\n    return total_distance","34005082":"start = time.time()\noriginal_path = list(df_cities.CityId[:].append(pd.Series([0])))\nprint('Total distance with path in original order is '+ \"{:,}\".format(total_distance(df_cities,original_path)))\nend = time.time()\n\n#Algorithm run time\nprint(\"Run time:\", end - start)","646e1300":"#show the first 100 steps with path in original order\ndf_path = pd.merge_ordered(pd.DataFrame({'CityId':original_path}),df_cities,on=['CityId'])\nfig, ax = plt.subplots(figsize=(15,10))\nax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\n\nfor i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)","a12eefb5":"start = time.time()\nsorted_cities = list(df_cities.iloc[1:,].sort_values(['X','Y'])['CityId'])\nsorted_cities = [0] + sorted_cities + [0]\nprint('Total distance with the sorted city path is '+ \"{:,}\".format(total_distance(df_cities,sorted_cities)))\nend = time.time()\n\n#Algorithm run time\nprint(\"Run time:\", end - start)","467ede1e":"#show the first 100 steps with sorted in X,Y coordinate_order\ndf_path = pd.DataFrame({'CityId':sorted_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(15,10))\nax.set_xlim(0,50)\nax.plot(df_path.iloc[0:100,]['X'], df_path.iloc[0:100,]['Y'],marker = 'o')\n\nfor i, txt in enumerate(df_path.iloc[0:100,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:100,]['X'][i], df_path.iloc[0:100,]['Y'][i]),size = 15)","d79d9ab4":"**In order to solve the Travelling Santa Problem for the assignment 1, I will make use of the insertion sort algorithm:**","a16e823e":"**The data structure used in this algorithm is a list.**\n* This function does not have a linear run time as it contains a for loop nested in a while loop\n* At worst, it will run through n elements n times O(n^2)\n* List comprehension runs n times with 2 operations\n* While loop runs n times\n* If statement runs 1 time with 1 primitive operations inside it\n* A for loop runs n times with 2 operations","558ce5b6":"There are prime cities approximately all around the map.","86b5cc91":"**This shows the dataset for the Travelling Santa competition appears when visualised as a scatter plot.**\n* The red dot indicates the North Pole (CityId = 0). \n* This is 10% of the full data set.","fcb7cf46":"**The \"Sieve of Eratosthenes\" function below is for finding all prime numbers up to any given limit.**\n* One of the parameters for the travelling santa competition is that if the chosen path does not originate from a prime city exactly every 10th step, it takes 10% longer. \n* Therefore having a list of prime numbers within the limit is essential for calculating the length of a path.","8ee7a2d5":"* This function is linear however the worst operation\n* There are 4 primitive operations before the for loop (assignment and sequence access)\n* The for loops runs for n amount of time\n* The numpy package is then accessed, adding to the run time"}}