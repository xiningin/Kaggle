{"cell_type":{"de516822":"code","4e148799":"code","623c6e24":"code","cc6d793a":"code","b0280193":"code","7bd2f81c":"code","6519625b":"code","a971b1c5":"code","8810c968":"code","aae13b96":"code","7fa5a3a9":"code","a8d4df90":"code","aed6f685":"code","6e5e8c6c":"code","65ff78be":"code","d555af0a":"code","0c27576e":"code","83f107dc":"code","4401acbd":"code","36281dcc":"code","8ab98343":"code","5e7472d8":"code","d57816d5":"markdown","82de3817":"markdown","bec9069f":"markdown"},"source":{"de516822":"# Import the needed referances\nimport pandas as pd\nimport numpy as np\nimport csv as csv\n\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier\n\n#Shuffle the datasets\nfrom sklearn.utils import shuffle\n\n#Learning curve\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import learning_curve\nfrom sklearn.model_selection import ShuffleSplit\n\n#import seaborn as sns\n#Output plots in notebook\n#%matplotlib inline \n\naddpoly = True\nplot_lc = 0   # 1--display learning curve\/ 0 -- don't display","4e148799":"#loading the data sets from the csv files\nprint('--------load train & test file------')\ntrain_dataset = pd.read_csv('..\/input\/train.csv')\ntest_dataset = pd.read_csv('..\/input\/test.csv')\n\nprint('train dataset: %s, test dataset %s' %(str(train_dataset.shape), str(test_dataset.shape)) )\ntrain_dataset.head()","623c6e24":"print('Id is unique.') if train_dataset.PassengerId.nunique() == train_dataset.shape[0] else print('oops')\nprint('Train and test sets are distinct.') if len(np.intersect1d(train_dataset.PassengerId.values, test_dataset.PassengerId.values))== 0 else print('oops')\n# print('We do not need to worry about missing values.') if train_dataset.count().min() == train_dataset.shape[0] and test_dataset.count().min() == test_dataset.shape[0] else print('oops we have nan')\n\ndatasetHasNan = False\nif train_dataset.count().min() == train_dataset.shape[0] and test_dataset.count().min() == test_dataset.shape[0] :\n    print('We do not need to worry about missing values.') \nelse:\n    datasetHasNan = True\n    print('oops we have nan')","cc6d793a":"print('----train dataset column types information-------')\ndtype_df = train_dataset.dtypes.reset_index()\ndtype_df.columns = [\"Count\", \"Column Type\"]\ndtype_df.groupby(\"Column Type\").aggregate('count').reset_index()","b0280193":"print('----train dataset information-------')\ndtype_df","7bd2f81c":"#Check for missing data & list them \nif datasetHasNan == True:\n    nas = pd.concat([train_dataset.isnull().sum(), test_dataset.isnull().sum()], axis=1, keys=['Train Dataset', 'Test Dataset']) \n    print('Nan in the data sets')\n    print(nas[nas.sum(axis=1) > 0])","6519625b":"# Class vs Survived\nprint(train_dataset[['Pclass', 'Survived']].groupby(['Pclass'], as_index=False).mean().sort_values(by='Survived', ascending=False))","a971b1c5":"# sex vs Survived\nprint(train_dataset[[\"Sex\", \"Survived\"]].groupby(['Sex'], as_index=False).mean().sort_values(by='Survived', ascending=False))","8810c968":"# SibSp vs Survived\n#Sibling = brother, sister, stepbrother, stepsister\n#Spouse = husband, wife (mistresses and fianc\u00e9s were ignored)\nprint(train_dataset[[\"SibSp\", \"Survived\"]].groupby(['SibSp'], as_index=False).mean().sort_values(by='Survived', ascending=False))","aae13b96":"# Parch vs Survived\n#Parent = mother, father\n#Child = daughter, son, stepdaughter, stepson\n#Some children travelled only with a nanny, therefore parch=0 for them.\nprint(train_dataset[[\"Parch\", \"Survived\"]].groupby(['Parch'], as_index=False).mean().sort_values(by='Survived', ascending=False))","7fa5a3a9":"# Data sets cleaing, fill nan (null) where needed and delete uneeded columns\nprint('----Strat data cleaning ------------')\n\n#train_dataset['IsMinor'] = 0\n#train_dataset.loc[(train_dataset['Age'] < 14) & ((train_dataset['Pclass'] == 1) | (train_dataset['Pclass'] == 2) ), 'IsMinor'] = 1\n\n#test_dataset['IsMinor'] = 0\n#test_dataset.loc[(test_dataset['Age'] < 14) & ((test_dataset['Pclass'] == 1 ) | (test_dataset['Pclass'] == 2 )), 'IsMinor'] = 1\n\n\n#manage Age\ntrain_random_ages = np.random.randint(train_dataset[\"Age\"].mean() - train_dataset[\"Age\"].std(),\n                                          train_dataset[\"Age\"].mean() + train_dataset[\"Age\"].std(),\n                                          size = train_dataset[\"Age\"].isnull().sum())\n\ntest_random_ages = np.random.randint(test_dataset[\"Age\"].mean() - test_dataset[\"Age\"].std(),\n                                          test_dataset[\"Age\"].mean() + test_dataset[\"Age\"].std(),\n                                          size = test_dataset[\"Age\"].isnull().sum())\n\ntrain_dataset[\"Age\"][np.isnan(train_dataset[\"Age\"])] = train_random_ages\ntest_dataset[\"Age\"][np.isnan(test_dataset[\"Age\"])] = test_random_ages\ntrain_dataset['Age'] = train_dataset['Age'].astype(int)\ntest_dataset['Age']    = test_dataset['Age'].astype(int)\n\n# Embarked \ntrain_dataset[\"Embarked\"].fillna('S', inplace=True)\ntest_dataset[\"Embarked\"].fillna('S', inplace=True)\ntrain_dataset['Port'] = train_dataset['Embarked'].map( {'S': 0, 'C': 1, 'Q': 2} ).astype(int)\ntest_dataset['Port'] = test_dataset['Embarked'].map({'S': 0, 'C': 1, 'Q': 2}).astype(int)\ndel train_dataset['Embarked']\ndel test_dataset['Embarked']\n\n# Fare\ntest_dataset[\"Fare\"].fillna(test_dataset[\"Fare\"].median(), inplace=True)\n","a8d4df90":"# Feature that tells whether a passenger had a cabin on the Titanic\ntrain_dataset['Has_Cabin'] = train_dataset[\"Cabin\"].apply(lambda x: 0 if type(x) == float else 1)\ntest_dataset['Has_Cabin'] = test_dataset[\"Cabin\"].apply(lambda x: 0 if type(x) == float else 1)\n\n# engineer a new Title feature\n# group them\nfull_dataset = [train_dataset, test_dataset]\n\n##engineer the family size feature\nfor dataset in full_dataset:\n    dataset['FamilySize'] = dataset['SibSp'] + dataset['Parch'] + 1\n### new try \n\n# Create new feature IsAlone from FamilySize\nfor dataset in full_dataset:\n    dataset['IsAlone'] = 0\n    dataset.loc[dataset['FamilySize'] == 1, 'IsAlone'] = 1\n    \n##############################\n\n\n# Get titles from the names\ntrain_dataset['Title'] = train_dataset.Name.str.extract(' ([A-Za-z]+)\\.', expand=False)\ntest_dataset['Title'] = test_dataset.Name.str.extract(' ([A-Za-z]+)\\.', expand=False)\n\nfor dataset in full_dataset:\n    dataset['Title'] = dataset['Title'].replace(['Lady', 'Countess','Capt', 'Col','Don', 'Dr', 'Major', 'Rev', 'Sir', 'Jonkheer', 'Dona'], 'Rare')\n    dataset['Title'] = dataset['Title'].replace('Mlle', 'Miss')\n    dataset['Title'] = dataset['Title'].replace('Ms', 'Miss')\n    dataset['Title'] = dataset['Title'].replace('Mme', 'Mrs')\n\n\n    \n## Create new column \"FamilySizeGroup\" and assign \"Alone\", \"Small\" and \"Big\"\nfor dataset in full_dataset:\n    dataset['FamilySizeGroup'] = 'Small'\n    dataset.loc[dataset['FamilySize'] == 1, 'FamilySizeGroup'] = 'Alone'\n    dataset.loc[dataset['FamilySize'] >= 5, 'FamilySizeGroup'] = 'Big'\n\n## Get the average survival rate of different FamilySizes\ntrain_dataset[['FamilySize', 'Survived']].groupby(['FamilySize'], as_index=False).mean()\n\nfor dataset in full_dataset:\n    dataset['Sex'] = dataset['Sex'].map( {'female': 1, 'male': 0} ).astype(int)\n        \nfor dataset in full_dataset:    \n    dataset.loc[ dataset['Age'] <= 14, 'Age'] = 0\n    dataset.loc[(dataset['Age'] > 14) & (dataset['Age'] <= 32), 'Age'] = 1\n    dataset.loc[(dataset['Age'] > 32) & (dataset['Age'] <= 48), 'Age'] = 2\n    dataset.loc[(dataset['Age'] > 48) & (dataset['Age'] <= 64), 'Age'] = 3\n    dataset.loc[ dataset['Age'] > 64, 'Age'] = 4\n\nfor dataset in full_dataset:\n    dataset.loc[ dataset['Fare'] <= 7.91, 'Fare'] = 0\n    dataset.loc[(dataset['Fare'] > 7.91) & (dataset['Fare'] <= 14.454), 'Fare'] = 1\n    dataset.loc[(dataset['Fare'] > 14.454) & (dataset['Fare'] <= 31), 'Fare']   = 2\n    dataset.loc[ dataset['Fare'] > 31, 'Fare'] = 3\n    dataset['Fare'] = dataset['Fare'].astype(int)\n","aed6f685":"# map the new features\ntitle_mapping = {\"Mr\": 1, \"Miss\": 2, \"Mrs\": 3, \"Master\": 4, \"Rare\": 5}\nfamily_mapping = {\"Small\": 0, \"Alone\": 1, \"Big\": 2}\nfor dataset in full_dataset:\n    dataset['Title'] = dataset['Title'].map(title_mapping)\n    dataset['FamilySizeGroup'] = dataset['FamilySizeGroup'].map(family_mapping)\n\n# engineer a new  features\nfor dataset in full_dataset:\n    dataset['IsChildandRich'] = 0\n    dataset.loc[(dataset['Age'] <= 0) & (dataset['Pclass'] == 1 ),'IsChildandRich'] = 1  \n    dataset.loc[(dataset['Age'] <= 0) & (dataset['Pclass'] == 2 ),'IsChildandRich'] = 1  \n    \n#for dataset in full_dataset:\n#    dataset['Age*Class'] = dataset.Age * dataset.Pclass \n\n\n#for dataset in full_dataset:\n#    dataset['Sex*Class'] = dataset.Sex * dataset.Pclass \n\n#for dataset in full_dataset:\n#    dataset['Sex*Age'] = dataset.Sex * dataset.Age \n    \n#for dataset in full_dataset:\n#    dataset['Age*Class*Sex'] = (dataset.Age * dataset.Pclass) + dataset.Sex\n\nfor data in full_dataset:\n    # classify Cabin by fare\n    data['Cabin'] = data['Cabin'].fillna('X')\n    data['Cabin'] = data['Cabin'].apply(lambda x: str(x)[0])\n    data['Cabin'] = data['Cabin'].replace(['A', 'D', 'E', 'T'], 'M')\n    data['Cabin'] = data['Cabin'].replace(['B', 'C'], 'H')\n    data['Cabin'] = data['Cabin'].replace(['F', 'G'], 'L')\n    data['Cabin'] = data['Cabin'].map({'X': 0, 'L': 1, 'M': 2, 'H': 3}).astype(int) \n    #data['Cabin'].loc[~data['Cabin'].isnull()] = 1\n    #data['Cabin'].loc[data['Cabin'].isnull()] = 0\n\n    \n# Delete Name column from datasets (No need for them in the analysis)\ndel train_dataset['Name']\ndel test_dataset['Name']\n\ndel train_dataset['SibSp']\ndel test_dataset['SibSp']\n\ndel train_dataset['Parch']\ndel test_dataset['Parch']\n\ndel train_dataset['FamilySize']\ndel test_dataset['FamilySize']\n\n#del train_dataset['FamilySizeGroup']\n#del test_dataset['FamilySizeGroup']\n\ndel train_dataset['Cabin']\ndel test_dataset['Cabin']\n\n# Delete Ticket column from datasets  (No need for them in the analysis)\ndel train_dataset['Ticket']\ndel test_dataset['Ticket']\n\ndel train_dataset['Port']\ndel test_dataset['Port']\n\n\n# Cabin has a lot of nan values, so i will remove it\n#del train_dataset['Cabin']\n#del test_dataset['Cabin']\n\n##title_dummies_titanic  = pd.get_dummies(train_dataset['Title'])\n##train_dataset = train_dataset.join(title_dummies_titanic)\n##\n##title_dummies_titanic  = pd.get_dummies(test_dataset['Title'])\n##test_dataset = test_dataset.join(title_dummies_titanic)\n##\n### Drop\n##train_dataset.drop(['Title'], axis=1,inplace=True)\n##test_dataset.drop(['Title'], axis=1,inplace=True)\n\n\nprint('----Finish data cleaning ------------')","6e5e8c6c":"print('train dataset: %s, test dataset %s' %(str(train_dataset.shape), str(test_dataset.shape)) )\ntrain_dataset.head()","65ff78be":"del train_dataset['PassengerId']\n\n#X_train = train_dataset.drop(\"Survived\",axis=1).as_matrix()\n#Y_train = train_dataset[\"Survived\"].as_matrix()\n#X_test  = test_dataset.drop(\"PassengerId\",axis=1).copy().as_matrix()\n\nX_train = train_dataset.drop(\"Survived\",axis=1)\nY_train = train_dataset[\"Survived\"]\nX_test  = test_dataset.drop(\"PassengerId\",axis=1).copy()\n\nprint(X_train.shape)\nprint(Y_train.shape)\nprint(X_test.shape)","d555af0a":"### try dummies:\n##\n##all_data = pd.concat((X_train,\n##                      X_test), ignore_index=True)\n##\n##title_dummies_titanic  = pd.get_dummies(all_data['Title'],prefix=\"title\" )\n##all_data = all_data.join(title_dummies_titanic)\n##all_data.drop(\"Title\",axis=1 ,inplace=True)\n##\n##sex_dummies_titanic  = pd.get_dummies(all_data['Sex'] ,prefix=\"sex\" )\n##all_data = all_data.join(sex_dummies_titanic)\n##all_data.drop(\"Sex\",axis=1,inplace=True)\n##\n##pclass_dummies_titanic  = pd.get_dummies(all_data['Pclass'],prefix=\"pclass\" )\n##all_data = all_data.join(pclass_dummies_titanic)\n##all_data.drop(\"Pclass\",axis=1 ,inplace=True)\n##\n##familygroup_dummies_titanic  = pd.get_dummies(all_data['FamilySizeGroup'],prefix=\"FamilySizeGroup\" )\n##all_data = all_data.join(familygroup_dummies_titanic)\n##all_data.drop(\"FamilySizeGroup\",axis=1 ,inplace=True)\n##\n### process columns, apply LabelEncoder to categorical features\n###from sklearn.preprocessing import LabelEncoder\n###for c in all_data.columns:\n###      if c in [\"Embarked\"]:\n###        lbl = LabelEncoder() \n###        lbl.fit(list(all_data[c].values)) \n###        all_data[c] = lbl.transform(list(all_data[c].values))\n##\n##port_dummies_titanic  = pd.get_dummies(all_data['Port'],prefix=\"port\" )\n##all_data = all_data.join(port_dummies_titanic)\n##all_data.drop(\"Port\",axis=1 ,inplace=True)\n##\n##X_train = all_data[:train_dataset.shape[0]]\n##X_test = all_data[train_dataset.shape[0]:]\n##\n##print(X_train.shape)\n##print(Y_train.shape)\n##print(X_test.shape)\n","0c27576e":"### try polynomials:\nfrom sklearn.preprocessing import MinMaxScaler,PolynomialFeatures\n\nif addpoly:\n    all_data = pd.concat((X_train,\n                          X_test), ignore_index=True)\n\n    scaler = MinMaxScaler()\n    scaler.fit(all_data)\n    all_data=scaler.transform(all_data)\n    poly = PolynomialFeatures(2)\n    all_data=poly.fit_transform(all_data)\n\n    X_train = all_data[:train_dataset.shape[0]]\n    X_test = all_data[train_dataset.shape[0]:]\n    ##\n    print(X_train.shape)\n    print(Y_train.shape)\n    print(X_test.shape)\n","83f107dc":"# Learning curve\ncv = ShuffleSplit(n_splits=100, test_size=0.2, random_state=0)\nlogreg_model = LogisticRegression()\ndef Learning_curve_model(X, Y, model, cv, train_sizes):\n\n    plt.figure()\n    plt.title(\"Learning curve\")\n    plt.xlabel(\"Training examples\")\n    plt.ylabel(\"Score\")\n\n\n    train_sizes, train_scores, test_scores = learning_curve(model, X, Y, cv=cv, n_jobs=4, train_sizes=train_sizes)\n\n    train_scores_mean = np.mean(train_scores, axis=1)\n    train_scores_std  = np.std(train_scores, axis=1)\n    test_scores_mean  = np.mean(test_scores, axis=1)\n    test_scores_std   = np.std(test_scores, axis=1)\n    plt.grid()\n    \n    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,train_scores_mean + train_scores_std, alpha=0.1,\n                     color=\"r\")\n    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,test_scores_mean + test_scores_std, alpha=0.1, color=\"g\")\n    plt.plot(train_sizes, train_scores_mean, 'o-', color=\"r\",label=\"Training score\")\n    plt.plot(train_sizes, test_scores_mean, 'o-', color=\"g\",label=\"Cross-validation score\")\n                     \n    plt.legend(loc=\"best\")\n    return plt\n\n#learn curve\nif plot_lc==1:\n    train_size=np.linspace(.1, 1.0, 15)\n    Learning_curve_model(X_train,Y_train , logreg_model, cv, train_size)","4401acbd":"# Logistic Regression\nlogreg = LogisticRegression() #(C=0.1, penalty='l1', tol=1e-6)\nlogreg.fit(X_train, Y_train)\nY_pred = logreg.predict(X_test)\n\nresult_train = logreg.score(X_train, Y_train)\nresult_val = cross_val_score(logreg,X_train, Y_train, cv=5).mean()\nprint('taring score = %s , while validation score = %s' %(result_train , result_val))\n","36281dcc":"### Support Vector Machines\n##\n###from sklearn import svm, grid_search\n###from sklearn.grid_search import GridSearchCV\n###Cs = [0.001, 0.01, 0.1, 1, 10]\n###gammas = [0.001, 0.01, 0.1, 1]\n###param_grid = {'C': Cs, 'gamma' : gammas}\n###grid_search = GridSearchCV(svm.SVC(kernel='rbf'), param_grid, cv=5)\n###grid_search.fit(X_train, Y_train)\n###print(grid_search.best_params_)\n##\nsvc = SVC(C = 0.1, gamma=0.1)\nsvc.fit(X_train, Y_train)\nY_pred = svc.predict(X_test)\n\nresult_train = svc.score(X_train, Y_train)\nresult_val = cross_val_score(svc,X_train, Y_train, cv=5).mean()\nprint('taring score = %s , while validation score = %s' %(result_train , result_val))\n\n","8ab98343":"# Random Forests\n\nrandom_forest = RandomForestClassifier(criterion='gini', \n                             n_estimators=1000,\n                             min_samples_split=10,\n                             min_samples_leaf=1,\n                             max_features='auto',\n                             oob_score=True,\n                             random_state=1,\n                             n_jobs=-1)\n\nseed= 42\nrandom_forest =RandomForestClassifier(n_estimators=1000, criterion='entropy', max_depth=5, min_samples_split=2,\n                           min_samples_leaf=1, max_features='auto',    bootstrap=False, oob_score=False, \n                           n_jobs=1, random_state=seed,verbose=0)\n\nrandom_forest.fit(X_train, Y_train)\nY_pred = random_forest.predict(X_test)\n\nresult_train = random_forest.score(X_train, Y_train)\nresult_val = cross_val_score(random_forest,X_train, Y_train, cv=5).mean()\n\nprint('taring score = %s , while validation score = %s' %(result_train , result_val))","5e7472d8":"submission = pd.DataFrame({\n        \"PassengerId\": test_dataset[\"PassengerId\"],\n        \"Survived\": Y_pred\n    })\nsubmission.to_csv('titanic.csv', index=False)\nprint('Exported')","d57816d5":"** Engineer New Features **","82de3817":"## Loading the data ##","bec9069f":"## Analyzing the data ##"}}