{"cell_type":{"4f1a0c59":"code","a4cdb6d0":"code","a1e68537":"code","03de8ecf":"code","a7e07d01":"code","2481393b":"code","7d27ca09":"code","69d8ffee":"code","543e7dc4":"code","81dd8ac0":"code","6e6a0a69":"code","f83f38ae":"code","9e3fe2e9":"code","3683a8e6":"code","ab2d25a0":"code","843b9199":"code","57d65b0b":"code","78ad2669":"code","adf4b6a7":"code","c514e5cb":"code","0f79dc7e":"code","5d986c1d":"code","3e2c5251":"code","7b403a0f":"code","06f0896d":"code","693bf960":"code","4860bddf":"code","daa5e878":"code","2770cd6f":"code","e75bc6a4":"code","19b7ffa7":"code","300cb6f7":"code","672478ee":"code","510e7e60":"code","1ad25981":"code","ca61bb03":"markdown","4a1ebbb4":"markdown","eaf0c480":"markdown","be64a3a8":"markdown","b7c12848":"markdown","05e961bc":"markdown","56946baf":"markdown","7586c26c":"markdown","069307f3":"markdown","369bf4a6":"markdown","8548b8c6":"markdown","30ba1e8c":"markdown","9a37a225":"markdown"},"source":{"4f1a0c59":"import pandas as pd\nimport numpy as np\nfrom glob import glob\nimport cv2\nfrom skimage import io\nfrom tqdm import tqdm\nimport seaborn as sns","a4cdb6d0":"!mkdir '512x512-dataset-melanoma'\n!mkdir '512x512-test'","a1e68537":"df_train = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/train.csv')","03de8ecf":"df_gt = pd.read_csv('..\/input\/isic-2019\/ISIC_2019_Training_GroundTruth.csv')\nimage_id = df_gt.iloc[25]['image']\nimage = cv2.imread(f'..\/input\/isic-2019\/ISIC_2019_Training_Input\/ISIC_2019_Training_Input\/{image_id}.jpg', cv2.IMREAD_COLOR)\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nio.imshow(image);","a7e07d01":"df_downsampled = df_gt[df_gt['image'].str.contains('downsampled')]\ndf_downsampled.shape[0]","2481393b":"print('[ALL]:', df_gt.shape[0])\nprint('[\u2229 isic2020]:', len(set(df_train['image_name'].values).intersection(df_gt['image'].values)))\nprint('[downsampled isic2019 \u2229 isic2020]:', len(set(df_train['image_name'].values).intersection([\n    image_id[:-12] for image_id in df_downsampled['image'].values\n])))\nprint('[downsampled isic2019 \u2229 isic2019]:', len(set(df_gt['image'].values).intersection([\n    image_id[:-12] for image_id in df_downsampled['image'].values\n])))","7d27ca09":"paths = glob('..\/input\/skin-lesion-analysis-toward-melanoma-detection\/skin-lesions\/*\/*\/*.jpg')\nimage = cv2.imread(paths[777], cv2.IMREAD_COLOR)\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nio.imshow(image);","69d8ffee":"image_ids = [path.split('\/')[-1][:-4] for path in paths]\nprint('[ALL]:', len(image_ids))\nprint('[\u2229 isic2020]:', len(set(image_ids).intersection(df_train['image_name'].values)))\nprint('[\u2229 isic2019]:', len(set(image_ids).intersection(df_gt['image'].values)))\nprint('[\u2229 isic2019 downsampled]:', len(set(image_ids).intersection([image_id[:-12] for image_id in df_gt[df_gt['image'].str.contains('downsampled')]['image'].values])))","543e7dc4":"df_meta = pd.read_csv('..\/input\/skin-cancer-mnist-ham10000\/HAM10000_metadata.csv')","81dd8ac0":"image_id = df_meta.iloc[777]['image_id']\nimage = cv2.imread(f'..\/input\/skin-cancer-mnist-ham10000\/HAM10000_images_part_1\/{image_id}.jpg', cv2.IMREAD_COLOR)\nimage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nio.imshow(image);","6e6a0a69":"print('[ALL]:', df_meta.shape[0])\nprint('[\u2229 isic2020]:', len(set(df_meta['image_id'].values).intersection(df_train['image_name'].values)))\nprint('[\u2229 isic2019]:', len(set(df_meta['image_id'].values).intersection(df_gt['image'].values)))\nprint('[\u2229 slatmd]:', len(set(df_meta['image_id'].values).intersection(image_ids)))","f83f38ae":"NEED_IMAGE_SAVE = False","9e3fe2e9":"dataset = {\n    'patient_id' : [],\n    'image_id': [],\n    'target': [],\n    'source': [],\n    'sex': [],\n    'age_approx': [],\n    'anatom_site_general_challenge': [],\n}\n\n# isic2020\ndf_train = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/train.csv', index_col='image_name')\nfor image_id, row in tqdm(df_train.iterrows(), total=df_train.shape[0]):\n    if image_id in dataset['image_id']:\n        continue\n    dataset['patient_id'].append(row['patient_id'])\n    dataset['image_id'].append(image_id)\n    dataset['target'].append(row['target'])\n    dataset['source'].append('ISIC20')\n    dataset['sex'].append(row['sex'])\n    dataset['age_approx'].append(row['age_approx'])\n    dataset['anatom_site_general_challenge'].append(row['anatom_site_general_challenge'])\n\n    if NEED_IMAGE_SAVE:\n        image = cv2.imread(f'..\/input\/siim-isic-melanoma-classification\/jpeg\/train\/{image_id}.jpg', cv2.IMREAD_COLOR)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        image = cv2.resize(image, (512, 512), cv2.INTER_AREA)\n        cv2.imwrite(f'.\/512x512-dataset-melanoma\/{image_id}.jpg', image)\n\n# isic2019\ndf_gt = pd.read_csv('..\/input\/isic-2019\/ISIC_2019_Training_GroundTruth.csv', index_col='image')\ndf_meta = pd.read_csv('..\/input\/isic-2019\/ISIC_2019_Training_Metadata.csv', index_col='image')\nfor image_id, row in tqdm(df_meta.iterrows(), total=df_meta.shape[0]):\n    if image_id in dataset['image_id']:\n        continue\n\n    dataset['patient_id'].append(row['lesion_id'])\n    dataset['image_id'].append(image_id)\n    dataset['target'].append(int(df_gt.loc[image_id]['MEL']))\n    dataset['source'].append('ISIC19')\n    dataset['sex'].append(row['sex'])\n    dataset['age_approx'].append(row['age_approx'])\n    dataset['anatom_site_general_challenge'].append(\n        {'anterior torso': 'torso', 'posterior torso': 'torso'}.get(row['anatom_site_general'], row['anatom_site_general'])\n    )\n    \n    if NEED_IMAGE_SAVE:\n        image = cv2.imread(f'..\/input\/isic-2019\/ISIC_2019_Training_Input\/ISIC_2019_Training_Input\/{image_id}.jpg', cv2.IMREAD_COLOR)\n        image = cv2.resize(image, (512, 512), cv2.INTER_AREA)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        cv2.imwrite(f'.\/512x512-dataset-melanoma\/{image_id}.jpg', image)\n\n\n# skin-lesion-analysis-toward-melanoma-detection [REMOVED]\n# paths = glob('..\/input\/skin-lesion-analysis-toward-melanoma-detection\/skin-lesions\/*\/*\/*.jpg')\n# for path in tqdm(paths, total=len(paths)):\n#     diagnosis, image_id = path.split('\/')[-2:]\n#     image_id = image_id[:-4]\n    \n#     if image_id in dataset['image_id']:\n#         continue\n    \n#     target = int(diagnosis == 'melanoma')\n#     dataset['patient_id'].append(np.nan)\n#     dataset['image_id'].append(image_id)\n#     dataset['target'].append(target)\n#     dataset['source'].append('SLATMD')\n#     dataset['sex'].append(np.nan)\n#     dataset['age_approx'].append(np.nan)\n#     dataset['anatom_site_general_challenge'].append(np.nan)\n    \n#     if NEED_IMAGE_SAVE:\n#         image = cv2.imread(path, cv2.IMREAD_COLOR)\n#         image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n#         image = cv2.resize(image, (512, 512), cv2.INTER_AREA)\n#         cv2.imwrite(f'.\/512x512-dataset-melanoma\/{image_id}.jpg', image)\n    \ndataset = pd.DataFrame(dataset).set_index('image_id')    ","3683a8e6":"dataset.head()","ab2d25a0":"df_duplicates = pd.read_csv('..\/input\/melanoma-merged-external-data-512x512-jpeg\/duplicates_13062020.csv', index_col='image_ids')","843b9199":"def get_value(duplicate_data, row, field):\n    if row[field] == 1 or duplicate_data.shape[0] <= 2:\n        return duplicate_data.iloc[0][field]\n    if 'ISIC20' in duplicate_data.source.values:\n        duplicate_data = duplicate_data[duplicate_data.source == 'ISIC20']\n    return sorted(duplicate_data[field].value_counts().items(), key=lambda x: -x[1])[0][0]","57d65b0b":"cleaned_duplicates = {\n    'image_id': [],\n    'patient_id': [],\n    'target': [],\n    'source': [],\n    'sex': [],\n    'age_approx': [],\n    'anatom_site_general_challenge': [],\n}\ndrop_image_ids = []\nfor image_ids, row in df_duplicates.iterrows():\n    image_ids = image_ids.split('.')\n    drop_image_ids.extend(image_ids)\n    duplicate_data = dataset.loc[image_ids].sort_values('source', ascending=False)\n    for field in [    \n        'patient_id',\n        'target',\n        'source',\n        'sex',\n        'age_approx',\n        'anatom_site_general_challenge',\n    ]:\n        cleaned_duplicates[field].append(get_value(duplicate_data, row, field))\n    cleaned_duplicates['image_id'].append(duplicate_data.index.values[0])\n\ncleaned_duplicates = pd.DataFrame(cleaned_duplicates).set_index('image_id')\ncleaned_duplicates.head()","78ad2669":"dataset = dataset.drop(drop_image_ids)\ndataset = dataset.append(cleaned_duplicates)","adf4b6a7":"dataset.to_csv('marking.csv')","c514e5cb":"dataset['source'].hist();","0f79dc7e":"print(dataset['target'].value_counts())\ndataset['target'].hist();","5d986c1d":"dataset['sex'].fillna('unknown').hist();","3e2c5251":"dataset['age_approx'].hist(bins=50);","7b403a0f":"dataset['anatom_site_general_challenge'].fillna('unknown').value_counts()","06f0896d":"import numpy as np\nimport random\nimport pandas as pd\nfrom collections import Counter, defaultdict\n\ndef stratified_group_k_fold(X, y, groups, k, seed=None):\n    \"\"\" https:\/\/www.kaggle.com\/jakubwasikowski\/stratified-group-k-fold-cross-validation \"\"\"\n    labels_num = np.max(y) + 1\n    y_counts_per_group = defaultdict(lambda: np.zeros(labels_num))\n    y_distr = Counter()\n    for label, g in zip(y, groups):\n        y_counts_per_group[g][label] += 1\n        y_distr[label] += 1\n\n    y_counts_per_fold = defaultdict(lambda: np.zeros(labels_num))\n    groups_per_fold = defaultdict(set)\n\n    def eval_y_counts_per_fold(y_counts, fold):\n        y_counts_per_fold[fold] += y_counts\n        std_per_label = []\n        for label in range(labels_num):\n            label_std = np.std([y_counts_per_fold[i][label] \/ y_distr[label] for i in range(k)])\n            std_per_label.append(label_std)\n        y_counts_per_fold[fold] -= y_counts\n        return np.mean(std_per_label)\n    \n    groups_and_y_counts = list(y_counts_per_group.items())\n    random.Random(seed).shuffle(groups_and_y_counts)\n\n    for g, y_counts in tqdm(sorted(groups_and_y_counts, key=lambda x: -np.std(x[1])), total=len(groups_and_y_counts)):\n        best_fold = None\n        min_eval = None\n        for i in range(k):\n            fold_eval = eval_y_counts_per_fold(y_counts, i)\n            if min_eval is None or fold_eval < min_eval:\n                min_eval = fold_eval\n                best_fold = i\n        y_counts_per_fold[best_fold] += y_counts\n        groups_per_fold[best_fold].add(g)\n\n    all_groups = set(groups)\n    for i in range(k):\n        train_groups = all_groups - groups_per_fold[i]\n        test_groups = groups_per_fold[i]\n\n        train_indices = [i for i, g in enumerate(groups) if g in train_groups]\n        test_indices = [i for i, g in enumerate(groups) if g in test_groups]\n\n        yield train_indices, test_indices","693bf960":"%%time\n\ndf_folds = pd.read_csv('marking.csv')\ndf_folds['patient_id'] = df_folds['patient_id'].fillna(df_folds['image_id'])\ndf_folds['sex'] = df_folds['sex'].fillna('unknown')\ndf_folds['anatom_site_general_challenge'] = df_folds['anatom_site_general_challenge'].fillna('unknown')\ndf_folds['age_approx'] = df_folds['age_approx'].fillna(round(df_folds['age_approx'].mean()))\n\npatient_id_2_count = df_folds[['patient_id', 'image_id']].groupby('patient_id').count()['image_id'].to_dict()\n\ndf_folds = df_folds.set_index('image_id')\n\ndef get_stratify_group(row):\n    stratify_group = row['sex']\n#     stratify_group += f'_{row[\"anatom_site_general_challenge\"]}'\n    stratify_group += f'_{row[\"source\"]}'\n    stratify_group += f'_{row[\"target\"]}'\n    patient_id_count = patient_id_2_count[row[\"patient_id\"]]\n    if patient_id_count > 80:\n        stratify_group += f'_80'\n    elif patient_id_count > 60:\n        stratify_group += f'_60'\n    elif patient_id_count > 50:\n        stratify_group += f'_50'\n    elif patient_id_count > 30:\n        stratify_group += f'_30'\n    elif patient_id_count > 20:\n        stratify_group += f'_20'\n    elif patient_id_count > 10:\n        stratify_group += f'_10'\n    else:\n        stratify_group += f'_0'\n    return stratify_group\n\ndf_folds['stratify_group'] = df_folds.apply(get_stratify_group, axis=1)\ndf_folds['stratify_group'] = df_folds['stratify_group'].astype('category').cat.codes","4860bddf":"%%time\n\ndf_folds.loc[:, 'fold'] = 0\n\nskf = stratified_group_k_fold(X=df_folds.index, y=df_folds['stratify_group'], groups=df_folds['patient_id'], k=5, seed=42)\n\nfor fold_number, (train_index, val_index) in enumerate(skf):\n    df_folds.loc[df_folds.iloc[val_index].index, 'fold'] = fold_number","daa5e878":"set(df_folds[df_folds['fold'] == 0]['patient_id'].values).intersection(df_folds[df_folds['fold'] == 1]['patient_id'].values)","2770cd6f":"df_folds[df_folds['fold'] == 0]['target'].hist();","e75bc6a4":"df_folds[df_folds['fold'] == 1]['target'].hist();","19b7ffa7":"df_folds.to_csv('folds_13062020.csv')","300cb6f7":"# test isic2020\ndf_test = pd.read_csv('..\/input\/siim-isic-melanoma-classification\/test.csv', index_col='image_name')\nfor image_id, row in tqdm(df_test.iterrows(), total=df_test.shape[0]):   \n    if NEED_IMAGE_SAVE:\n        image = cv2.imread(f'..\/input\/siim-isic-melanoma-classification\/jpeg\/test\/{image_id}.jpg', cv2.IMREAD_COLOR)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        image = cv2.resize(image, (512, 512), cv2.INTER_AREA)\n        cv2.imwrite(f'..\/input\/512x512-test\/{image_id}.jpg', image)","672478ee":"df_folds = pd.read_csv('..\/input\/melanoma-merged-external-data-512x512-jpeg\/folds_13062020.csv')\ndf_folds.head()","510e7e60":"image = cv2.imread(f'..\/input\/melanoma-merged-external-data-512x512-jpeg\/512x512-dataset-melanoma\/512x512-dataset-melanoma\/ISIC_0074268.jpg', cv2.IMREAD_COLOR)\nio.imshow(image);","1ad25981":"image = cv2.imread(f'..\/input\/melanoma-merged-external-data-512x512-jpeg\/512x512-test\/512x512-test\/ISIC_0089356.jpg', cv2.IMREAD_COLOR)\nio.imshow(image);","ca61bb03":"# Thank you all for reading my kernel!\n\n","4a1ebbb4":"# Main Idea\n\nLets merge these datasets from [topic](https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/discussion\/154296#864656) by [@andrewmvd](https:\/\/www.kaggle.com\/andrewmvd):\n\n---\n- [Melanoma Detection Dataset](https:\/\/www.kaggle.com\/wanderdust\/skin-lesion-analysis-toward-melanoma-detection)\n- [Skin Lesion Images for Melanoma Classification](https:\/\/www.kaggle.com\/andrewmvd\/isic-2019)\n- [Skin Cancer MNIST: HAM10000](https:\/\/www.kaggle.com\/kmader\/skin-cancer-mnist-ham10000)\n---\n\n- [SIIM-ISIC Melanoma Classification](https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/data)\n","eaf0c480":"## Test","be64a3a8":"# Simple EDA:","b7c12848":"# Changelog\n\n\n- v2 initial version\n- v4 add StratifiedGroupKFold\n- v5 remove: skin-lesion-analysis-toward-melanoma-detection (see [here](https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/discussion\/155859#878163))\n- v7 exclude duplicates (see [here](https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/discussion\/157701)), add stratification by `count of target_id`, add `folds_13062020.csv` ","05e961bc":"# Excluding duplicates (with [clustering approach](https:\/\/www.kaggle.com\/shonenkov\/dbscan-clustering-check-marking))","56946baf":"# Skin Cancer MNIST: HAM10000 [Repeated]","7586c26c":"## [@ipateam](https:\/\/www.kaggle.com\/ipateam) Thanks a lot for [finding dublicated images](https:\/\/www.kaggle.com\/c\/siim-isic-melanoma-classification\/discussion\/155859#878163)! ","069307f3":"# Merge datasets & metadata","369bf4a6":"# SLATMD [Almost completely repeated] [Removed]","8548b8c6":"# Stratify GroupKFold Splitting\n\nhttps:\/\/www.kaggle.com\/jakubwasikowski\/stratified-group-k-fold-cross-validation","30ba1e8c":"# isic 2019","9a37a225":"# Final Dataset\n\nFinal dataset jpeg 512x512 you can find [here](https:\/\/www.kaggle.com\/shonenkov\/melanoma-merged-external-data-512x512-jpeg)\n\nexamples for usage:"}}