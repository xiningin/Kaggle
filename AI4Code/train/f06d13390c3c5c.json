{"cell_type":{"e0d9f9a7":"code","093a4614":"code","706249c1":"code","914c8060":"code","1752e4f0":"code","2d9b95a6":"code","3056425b":"code","c28cfe73":"code","30c7eab6":"code","5db5fd24":"code","a949145f":"code","648183b1":"code","772ccf90":"code","f8e56cde":"code","f5251675":"code","7fc06217":"code","617146b4":"code","bcaa2ff8":"markdown","d0fca95b":"markdown","75014413":"markdown","23d06109":"markdown","80cb276d":"markdown","a90180f0":"markdown","582f2586":"markdown"},"source":{"e0d9f9a7":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\n#Import the relevant modules\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nimport requests as r\nimport seaborn as sns\nimport re\nimport time\nimport bs4 as BeautifulSoup\nimport sys  \nimport plotly.plotly as py\nimport plotly.graph_objs as go\nfrom plotly import tools\nfrom plotly.offline import iplot, init_notebook_mode, plot\ninit_notebook_mode(connected=True)\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","093a4614":"#Import the Datasets\ngtd = pd.read_csv('..\/input\/gtd\/globalterrorismdb_0718dist.csv', encoding='ISO-8859-1',)\necon_df = pd.read_csv('..\/input\/econset\/AP_NY_MKTCAP.csv', skiprows = 4)","706249c1":"#Evaluate the Paramaters and Rows\ngtd.info() #Evaluation of the Paramaters results in a high number of features\ngtd.rename(\n    columns={'iyear':'year', 'imonth':'month', 'iday':'day', 'gname': 'gname1', 'claimmode': 'claimmode1', 'gsubname': 'gsubname1', 'claimmode_txt': 'claimmode1_txt'}, inplace=True)\n\n\n#The below breaks the features into varioius subgroups for further study\ndb_vars = ['eventid', 'year', 'month', 'day','approxdate','extended','resolution']\ninfo_vars = ['summary', 'crit1', 'crit2', 'crit3','doubtterr','alternative',\n                'alternative_txt', 'multiple','related'] #Array of General Paramaters\nloc_vars = ['country', 'country_txt','region', 'region_txt','provstate','city','vicinity','location',\n           'latitude','longitude', 'specificity'] #Array of Location Parameters\natk_vars = ['attacktype1','attacktype1_txt', 'attacktype2','attacktype2_txt','attacktype3',\n           'attacktype3_txt','success','weaptype1','weaptype1_txt','weapsubtype1','weapsubtype1_txt',\n           'weaptype2','weaptype2_txt','weapsubtype2','weapsubtype2_txt','weaptype3','weaptype3_txt',\n           'weapsubtype3','weapsubtype3_txt','weaptype4','weaptype4_txt','weapsubtype4',\n            'weapsubtype4_txt','weapdetail'] #Array of Attack Detail Parameters\nvic_vars = ['targtype1','targtype1_txt','targsubtype1','targsubtype1_txt','corp1','target1',\n           'natlty1','natlty1_txt','targtype2','targtype2_txt','targsubtype2','targsubtype2_txt',\n           'corp2','target2','natlty2','natlty2_txt','targtype3','targtype3_txt','targsubtype3',\n           'targsubtype3_txt','corp3','target3','natlty3','natlty3_txt'] #Array of Target\/Victim Parameters\nperp_vars = ['gname1','gsubname1','gname2','gsubname2','gname3','gsubname3','guncertain1','guncertain2','guncertain3',\n           'individual','nperps','nperpcap','claimmode1','claimmode1_txt','compclaim','claim2','claimmode2',\n            'claim3','claimmode3','motive'] #Arrray of Perpetrator Parameters\ncas_vars =['nkill','nkillus','nkillter','nwound','nwoundus','nwoundte','property','propextent','propextent_txt',\n          'propvalue','propcomment','ishostkid','nhostkid','nhostkidus','nhours','ndays','divert','kidhijcountry',\n          'ransom','ransomamt','ransomamtus','ransompaid','ransompaidus','ransomnote','hostkidoutcome',\n           'hostkidoutcome_txt','nreleased'] #Array of Casualty Parameters\nxtra_vars = ['addnotes','INT_LOG','INT_IDEO','INT_MISC','INT_ANY','scite1','scite2','scite3','dbsource'] #Additional Misc Parameters","914c8060":"#There are still too many parameters even within the sub groups - further cleaning below\npattern = r'_txt'\n\n#Will create a function to clean up the extra columns with name \"text\"\ngroup = [db_vars,info_vars,loc_vars,atk_vars,vic_vars,perp_vars,cas_vars,xtra_vars]\n\ndef txt_col(pattern,group): #CAN ONLY BE PERFORMED ONCE\n    cols_dict = {} #Dictionary to upload to our rename dictionary\n    toss_list = [] #List to drop and create separate DF for ML\n    cat_list = [] #List to change format to categories for charts\n    for var in group: #For loop to create entries in dictionary\n        for param in var:\n            if re.search(pattern,param):\n                root = param[0:(len(param)-len(pattern))]\n                cols_dict[root] = str(root)+\"_cat\"\n                cols_dict[param] = root\n                toss_list.append(cols_dict[root])\n                cat_list.append(root)\n                var.remove(param)\n    return cols_dict, toss_list, cat_list \n\ncols_dict, toss_list, cat_list = txt_col(pattern,group)\n\n#Set of operations TO BE PERFORMED ONCE \ngtd.rename(columns=cols_dict, inplace=True)\ngtd_ml = gtd[toss_list].copy()\ngtd.drop(columns=toss_list, inplace=True)","1752e4f0":"#Next up we are going to create a dictionary of country codes from another database\n#We will map the values of the Country code to the input database so se can create Chloropleth Maps\n\n#Ahead we saw that some Country names are different...\necon_df.loc[econ_df['Country Name'] == 'Russian Federation', 'Country Name'] = 'Russia'\n\n\n#We need to build some script to add country codes to a new dictionary so we can build new DF\neach_country = econ_df['Country Name'].unique()\ncountry_dict = {}\ncode_dict = {}\nfor i, e in enumerate(each_country):\n    country_dict[e] = econ_df.loc[econ_df['Country Name'] == e,'Country Code'][i]\n    code_dict[econ_df.loc[econ_df['Country Name'] == e,'Country Code'][i]] = e\n\ngtd.insert(list(gtd.columns).index('country'),'country_code',gtd.country)\ngtd['country_code'] = gtd.country_code.map(country_dict)","2d9b95a6":"#To create a map to better visualize the spread, we prep the data by creating a new DF\n\n#First we create a few new dataframes to more easily extract the various countries\nmap_df = econ_df.copy()\n\n#set the new DF's index to country code so you can more easily dig out the value counts later\n\nmap_df.set_index('Country Code',inplace = True)\nmap_df['Terror Incidents'] = gtd.country_code.value_counts()\nmap_df['Terror Incidents'].fillna(0, inplace=True)","3056425b":"\"\"\"\nWe write a function  to create a new valcnt column so we can make many (there are many groups)\nThe following function is for string outputs\nWe see that a number of the categories have types 1-3 so a for loop concatenates all the relevant values\n\nThe function will take the mapdf, filter column and new column values as inputs\nThe function will output and perform column operations which will create a new column with aggregate values\nThe function will also have a nested funciton to create dictionaries which will be used to later aggregate valeus\n\"\"\"\ndef val_cnt_create(df, col_fil, n_col):\n    # First for loop pulls out each country code\n    for e in df.index:\n        dict_list = [] #Array will be used to store dictionaries later of value counts later\n        param_list = [] #Array will store all the different values for global parameters\n        txt_col = [] #Array will concatenate the string values in the ned\n        first_str = \"<b>\" + df.loc[e,'Country Name'] + '<\/b><br> '\n        \n        def dict_create(n, col_fil): #Function to create dicitonaries to append to dict_list\n            unique_params = []\n            spec_filter = col_fil+str(n+1) #variable to track column titles from gtd\n            for param in gtd[spec_filter].unique():\n                unique_params.append(param)  \n            filtered_df = gtd.loc[gtd.country_code == e, spec_filter] #variable for filtered dated set\n            val_cnt_dict = {filtered_df.value_counts().index[i]: a1 for i, a1 in enumerate(filtered_df.value_counts())}\n            return val_cnt_dict, unique_params\n    \n        \n        #Second for loop creates a column with dictionary of different va variables\n        for n1 in range(3):\n            val, unique = dict_create(n1, col_fil)\n            dict_list.append(val)\n            for x in unique:\n                if x not in param_list:\n                    param_list.append(x)\n                    \n        old_dict = {param: 0 for param in param_list}\n        for dic in dict_list:\n            for param in param_list:\n                try:\n                    old_dict[param] += dic[param]\n                except:\n                    pass\n        for param in param_list:\n            if old_dict[param] == 0:\n                del old_dict[param]\n            try:\n                txt_input = \"{}: {} <br> \".format(param, old_dict[param])\n                txt_col.append(txt_input)\n            except:\n                pass\n        \n        second_str = \"\".join(txt_col)\n        txt = first_str + second_str\n        df.loc[e,n_col] = txt\n\n#Whew! Not the sexiest piece of code with all those for loops, but the number of parameters is not too many\n#Now we can create many many chart inputs for many different charts!","c28cfe73":"def sum_create(a, col_fil, n_col):\n    for e in a.index:\n        total = gtd.loc[gtd.country_code == e, col_fil].sum()\n        a.loc[e, n_col] = total.astype(int)\n\nsum_create(map_df, 'nkill', 'Total Victims')\nsum_create(map_df, 'nkillter', 'Terrorist Deaths')\nmap_df['Total Body Count'] = map_df['Total Victims'] + map_df['Terrorist Deaths']\nsum_create(map_df, 'propvalue', 'Total Property Damage')","30c7eab6":"val_cnt_create(map_df, 'gname', 'Perpetrator Text') \nval_cnt_create(map_df, 'weaptype', 'Weapon Text')\nval_cnt_create(map_df, 'attacktype', 'Attack Text')\nval_cnt_create(map_df, 'targtype', 'Target Text')\nval_cnt_create(map_df, 'natlty', 'Target Nationality Text')\nval_cnt_create(map_df, 'gsubname', 'Perpsub Text')","5db5fd24":"#Next create a lazy function to construct quick maps - the following is for the chloropleth types\n#Chlorpleth maps will use the \"Country Code\" columns that were created earlier\n\n#Lets give ourself options for color so we can later divide themes\ncolor_dict = {'blue': [\n        [0, \"rgb(5, 10, 172)\"],\n        [0.35, \"rgb(40, 60, 190)\"],\n        [0.5, \"rgb(70, 100, 245)\"],\n        [0.6, \"rgb(90, 120, 245)\"],\n        [0.7, \"rgb(106, 137, 247)\"],\n        [1, \"rgb(220, 220, 220)\"]\n    ] , \n          'green': [\n        [0, \"rgb(5, 172, 10)\"],\n        [0.35, \"rgb(40, 190, 60)\"],\n        [0.5, \"rgb(70, 245, 100)\"],\n        [0.6, \"rgb(90, 245, 120)\"],\n        [0.7, \"rgb(106, 247, 137)\"],\n        [1, \"rgb(220, 220, 220)\"]\n    ],\n          'red': [\n        [0, \"rgb(172, 10, 5)\"],\n        [0.35, \"rgb(190, 60, 40)\"],\n        [0.5, \"rgb(245, 100, 70)\"],\n        [0.6, \"rgb(245, 120, 90)\"],\n        [0.7, \"rgb(247, 137, 106)\"],\n        [1, \"rgb(220, 220, 220)\"]\n    ]}\n\ndef button_vars(df, main_var, text_var, color='blue'):\n    \n    #Next create the data variable - array of graph objects \n    data = dict(type = 'choropleth',\n        locations = df.index,\n        z = df[main_var],\n        text = [e for e in df[text_var]],\n        colorscale = color_dict[color],#we implement the dicitonary constructed above\n        autocolorscale = False,\n        reversescale = True,\n        marker = go.choropleth.Marker(\n            line = go.choropleth.marker.Line(\n            color = 'rgb(180,180,180)',\n            width = 0.5\n            )),\n        colorbar = go.choropleth.ColorBar( \n            title = 'Number<br>of {}'.format(main_var),#function input\n        )\n    )\n    \n        \n    layout = {\n        'title': {\n            'text' : '{} by Country'.format(main_var) #function input\n            },\n        'annotations' : [{\n            'x' : 0.55,\n            'y' : 0.1,\n            'xref' : 'paper',\n            'yref' : 'paper',\n            'text' : 'Hover over countries for more details on {}s'.format(text_var.split(\" \")[0]),#function input\n            'showarrow': False\n        }]\n    }\n    \n\n    return data, layout","a949145f":"#First create empty dictionary for figure\nvic_tgt_dat, vic_tgt_lay = button_vars(map_df, 'Total Victims', 'Target Text', 'red')\nvic_perp_dat, vic_perp_lay = button_vars(map_df, 'Total Victims', 'Perpetrator Text', 'red')\nvic_atk_dat, vic_atk_lay = button_vars(map_df, 'Total Victims', 'Attack Text', 'red')\n\ntot_tgt_dat, tot_tgt_lay = button_vars(map_df, 'Total Body Count', 'Target Text', 'red')\ntot_perp_dat, tot_perp_lay = button_vars(map_df, 'Total Body Count', 'Perpetrator Text', 'red')\ntot_atk_dat, tot_atk_lay = button_vars(map_df, 'Total Body Count', 'Attack Text', 'red')\n\ninc_tgt_dat, inc_tgt_lay = button_vars(map_df, 'Terror Incidents', 'Target Text', 'blue')\ninc_perp_dat, inc_perp_lay = button_vars(map_df, 'Terror Incidents', 'Perpetrator Text', 'blue')\ninc_atk_dat, inc_atk_lay = button_vars(map_df, 'Terror Incidents', 'Attack Text', 'blue')\n\nprp_tgt_dat, prp_tgt_lay = button_vars(map_df, 'Total Property Damage', 'Target Text', 'green')\nprp_perp_dat, prp_perp_lay = button_vars(map_df, 'Total Property Damage', 'Perpetrator Text', 'green')\nprp_atk_dat, prp_atk_lay = button_vars(map_df, 'Total Property Damage', 'Attack Text', 'green')\n\n\natk_dat, atk_lay = button_vars(map_df, 'Terror Incidents', 'Attack Text', 'blue')\n\n\nfigure = {'data': [],\n         'layout': {},\n         'frames': []}\n\nfigure['data'] = [atk_dat]\nfigure['layout'] = go.Layout(\n        title = go.layout.Title(\n        text = '{} by Country'.format('Total Victims') #function input\n        ),\n        geo = go.layout.Geo(\n            showframe = False,\n            showcoastlines = False,\n            projection = go.layout.geo.Projection(\n                type = 'equirectangular'\n            )\n        ),\n        annotations = [go.layout.Annotation(\n            x = 0.6,\n            y = 0.1,\n            xanchor='right',\n            yanchor='top',\n            xref = 'paper',\n            yref = 'paper',\n            text = 'Hover over countries for more details'.format('Target Text'.split(\" \")[0]),#function input\n            showarrow = False\n        )]\n    )\n\n\n\nfigure['frames'].append({'data': [vic_tgt_dat], 'name': 'vic tgt'})\nfigure['frames'].append({'data': [vic_perp_dat], 'name': 'vic perp'})\nfigure['frames'].append({'data': [vic_atk_dat], 'name': 'vic atk'})\n\nfigure['frames'].append({'data': [tot_tgt_dat], 'name': 'tot tgt'})\nfigure['frames'].append({'data': [tot_perp_dat], 'name': 'tot perp'})\nfigure['frames'].append({'data': [tot_atk_dat], 'name': 'tot atk'})\n\nfigure['frames'].append({'data': [inc_tgt_dat], 'name': 'inc tgt'})\nfigure['frames'].append({'data': [inc_perp_dat], 'name': 'inc perp'})\nfigure['frames'].append({'data': [inc_atk_dat], 'name': 'inc atk'})\n\nfigure['frames'].append({'data': [prp_tgt_dat], 'name': 'prp tgt'})\nfigure['frames'].append({'data': [prp_perp_dat], 'name': 'prp perp'})\nfigure['frames'].append({'data': [prp_atk_dat], 'name': 'prp atk'})\n\nfigure['layout']['updatemenus'] = [\n    {'buttons': [\n        {'args': [['vic tgt'], {'frame': {'duration': 300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'},\n                                    }, vic_tgt_lay],\n         'label': 'Target by Total Victims',\n         'method': 'animate'},\n        {'args': [['tot tgt'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, tot_tgt_lay],\n         'label': 'Target by Total Body Count ',\n         'method': 'animate'},\n        {'args': [['inc tgt'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, inc_tgt_lay],\n         'label': 'Target by Total Incidents ',\n         'method': 'animate'},\n        {'args': [['prp tgt'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, prp_tgt_lay],\n         'label': 'Target by Total Cost ',\n         'method': 'animate'}\n        \n    ],\n     'direction': 'down',\n     'pad': {'r': 10, 't': 87},\n     'showactive': False,\n     'x': 0.1,\n     'xanchor': 'right',\n     'y': 1,\n     'yanchor': 'top'}, \n    {'buttons': [\n        {'args': [['vic perp'], {'frame': {'duration': 300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'},\n                                    }, vic_perp_lay],\n         'label': 'Perpetrator by Total Victims',\n         'method': 'animate'},\n        {'args': [['tot perp'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, tot_perp_lay],\n         'label': 'Perpetrator by Total Body Count ',\n         'method': 'animate'},\n        {'args': [['inc perp'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, inc_perp_lay],\n         'label': 'Perpetrator by Total Incidents ',\n         'method': 'animate'},\n        {'args': [['prp perp'], {'frame': {'duration':300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, prp_perp_lay],\n         'label': 'Perpetrator by Total Cost ',\n         'method': 'animate'}\n        \n    ],\n     'direction': 'down',\n     'pad': {'r': 10, 't': 87},\n     'showactive': False,\n     'x': 0.1,\n     'xanchor': 'right',\n     'y': 0.9,\n     'yanchor': 'top'},\n    {'buttons': [\n        {'args': [['vic atk'], {'frame': {'duration': 300, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'},\n                                    }, vic_atk_lay],\n         'label': 'Attack Type by Total Victims',\n         'method': 'animate'},\n        {'args': [['tot atk'], {'frame': {'duration':3500, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, tot_atk_lay],\n         'label': 'Attack Type by Total Body Count ',\n         'method': 'animate'},\n        {'args': [['inc atk'], {'frame': {'duration':3500, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, inc_atk_lay],\n         'label': 'Attack by Total Incidents ',\n         'method': 'animate'},\n        {'args': [['prp atk'], {'frame': {'duration':3500, 'redraw': True},\n                                    'fromcurrent': True, \n                                    'transition': {'duration': 300, 'easing': 'quadratic-in-out'}\n                                   }, prp_atk_lay],\n         'label': 'Attack by Total Cost ',\n         'method': 'animate'}\n        \n    ],\n     'direction': 'down',\n     'pad': {'r': 10, 't': 87},\n     'showactive': False,\n     'x': 0.1,\n     'xanchor': 'right',\n     'y': 0.8,\n     'yanchor': 'top'}]\n\n\niplot(figure, filename = 'd3-world-map')","648183b1":"#Next lets look at a couple historical events\n#Since there are too many countries and we will use 5 countries with most attack for each year\n\ntraces = []\n\n#Since we don't want a bunch of duplicate series, we will create graphs per country\ncountry_dictY = {} #dictionary for y values\ncountry_dictX = {} #dictionary for xvalues\ncountry_dictTxt = {}\nfor e in gtd.year.unique(): #We want to pull up top 5 for each year and add them to dictionaries\n    top_5 = gtd.groupby(['year','country']).country.count()[e].sort_values(ascending=False)[0:5]\n    for i, country in enumerate(top_5.index):\n        if country not in country_dictX:\n            country_dictX[country] = []\n            country_dictY[country] = []\n            country_dictTxt[country] = []\n            \n        country_dictX[country].append(e)\n        country_dictY[country].append(top_5[i])\n        text_primer = gtd.loc[(gtd.country==country) & (gtd.year == e), 'gname1'].value_counts().sort_values(ascending=False).index\n        try:\n            txt_input = \"Three Most Active Terror Groups <br>1) {}<br>2) {}<br>3) {}\".format(text_primer[0],text_primer[1],text_primer[2])\n        except:\n            txt_input = \"Most Active Group<br> {}\".format(text_primer[0])\n        \n        country_dictTxt[country].append(txt_input)\n\n\nfor country in country_dictX: #After our dictionaries are loaded, we create instances of graph object and append to list\n    #text = \"Top 3 Most active Terror Groups <br>1 {}<br>2 {}<br>3 {}\".format(country_dictTxt[country].index[0],country_dictTxt[country].index[1],country_dictTxt[country].index[2])\n    \n    trace = go.Bar(x = country_dictX[country], y=country_dictY[country], name=country, text=country_dictTxt[country])\n    traces.append(trace)\nline_trace = go.Scatter(x = gtd.groupby('year').year.count().index, \n                        y=[total for total in gtd.groupby('year').year.count()], \n                           name='Total Terror Attacks for the year', \n                           mode='lines+markers', \n                       yaxis='y2')\ntraces.append(line_trace)\n\ndata = traces \nlayout = go.Layout(\n    autosize = False, width = 1000, height=750, \n    title = 'Terrorist Attacks by Year in Five most Affected Countries',\n    xaxis = dict(\n             rangeslider = dict(thickness = 0.1),\n             showline = True,\n             showgrid = False\n         ),\n    yaxis = dict(title='Terror Attack by Country',\n             showline = True,\n             showgrid = False),\n    yaxis2 = dict(title = 'Total Terror Attack',\n                 showline = True,\n                 overlaying = 'y', #Allows for second axis\n                 side = 'right'),\n    legend=dict(x=1.1, y=1.2),\n    annotations = [go.layout.Annotation(\n            x = 0.01,\n            y = -.1,\n            xref = 'paper',\n            yref = 'paper',\n            text = 'Hover over countries for more details on Groups involved',\n            showarrow = False\n        )]#If you don't want the leged rubbing to close to the graph...\n)\nfig = go.Figure(data=data, layout=layout)\niplot(fig, filename='grouped-bar')","772ccf90":"#Lets create a visual which highlights the terror attacks by target types\n#We want to create a scatter plot which will capture injuries, kills and total attempts\n#The text should include (1) Most Frequent Group, (2) Most common country\nscatter_traces = []\nkill_dicts = []\ninjury_dicts = []\nsize_dicts = []\nfor n in range(3):\n    kill_dict = {gtd.groupby(['targtype'+str(n+1)]).nkill.sum().index[i]: e for i, e in enumerate(gtd.groupby(['targtype'+str(n+1)]).nkill.sum())}\n    injury_dict = {gtd.groupby(['targtype'+str(n+1)]).nwound.sum().index[i]: e for i, e in enumerate(gtd.groupby(['targtype'+str(n+1)]).nwound.sum())}\n    size_dict = {gtd['targtype'+str(n+1)].value_counts().index[i]: e for i, e in enumerate(gtd['targtype'+str(n+1)].value_counts())}\n    kill_dicts.append(kill_dict)\n    injury_dicts.append(injury_dict)\n    size_dicts.append(size_dict)\n\ntkill_dict = {e: 0 for e in gtd.targtype1.unique()}\ntinjury_dict = {e: 0 for e in gtd.targtype1.unique()}\ntsize_dict = {e: 0 for e in gtd.targtype1.unique()}\ntext_dict = {e:0 for e in gtd.targtype1.unique()}\n\nfor e in gtd.targtype1.unique():\n    for dic1 in kill_dicts:\n        try:\n            tkill_dict[e] += dic1[e]\n        except:\n            pass\n    for dic2 in injury_dicts:\n        try:\n            tinjury_dict[e] += dic2[e]\n        except:\n            pass\n    for dic3 in size_dicts:\n        try:\n            tsize_dict[e] += dic3[e]\n        except:\n            pass\n    most_group = gtd.loc[gtd.targtype1==e,'gname1'].value_counts().sort_values(ascending=False).index[0]\n    most_weap = gtd.loc[gtd.targtype1==e,'weaptype1'].value_counts().sort_values(ascending=False).index[0]\n    most_attack = gtd.loc[gtd.targtype1==e,'attacktype1'].value_counts().sort_values(ascending=False).index[0]\n    most_country = gtd.loc[gtd.targtype1==e, 'country'].value_counts().sort_values(ascending=False).index[0]\n    \n    try:\n        detperc = round(tkill_dict[e]\/(tkill_dict[e]+tinjury_dict[e])*100,2)\n    except:\n        detperc = 'No Attacks'\n\n\n    text_dict[e] = 'Target Type <b>{cat}<\/b> <br>Total Injuries: <b>{inj}<\/b>, Total Deaths: <b>{det}<\/b><br> \\\n    Total Incidents: <b>{inc}<\/b>, Death to Death + Injury Percentage <b>\\\n    {detperc}%<\/b><br>The most common attack: <b>{atk}<\/b><br> \\\n    The most affected country: <b>{con}<\/b>'.format(cat=e,\\\n                                                    con=most_country, \\\n                                                    det=tkill_dict[e], inj=tinjury_dict[e],\\\n                                                    detperc=detperc, atk = most_attack,\\\n                                                    inc=tsize_dict[e])\n\n\n\n\n\nfor i, item in enumerate(tkill_dict):\n    scatter_trace = go.Scatter(x =[tinjury_dict[item]], y = [tkill_dict[item]], name = item, mode = 'markers', text = text_dict[item],\n        marker = dict(\n            size = tsize_dict[item]\/1000,\n            opacity = 0.9))\n    \n    scatter_traces.append(scatter_trace)\n\ndata = scatter_traces \nlayout = go.Layout(\n    autosize = False, width = 1000, height = 750,\n    title = 'Target Victim Breakdowns',\n    xaxis = dict(title = \"Total Injuries\",\n                 #type = 'log',\n             showline = True,\n             showgrid = False\n         ),\n    yaxis = dict(title='Total Kills',\n                 type = 'log',\n             showline = True,\n             showgrid = False),\n    annotations = [go.layout.Annotation(\n            x = 0.55,\n            y = 0.1,\n            xref = 'paper',\n            yref = 'paper',\n            text = 'Hover over markers to see more details',\n            showarrow = False\n)])\n\nfig = go.Figure(data=data, layout=layout)\niplot(fig, filename='grouped-bar')","f8e56cde":"# We are going to remake the above chart with a few more features - namely a slider with time and region distinction\n\nstart_yr = 1970\n\n#First create empty dictionary for figure\nfigure = {\n    'data': [],\n    'layout': {},\n    'frames': []\n}\n\n# fill in most of figure layout\nfigure['layout']['xaxis'] = {'range':[0,5],'title': 'Total Injuries', 'type': 'log'} #Remember log = 10^range\nfigure['layout']['yaxis'] = {'range':[0,5],'title': 'Total Kills', 'type': 'log'}\nfigure['layout']['hovermode'] = 'closest'\nfigure['layout']['title'] = 'Target Victim Break down by Region and Year'\n#Initilialize  figure Slider\nfigure['layout']['sliders'] = {\n    'args': [\n        'transition', {\n            'duration': 400,\n            'easing': 'cubic-in-out'\n        }\n    ],\n    'initialValue': str(start_yr),\n    'plotlycommand': 'animate',\n    'values': gtd.loc[gtd.year >= start_yr, 'year'].unique().astype(str),\n    'visible': True}\n\n# Update figure Button menus\nfigure['layout']['updatemenus'] = [\n    {'buttons': [\n        {'args': [None, {'frame': {'duration': 500, 'redraw': True},\n                         'fromcurrent': True, 'transition': \n                         {'duration': 300, 'easing': 'quadratic-in-out'}}\n                 ],\n         'label': 'Play',\n         'method': 'animate'},\n        {'args': [[None], {'frame': {'duration': 0, 'redraw': False}, 'mode': 'immediate',\n                           'transition': {'duration': 0}}],\n         'label': 'Pause',\n         'method': 'animate'}\n    ],\n     'direction': 'left',\n     'pad': {'r': 10, 't': 87},\n    'showactive': False,\n    'type': 'buttons',\n    'x': 0.1,\n    'xanchor': 'right',\n    'y': 0,\n    'yanchor': 'top'}]\n\n#skeleton dictionary of figure slider parameters\nsliders_dict = {\n    'active': 0,\n    'yanchor': 'top',\n    'xanchor': 'left',\n    'currentvalue': {\n        'font': {'size': 20},\n        'prefix': 'Year:',\n        'visible': True,\n        'xanchor': 'right'\n    },\n    'transition': {'duration': 300, 'easing': 'cubic-in-out'},\n    'pad': {'b': 10, 't': 50},\n    'len': 0.9,\n    'x': 0.1,\n    'y': 0,\n    'steps': []\n}\n\n\n","f5251675":"#We create the figure Data portion here\n\n#create empty dictionaries first\nregion_kills = {region: [] for region in gtd.region.unique()}\nregion_injury = {region: [] for region in gtd.region.unique()}\nregion_size = {region: [] for region in gtd.region.unique()}\nregion_text = {region: [] for region in gtd.region.unique()}\n\nfor region in gtd.region.unique(): # Loop through all regions and to create each series for each continent\n    kill_dicts = []\n    injury_dicts = []\n    size_dicts = []\n    regionset = gtd[(gtd.region == region) & (gtd.year == start_yr)]\n    \n    if regionset.shape[0] > 0: #Make sure to take out empty regions with no incidents and maintain memory usage\n        #First create empty dictionary to collect all target type sub dictionary totals\n        tkill_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n        tinjury_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n        tsize_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n        text_dict = {e:0 for e in gtd[gtd.region==region].targtype1.unique()}\n        \n        for n in range(3): \n            #Loop to find all the target types and create dictionary of kills\/injuries\/sizes\n            kill_dict = {regionset.groupby(['targtype'+str(n+1)]).nkill.sum().index[i]: e for i, e in enumerate(regionset.groupby(['targtype'+str(n+1)]).nkill.sum())}\n            injury_dict = {regionset.groupby(['targtype'+str(n+1)]).nwound.sum().index[i]: e for i, e in enumerate(regionset.groupby(['targtype'+str(n+1)]).nwound.sum())}\n            size_dict = {gtd.loc[(gtd.region == region) & (gtd.year == start_yr),'targtype'+str(n+1)].value_counts().index[i]: e for i, e in enumerate(gtd.loc[(gtd.region == region) & (gtd.year == start_yr),'targtype'+str(n+1)].value_counts())}\n            #update the dictionary to appropriate lists\n            kill_dicts.append(kill_dict)\n            injury_dicts.append(injury_dict)\n            size_dicts.append(size_dict)\n        \n\n        #Next loop through each target type and collect all the values in each dictionary\/list\n        #Objective here is to create a list for x, y, text descrip and size based on each target\/country\/year\n        for target in regionset.targtype1.unique():#First pull out each target type\n            #Next loop through each dictionary in the all the lists and append the total dictionary\n            for dic1 in kill_dicts:\n                try:\n                    tkill_dict[target] += dic1[target]\n                except:\n                    continue\n            for dic2 in injury_dicts:\n                try:\n                    tinjury_dict[target] += dic2[target]\n                except:\n                    continue\n            for dic3 in size_dicts:\n                try:\n                    tsize_dict[target] += dic3[target]\n                except:\n                    continue\n                    \n            #For each region\/year and target type there is a most attacked\/country which we can add to text\n            most_attack = regionset.loc[regionset.targtype1==target,'attacktype1'].value_counts().sort_values(ascending=False).index[0]\n            most_country = regionset.loc[regionset.targtype1==target, 'country'].value_counts().sort_values(ascending=False).index[0]\n            most_group = regionset.loc[regionset.targtype1==target,'gname1'].value_counts().sort_values(ascending=False).index[0]\n            \n            try: #Next we want to create a text variable for each target which shows death percentage\n                detperc = round(tkill_dict[target]\/(tkill_dict[target]+tinjury_dict[target])*100,2)\n            except:\n                detperc = 'No Attacks'\n            \n            #We add all the items from the dictionaries to the text dictionary\n            text_dict[target] = 'Target Type <b>{cat}<\/b> in {reg} for {yr} <br>Total Injuries: <b>{inj}<\/b>, Total Deaths: <b>{det}<\/b><br> \\\n            Total Incidents: <b>{inc}<\/b>, Death to Death + Injury Percentage <b>\\\n            {detperc}%<\/b><br>The most common attack: <b>{atk}<\/b><br> \\\n            The most affected country: <b>{con}<\/b><br>The most active group: <b>{grp}<\/b>'.format(cat=target,\\\n                                                            con=most_country, \\\n                                                            det=tkill_dict[target], inj=tinjury_dict[target],\\\n                                                            detperc=detperc, atk = most_attack,\\\n                                                            inc=tsize_dict[target], reg=region, yr = start_yr, grp=most_group)\n\n\n            #end of target loop, total target dictionaries should be finished now  \n            \n        \n        #Now collect the target and total dictionaries into regional subdivisions\n        region_kills[region] = tkill_dict\n        region_injury[region] = tinjury_dict\n        region_size[region] = tsize_dict\n        region_text[region] = text_dict\n        \n        #Now that we have all the totals collected, create arrays for the data dictionary\n\n#First loop pulls out each key from the dictionary (each key = region)\nfor region in region_kills: #Contents is a list with dictionary for each target type\n    xlist = []\n    ylist = []\n    tlist = []\n    slist = []\n    for target in region_kills[region]: #This loop pulls out each target from the dictionary so we can append to each list\n        if region_kills[region][target]>0 or region_injury[region][target]>0: #This way we only capture \"live\" incidents\n            xlist.append(region_injury[region][target])\n            ylist.append(region_kills[region][target])\n            tlist.append(region_text[region][target])\n            slist.append(region_size[region][target])\n    #At at end of for loop we should have full list for each region \n    \n    if bool(xlist):\n        data_dict = {\n        'x': xlist,\n        'y': ylist,\n        'mode': 'markers',\n        'text': tlist,\n        'marker': {\n            'sizemode': 'area',\n            'sizeref': 1,\n            'size': slist\n        },\n        'name': region}\n        #For each region, we append a series to data\n        figure['data'].append(data_dict)","7fc06217":"#Create the Frames and Slider step for each year\nfor yr in gtd.loc[gtd.year >= start_yr, 'year'].unique():\n    frame = {'data':[], 'name':str(yr)} #Dictionary for each frame - end of each yr loop pass will be added here\n    \n    #Create a lot of empty dictionaries for each year\/region split\n    region_yr_kills = {region: [] for region in gtd.region.unique()}\n    region_yr_injury = {region: [] for region in gtd.region.unique()}\n    region_yr_size = {region: [] for region in gtd.region.unique()}\n    region_yr_text = {region: [] for region in gtd.region.unique()}\n    \n    for region in gtd.region.unique(): # Loop through all regions and to create each series for each continent\n        kill_dicts = []\n        injury_dicts = []\n        size_dicts = []\n        regionset = gtd[(gtd.region == region) & (gtd.year == yr)]\n\n        if regionset.shape[0] > 0: #Make sure to take out empty regions with no incidents and maintain memory usage\n            #First create empty dictionary to collect all target type sub dictionary totals\n            tkill_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n            tinjury_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n            tsize_dict = {e: 0 for e in gtd[gtd.region==region].targtype1.unique()}\n            text_dict = {e:0 for e in gtd[gtd.region==region].targtype1.unique()}\n\n            for n in range(3): \n                #Loop to find all the target types and create dictionary of kills\/injuries\/sizes\n                kill_dict = {regionset.groupby(['targtype'+str(n+1)]).nkill.sum().index[i]: e for i, e in enumerate(regionset.groupby(['targtype'+str(n+1)]).nkill.sum())}\n                injury_dict = {regionset.groupby(['targtype'+str(n+1)]).nwound.sum().index[i]: e for i, e in enumerate(regionset.groupby(['targtype'+str(n+1)]).nwound.sum())}\n                size_dict = {gtd.loc[(gtd.region == region) & (gtd.year == yr),'targtype'+str(n+1)].value_counts().index[i]: e for i, e in enumerate(gtd.loc[(gtd.region == region) & (gtd.year == yr),'targtype'+str(n+1)].value_counts())}\n                #update the dictionary to appropriate lists\n                kill_dicts.append(kill_dict)\n                injury_dicts.append(injury_dict)\n                size_dicts.append(size_dict)\n\n\n            #Next loop through each target type and collect all the values in each dictionary\/list\n            #Objective here is to create a list for x, y, text descrip and size based on each target\/country\/year\n            for target in regionset.targtype1.unique():#First pull out each target type\n                #Next loop through each dictionary in the all the lists and append the total dictionary\n                for dic1 in kill_dicts:\n                    try:\n                        tkill_dict[target] += dic1[target]\n                    except:\n                        continue\n                for dic2 in injury_dicts:\n                    try:\n                        tinjury_dict[target] += dic2[target]\n                    except:\n                        continue\n                for dic3 in size_dicts:\n                    try:\n                        tsize_dict[target] += dic3[target]\n                    except:\n                        continue\n\n                #For each region\/year and target type there is a most attacked\/country which we can add to text\n                most_attack = regionset.loc[regionset.targtype1==target,'attacktype1'].value_counts().sort_values(ascending=False).index[0]\n                most_country = regionset.loc[regionset.targtype1==target, 'country'].value_counts().sort_values(ascending=False).index[0]\n                most_group = regionset.loc[regionset.targtype1==target,'gname1'].value_counts().sort_values(ascending=False).index[0]\n\n                try: #Next we want to create a text variable for each target which shows death percentage\n                    detperc = round(tkill_dict[target]\/(tkill_dict[target]+tinjury_dict[target])*100,2)\n                except:\n                    detperc = 'No Attacks'\n\n                #We add all the items from the dictionaries to the text dictionary\n                text_dict[target] = 'Target Type <b>{cat}<\/b> in {reg} for {yr} <br>Total Injuries: <b>{inj}<\/b>, Total Deaths: <b>{det}<\/b><br> \\\n                Total Incidents: <b>{inc}<\/b>, Death to Death + Injury Percentage <b>\\\n                {detperc}%<\/b><br>The most common attack: <b>{atk}<\/b><br> \\\n                The most affected country: <b>{con}<\/b><br>The most active group: <b>{grp}<\/b>'.format(cat=target,\\\n                                                                con=most_country, \\\n                                                                det=tkill_dict[target], inj=tinjury_dict[target],\\\n                                                                detperc=detperc, atk = most_attack,\\\n                                                                inc=tsize_dict[target], reg=region, yr = yr, grp = most_group)\n\n\n                #end of target loop, total target dictionaries should be finished now  \n\n\n            #Now collect the target and total dictionaries into regional subdivisions\n            region_yr_kills[region] = tkill_dict\n            region_yr_injury[region] = tinjury_dict\n            region_yr_size[region] = tsize_dict\n            region_yr_text[region] = text_dict\n\n            #Now that we have all the totals collected, create arrays for the data dictionary\n            #First loop pulls out each key from the dictionary (each key = region)\n    for region in region_yr_kills: #Contents is a list with dictionary for each target type\n        xlist = []\n        ylist = []\n        tlist = []\n        slist = []\n        for target in region_yr_kills[region]: #This loop pulls out each target from the dictionary so we can append to each list\n            if region_yr_kills[region][target]>0 or region_yr_injury[region][target]>0: #This way we only capture \"live\" incidents\n                xlist.append(region_yr_injury[region][target])\n                ylist.append(region_yr_kills[region][target])\n                tlist.append(region_yr_text[region][target])\n                slist.append(region_yr_size[region][target])\n        #At at end of for loop we should have full list for each region \n\n        if bool(xlist):\n            data_dict = {\n            'x': xlist,\n            'y': ylist,\n            'mode': 'markers',\n            'text': tlist,\n            'marker': {\n                'sizemode': 'area',\n                'sizeref': 1,\n                'size': slist\n            },\n            'name': region}\n            frame['data'].append(data_dict)\n\n    figure['frames'].append(frame)\n    \n    slider_step = {'args': [\n        [str(yr)],\n        {'frame': {'duration': 300, 'redraw': True},\n         'mode': 'immediate',\n         'transition': {'duration': 300}}\n    ],'label': str(yr),'method': 'animate'}\n\n    sliders_dict['steps'].append(slider_step)\n\n        \n\nfigure['layout']['sliders'] = [sliders_dict]","617146b4":"iplot(figure)","bcaa2ff8":"### That's it for now!\n\nThe data set is patchy in areas (the dates are a hot mess) but the information can be useful in being used as an output layer for deep learning frameworks (most of the parameters are split into nice categories). However, it's hard to imagine that we can find substantial correlation to predict events with this information alone. Further work will involve testing this to see if there is substantial variability between parameters to deduce a relationship through a neural network. What will be nice is more economic  and political data (though will need a crawl through central economic databases around the world) which documents historical levels and paints a better picture on general stability during the time of attacks. More work likely to follow on this but would love to hear your thought! Also, if any experts on plotly buttons who know how to adjust choropleth maps, please let me know!","d0fca95b":"### What does this tell us?\n- The above chart is an extension of the previous scatter plot outlining Target Victim Types\n- This chart helps paint a much more useful picture on what we gathered from the earlier time series bar plot which showed the top 5 most affected countries.\n- The animation (admittedly - slider needs some more work) provides a helpful perspective in the sudden lul and jump in activity. I recommend looking at the animatino by doule clicking one region and seeing the evolution - though be careful as I need to debug the colorscheme.\n    - For example, a look into Sub Sahara Africa shows that the terrorist activity is characterized by regional political transition\/instability (South Africa and Apartheid, Sierre Leone\/Burundi's melt down and since the 2000's Somalia's insurgence of Al Shahaab and Nigeria's Boko Harem). Also interesting is the sharp rise in Armed Assault Activity in regions like Nigeria (which is Afria's most populous country)\n    - It's interesting how the Middle East had so little acivity for decades and became such a hotspot for terrorism only in the last decade.\n    - Also interesting to note is the consistent level of terrorism in places like the Phillippines - even though India places like India and Pakistan have drastically more aggregate terrorism,, the more violent outbursts seem to be characterized by in the Phillipines and Thailand.\n        - It would be interesitng to see if there are any underlying parameters that connect the regions","75014413":"# Global Terrorism Data Analysis\n\n## __About Notebook__\nThe contents of this notebook are supplementary to a Dash web application. The majority of the below is scratchwork that will be used to build the web application - I've included my thought process to hopefully help other \"wanna-be Data Scientists\" who are trying to  something similar. The notebook will enclude rudimentary analysis and aims to produce an \"end product\" which will be a refined dataframe that can be used as an input for the Dash app. Also, this is an on going project as I am still learning and trying new things but I thought I'd share the finer points with the Kaggle community. \n\n## __Analysis Objective__\nThe purpose of this analysis is to help combat the rise and spread of terrorism. The analysis hopes to achieve this objective by first providing a collection of useful graphs\/charting material that wil provide a better illustration of coherent terrorism trends and eventually tools that will use supervised learning methods to predict the *odds* of an attack. While it hopefully shouldn't need any explaining, this product tries to avoid any political\/religious\/personal biases in order to make more accurate predictions.\n\n#### A Note to Readers\nThis notebook uses interactive plotly charts. For charts which have multiple series, you can de\/select a series by clicking on it once and zoom in on just that one series by double clicking on it (and the reactivating all series by double clicking).","23d06109":"### What does this tell us?\n- This chart would be better served as a select event to a country (so that you can see the break down over history). \n- While as a whole it proves to broad to be useful (clearly Iraq is skewing the ouput of the data), it does prove useful as a starting point to do more things","80cb276d":"### About this chart\n- Hover over the data points to get more details on the main groups and the countries (the label is sometimes not so visible on the right)\n- I added a range slider as its sometimes nice to take a look at the the years upclose (thought it would be nice if someone knew how to stop the years to switch to smaller integers?\n\n\n### What does this tell us?\n- This graph shows that the sharp rise in global terrorism really took off in 2011 with the rise of the Taliban in Iraq, Afghanistan and Pakistan. \n- Things really started kicking off when ISIL entered the scene in 2013\n- Interestingly, there was a drop in the period of the 90s up to 9\/11\n- The period before 9\/11 was marked by largely local\/smaller scale incidents in regions experiencing political unrest\n- The 80s were marked by generally elevating tensions which seem to drop shortly after cold war (conveniently during the Clinton  era - related?). The regions most affected seem to be Central\/South American countries\n- The 70s seemed like they were a milder time where we go even more local (heating tensions in Ireland)\n\n#### Things to highlight\n- The trend in this data highlihgts that we are lacking feature representation in this data as there is clearly a trend (introduction of new adversaries and political climate) so part of the project to make this into a successful predictive algorithm, we will need to extract additional features like political climate and formation of new groups ","a90180f0":"## Formating","582f2586":"### What does this tell us?\n\n#### <u>Attacks<\/u>:\n<p>\n    We can see from hovering over the main hot spots that bombing\/explosions is the predominant method of attack\n    across every region followed usually by Armed Assault or Facillity Infrastructure Attacks. this information seems\n    relevant but should be expressed as a bar graph (horizontal) in the dashboard\n<\/p>\n\n#### <u> Perpetrators\/Perpetrator sub groups<\/u>:\n<p>\n    The perpetrator visual by group seems less helpful as the underlying data is inconsistent - we're gonna try taking a look as a scatter plot instead\n    <\/p>\n\n#### <u> Weapon Visuals <\/u>:\n<p>\n    Also not hugely helpful as it is, we'll try some scatter plots for the weapons and see what other trends we can find\n    \n\n### How can we use this?\n\nThe filter view is a good idea for the dash application implementation. Initial idea is to implement the graph in the lower left majority of the dash application. \n\n#### <u> Specific additions<\/u>\n- [ ] The right panel will need to have linked windows which can give greater detail on other subtypes. \n- [ ] We will need to implement a range slider that can show break downs for date ranges\n- [ ] Annoyingly, the documentation for the plotly offline buttons is very thin so I'm unsure on how to use the update method to adjust the data attributes (I tried dictionaries combined with lists) but have been so far unsuccessful. If anyone in the Kaggle Community has some better suggestions, would love to hear them. If I could use the updae method to change parameters in both the Layout and the Data section then I could use the animation to connect the map to a slider and  perhaps even add some scatter geos to see how different attack patterns evolve over time\n- [ ] A bar chart to see the distribution of parameters is more useful than text - something to link to the right panel if there is a hoverData output\n\n\n### What should we check next\n- [X] Lets see if we can find some break down of the main perpetrator for each country and links to the acts they have commmitted (accomplished with funciton above)\n- [X] Analysis for damage dealt with total dead and wounded - include property damage (accomplishd with function above)\n- [X] Lets see breakdown of target types\n\nOverall, I'd like to do a lot more with this chart but I wanted to show what I had so far. "}}