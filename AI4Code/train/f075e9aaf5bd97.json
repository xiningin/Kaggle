{"cell_type":{"94993c8e":"code","9ca6111d":"code","cebbcf01":"code","d0d1883e":"code","64e65207":"code","88d222df":"code","9df6704e":"code","de917dad":"code","7db658ff":"code","8f0cfef4":"code","b5b95a45":"code","baad67a3":"code","17ecc1fe":"code","9af283f2":"code","60a0e5e4":"code","2ebd5e28":"code","41588494":"code","a708f2cc":"code","5f3ddee9":"code","33bfc139":"code","02c0d092":"code","b99d82ba":"code","8d020dc3":"code","1ef3b086":"code","b4263e8c":"code","25ccb9c9":"code","4f3d1770":"code","7cacdf8c":"code","08d34d97":"code","ab4917fd":"code","ac8705fb":"code","faee18a4":"code","eb3e93b9":"code","361ea7d2":"code","eea21bc8":"code","6bb2b6b2":"markdown","ac973c6d":"markdown","dd96eb23":"markdown","04806b70":"markdown","9631b7d1":"markdown","e14af4d3":"markdown","48a6871e":"markdown","120c9d3d":"markdown","d01147ca":"markdown","3fce30a5":"markdown","c90fc07f":"markdown","fc42ae00":"markdown","5ceb2ba8":"markdown","9fb60f67":"markdown","858db410":"markdown","ede223f2":"markdown","f053ec41":"markdown","ff6bfe8c":"markdown","aade6fb2":"markdown","ea209b0f":"markdown","2fe7289a":"markdown","0b441aab":"markdown","b76645c1":"markdown","a687f47d":"markdown","0b8effe3":"markdown","b1fe7ce8":"markdown","b198c95e":"markdown","de9371ad":"markdown","3785e8c3":"markdown","b272c1f8":"markdown","4624bbab":"markdown","496cdb27":"markdown"},"source":{"94993c8e":"pip install -U d2l","9ca6111d":"import numpy as np\nimport pandas as pd\nimport torch\nfrom torch import nn\nfrom d2l import torch as d2l\n\ntrain_data = pd.read_csv(\"..\/input\/california-house-prices\/train.csv\")\ntest_data = pd.read_csv(\"..\/input\/california-house-prices\/test.csv\")","cebbcf01":"print(train_data.shape)\nprint(test_data.shape)","d0d1883e":"[i for i in train_data.columns if i not in test_data.columns]","64e65207":"train_data.columns","88d222df":"test_data.columns","9df6704e":"all_features = pd.concat((train_data.iloc[:, 4:-1], test_data.iloc[:, 3:-1]))","de917dad":"all_features.shape","7db658ff":"missing_values_count = all_features.isnull().sum()\n\n# look at the # of missing points in the first ten columns\nmissing_values_count.loc[missing_values_count>0]","8f0cfef4":"total_cells = np.product(all_features.shape)\ntotal_missing = missing_values_count.sum()\n\n# percent of data that is missing\npercent_missing = (total_missing\/total_cells) * 100\nprint(percent_missing)","b5b95a45":"all_features = all_features.fillna(method='bfill', axis=0).fillna(0)","baad67a3":"missing_values_count = all_features.isnull().sum()\n\n# look at the # of missing points in the first ten columns\nmissing_values_count.loc[missing_values_count>0]","17ecc1fe":"all_features.columns","9af283f2":"print(all_features['Listed On'].head())\nprint(all_features['Last Sold On'].head())","60a0e5e4":"all_features['Listed On'] = pd.to_datetime(all_features['Listed On'], format=\"%Y-%m-%d\")","2ebd5e28":"all_features['Last Sold On'] = pd.to_datetime(all_features['Last Sold On'], format=\"%Y-%m-%d\")","41588494":"print(all_features['Listed On'].head())\nprint(all_features['Last Sold On'].head())","a708f2cc":"all_features.dtypes.unique()","5f3ddee9":"numeric_features = all_features.dtypes[all_features.dtypes == 'float64'].index\nall_features[numeric_features] = all_features[numeric_features].apply(\n    lambda x: (x - x.mean()) \/ (x.std()))","33bfc139":"all_features.dtypes[all_features.dtypes=='object']","02c0d092":"print(len(all_features['Type'].unique()))\nprint(len(all_features['Heating'].unique()))\nprint(len(all_features['Cooling'].unique()))\nprint(len(all_features['Parking'].unique()))\nprint(len(all_features['Bedrooms'].unique()))\nprint(len(all_features['Region'].unique()))\nprint(len(all_features['Elementary School'].unique()))\nprint(len(all_features['Middle School'].unique()))\nprint(len(all_features['High School'].unique()))\nprint(len(all_features['Flooring'].unique()))\nprint(len(all_features['Heating features'].unique()))\nprint(len(all_features['Cooling features'].unique()))\nprint(len(all_features['Appliances included'].unique()))\nprint(len(all_features['Laundry features'].unique()))\nprint(len(all_features['Parking features'].unique()))\nprint(len(all_features['City'].unique()))","b99d82ba":"all_features['Appliances included']","8d020dc3":"features = list(numeric_features)\nfeatures.append('Type')   # \u52a0\u4e0a\u7c7b\u522b\u6570\u76f8\u5bf9\u8f83\u5c11\u7684Type\nprint(features)","1ef3b086":"all_features = all_features[features]","b4263e8c":"all_features.shape","25ccb9c9":"all_features = pd.get_dummies(all_features, dummy_na=True)\nall_features.shape","4f3d1770":"n_train = train_data.shape[0]\ntrain_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)\ntest_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)\ntrain_labels = torch.tensor(train_data['Sold Price'].values.reshape(-1,1), dtype=torch.float32)","7cacdf8c":"loss = nn.MSELoss()\nin_features = train_features.shape[1]\n\ndef get_net():\n    net = nn.Sequential(nn.Linear(in_features,256), nn.ReLU(), nn.Linear(256,1))  \n    #net = nn.Sequential(nn.Linear(in_features, 1))\n    return net","08d34d97":"def log_rmse(net, features, labels):\n    # \u4e3a\u4e86\u5728\u53d6\u5bf9\u6570\u65f6\u8fdb\u4e00\u6b65\u7a33\u5b9a\u8be5\u503c\uff0c\u5c06\u5c0f\u4e8e1\u7684\u503c\u8bbe\u7f6e\u4e3a1\n    clipped_preds = torch.clamp(net(features), 1, float('inf'))\n    rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels)))\n    return rmse.item()","ab4917fd":"def train(net, train_features, train_labels, test_features, test_labels,\n          num_epochs, learning_rate, weight_decay, batch_size):\n    train_ls, test_ls = [], []   # train_loss\u548ctest_loss\n    train_iter = d2l.load_array((train_features, train_labels), batch_size)\n    # \u8fd9\u91cc\u4f7f\u7528\u7684\u662fAdam\u4f18\u5316\u7b97\u6cd5\uff0c\u5bf9\u521d\u59cb\u5b66\u4e60\u7387\u6ca1\u6709\u90a3\u4e48\u654f\u611f\n    optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate,\n                                 weight_decay=weight_decay)\n    for epoch in range(num_epochs):\n        for X, y in train_iter:\n            optimizer.zero_grad()\n            l = loss(net(X), y)\n            l.backward()\n            optimizer.step()\n        train_ls.append(log_rmse(net, train_features, train_labels))\n        if test_labels is not None:\n            test_ls.append(log_rmse(net, test_features, test_labels))\n    return train_ls, test_ls","ac8705fb":"def get_k_fold_data(k, i, X, y):\n    assert k > 1\n    fold_size = X.shape[0] \/\/ k\n    X_train, y_train = None, None\n    for j in range(k):\n        idx = slice(j * fold_size, (j + 1) * fold_size)\n        X_part, y_part = X[idx, :], y[idx]\n        if j == i:\n            X_valid, y_valid = X_part, y_part\n        elif X_train is None:\n            X_train, y_train = X_part, y_part\n        else:\n            X_train = torch.cat([X_train, X_part], 0)\n            y_train = torch.cat([y_train, y_part], 0)\n    return X_train, y_train, X_valid, y_valid","faee18a4":"# \u8fd4\u56de\u8bad\u7ec3\u548c\u9a8c\u8bc1\u8bef\u5dee\u7684\u5e73\u5747\u503c\ndef k_fold(k, X_train, y_train, num_epochs, learning_rate, weight_decay,\n           batch_size):\n    train_l_sum, valid_l_sum = 0, 0\n    for i in range(k):\n        data = get_k_fold_data(k, i, X_train, y_train)\n        net = get_net()\n        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,\n                                   weight_decay, batch_size)\n        train_l_sum += train_ls[-1]\n        valid_l_sum += valid_ls[-1]\n        if i == 0:\n            d2l.plot(list(range(1, num_epochs + 1)), [train_ls, valid_ls],\n                     xlabel='epoch', ylabel='rmse', xlim=[1, num_epochs],\n                     legend=['train', 'valid'], yscale='log')\n        print(f'fold {i + 1}, train log rmse {float(train_ls[-1]):f}, '\n              f'valid log rmse {float(valid_ls[-1]):f}')\n    return train_l_sum \/ k, valid_l_sum \/ k","eb3e93b9":"k, num_epochs, lr, weight_decay, batch_size = 5, 100, 0.1, 0.1, 64    # \u8c03\u53c2\u6570\ntrain_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,\n                          weight_decay, batch_size)\nprint(f'{k}-\u6298\u9a8c\u8bc1: \u5e73\u5747\u8bad\u7ec3log rmse: {float(train_l):f}, '\n      f'\u5e73\u5747\u9a8c\u8bc1log rmse: {float(valid_l):f}')","361ea7d2":"def train_and_pred(train_features, test_feature, train_labels, test_data,\n                   num_epochs, lr, weight_decay, batch_size):\n    net = get_net()\n    train_ls, _ = train(net, train_features, train_labels, None, None,\n                        num_epochs, lr, weight_decay, batch_size)\n    d2l.plot(np.arange(1, num_epochs + 1), [train_ls], xlabel='epoch',\n             ylabel='log rmse', xlim=[1, num_epochs], yscale='log')\n    print(f'train log rmse {float(train_ls[-1]):f}')\n    # \u5c06\u7f51\u7edc\u5e94\u7528\u4e8e\u6d4b\u8bd5\u96c6\u3002\n    preds = net(test_features).detach().numpy()\n    # \u5c06\u5176\u91cd\u65b0\u683c\u5f0f\u5316\u4ee5\u5bfc\u51fa\u5230Kaggle\n    test_data['Sold Price'] = pd.Series(preds.reshape(1, -1)[0])\n    submission = pd.concat([test_data['Id'], test_data['Sold Price']], axis=1)\n    submission.to_csv('submission.csv', index=False)","eea21bc8":"train_and_pred(train_features, test_features, train_labels, test_data,\n               num_epochs, lr, weight_decay, batch_size)","6bb2b6b2":"\u5728\u6a21\u578b\u9009\u62e9\u7684\u8fc7\u7a0b\u4e2d\u53d1\u73b0\uff0c\u6709\u7684\u53c2\u6570\u4f1a\u4f7floss\u968f\u7740epoch\u589e\u52a0\u6ce2\u52a8\u8fc7\u5927\uff0c\u800c\u4e0d\u662f\u7a33\u5b9a\u4e0b\u964d\u3002\u8fd9\u79cd\u60c5\u51b5\u5f88\u53ef\u80fd\u662f\u56e0\u4e3abatch_size\u4e0d\u591f\u5927\uff0c\u6a21\u578b\u4e0d\u7a33\u5b9a\uff0c\u53ef\u4ee5\u589e\u5927batch_size\u6765\u7f13\u89e3\u3002","ac973c6d":"\u4ece\u4e0a\u9762\u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u8981\u9884\u6d4b\u7684\u623f\u4ef7\u5217\u540d\u4e3a```Sold Price```","dd96eb23":"### \u8f6c\u4e3a\u5f20\u91cf","04806b70":"## \u8bad\u7ec3","9631b7d1":"## \u5bfc\u5165\u6570\u636e","e14af4d3":"\u9a8c\u8bc1\u4e00\u4e0bdtype\uff1a","48a6871e":"train_data\u4e2d```Sold Price```\u9700\u8981\u5254\u9664\uff0c\u56e0\u4e3a\u662f\u6807\u7b7e\u3002\ntrain_data\u548ctest_data\u4e2d\u7684```Id```\u9700\u8981\u5254\u9664\uff0c\u56e0\u4e3a\u548c\u7ed3\u679c\u65e0\u5173\u3002","120c9d3d":"### \u6807\u51c6\u5316","d01147ca":"## \u6570\u636e\u9884\u5904\u7406","3fce30a5":"###  \u72ec\u70ed\u7f16\u7801\n\n\u67e5\u770b\u4e00\u4e0ball_features\u4e2d\u7c7b\u578b\u4e3aobject\u7684\u7279\u5f81\u6709\u54ea\u4e9b\uff1a","c90fc07f":"\u4e3a\u4e86\u63d0\u9ad8\u72ec\u70ed\u7f16\u7801\u65f6\u7684\u8d28\u91cf\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9bobject\u7c7b\u578b\u4e2d\u662f\u5426\u5b58\u5728\u6570\u636e\u4e0d\u4e00\u81f4\u7684\u60c5\u51b5\uff1a","fc42ae00":"## \u9884\u6d4b","5ceb2ba8":"### \u7279\u5f81\u9009\u62e9","9fb60f67":"\u5176\u4e2d*trian_data*\u6bd4*test_data*\u591a\u4e86\u4e00\u5217\uff0c\u8fd9\u4e00\u5217\u5c31\u662f\u6211\u4eec\u8981\u9884\u6d4b\u7684\u623f\u4ef7\u3002","858db410":"\u8fd9\u4e2a\u65b9\u6cd5\u5b8c\u5168\u4eff\u7167\u8bfe\u4e0aPPT\u7684\u505a\u6cd5\u3002","ede223f2":"\u6211\u4eec\u5148\u9700\u8981\u770b\u4e00\u4e0btrain_data\u548ctest_data\u6709\u54ea\u4e9b\u7279\u5f81\uff1a","f053ec41":"\u4ece\u4e0a\u9762\u5404\u4e2a\u957f\u5ea6\u53ef\u4ee5\u770b\u51fa\uff0c\u7279\u5f81\u5305\u542b\u7684\u7c7b\u522b\u6570\u592a\u591a\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u662f\u4ec0\u4e48\u60c5\u51b5\uff1a","ff6bfe8c":"### \u9009\u53d6loss\u51fd\u6570\uff1a\n\n\u56e0\u4e3a\u4e0d\u540c\u533a\u57df\u7684\u623f\u4ef7\u7edd\u5bf9\u6570\u503c\u76f8\u5dee\u5f88\u5927\uff0c\u6211\u4eec\u66f4\u5173\u5fc3\u76f8\u5bf9\u8bef\u5dee\uff1a$\\frac{y - \\hat{y}}{y}$\uff0c\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49loss\u4e3a\uff1a\n\n$$\\sqrt{\\frac{1}{n}\\sum_{i=1}^n\\left(\\log y_i -\\log \\hat{y}_i\\right)^2}.$$","aade6fb2":"\u9664\u6b64\u4e4b\u5916\uff0c\u56e0\u4e3a\u90fd\u662f\u52a0\u5dde\u7684\u623f\u5b50\uff0c\u9700\u8981\u5254\u9664```State```;```Summary```\u662f\u6587\u672c\u6570\u636e\uff0c\u5206\u6790\u6709\u9650\u5c31\u76f4\u63a5\u5254\u9664\uff0c\u540c\u7406```Address```\uff1a\u6bcf\u4e2a\u623f\u5b50\u7684\u5730\u5740\u90fd\u4e0d\u540c\uff0c\u5982\u679c\u8fdb\u884c\u72ec\u70ed\u7f16\u7801\u8d1f\u62c5\u592a\u5927\uff0c\u5206\u6790\u4e5f\u6709\u9650\uff0c\u6240\u4ee5\u4e5f\u5254\u9664\u3002","ea209b0f":"\u8fdb\u884c\u7f16\u7801\uff1a","2fe7289a":"### \u5904\u7406\u65e5\u671f\u6570\u636e","0b441aab":"\u56e0\u4e3akaggle\u4e0a\u5185\u5b58\u6709\u9650\uff0c\u9700\u8981\u9009\u62e9\u597d\u54ea\u4e9b\u7279\u5f81\u518d\u8fdb\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c\uff0c\u4ee5\u514d\u8d85\u9650\u3002","b76645c1":"\u4e3a\u4e86\u8ba9\u8bad\u7ec3\u96c6\u548c\u6d4b\u8bd5\u96c6\u4e00\u8d77\u5b8c\u6210\u6570\u636e\u9884\u5904\u7406\uff0c\u8fd8\u9700\u8981```cancat```\u3002","a687f47d":"\u770b\u4e00\u4e0b\u73b0\u5728all_features\u4e2d\u7684\u6570\u636e\u6709\u54ea\u4e9b\u7c7b\u578b\uff1a","0b8effe3":"\u6765\u9a8c\u8bc1\u4e00\u4e0b\uff0cNA\u662f\u5426\u90fd\u53bb\u9664\u4e86\uff1a","b1fe7ce8":"### \u5904\u7406\u7f3a\u5931\u6570\u636e","b198c95e":"\u6240\u4ee5\u6570\u636e\u96c6\u4e2d\u7f3a\u5931\u503c\u5360\u6570\u636e\u603b\u6570\u7684......?","de9371ad":"### \u8bad\u7ec3\u51fd\u6570","3785e8c3":"### \u6a21\u578b\u9009\u62e9","b272c1f8":"\u5148\u770b\u4e00\u4e0b\u6709\u54ea\u4e9b\u5217\u6709\u7f3a\u5931\u503c\uff1a","4624bbab":"### k\u6298\u4ea4\u53c9\u9a8c\u8bc1","496cdb27":"\u9664\u4e86```Appliances included```\u4ee5\u5916\uff0c\u5176\u4ed6\u6570\u91cf\u5f88\u5927\u7684\u7c7b\u522b\u4e5f\u90fd\u662f\u7528\u9017\u53f7\u5206\u9694\u7684\u591a\u7c7b\u522b\u6587\u672c\u6570\u636e\u3002\u56e0\u4e3a\u73b0\u5728\u6211\u7684\u6c34\u5e73\u6709\u9650\uff0c\u4e0d\u592a\u77e5\u9053\u8fd9\u79cd\u6570\u636e\u600e\u4e48\u7f16\u7801\uff0c\u6240\u4ee5\u51b3\u5b9a\u628a\u5b83\u4eec\u90fd\u5254\u9664\u6389\uff1a"}}