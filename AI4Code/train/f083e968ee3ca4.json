{"cell_type":{"1e875aae":"code","2516fb2c":"code","c6551260":"code","18bfd72b":"code","87b0e51e":"code","86c8b2fe":"code","2b9375c3":"code","b7605fea":"code","f831cd6e":"code","55c65061":"code","0888c329":"code","6b4b7fdd":"code","2b9faeb3":"markdown"},"source":{"1e875aae":"\"\"\"\nTitle: Text classification with Transformer\nAuthor: [Apoorv Nandan](https:\/\/twitter.com\/NandanApoorv)\nDate created: 2020\/05\/10\nLast modified: 2020\/05\/10\nDescription: Implement a Transformer block as a Keras layer and use it for text classification.\n\"\"\"\n\"\"\"\n## Setup\n\"\"\"\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers, callbacks\nfrom keras.utils import to_categorical\nfrom keras.preprocessing import text, sequence\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.optimizers import Adam\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport time\n\n\"\"\"\n## Implement multi head self attention as a Keras layer\n\"\"\"\n\nprint(\"Tensorflow Version: \", tf.__version__)\nprint(\"Eager mode enabled: \", tf.executing_eagerly())\nprint(\"GPU available: \", tf.test.is_gpu_available())\n\nnotebookstart = time.time()","2516fb2c":"class MultiHeadSelfAttention(layers.Layer):\n    def __init__(self, embed_dim, num_heads=8):\n        super(MultiHeadSelfAttention, self).__init__()\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        if embed_dim % num_heads != 0:\n            raise ValueError(\n                f\"embedding dimension = {embed_dim} should be divisible by number of heads = {num_heads}\"\n            )\n        self.projection_dim = embed_dim \/\/ num_heads\n        self.query_dense = layers.Dense(embed_dim)\n        self.key_dense = layers.Dense(embed_dim)\n        self.value_dense = layers.Dense(embed_dim)\n        self.combine_heads = layers.Dense(embed_dim)\n\n    def attention(self, query, key, value):\n        score = tf.matmul(query, key, transpose_b=True)\n        dim_key = tf.cast(tf.shape(key)[-1], tf.float32)\n        scaled_score = score \/ tf.math.sqrt(dim_key)\n        weights = tf.nn.softmax(scaled_score, axis=-1)\n        output = tf.matmul(weights, value)\n        return output, weights\n\n    def separate_heads(self, x, batch_size):\n        x = tf.reshape(x, (batch_size, -1, self.num_heads, self.projection_dim))\n        return tf.transpose(x, perm=[0, 2, 1, 3])\n\n    def call(self, inputs):\n        # x.shape = [batch_size, seq_len, embedding_dim]\n        batch_size = tf.shape(inputs)[0]\n        query = self.query_dense(inputs)  # (batch_size, seq_len, embed_dim)\n        key = self.key_dense(inputs)  # (batch_size, seq_len, embed_dim)\n        value = self.value_dense(inputs)  # (batch_size, seq_len, embed_dim)\n        query = self.separate_heads(\n            query, batch_size\n        )  # (batch_size, num_heads, seq_len, projection_dim)\n        key = self.separate_heads(\n            key, batch_size\n        )  # (batch_size, num_heads, seq_len, projection_dim)\n        value = self.separate_heads(\n            value, batch_size\n        )  # (batch_size, num_heads, seq_len, projection_dim)\n        attention, weights = self.attention(query, key, value)\n        attention = tf.transpose(\n            attention, perm=[0, 2, 1, 3]\n        )  # (batch_size, seq_len, num_heads, projection_dim)\n        concat_attention = tf.reshape(\n            attention, (batch_size, -1, self.embed_dim)\n        )  # (batch_size, seq_len, embed_dim)\n        output = self.combine_heads(\n            concat_attention\n        )  # (batch_size, seq_len, embed_dim)\n        return output\n\n\n\"\"\"\n## Implement a Transformer block as a layer\n\"\"\"\n\n\nclass TransformerBlock(layers.Layer):\n    def __init__(self, embed_dim, num_heads, ff_dim, rate=0.1):\n        super(TransformerBlock, self).__init__()\n        self.att = MultiHeadSelfAttention(embed_dim, num_heads)\n        self.ffn = keras.Sequential(\n            [layers.Dense(ff_dim, activation=\"relu\"), layers.Dense(embed_dim),]\n        )\n        self.layernorm1 = layers.LayerNormalization(epsilon=1e-6)\n        self.layernorm2 = layers.LayerNormalization(epsilon=1e-6)\n        self.dropout1 = layers.Dropout(rate)\n        self.dropout2 = layers.Dropout(rate)\n\n    def call(self, inputs, training):\n        attn_output = self.att(inputs)\n        attn_output = self.dropout1(attn_output, training=training)\n        out1 = self.layernorm1(inputs + attn_output)\n        ffn_output = self.ffn(out1)\n        ffn_output = self.dropout2(ffn_output, training=training)\n        return self.layernorm2(out1 + ffn_output)\n\n\n\"\"\"\n## Implement embedding layer\nTwo seperate embedding layers, one for tokens, one for token index (positions).\n\"\"\"\n\n\nclass TokenAndPositionEmbedding(layers.Layer):\n    def __init__(self, maxlen, vocab_size, embed_dim):\n        super(TokenAndPositionEmbedding, self).__init__()\n        self.token_emb = layers.Embedding(input_dim=vocab_size, output_dim=embed_dim)\n        self.pos_emb = layers.Embedding(input_dim=maxlen, output_dim=embed_dim)\n\n    def call(self, x):\n        maxlen = tf.shape(x)[-1]\n        positions = tf.range(start=0, limit=maxlen, delta=1)\n        positions = self.pos_emb(positions)\n        x = self.token_emb(x)\n        return x + positions","c6551260":"MAXLEN = 250\nVOCABLEN = 10000\nNCHANNEL = 3\nBATCHSIZE = 32\nEPOCHS = 60\n\nTEXTCOL = \"text\"\nTARGETCOL = \"author\"\nCHARS_TO_REMOVE = '!\"#$%&()*+,-.\/:;<=>?@[\\\\]^_`{|}~\\t\\n\u201c\u201d\u2019\\'\u221e\u03b8\u00f7\u03b1\u2022\u00e0\u2212\u03b2\u2205\u00b3\u03c0\u2018\u20b9\u00b4\u00b0\u00a3\u20ac\\\u00d7\u2122\u221a\u00b2\u2014'","18bfd72b":"train = pd.read_csv(\"..\/input\/spooky-author-identification\/train.zip\")\ntest = pd.read_csv(\"..\/input\/spooky-author-identification\/test.zip\")\ntestdex = test.id\nsubmission = pd.read_csv(\"..\/input\/spooky-author-identification\/sample_submission.zip\")\nsub_cols = submission.columns\n\nxtrain = train[TEXTCOL].astype(str)\nxtest = test[TEXTCOL].astype(str)\n\nlabel_mapper = {name: i for i,name in enumerate(set(train[TARGETCOL].values))}\nnum_label = np.vectorize(label_mapper.get)(train[TARGETCOL].values)\ny_train = to_categorical(num_label)\n\ntokenizer = text.Tokenizer(\n    filters=CHARS_TO_REMOVE,\n    lower=False,\n    num_words=VOCABLEN)\ntokenizer.fit_on_texts(list(xtrain) + list(xtest))\n\nxtrain = tokenizer.texts_to_sequences(xtrain)\nxtest = tokenizer.texts_to_sequences(xtest)\n\nxtrain = sequence.pad_sequences(xtrain, maxlen=MAXLEN)\nxtest = sequence.pad_sequences(xtest, maxlen=MAXLEN)\n\n\nprint(\"X Shape: {}\".format(xtrain.shape))\nprint(\"y Shape: {}\".format(xtrain.shape))\n\nX_train, X_val, y_train, y_val = train_test_split(\n    xtrain, y_train, test_size=0.33, random_state=42)\n\nprint(\"X_train Shape: {}\".format(X_train.shape))\nprint(\"y_train Shape: {}\".format(y_train.shape))\n\n\ndel train, test, xtrain","87b0e51e":"embed_dim = 32  # Embedding size for each token\nnum_heads = 4  # Number of attention heads\nff_dim = 32  # Hidden layer size in feed forward network inside transformer\n\ninputs = layers.Input(shape=(MAXLEN,))\nembedding_layer = TokenAndPositionEmbedding(MAXLEN, VOCABLEN, embed_dim)\nx = embedding_layer(inputs)\ntransformer_block = TransformerBlock(embed_dim, num_heads, ff_dim)\nx = transformer_block(x)\nx = layers.GlobalAveragePooling1D()(x)\nx = layers.Dropout(0.3)(x)\nx = layers.Dense(32, activation=\"relu\")(x)\nx = layers.Dropout(0.3)(x)\noutputs = layers.Dense(NCHANNEL, activation=\"softmax\")(x)\n\nmodel = keras.Model(inputs=inputs, outputs=outputs)","86c8b2fe":"\"\"\"\n## Train and Evaluate\n\"\"\"\n# checkpoint = callbacks.ModelCheckpoint('model.h5', monitor='val_loss', save_best_only=True)\nes = callbacks.EarlyStopping(monitor='val_loss', min_delta=0.0001,\n                             patience=4, verbose=1, mode='min', baseline=None,\n                             restore_best_weights=False)\n\n\nmodel.compile(Adam(lr=5e-5), \"categorical_crossentropy\", metrics=[\"accuracy\"])\nhistory = model.fit(\n    X_train, y_train, batch_size=BATCHSIZE, epochs=EPOCHS, validation_data=(X_val, y_val),\n    callbacks=[es]\n)","2b9375c3":"plot_metrics = ['loss']\n\nf, ax = plt.subplots(1,figsize = [7,4])\nfor p_i,metric in enumerate(plot_metrics):\n    ax.plot(history.history[metric], label='Train ' + metric)\n    ax.plot(history.history['val_' + metric], label='Val ' + metric)\n    ax.set_title(\"Loss Curve - {}\".format(metric))\n    ax.legend()\nplt.show()","b7605fea":"### Function to create confusion matrix ###\nimport itertools\nfrom sklearn.metrics import confusion_matrix\n\n### From http:\/\/scikit-learn.org\/stable\/auto_examples\/model_selection\/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py #\ndef plot_confusion_matrix(cm, classes,\n                          normalize=False,\n                          title='Confusion matrix',\n                          cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        #print(\"Normalized confusion matrix\")\n    #else:\n    #    print('Confusion matrix, without normalization')\n\n    #print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n\n\nval_pred = model.predict(X_val)\ncnf_matrix = confusion_matrix(np.argmax(y_val,axis=1), np.argmax(val_pred,axis=1))\nnp.set_printoptions(precision=2)\n\n# Plot non-normalized confusion matrix\nplt.figure(figsize=(4,4))\nplot_confusion_matrix(cnf_matrix, classes=['EAP', 'HPL', 'MWS'],\n                      title='Confusion matrix, without normalization')\nplt.show()","f831cd6e":"# model.load_weights('model.h5')\ntest_pred = model.predict(xtest)\ntest_pred.shape","55c65061":"submission = pd.DataFrame(test_pred, columns=label_mapper.keys())\nsubmission['id'] = testdex\n\nsubmission = submission[sub_cols]\nsubmission.to_csv('submission_transfomer_keras.csv', index=False)\nprint(submission.shape)","0888c329":"!head submission_transfomer_keras.csv","6b4b7fdd":"print(\"Notebook Runtime: %0.2f Minutes\"%((time.time() - notebookstart)\/60))","2b9faeb3":"# Spooky Authors - Keras Transformers\n\nhttps:\/\/github.com\/keras-team\/keras-io\/blob\/master\/examples\/nlp\/text_classification_with_transformer.py"}}