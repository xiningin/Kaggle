{"cell_type":{"847a0ae9":"code","bd92198f":"markdown","48971518":"markdown","f4ae0004":"markdown","2ad93f24":"markdown","87dfa06b":"markdown"},"source":{"847a0ae9":"import numpy as np\n\ndef calculate_psi(expected, actual, buckettype='bins', buckets=10, axis=0):\n    '''Calculate the PSI (population stability index) across all variables\n    Args:\n       expected: numpy matrix of original values\n       actual: numpy matrix of new values, same size as expected\n       buckettype: type of strategy for creating buckets, bins splits into even splits, quantiles splits into quantile buckets\n       buckets: number of quantiles to use in bucketing variables\n       axis: axis by which variables are defined, 0 for vertical, 1 for horizontal\n    Returns:\n       psi_values: ndarray of psi values for each variable\n    Author:\n       Matthew Burke\n       github.com\/mwburke\n       worksofchart.com\n    '''\n\n    def psi(expected_array, actual_array, buckets):\n        '''Calculate the PSI for a single variable\n        Args:\n           expected_array: numpy array of original values\n           actual_array: numpy array of new values, same size as expected\n           buckets: number of percentile ranges to bucket the values into\n        Returns:\n           psi_value: calculated PSI value\n        '''\n\n        def scale_range (input, min, max):\n            input += -(np.min(input))\n            input \/= np.max(input) \/ (max - min)\n            input += min\n            return input\n\n\n        breakpoints = np.arange(0, buckets + 1) \/ (buckets) * 100\n\n        if buckettype == 'bins':\n            breakpoints = scale_range(breakpoints, np.min(expected_array), np.max(expected_array))\n        elif buckettype == 'quantiles':\n            breakpoints = np.stack([np.percentile(expected_array, b) for b in breakpoints])\n\n\n\n        expected_percents = np.histogram(expected_array, breakpoints)[0] \/ len(expected_array)\n        actual_percents = np.histogram(actual_array, breakpoints)[0] \/ len(actual_array)\n\n        def sub_psi(e_perc, a_perc):\n            '''Calculate the actual PSI value from comparing the values.\n               Update the actual value to a very small number if equal to zero\n            '''\n            if a_perc == 0:\n                a_perc = 0.0001\n            if e_perc == 0:\n                e_perc = 0.0001\n\n            value = (e_perc - a_perc) * np.log(e_perc \/ a_perc)\n            return(value)\n\n        psi_value = np.sum(sub_psi(expected_percents[i], actual_percents[i]) for i in range(0, len(expected_percents)))\n\n        return(psi_value)\n\n    if len(expected.shape) == 1:\n        psi_values = np.empty(len(expected.shape))\n    else:\n        psi_values = np.empty(expected.shape[axis])\n\n    for i in range(0, len(psi_values)):\n        if len(psi_values) == 1:\n            psi_values = psi(expected, actual, buckets)\n        elif axis == 0:\n            psi_values[i] = psi(expected[:,i], actual[:,i], buckets)\n        elif axis == 1:\n            psi_values[i] = psi(expected[i,:], actual[i,:], buckets)\n\n    return(psi_values)","bd92198f":"## Use of Population Stability Index (PSI)\n\nThere are multiple uses of Population Stability Index (PSI). They are listed below -\n\nModel might be influenced by economic changes. Suppose you built a risk model during economic recession (year 2008) and you are using the same model to score datasets in year 2016. There is a high chance that various attributes of the model are changed drastically over last 8 years. It means it does not make sense to use this model anymore if features of the model are changed significantly.\nChange in product offerings due to internal policy changes. For example, one of your product are relaunched recently so attributes may behave differently as compared to attributes of your model.\nPSI can detect if any data integration or programming issues to run the scoring code.","48971518":"## How PSI is calculated?\nPSI = (% of records based on scoring variable in Scoring Sample (A) - % of records based on scoring variable in Training Sample (B)) * In(A\/ B)\nSteps\nSort scoring variable on descending order in scoring sample\nSplit the data into 10 or 20 groups (deciling)\nCalculate % of records in each group based on scoring sample\nCalculate % of records in each group based on training sample\nCalculate difference between Step 3 and Step 4\nTake Natural Log of (Step3 \/ Step4)\nMultiply Step5 and Step6","f4ae0004":"In simple words, Population Stability Index (PSI) compares the distribution of a scoring variable (predicted probability) in scoring data set to a training data set that was used to develop the model. The idea is to check \"How the current scoring is compared to the predicted probability from training data set\".","2ad93f24":"## Rules\nPSI < 0.1 - No change. You can continue using existing model.\nPSI >=0.1 but less than 0.2 - Slight change is required.\nPSI >=0.2 - Significant change is required. Ideally, you should not use this model any more.","87dfa06b":"# POPULATION STABILITY INDEX \n* This tutorial describes the meaning and use of Population Stability Index and Characteristic Analysis."}}