{"cell_type":{"ade28453":"code","a7ed48d0":"code","b6afb3e1":"code","8ae6177c":"code","d47d7a78":"code","5dfe2180":"code","0955b785":"code","0c863ecc":"code","7557914a":"code","1f569b4a":"code","a817de62":"code","ab43e5c2":"code","8a96b3b5":"code","31efc209":"code","af2c3423":"code","9b69e904":"code","94b9de19":"code","9c5cdc45":"code","8b4520fd":"code","b19d9089":"code","108ade84":"code","d967f9fb":"code","2e81a788":"markdown","b0efdb3d":"markdown","bcfa47c1":"markdown","e7dccf7e":"markdown","5af2e2c1":"markdown","9b735066":"markdown","77940c63":"markdown","82f213d2":"markdown","7998bc38":"markdown","afea0269":"markdown","81a36a91":"markdown","0817b8b8":"markdown","0f236eb2":"markdown","b04cd419":"markdown","8027d94e":"markdown","4b744620":"markdown"},"source":{"ade28453":"import numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nimport math\nimport time\nimport os","a7ed48d0":"# Read in the data\nroot_dir = '..\/input\/nfl-big-data-bowl-2022\/'\n\nli = []\n\ntracking_cols = ['gameId','playId','displayName','position','nflId','position','playDirection','x','y','team','frameId']\nfor filename in ['tracking2018.csv', 'tracking2019.csv', 'tracking2020.csv']:\n    df = pd.read_csv(root_dir + filename, index_col=None, header=0, usecols=tracking_cols)\n    li.append(df)\n\ntracking = pd.concat(li, axis=0, ignore_index=True)\n\nplay_cols = ['gameId','playId', 'possessionTeam', 'specialTeamsPlayType', 'specialTeamsResult']\nplays = pd.read_csv(root_dir + 'plays.csv', usecols=play_cols)\n\nprint(f\"Loaded in {len(plays)} plays and {len(tracking)} tracking records\")","b6afb3e1":"# combine gameid and playid to create a unique play id\ntracking['playUniqueId'] = tracking['gameId'].astype(str) + tracking['playId'].astype(str)\nplays['playUniqueId'] = plays['gameId'].astype(str) + plays['playId'].astype(str)\n\n# Rename all instances of OAK to LV\nplays.loc[plays['possessionTeam']=='OAK', 'possessionTeam'] = 'LV'\n\n#Fill in some gaps in the tracking data for the football\ntracking.loc[tracking['displayName']=='football', 'position'] = 'BLL'\ntracking.loc[tracking['displayName']=='football', 'nflId'] = 99999.9","8ae6177c":"# Filter for the punt data\npunt_plays = plays.loc[plays['specialTeamsPlayType']=='Punt']\npunt_tracking = tracking.loc[tracking['playUniqueId'].isin(punt_plays.playUniqueId.unique())]\nprint(f\"There are {len(punt_plays)} punt plays and {len(punt_tracking)} punt tracking records\")\n# Tidy up data that is no longer needed\ndel plays\ndel tracking","d47d7a78":"# Chart the punt outcomes\nmpl.rc('font', size=15) \nplt.figure(figsize=(20, 6))\nplt.xticks(rotation=90)\nax = sns.histplot(data=punt_plays.specialTeamsResult)\nax.set_title('Punt Outcomes')","5dfe2180":"# Create the plot data\nframe_count = pd.DataFrame(punt_tracking.groupby('frameId').playUniqueId.nunique()).reset_index()# columns=['Frame No.', 'Count'])\nframe_count.columns = ['Frame No.', 'Count']\n# Create the chart\nmpl.rc('font', size=15) \nplt.figure(figsize=(20, 6))\nplt.xticks(rotation=90)\nax = sns.lineplot(x='Frame No.', y='Count', data=frame_count)\nax.set_title('Count of Plays with No. of Frames')\nax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(10))\nax.set(xlim=(0, None))","0955b785":"max_number_of_frames = 140\n\n# RENAME ANY K VALUES TO P IN POSITION\ndef convert_k_to_p(df):\n    df.loc[df['position']=='K', 'position'] = 'P'\n    return df\n\n# NORMALIZE THE COORDINATES SO ALL PLAYS PLAYED IN SAME DIRECTION\ndef flip_left_to_right(df):\n    df.loc[df['playDirection']=='left', 'x'] = 120-df.loc[df['playDirection']=='left', 'x']\n    df.loc[df['playDirection']=='left', 'y'] = 53.3-df.loc[df['playDirection']=='left', 'y']\n    df.loc[:, 'playDirection'] = 'right'\n    return df\n\ndef scale_coordinates(df):\n    df.loc[:,'x'] = (df.loc[:,'x'] - 60)\/60\n    df.loc[:,'y'] = (df.loc[:,'y'] - 26.65)\/26.65\n    return df\n\n# Organize the players so that they appear in order ball, punter, punting team, receiving team with punting teama dn receiving team ordered by distance from ball\ndef sort_by_distance_from_ball(players):\n    # Create an array to hold the sorted value\n    sorted_ids = []\n    # Get the ball\n    ball = players.loc[players['position']=='BLL'].iloc[0]\n    punter = players.loc[players['position']=='P'].iloc[0]\n    # Calculate every players distance from the ball\n    players.loc[:, 'distanceFromBall'] = players.apply(lambda x: abs(math.dist([ball['x'],ball['y']],[x['x'],x['y']])), axis=1)\n    # Override the distance of the ball itself and the punter so that they appear in indexes 0 and 1\n    players.loc[players['position']=='BLL', 'distanceFromBall'] = -99.9\n    players.loc[players['position']=='P', 'distanceFromBall'] = -49.9\n    # Add 100 yards to the receiving team so that they are sorted lower than the kicking team and appear in the last 11 indexes\n    players.loc[~players['team'].isin(['football',punter['team']]), 'distanceFromBall'] += 100.0 \n    # Sort the players\n    players = players.sort_values(by='distanceFromBall', ascending=True)\n    # Return the array\n    return players\n\ndef create_input_data(play_tracking):\n    # Get a consistent position value for the punter (sometimes position is marked as K for kicker)\n    play_tracking = convert_k_to_p(play_tracking)\n    # Transform all plays so they are in same direction\n    play_tracking = flip_left_to_right(play_tracking)\n    # Scale the coordinates to a range of -1 to 1\n    play_tracking = scale_coordinates(play_tracking)\n    # Sort the payers so there is some consistency to their order\n    player_sorted_ids = sort_by_distance_from_ball(play_tracking.loc[play_tracking['frameId']==1])\n    player_sorted_ids = player_sorted_ids[['nflId','distanceFromBall']].copy()\n    # Add the sorting value to the data and sort by frame then distance\n    play_tracking = pd.merge(play_tracking, player_sorted_ids, how='left', on='nflId')\n    play_tracking = play_tracking.sort_values(by=['frameId','distanceFromBall'], ascending=True)\n    # Create an array to hold the values\n    input_array = []\n    # Loop through each frame to add the data to the array\n    for frame_no in range(1, (max_number_of_frames+1)):\n        # Identify if there is data for that frame\n        if frame_no <= play_tracking.frameId.max():\n            # Append the x,y data to the input array\n            input_array.append(play_tracking.loc[play_tracking['frameId']==frame_no, ['x','y']].values)\n        else:\n            # Create an array of [23, 2] filed with zero\n            input_array.append(np.zeros((23, 2)))\n    return input_array","0c863ecc":"# Create the tensor for the training data. This is a sizeable operation so the tensor is saved and on subsequent runs reloaded instead of running again.\nexisting_examples_path = \"..\/input\/nfl-gan-data\/training_examples.npy\"\n\nif not os.path.exists(existing_examples_path):\n    training_examples = []\n    for unique_play in punt_plays.playUniqueId.unique():\n        unique_play_tracking = punt_tracking.loc[punt_tracking['playUniqueId']==unique_play]\n        # Build the data\n        example = create_input_data(unique_play_tracking)\n        training_examples.append(example)\n    training_examples = np.array(training_examples)\n    # Save the examples so future runs not needed\n    np.save('..\/input\/nfl-gan-data\/training_examples.npy', training_examples)\n    \nloaded_training_examples = np.load('..\/input\/nfl-gan-data\/training_examples.npy')\n\n# Keep a play to use as an example later\nexample_punt_play = loaded_training_examples[-1]","7557914a":"BUFFER_SIZE = 12000\nBATCH_SIZE = 128\n\nos.environ['KMP_WARNINGS'] = '0'\n\ncross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=True)\n\ntrain_dataset = tf.data.Dataset.from_tensor_slices(loaded_training_examples).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)","1f569b4a":"def generator_model():\n    model = tf.keras.Sequential()\n    model.add(layers.Dense(35*6*8, use_bias=False, input_shape=(60,)))\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Reshape((35, 6, 8)))\n    assert model.output_shape == (None, 35, 6, 8)\n\n    model.add(layers.Conv2DTranspose(8, (5, 5), strides=(1, 1), padding='same', use_bias=False, data_format='channels_last'))\n    assert model.output_shape == (None, 35, 6, 8)\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(8, (5, 5), strides=(1, 1), padding='same', use_bias=False, data_format='channels_last'))\n    assert model.output_shape == (None, 35, 6, 8)\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(4, (5, 5), strides=(2, 2), padding='same', use_bias=False, data_format='channels_last'))\n    assert model.output_shape == (None, 70, 12, 4)\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(4, (5, 5), strides=(1, 1), padding='same', use_bias=False, data_format='channels_last'))\n    assert model.output_shape == (None, 70, 12, 4)\n    model.add(layers.BatchNormalization())\n    model.add(layers.LeakyReLU())\n\n    model.add(layers.Conv2DTranspose(2, (5, 5), strides=(2, 2), padding='same', use_bias=False, activation='tanh', data_format='channels_last'))\n    assert model.output_shape == (None, 140, 24, 2)\n\n    model.add(layers.Cropping2D(cropping=((0,0), (0,1))))\n    assert model.output_shape == (None, 140, 23, 2)\n\n    return model\n\ndef generator_loss(fake_output):\n    return cross_entropy(tf.ones_like(fake_output), fake_output)","a817de62":"def make_discriminator_model():\n    model = tf.keras.Sequential()\n    model.add(layers.Conv2D(64, (5, 5), strides=(2, 2), padding='same',\n                                     input_shape=[140, 23, 2]))\n    model.add(layers.LeakyReLU())\n    model.add(layers.Dropout(0.3))\n\n    model.add(layers.Conv2D(128, (5, 5), strides=(1, 1), padding='same'))\n    model.add(layers.LeakyReLU())\n    model.add(layers.Dropout(0.3))\n\n    model.add(layers.Conv2D(128, (5, 5), strides=(1, 1), padding='same'))\n    model.add(layers.LeakyReLU())\n    model.add(layers.Dropout(0.3))\n\n    model.add(layers.Conv2D(128, (5, 5), strides=(2, 2), padding='same'))\n    model.add(layers.LeakyReLU())\n    model.add(layers.Dropout(0.3))\n\n    model.add(layers.Flatten())\n    model.add(layers.Dense(1))\n\n    return model\n\ndef discriminator_loss(real_output, fake_output):\n    real_loss = cross_entropy(tf.ones_like(real_output), real_output)\n    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)\n    total_loss = real_loss + fake_loss\n    return total_loss","ab43e5c2":"# Training setup\ngenerator = generator_model()\ndiscriminator = make_discriminator_model()\n\n# Set the optimizers\ngenerator_optimizer = tf.keras.optimizers.Adam(learning_rate=2e-4, beta_1=0.5)\ndiscriminator_optimizer = tf.keras.optimizers.Adam(learning_rate=2e-4, beta_1=0.5)\n\n# Checkpoints code\ncheckpoint_dir = '..\/input\/nfl-gan-data\/checkpoints'\ncheckpoint_prefix = os.path.join(checkpoint_dir, \"ckpt\")\ncheckpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer,\n                                 discriminator_optimizer=discriminator_optimizer,\n                                 generator=generator,\n                                 discriminator=discriminator)\n\n# Training loop\nEPOCHS = 500\nnoise_dim = 60\nnum_examples_to_generate = 256\n\nseed = tf.random.normal([num_examples_to_generate, noise_dim])","8a96b3b5":"@tf.function\ndef train_step(images):\n    noise = tf.random.normal([BATCH_SIZE, noise_dim])\n\n    with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:\n      generated_images = generator(noise, training=True)\n      real_output = discriminator(images, training=True)\n      fake_output = discriminator(generated_images, training=True)\n\n      gen_loss = generator_loss(fake_output)\n      disc_loss = discriminator_loss(real_output, fake_output)\n\n    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)\n    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)\n\n    generator_optimizer.apply_gradients(zip(gradients_of_generator, generator.trainable_variables))\n    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))\n\ndef train(dataset, epochs):\n\n  checkpoint.restore(tf.train.latest_checkpoint(checkpoint_dir))\n  for epoch in range(epochs):\n    start = time.time()\n\n    for image_batch in dataset:\n      train_step(image_batch)\n\n    # Save generated plays every 100 epochs\n    if epoch % 100 == 0:\n        generate_and_save_plays(generator,\n                                 epoch + 1,\n                                 seed)\n\n    # Save the model every 15 epochs\n    if (epoch + 1) % 15 == 0:\n      checkpoint.save(file_prefix = checkpoint_prefix)\n\n    print ('Time for epoch {} is {} sec'.format(epoch + 1, time.time()-start))\n\n  # Generate after the final epoch\n  generate_and_save_plays(generator,\n                           epochs,\n                           seed)\n\ngenerated_plays_during_training = []\n\ndef generate_and_save_plays(model, epoch, test_input):\n  predictions = model(test_input, training=False)\n  if len(predictions) > 0:\n      generated_plays_during_training.append(predictions)","31efc209":"# Train the network, only run number of epochs from latest checkpoint\nlast_ckpt = tf.train.latest_checkpoint(\n    checkpoint_dir, latest_filename=None\n)\nlast_ckpt = int(last_ckpt.split(\"-\")[-1])\nnet_epochs = EPOCHS - (last_ckpt*15) if last_ckpt < (EPOCHS\/15) else 0\n    \ntrain(train_dataset, net_epochs)","af2c3423":"# Save the generated examples\nif len(generated_plays_during_training) > 1:\n    generated_examples = np.array(generated_plays_during_training)\n\n    # Check if previous examples created and add the new ones to it.\n    generated_examples_path = \"..\/input\/nfl-gan-data\/generated_examples.npy\"\n\n    if os.path.exists(generated_examples_path):\n        # Add the examples generated this run to ones generated previously\n        all_loaded_generated_examples = np.load('..\/input\/nfl-gan-data\/generated_examples.npy')\n        all_examples = np.concatenate((all_loaded_generated_examples, generated_examples), axis = 0)\n        np.save('..\/input\/nfl-gan-data\/generated_examples', all_examples)\n    else:\n        np.save('..\/input\/nfl-gan-data\/generated_examples', generated_examples)\n        all_examples = generated_examples","9b69e904":"# THIS CODE CREATES THE FOOTBALL PITCH\n\nimport matplotlib.patches as patches\nfrom matplotlib.patches import Arc\nfrom matplotlib import pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Change size of the figure\nplt.rcParams['figure.figsize'] = [12, 8]\ndef drawPitch(width, height, color=\"w\"):\n    fig = plt.figure()\n    ax = plt.axes(xlim=(-10, width + 30), ylim=(-15, height + 5))\n    plt.axis('off')\n\n    # Grass around pitch\n    rect = patches.Rectangle((-10, -5), width + 40, height + 10, linewidth=1, facecolor='#3f995b', capstyle='round')\n    ax.add_patch(rect)\n    ###################\n\n    # Pitch boundaries\n    rect = plt.Rectangle((0, 0), width + 20, height, ec=color, fc=\"None\", lw=2)\n    ax.add_patch(rect)\n    ###################\n\n    # vertical lines - every 5 yards\n    for i in range(21):\n        plt.plot([10 + 5 * i, 10 + 5 * i], [0, height], c=\"w\", lw=2)\n    ###################\n        \n    # distance markers - every 10 yards\n    for yards in range(10, width, 10):\n        yards_text = yards if yards <= width \/ 2 else width - yards\n        # top markers\n        plt.text(10 + yards - 2, height - 7.5, yards_text, size=15, c=\"w\", weight=\"bold\")\n        # botoom markers\n        plt.text(10 + yards - 2, 7.5, yards_text, size=15, c=\"w\", weight=\"bold\", rotation=180)\n    ###################\n\n    # yards markers - every yard\n    # bottom markers\n    for x in range(20):\n        for j in range(1, 5):\n            plt.plot([10 + x * 5 + j, 10 + x * 5 + j], [1, 3], color=\"w\", lw=2)\n\n    # top markers\n    for x in range(20):\n        for j in range(1, 5):\n            plt.plot([10 + x * 5 + j, 10 + x * 5 + j], [height - 1, height - 3], color=\"w\", lw=2)\n\n    # middle bottom markers\n    y = (height - 18.5) \/ 2\n    for x in range(20):\n        for j in range(1, 5):\n            plt.plot([10 + x * 5 + j, 10 + x * 5 + j], [y, y + 2], color=\"w\", lw=2)\n\n    # middle top markers\n    for x in range(20):\n        for j in range(1, 5):\n            plt.plot([10 + x * 5 + j, 10 + x * 5 + j], [height - y, height - y - 2], color=\"w\", lw=2)\n    ###################\n\n    # draw home end zone\n    plt.text(2.5, (height - 15) \/ 2, \"HOME\", size=30, c=\"w\", weight=\"bold\", rotation=90)\n    rect = plt.Rectangle((0, 0), 10, height, ec=color, fc=\"#0064dc\", lw=2)\n    ax.add_patch(rect)\n\n    # draw away end zone    \n    plt.text(111, (height - 15) \/ 2, \"AWAY\", size=30, c=\"w\", weight=\"bold\", rotation=-90)\n    rect = plt.Rectangle((width + 10, 0), 10, height, ec=color, fc=\"#c80014\", lw=2)\n    ax.add_patch(rect)\n    ###################\n    \n    # draw extra spot point\n    # left\n    y = (height - 3) \/ 2\n    plt.plot([10 + 2, 10 + 2], [y, y + 3], c=\"w\", lw=2)\n    \n    # right\n    plt.plot([width + 10 - 2, width + 10 - 2], [y, y + 3], c=\"w\", lw=2)\n    ###################\n    \n    # draw goalpost\n    goal_width = 6 # yards\n    y = (height - goal_width) \/ 2\n    # left\n    plt.plot([0, 0], [y, y + goal_width], \"-\", c=\"y\", lw=10, ms=20)\n    # right\n    plt.plot([width + 20, width + 20], [y, y + goal_width], \"-\", c=\"y\", lw=10, ms=20)\n    \n    return fig, ax","94b9de19":"%matplotlib ipympl\nfrom matplotlib import animation\nfrom IPython.display import HTML\ndef animate_generated_play(df):\n    fig, ax = drawPitch(100, 53.3)\n    play = df\n    team_left, = ax.plot([], [], 'o', markersize=20, markerfacecolor=\"r\", markeredgewidth=2, markeredgecolor=\"white\", zorder=7)\n    team_right, = ax.plot([], [], 'o', markersize=20, markerfacecolor=\"b\", markeredgewidth=2, markeredgecolor=\"white\", zorder=7)\n    ball, = ax.plot([], [], 'o', markersize=10, markerfacecolor=\"black\", markeredgewidth=2, markeredgecolor=\"white\", zorder=7)\n    drawings = [team_left, team_right, ball]\n\n    def init():\n        team_left.set_data([], [])\n        team_right.set_data([], [])\n        ball.set_data([], [])\n        return drawings\n    \n    # Re-scale the generated examples\n    def upscale_coordinates(coords):\n        x,y = coords\n        x = (x * 60) + 60\n        y = (y * 26.65) + 26.65\n        return [x, y]\n\n    def draw_teams(i):\n        X = []\n        Y = []\n        for coords in play[i][1:12]:\n            x, y = upscale_coordinates(coords)\n            X.append(x)\n            Y.append(y)\n        team_left.set_data(X, Y)\n        \n        X = []\n        Y = []\n        for coords in play[i][12:23]:\n            x, y = upscale_coordinates(coords)\n            X.append(x)\n            Y.append(y)\n        team_right.set_data(X, Y)\n\n    def animate(i):\n        draw_teams(i)\n        x, y = upscale_coordinates(play[i][0])\n        ball.set_data([x, y])\n        return drawings\n    \n    anim = animation.FuncAnimation(fig, animate, init_func=init,\n                                   frames=140, interval=100, blit=True)\n\n    return HTML(anim.to_html5_video())","9c5cdc45":"animate_generated_play(example_punt_play)","8b4520fd":"all_loaded_generated_examples = np.load('..\/input\/nfl-gan-data\/generated_examples.npy')","b19d9089":"animate_generated_play(all_loaded_generated_examples[0][0])","108ade84":"animate_generated_play(all_loaded_generated_examples[4][0])","d967f9fb":"predictions = generator(seed, training=False)\npredictions = np.array(predictions)\nanimate_generated_play(predictions[0])","2e81a788":"<h2>Introduction<\/h2>\n<p>\nA world class football coach may have a top secret playbook, mind blowing creativity and seemingly psychic intuition, skills which are learned through study, practice and experience. If these skills can be learned by a human, could they be learned by a machine?\n<br><br>\nThe subject of artificial intelligence undertaking jobs traditionally completed by humans is frequently discussed across a wide variety of platforms and industries. This notebook will not answer the question of whether a special teams coach can be replaced by an artificial intelligence, there is far more to being a special teams coach than what can be learned from this data. However, it will take a step on the road to answering that question by attempting to train a Generative Adversarial Network (GAN) to generate new and unique punt plays. If it can learn how 22 players and the ball line up and react to each others movements then perhaps, with further work, it could predict the optimum location of the field to aim a punt or the return route that will yield the most yards.\n<\/p>\n<br>\n<h2>Contents<\/h2>\n<p>\n    <ol>\n        <li><a href='#1'>Configuration and Data Load<\/a><\/li>\n        <li><a href='#2'>Data Setup<\/a><\/li>\n        <li><a href='#3'>Data Analysis<\/a><\/li>\n        <ul>\n            <li><a href='#3.1'>Punt Outcomes<\/a><\/li>\n            <li><a href='#3.2'>Number of Frames in a Punt Play<\/a><\/li>\n        <\/ul>\n        <li><a href='#4'>Training Data Construction<\/a><\/li>\n        <li><a href='#5'>Creating the Generative Adversarial Network<\/a><\/li>\n        <li><a href='#6'>Animation Setup<\/a><\/li>\n        <li><a href='#7'>Results<\/a><\/li>\n        <ul>\n            <li><a href='#7.1'>Real Punt Example<\/a><\/li>\n            <li><a href='#7.2'>Early Training Example<\/a><\/li>\n            <li><a href='#7.3'>Mid-Training Example<\/a><\/li>\n            <li><a href='#7.4'>Final Example<\/a><\/li>\n        <\/ul>\n        <li><a href='#8'>Conclusion<\/a><\/li>\n    <\/ol>\n<\/p>","b0efdb3d":"<a id=\"3\"><\/a>\n<h2>3. Data Analysis<\/h2>","bcfa47c1":"<a id=\"7.3\"><\/a>\n<h3>Mid-Training Example<\/h3>\n<p>By mid-training the output is starting to look more convincing. The initial position of the players and the ball look realistic, which covers point 1 of our checklist. However, the ball does not appear to travel from the snapper to the punter, instead it hangs around the line of scrimmage for a few frames before making it's way down field. There is movement of all the players towards the ball once it makes it's way down field though. Overall 2 out of 3 elements are already present midway through training.<\/p>","e7dccf7e":"<a id=\"6\"><\/a>\n<h2>6. Animation Setup<\/h2>\n\n<p>The animation of a play is adapted from a post created by JARON_MICHAL. See the post here - https:\/\/www.kaggle.com\/jaronmichal\/tracking-data-visualization <\/p>","5af2e2c1":"<a id=\"7.4\"><\/a>\n<h3>Final Example<\/h3>\n<p>In the final output all initial player positions looks accurate, the ball travels in a realistic manner, and the players move as expected during a punt play.<\/p>","9b735066":"<a id=\"1\"><\/a>\n<h2>1. Configuration and Data Load<\/h2>\n<p>Importing the libraries needed in the notebook and loading the raw data.<\/p>","77940c63":"<a id=\"4\"><\/a>\n<h2>4. Training Data Construction<\/h2>\n<p>\nTo help the network learn I organise the data to make it as consistent as possible:\n<ul>\n<li>All plays are normalized so that the action occurs left to right<\/li>\n<li>A small number of instances where the player kicking the punt has a position of 'K' (kicker) are amended so the position is 'P' (punter)<\/li>\n<li>Field co-ordinates are scaled to values between -1 and 1<\/li>\n<\/ul>\nThe distance of each player from the ball is calculated in an attempt to ensure that similar field positions occur in similar positions in the training data. To assist with this the value for the ball and punter are overridden to negative values. The receiving team players values are increased to ensure they are greater than the kicking team. Each frame is then sorted by distance from the ball which results in an order of:\n<ol>\n<li>Ball<\/li>\n<li>Punter<\/li>\n<li>Players from kicking team sorted by distance from ball<\/li>\n<li>Players from receiving team sorted by distance from ball<\/li>\n<\/ol>\nTo maintain a consistent size the number of frames to include is set at 140 which covers the entire play for 90% of the data (see abaove analysis). Any plays which are shorter than 140 frames are padded with zeroes, any plays which are longer are truncated so data beyond 140 plays is lost.\n<br><br>\nNo filtering is done on the punt outcomes, all punt types are included in the training data.\n<\/p>","82f213d2":"<a id=\"3.1\"><\/a>\n<h3>Punt Outcomes<\/h3>\n<p>\nThe 8 different punt outcomes that can be split into 2 groups, ones where the ball was successfully punted and made it's way down field, and ones where the ball was not successfully punted. The outcomes in the first group, successful punts, are all individually more numerous than any of the categories in the second group, unsuccessful punts.\n<br><br>\nSuccessful Punts (in order of most numerous):\n<ul>\n<li>Return - the ball is caught by an opposing team player who then runs with the ball upfield to try and gain as many yards as possible before they are tackled or reach the opposing team end zone.<\/li>\n<li>Fair Catch - the opposing player signals their intention not to advance the ball and in return is protected from tackles by opposing players.<\/li>\n<li>Downed - the kicking team are the first to possess the ball after the punt. This is technically a spot foul where the ball was possessed, although a flag is generally not thrown. The receiving team start their drive from the yard line where the ball was first touched by a kicking team member.<\/li>\n<li>Out of Bounds - the punt goes out of bounds before it is touched by a player. The receiving team start their drive from the yard line where the ball went out of bounds.<\/li>\n<li>Touchback - the punt is dead within or beyond the receiving teams end zone. This can occur either by the punt travelling untouched through the end zone or by being caught by a receiving team player in the end zone who then takes a knee to end the play. The receiving team start their drive from the 25 yard line in this scenario.<\/li>\n<li>Muffed - the ball strikes a player of the receiving team and goes loose but they did not possess the ball (if they possess the ball and then drop it it is a fumble). The ball can then be possessed by the kicking team again and, although they cannot advance it from the point they possess it, they will keep posession and a new set of downs from the yard line in which they gained possession.<\/li>\n<\/ul>\n<br><br>\nThe unsuccessful punt categories are:\n<ul>\n<li>Non-Special Teams Results - includes scenarios where a punt formation was used to mask a pass or a run.<\/li>\n<li>Blocked Punt - an opposing team player blocked the punt as it was being kicked.<\/li>\n<\/ul>\n<br><br>\nBased on the frequency of these outcomes an artificially generated punt should be more likely to show a returned punt than any other type of punt.\n<\/p>","7998bc38":"<a id=\"5\"><\/a>\n<h2>5. Creating the Generative Adversarial Network<\/h2>\n<p>\nA generator is created, which feeds random data through a network to create a punt play. A discriminator is created, which determines whether a punt play is real or fake from a mix of examples containing generated and real punt plays. The output is then used to tune both networks so that the generator becomes better at generating convincing punt plays and the discriminator becomes better at detecting fake plays.\n<\/p>","afea0269":"<a id=\"8\"><\/a>\n<h2>8. Conclusion<\/h2>\n<p>\nThe aim of this notebook was to find out if a GAN could be trained to generate a realistic looking punt play. I believe this was achieved as output from the final model showed realistic starting positions and expected movements of both the players and the ball.\n<br><br>\nThe practical applications for this work in it's current state are limited. A coach could generate and watch plays in the hope of seeing a new and unique formation or it could be used as a training tool to give players exposure to more punt plays in the hope they will obtain a greater intuition for how they play out.\n<br><br>\nThis model was a proof of concept but, if the model was developed further, it could provide greater practical application. For example, if the starting position of the kicking team players were used as an input, the model could generate numerous examples from which monte carlo simulations could help inform which is the optimal running lane that will provide the punt returner with the greatest chance of the most yards.\n<br><br>\nThanks for reading my analysis.\n<\/p>","81a36a91":"<h1>Can an Artificial Intelligence Coach Special Teams?<\/h1>","0817b8b8":"<a id=\"3.2\"><\/a>\n<h3>Number of Frames in a Punt Play<\/h3>\n<p>\nThe length of a punt play can vary for example, a kick out of bounds would be much shorter than a zig-zagging return run. The length of a play is measured in the number of frames it occupies.\n<br><br>\nMost plays (5,981) have at least 57 frames, at this point a slow decline in the number of plays still happening starts to happen. A steep decline occurs between 87 frames, where the number of plays drops below 5,000, and 92 frames where the number of plays drops below 4,000. From here there is a more gradual decline with the below 3,000 occuring at 105 frames, below 2,000 at 119 frames and below 1,000 at 132 frames. At 140 frames 90% of the plays have finished leaving a long tail that continues out to 272 frames.\n<\/p>","0f236eb2":"![BDB_Logo.jpg](attachment:676fb85f-58eb-4f6f-af5f-8e3486dff594.jpg)","b04cd419":"<a id=\"2\"><\/a>\n<h2>2. Data Setup<\/h2>\n<h3>Global Data Fixes<\/h3>\n<p>\nCreate a unique identifier by combining the playId, which is only unique within a game, and the gameId which is unique globally. This gives each play a global unique identifier.\n<br><br>\nDuring the period covered by the data the team known as the Raiders re-located from Oakland to Las Vegas. The team abbreviation used for the Raiders also changed from OAK to LV. To achieve consistency throughout the data all instances of the OAK team abbreviation will be renamed to LV.\n<br><br>\nThe tracking data for the ball does not hold a position or an NFL ID. To ensure the ball can be separated from players within the tracking data, these values will be populated with some arbitrary values.\n<\/p>\n<h3>Filter Data<\/h3>\n<p>\nSelect only the punt related data and clean up any irrelevant data.\n<\/p>","8027d94e":"<a id=\"7.2\"><\/a>\n<h3>Early Training Example<\/h3>\n<p>\nThe early output of the generator looks nothing like a real punt play. All players and the ball clustered around the centere of the pitch making seemingly random movements. None of the elements listed above that define a real punt play are present in this example.\n<\/p>","4b744620":"<a id=\"7\"><\/a>\n<h2>7. Results<\/h2>\n<p>\nIn this section I compare a real punt play with plays generated by the model during the early, mid and final stages of training.    \n<\/p>\n<br>\n<a id=\"7.1\"><\/a>\n<h3>Real Punt Play<\/h3>\n<p>\nA real play taken from the training data showing an actual punt play from the NFL. Things that define this as a real punt play include:\n    <ol>\n        <li>Initial positions of the players show:<ul> \n            <li>Members from either team lined up on opposing sides of the line of scrimmage.<\/li>\n        <li>The punter located behind the rest of team, this gives the punter enough space to kick the ball before the opposing team can get near him and block the punt.<\/li>\n        <li>The returner of the receiving team located much further down field than the rest of his team.<\/li><\/ul>\n        <li>The ball initially travelling backwards from the snapper to the punter before moving forwards after the punter kicks it.<\/li>\n        <li>The majority of players from both team moving towards the ball after it is caught\/lands.<\/li>\n    <\/ol>\nThese elements can be used to assess the realism of the punt plays created by the generator.\n<\/p>"}}