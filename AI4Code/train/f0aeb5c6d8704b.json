{"cell_type":{"18065625":"code","fcf1fb0b":"code","e4dfd769":"code","a77f15b0":"code","f934b11f":"code","710b1e9d":"code","358a2855":"code","eb727d09":"code","dcaa39fb":"code","03b4aa79":"code","96c87e84":"code","6308094b":"code","e67c6248":"code","56ab29cb":"markdown","1c690239":"markdown"},"source":{"18065625":"import os\nimport sys\n\nimport random\nimport math\nimport time\nimport pandas as pd\nimport numpy as np\n\nimport torch\nimport torch.utils.data as data\nimport torch.nn as nn\nimport torch.nn.init as init\nimport torch.nn.functional as F\nimport torch.optim as optim","fcf1fb0b":"torch.manual_seed(1234)\nnp.random.seed(1234)\nrandom.seed(1234)","e4dfd769":"os.mkdir('.\/utils')\nos.mkdir('.\/weights')\nsys.path.append('.\/utils')","a77f15b0":"from shutil import copyfile\ncopyfile(src = \"..\/input\/utils-train\/data_augumentation.py\", dst = \".\/utils\/data_augumentation.py\")\ncopyfile(src = \"..\/input\/utils-train\/dataloader.py\", dst = \".\/utils\/dataloader.py\")\ncopyfile(src = \"..\/input\/utils-train\/pspnet.py\", dst = \".\/utils\/pspnet.py\")","f934b11f":"from dataloader import make_datapath_list, DataTransform, VOCDataset\n\nrootpath = \"..\/input\/sartorius-cell-instance-segmentation\/\"\ntrain_img_list, train_anno_list, val_img_list, val_anno_list = make_datapath_list(\n    rootpath=rootpath)\n\ncolor_mean = (1.0, 1.0, 1.0)\ncolor_std = (1.0, 1.0, 1.0)\n\ntrain_dataset = VOCDataset(train_img_list, train_anno_list, phase=\"train\", transform=DataTransform(\n    input_size=520, color_mean=color_mean, color_std=color_std))\n\nval_dataset = VOCDataset(val_img_list, val_anno_list, phase=\"val\", transform=DataTransform(\n    input_size=520, color_mean=color_mean, color_std=color_std))\n\nbatch_size = 8\n\ntrain_dataloader = data.DataLoader(\n    train_dataset, batch_size=batch_size, shuffle=True)\n\nval_dataloader = data.DataLoader(\n    val_dataset, batch_size=batch_size, shuffle=False)\n\ndataloaders_dict = {\"train\": train_dataloader, \"val\": val_dataloader}","710b1e9d":"print(val_dataset.__getitem__(0)[0].shape)\nprint(val_dataset.__getitem__(0)[1].shape)\nprint(val_dataset.__getitem__(0))","358a2855":"from utils.pspnet import PSPNet\n\nnet = PSPNet(n_classes=150)\n\nn_classes = 1\nnet.decode_feature.classification = nn.Conv2d(\n    in_channels=512, out_channels=n_classes, kernel_size=1, stride=1, padding=0)\n\nnet.aux.classification = nn.Conv2d(\n    in_channels=256, out_channels=n_classes, kernel_size=1, stride=1, padding=0)\n\ndef weights_init(m):\n    if isinstance(m, nn.Conv2d):\n        nn.init.xavier_normal_(m.weight.data)\n        if m.bias is not None:\n            nn.init.constant_(m.bias, 0.0)\n\nnet.decode_feature.classification.apply(weights_init)\nnet.aux.classification.apply(weights_init)","eb727d09":"net","dcaa39fb":"from sklearn.metrics import log_loss","03b4aa79":"class PSPLoss(nn.Module):\n\n    def __init__(self, aux_weight=0.4):\n        super(PSPLoss, self).__init__()\n        self.aux_weight = aux_weight\n\n    def forward(self, outputs, targets):\n        \n        loss = F.binary_cross_entropy_with_logits(torch.reshape(outputs[0], ([-1, 520, 520])), targets.to(torch.float32))      \n        loss_aux = F.binary_cross_entropy_with_logits(torch.reshape(outputs[1], ([-1, 520, 520])), targets.to(torch.float32)) \n\n        return loss+self.aux_weight*loss_aux\n\ncriterion = PSPLoss(aux_weight=0.4)","96c87e84":"optimizer = optim.SGD([\n    {'params': net.feature_conv.parameters(), 'lr': 1e-3},\n    {'params': net.feature_res_1.parameters(), 'lr': 1e-3},\n    {'params': net.feature_res_2.parameters(), 'lr': 1e-3},\n    {'params': net.feature_dilated_res_1.parameters(), 'lr': 1e-3},\n    {'params': net.feature_dilated_res_2.parameters(), 'lr': 1e-3},\n    {'params': net.pyramid_pooling.parameters(), 'lr': 1e-3},\n    {'params': net.decode_feature.parameters(), 'lr': 1e-2},\n    {'params': net.aux.parameters(), 'lr': 1e-2},\n], momentum=0.9, weight_decay=0.0001)\n\ndef lambda_epoch(epoch):\n    max_epoch = 100\n    return math.pow((1-epoch\/max_epoch), 0.9)\n\nscheduler = optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda_epoch)","6308094b":"def train_model(net, dataloaders_dict, criterion, scheduler, optimizer, num_epochs):\n\n    device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\n    net.to(device)\n\n    torch.backends.cudnn.benchmark = True\n\n    num_train_imgs = len(dataloaders_dict[\"train\"].dataset)\n    num_val_imgs = len(dataloaders_dict[\"val\"].dataset)\n    batch_size = dataloaders_dict[\"train\"].batch_size\n\n    iteration = 1\n    logs = []\n\n    batch_multiplier = 3\n\n    for epoch in range(num_epochs):\n\n        t_epoch_start = time.time()\n        t_iter_start = time.time()\n        epoch_train_loss = 0.0 \n        epoch_val_loss = 0.0 \n\n        print('-------------')\n        print('Epoch {}\/{}'.format(epoch+1, num_epochs))\n        print('-------------')\n\n        for phase in ['train', 'val']:\n            if phase == 'train':\n                net.train()  \n                scheduler.step()\n                optimizer.zero_grad()\n                print('\uff08train\uff09')\n\n            else:\n                if((epoch+1) % 5 == 0):\n                    net.eval() \n                    print('-------------')\n                    print('\uff08val\uff09')\n                else:\n                    continue\n\n            count = 0 \n            for imges, anno_class_imges in dataloaders_dict[phase]:\n                if imges.size()[0] == 1:\n                    continue\n\n                imges = imges.to(device)\n                anno_class_imges = anno_class_imges.to(device)\n\n                if (phase == 'train') and (count == 0):\n                    optimizer.step()\n                    optimizer.zero_grad()\n                    count = batch_multiplier\n\n                with torch.set_grad_enabled(phase == 'train'):\n                    outputs = net(imges)\n                    loss = criterion(\n                        outputs, anno_class_imges.long()) \/ batch_multiplier\n\n                    if phase == 'train':\n                        loss.backward()\n                        count -= 1 \n\n                        if (iteration % 10 == 0):\n                            t_iter_finish = time.time()\n                            duration = t_iter_finish - t_iter_start\n                            print('iterations {} || Loss: {:.4f} || 10iter: {:.4f} sec.'.format(\n                                iteration, loss.item()\/batch_size*batch_multiplier, duration))\n                            t_iter_start = time.time()\n\n                        epoch_train_loss += loss.item() * batch_multiplier\n                        iteration += 1\n\n                    else:\n                        epoch_val_loss += loss.item() * batch_multiplier\n\n        t_epoch_finish = time.time()\n        print('-------------')\n        print('epoch {} || Epoch_TRAIN_Loss:{:.4f} ||Epoch_VAL_Loss:{:.4f}'.format(\n            epoch+1, epoch_train_loss\/num_train_imgs, epoch_val_loss\/num_val_imgs))\n        print('timer:  {:.4f} sec.'.format(t_epoch_finish - t_epoch_start))\n        t_epoch_start = time.time()\n\n        log_epoch = {'epoch': epoch+1, 'train_loss': epoch_train_loss \/\n                     num_train_imgs, 'val_loss': epoch_val_loss\/num_val_imgs}\n        logs.append(log_epoch)\n        df = pd.DataFrame(logs)\n        df.to_csv(\"log_output.csv\")\n\n    torch.save(net.state_dict(), 'weights\/pspnet50_' +\n               str(epoch+1) + '.pth')","e67c6248":"num_epochs = 40\ntrain_model(net, dataloaders_dict, criterion, scheduler, optimizer, num_epochs=num_epochs)","56ab29cb":"# Since the evaluation method for this competition is \"instance segmentation\", this notebook **cannot** be used directly for submission.\n \nPlease use this notebook as a reference for semantic segmentation.","1c690239":"The codes in this notebook refer to https:\/\/github.com\/YutaroOgawa\/pytorch_advanced\/tree\/master\/3_semantic_segmentation.\n\n\nCopyright (c) 2019 Yutaro Ogawa\n\nReleased under the MIT license\nhttps:\/\/github.com\/YutaroOgawa\/pytorch_advanced\/blob\/master\/LICENSE"}}