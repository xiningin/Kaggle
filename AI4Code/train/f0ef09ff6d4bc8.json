{"cell_type":{"5e1ddbc7":"code","5811c74c":"code","692bcf6e":"code","da3f35bf":"code","e0d922ef":"code","8f4eb3e2":"code","4f9b9a76":"code","3fbddc04":"code","ebe9a67f":"code","f28f4bbd":"markdown","da27998e":"markdown","a3828c22":"markdown","c1c4ee0f":"markdown","19d799e3":"markdown","fd176b73":"markdown"},"source":{"5e1ddbc7":"import numpy as np\nimport pandas as pd\nimport math\nimport sklearn\nimport sklearn.preprocessing\nimport datetime\nimport os\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n# split data in 80%\/10%\/10% train\/validation\/test sets\nvalid_set_size_percentage = 10 \ntest_set_size_percentage = 10 \n","5811c74c":"df = pd.read_parquet('\/kaggle\/input\/binance-full-history\/ETH-BTC.parquet')\n\ndf.drop(['volume', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume'],1,inplace=True)\ndf.info()\ndf.head()\n","692bcf6e":"df.describe()","da3f35bf":"plt.figure(figsize=(15, 5));\nplt.plot(df.open.values, color='red', label='open')\nplt.plot(df.close.values, color='green', label='close')\nplt.plot(df.low.values, color='blue', label='low')\nplt.plot(df.high.values, color='black', label='high')\nplt.title('stock price')\nplt.xlabel('time [days]')\nplt.ylabel('price')\nplt.legend(loc='best')\nplt.show()\n","e0d922ef":"# function for min-max normalization of stock\ndef normalize_data(df):\n    min_max_scaler = sklearn.preprocessing.MinMaxScaler()\n    opens = df.open.values.reshape(-1,1)\n    lows = df.low.values.reshape(-1,1)\n    highs = df.high.values.reshape(-1,1)\n    closes = df['close'].values.reshape(-1,1)\n    scale = min_max_scaler.fit(opens + highs + lows + closes)\n    df['open'] = scale.transform(opens)\n    df['high'] = scale.transform(highs)\n    df['low'] = scale.transform(lows)\n    df['close'] = scale.transform(closes)\n    return df\n\n# function to create train, validation, test data given stock data and sequence length\ndef load_data(stock, seq_len):\n    data_raw = stock.values # convert to numpy array\n    data = []\n    \n    # create all possible sequences of length seq_len\n    for index in range(len(data_raw) - seq_len): \n        data.append(data_raw[index: index + seq_len])\n    \n    data = np.array(data);\n    valid_set_size = int(np.round(valid_set_size_percentage\/100*data.shape[0]));  \n    test_set_size = int(np.round(test_set_size_percentage\/100*data.shape[0]));\n    train_set_size = data.shape[0] - (valid_set_size + test_set_size);\n    \n    x_train = data[:train_set_size,:-1,:]\n    y_train = data[:train_set_size,-1,:]\n    \n    x_valid = data[train_set_size:train_set_size+valid_set_size,:-1,:]\n    y_valid = data[train_set_size:train_set_size+valid_set_size,-1,:]\n    \n    x_test = data[train_set_size+valid_set_size:,:-1,:]\n    y_test = data[train_set_size+valid_set_size:,-1,:]\n    \n    return [x_train, y_train, x_valid, y_valid, x_test, y_test]\n\n# normalize stock\ndf_stock_norm = df.copy()\ndf_stock_norm = normalize_data(df_stock_norm)\n\n# create train, test data\nseq_len = 20 # choose sequence length\nx_train, y_train, x_valid, y_valid, x_test, y_test = load_data(df_stock_norm, seq_len)\nprint('x_train.shape = ',x_train.shape)\nprint('y_train.shape = ', y_train.shape)\nprint('x_valid.shape = ',x_valid.shape)\nprint('y_valid.shape = ', y_valid.shape)\nprint('x_test.shape = ', x_test.shape)\nprint('y_test.shape = ',y_test.shape)\n","8f4eb3e2":"plt.figure(figsize=(15, 5));\nplt.plot(df_stock_norm.open.values, color='red', label='open')\nplt.plot(df_stock_norm.close.values, color='green', label='low')\nplt.plot(df_stock_norm.low.values, color='blue', label='low')\nplt.plot(df_stock_norm.high.values, color='black', label='high')\nplt.title('stock')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price')\nplt.legend(loc='best')\nplt.show()","4f9b9a76":"## Basic Cell RNN in tensorflow\n\nindex_in_epoch = 0;\nperm_array  = np.arange(x_train.shape[0])\nnp.random.shuffle(perm_array)\n\n# function to get the next batch\ndef get_next_batch(batch_size):\n    global index_in_epoch, x_train, perm_array   \n    start = index_in_epoch\n    index_in_epoch += batch_size\n    \n    if index_in_epoch > x_train.shape[0]:\n        np.random.shuffle(perm_array) # shuffle permutation array\n        start = 0 # start next epoch\n        index_in_epoch = batch_size\n        \n    end = index_in_epoch\n    return x_train[perm_array[start:end]], y_train[perm_array[start:end]]\n\n# parameters\nn_steps = seq_len-1 \nn_inputs = 4\nn_neurons = 1 # 200\nn_outputs = 4\nn_layers = 1 # 2\nlearning_rate = 0.001\nbatch_size = 50\nn_epochs = 6 # 100\ntrain_set_size = x_train.shape[0]\ntest_set_size = x_test.shape[0]\n\ntf.compat.v1.disable_eager_execution()\ntf.compat.v1.reset_default_graph()\n\nX = tf.compat.v1.placeholder(tf.float32, [None, n_steps, n_inputs])\ny = tf.compat.v1.placeholder(tf.float32, [None, n_outputs])\n\n# use Basic RNN Cell\nlayers = [tf.compat.v1.nn.rnn_cell.BasicRNNCell(num_units=n_neurons, activation=tf.nn.elu)\n          for layer in range(n_layers)]\n\n# use Basic LSTM Cell \n#layers = [tf.compat.v1.nn.rnn_cell.BasicLSTMCell(num_units=n_neurons, activation=tf.nn.elu)\n#          for layer in range(n_layers)]\n\n# use LSTM Cell with peephole connections\n#layers = [tf.compat.v1.nn.rnn_cell.LSTMCell(num_units=n_neurons, \n#                                  activation=tf.nn.leaky_relu, use_peepholes = True)\n#          for layer in range(n_layers)]\n\n# use GRU cell\n#layers = [tf.compat.v1.nn.rnn_cell.GRUCell(num_units=n_neurons, activation=tf.nn.leaky_relu)\n#          for layer in range(n_layers)]\n\nmulti_layer_cell = tf.compat.v1.nn.rnn_cell.MultiRNNCell(layers)\nrnn_outputs, states = tf.compat.v1.nn.dynamic_rnn(multi_layer_cell, X, dtype=tf.float32)\n\nstacked_rnn_outputs = tf.reshape(rnn_outputs, [-1, n_neurons]) \nstacked_outputs = tf.compat.v1.layers.dense(stacked_rnn_outputs, n_outputs)\noutputs = tf.reshape(stacked_outputs, [-1, n_steps, n_outputs])\noutputs = outputs[:,n_steps-1,:] # keep only last output of sequence\n                                              \nloss = tf.reduce_mean(tf.square(outputs - y)) # loss function = mean squared error \noptimizer = tf.compat.v1.train.AdamOptimizer(learning_rate=learning_rate) \ntraining_op = optimizer.minimize(loss)\n\n# run graph\nwith tf.compat.v1.Session() as sess: \n    sess.run(tf.compat.v1.global_variables_initializer())\n    for iteration in range(int(n_epochs*train_set_size\/batch_size)):\n        x_batch, y_batch = get_next_batch(batch_size) # fetch the next training batch \n        sess.run(training_op, feed_dict={X: x_batch, y: y_batch}) \n        if iteration % int(5*train_set_size\/batch_size) == 0:\n            mse_train = loss.eval(feed_dict={X: x_train, y: y_train}) \n            mse_valid = loss.eval(feed_dict={X: x_valid, y: y_valid}) \n            print('%.2f epochs: MSE train\/valid = %.6f\/%.6f'%(\n                iteration*batch_size\/train_set_size, mse_train, mse_valid))\n\n    y_train_pred = sess.run(outputs, feed_dict={X: x_train})\n    y_valid_pred = sess.run(outputs, feed_dict={X: x_valid})\n    y_test_pred = sess.run(outputs, feed_dict={X: x_test})\n    ","3fbddc04":"y_train.shape","ebe9a67f":"ft = 0 # 0 = open, 1 = close, 2 = highest, 3 = lowest\n\n## show predictions\nplt.figure(figsize=(15, 5));\nplt.subplot(1,2,1);\n\nplt.plot(np.arange(y_train.shape[0]), y_train[:,ft], color='blue', label='train target')\n\nplt.plot(np.arange(y_train.shape[0], y_train.shape[0]+y_valid.shape[0]), y_valid[:,ft],\n         color='gray', label='valid target')\n\nplt.plot(np.arange(y_train.shape[0]+y_valid.shape[0],\n                   y_train.shape[0]+y_test.shape[0]+y_test.shape[0]),\n         y_test[:,ft], color='black', label='test target')\n\nplt.plot(np.arange(y_train_pred.shape[0]),y_train_pred[:,ft], color='red',\n         label='train prediction')\n\nplt.plot(np.arange(y_train_pred.shape[0], y_train_pred.shape[0]+y_valid_pred.shape[0]),\n         y_valid_pred[:,ft], color='orange', label='valid prediction')\n\nplt.plot(np.arange(y_train_pred.shape[0]+y_valid_pred.shape[0],\n                   y_train_pred.shape[0]+y_valid_pred.shape[0]+y_test_pred.shape[0]),\n         y_test_pred[:,ft], color='green', label='test prediction')\n\nplt.title('past and future stock prices')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price')\nplt.legend(loc='best');\n\nplt.subplot(1,2,2);\n\nplt.plot(np.arange(y_train.shape[0], y_train.shape[0]+y_test.shape[0]),\n         y_test[:,ft], color='black', label='test target')\n\nplt.plot(np.arange(y_train_pred.shape[0], y_train_pred.shape[0]+y_test_pred.shape[0]),\n         y_test_pred[:,ft], color='green', label='test prediction')\n\nplt.title('future stock prices')\nplt.xlabel('time [days]')\nplt.ylabel('normalized price')\nplt.legend(loc='best');\n\ncorr_price_development_train = np.sum(np.equal(np.sign(y_train[:,1]-y_train[:,0]),\n            np.sign(y_train_pred[:,1]-y_train_pred[:,0])).astype(int)) \/ y_train.shape[0]\ncorr_price_development_valid = np.sum(np.equal(np.sign(y_valid[:,1]-y_valid[:,0]),\n            np.sign(y_valid_pred[:,1]-y_valid_pred[:,0])).astype(int)) \/ y_valid.shape[0]\ncorr_price_development_test = np.sum(np.equal(np.sign(y_test[:,1]-y_test[:,0]),\n            np.sign(y_test_pred[:,1]-y_test_pred[:,0])).astype(int)) \/ y_test.shape[0]\n\nprint('correct sign prediction for close - open price for train\/valid\/test: %.2f\/%.2f\/%.2f'%(\n    corr_price_development_train, corr_price_development_valid, corr_price_development_test))\n","f28f4bbd":"# 5. Predictions <a class=\"anchor\" id=\"5-bullet\"><\/a> ","da27998e":"# 2. Analyze data <a class=\"anchor\" id=\"2-bullet\"><\/a> \n- load stock prices from prices-split-adjusted.csv\n- analyze data","a3828c22":"# 1. Libraries and settings <a class=\"anchor\" id=\"1-bullet\"><\/a> ","c1c4ee0f":"# 3. Manipulate data <a class=\"anchor\" id=\"3-bullet\"><\/a> \n- choose a specific stock\n- drop feature: volume\n- normalize stock data\n- create train, validation and test data sets","19d799e3":"# 4. Model and validate data <a class=\"anchor\" id=\"4-bullet\"><\/a> \n- RNNs with basic, LSTM, GRU cells\n","fd176b73":"**Author:** Raoul Malm  \n\n**Description:** \n\nThis notebook demonstrates the future price prediction for different stocks using recurrent neural networks in tensorflow. Recurrent neural networks with basic, LSTM or GRU cells are implemented. \n\n**Outline:**\n\n1. [Libraries and settings](#1-bullet)\n2. [Analyze data](#2-bullet)\n3. [Manipulate data](#3-bullet)\n4. [Model and validate data](#4-bullet)\n5. [Predictions](#5-bullet)\n\n**Reference:**  \n\n[LSTM_Stock_prediction-20170507 by BenF](https:\/\/www.kaggle.com\/benjibb\/lstm-stock-prediction-20170507\/notebook)"}}