{"cell_type":{"7d5fd3c8":"code","7fc2fb23":"code","6ddf3323":"code","9347513a":"code","4bc1fb38":"code","76179466":"code","12a876b7":"code","d6ac56e4":"code","5bf09fb7":"code","7e638585":"code","be598a81":"markdown","88dee086":"markdown","d0febded":"markdown"},"source":{"7d5fd3c8":"import itertools\n\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn.functional as F","7fc2fb23":"perms = list(map(lambda p: \"\".join(p), itertools.permutations(\"1234567\")))\nperm2id = {p: i for i, p in enumerate(perms)}\n\nperms_arr = np.array([list(map(int, p)) for p in perms])\nperms_arr.shape","6ddf3323":"perms_onehot = np.eye(7)[perms_arr-1, :].transpose(0, 2, 1)\nassert np.allclose(perms_onehot[:,0,:].astype(np.int64), (perms_arr == 1).astype(np.int64))\n\nprint(\"onehot 1234567:\")\nprint(perms_onehot[perm2id[\"1234567\"]])\n\nprint(\"onehot 5671234:\")\nprint(perms_onehot[perm2id[\"5671234\"]])\n\nprint(\"correlate between 1234567 and 5671234\")\nleft = perms_onehot[perm2id[\"1234567\"]]\nright = perms_onehot[perm2id[\"5671234\"]]\nmatches = F.conv2d(\n    F.pad(torch.Tensor(left[None, None, :, :]), (7, 7)),\n    torch.Tensor(right[None, None, :, :]),\n    padding=\"valid\"\n).numpy().reshape(-1)\nprint(matches)\nmust_match_left2right = np.array([-1, -1, -1, -1, -1, -1, -1, 7, 6, 5, 4, 3, 2, 1, 0])\nmust_match_right2left = np.array([0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1])\ncost_ifmatch = np.array([7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7])\nprint(\"cost of 1234567 -> 5671234:\", min(cost_ifmatch[np.equal(must_match_left2right, matches)]))\nprint(\"cost of 5671234 -> 1234567:\", min(cost_ifmatch[np.equal(must_match_right2left, matches)]))","9347513a":"M = F.conv2d(\n    F.pad(torch.Tensor(perms_onehot[:, None, :, :]), (7, 7)),\n    torch.Tensor(perms_onehot[:, None, :, :]),\n    padding=\"valid\"\n).squeeze().numpy()\n\nM.shape","4bc1fb38":"must_match_left2right = np.array([-1, -1, -1, -1, -1, -1, -1, 7, 6, 5, 4, 3, 2, 1, 0])\nmust_match_left2right_wild = np.array([-1, -1, -1, -1, -1, -1, -1, 6, 5, 4, 3, 2, 1, 0, 0])\n\ncost_ifmatch = np.array([7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7])\n\ncostMat = np.where(M == must_match_left2right, cost_ifmatch, np.inf).min(axis=-1).astype(np.int8)\ncostMatWild = np.minimum(costMat, np.where(M == must_match_left2right_wild, cost_ifmatch, np.inf).min(axis=-1)).astype(np.int8)","76179466":"symbols = \"\ud83c\udf85\ud83e\udd36\ud83e\udd8c\ud83e\udddd\ud83c\udf84\ud83c\udf81\ud83c\udf80\"\nschedule = pd.read_csv(\"..\/input\/santa-2021-tsp-baseline-2500\/submission.csv\").schedule.tolist()\nwords = [s.translate(str.maketrans(symbols, \"1234567\")) for s in schedule]\n\nlist(map(len, words))","12a876b7":"\"\"\"\nPermutations Rebalancing (https:\/\/www.kaggle.com\/kostyaatarik\/permutations-rebalancing\/notebook)\n\nThis leads a relaxation of constraints and sometimes you can find a better solution of wildcard positions.\n\"\"\"\n\ndef find_strings_perms(strings, verbose=False):\n    global perms\n    found_perms = []\n    for s in strings:\n        found_perms.append([])\n        for i in range(len(s)-6):\n            p = s[i:i+7]\n            if p in perms:\n                found_perms[-1].append(p)\n    if verbose:\n        lens = [len(_) for _ in  found_perms]\n        print(f'There are {lens} permutations in strings, {sum(lens)} in total.')\n        lens = [len(set(_)) for _ in  found_perms]\n        print(f'There are {lens} unique permutations in strings, {sum(lens)} in total.')\n    return found_perms\n\ndef rebalance_perms(strings_perms, verbose=False):\n    # convert to dicts for fast lookup and to keep permutations order\n    strings_perms = [dict.fromkeys(_) for _ in strings_perms] \n    for p in strings_perms[0].copy():  # iterate over the copy to allow modification during iteration\n        if p[:2] != \"12\" and (p in strings_perms[1] or p in strings_perms[2]):\n            strings_perms[0].pop(p)\n    for p in strings_perms[1].copy():\n        if p[:2] != \"12\" and p in strings_perms[2]:\n            strings_perms[1].pop(p)\n    if verbose:\n        lens = [len(_) for _ in  strings_perms]\n        print(f'There are {lens} permutations left in strings after rebalancing, {sum(lens)} in total.')\n    return [list(_) for _ in strings_perms] \n\nfound_perms = find_strings_perms(words, verbose=True)\nbalanced_perms = rebalance_perms(found_perms, verbose=True)","d6ac56e4":"def wildcard(input_perms):\n    new_words = []\n    \n    for i in range(len(input_perms)):\n        nodes = [perm2id[p] for p in input_perms[i]]\n\n        \"\"\"\n        0: no wild\n        1-14: # of digits appeared after the first wild\n        15-22: (# of digits appeared after the second wild) + 14\n        \"\"\"\n        table = np.full((len(nodes), 23), 1e7, dtype=np.int64)\n        backtrack = np.zeros((len(nodes), 23), dtype=np.int64)\n        table[0, :] = 7\n        for i in range(1, len(nodes)):\n            e = costMat[nodes[i-1], nodes[i]]\n            ew = costMatWild[nodes[i-1], nodes[i]]\n\n            # non-wild transition\n            table[i,0] = table[i-1,0] + e\n            backtrack[i,0] = 0\n            for j in range(1, 15):\n                if table[i, min(14, j + e)] > table[i-1, j] + e:\n                    table[i, min(14, j + e)] = table[i-1, j] + e\n                    backtrack[i, min(14, j + e)] = j\n            for j in range(15, 23):\n                if table[i, min(22, j + e)] > table[i-1, j] + e:\n                    table[i, min(22, j + e)] = table[i-1, j] + e\n                    backtrack[i, min(22, j + e)] = j\n\n            if ew < e:\n                \"\"\"\n                i-1:  00000*0\n                i  :    000*000\n                             == ew\n                        ===     mis\n                            === distance_from_wild\n                \"\"\"\n                left = np.array(list(map(int, perms[nodes[i-1]][ew:])))\n                right = np.array(list(map(int, perms[nodes[i]][:-ew])))\n                mis = np.where(left != right)[0][0]\n                distance_from_wild = 7 - mis - 1\n\n                # first wild transition\n                if table[i, distance_from_wild] >= table[i-1, 0] + ew:\n                    table[i, 1] = table[i-1, 0] + ew\n                    backtrack[i, 1] = 0\n\n                # second wild transition\n                ## position of the second wild card is same as the previous one\n                ## <=> table[i-1, distance_from_wild-ew]->table[i, distance_from_wild]\n                if distance_from_wild - ew >= 1 and table[i, distance_from_wild] >= table[i-1, distance_from_wild-ew] + ew:\n                    table[i, distance_from_wild] = table[i-1, distance_from_wild-ew] + ew\n                    backtrack[i, distance_from_wild] = distance_from_wild-ew\n                ## position of the third wild card is same as the previous one\n                if distance_from_wild - ew >= 1 and table[i, distance_from_wild+14] >= table[i-1, distance_from_wild-ew+14] + ew:\n                    table[i, distance_from_wild+14] = table[i-1, distance_from_wild-ew+14] + ew\n                    backtrack[i, distance_from_wild+14] = distance_from_wild-ew+14\n\n                ## put the second wild card and it is >=7 digits far from the previous one\n                for j in range(1, 15):\n                    if j + ew - distance_from_wild >= 7:\n                        if table[i, distance_from_wild+14] >= table[i-1, j] + ew:\n                            table[i, distance_from_wild+14] = table[i-1, j] + ew\n                            backtrack[i, distance_from_wild+14] = j\n        print(table[-1].min(), table[-1])\n\n        # backtrack\n        ns = [perms[nodes[-1]]]\n        track = np.argmin(table[-1])\n        wild = []\n        for i in range(len(nodes)-2, -1, -1):\n            e = costMat[nodes[i], nodes[i+1]]\n            ew = costMatWild[nodes[i], nodes[i+1]]\n            next_track = backtrack[i+1, track]\n            if table[i+1, track] == table[i, next_track] + e:\n                ns.append(perms[nodes[i]][:e])\n            else:\n                left = np.array(list(map(int, perms[nodes[i]][ew:])))\n                right = np.array(list(map(int, perms[nodes[i+1]][:-ew])))\n                mis = np.where(left != right)[0][0]\n                wild.append(table[i, next_track]-7+ew+mis)\n                ns.append(perms[nodes[i]][:ew])\n            track = next_track\n        assert track == 0\n        nsw = list(\"\".join(ns[::-1]))\n        for w in wild:\n            nsw[w] = \"*\"\n        new_words.append(\"\".join(nsw))\n    return new_words\n\nnew_words = wildcard(balanced_perms)","5bf09fb7":"print(\"score: \", max(map(len, words)), \"->\", max(map(len, new_words)))","7e638585":"submission = pd.Series([a.translate(str.maketrans(\"1234567*\", symbols+\"\ud83c\udf1f\")) for a in new_words], name='schedule')\nsubmission.to_csv('submission.csv', index=False)","be598a81":"- v4: better folding\n    * supports (\"1234567\", \"2345617\", \"3456271\", \"4563712\", \"5647123\", \"6571234\", \"6712345\") -> \"123456*712345\"\n    * but no improvement :(\n- v3: Apply the [permutation rebalancing](https:\/\/www.kaggle.com\/kostyaatarik\/permutations-rebalancing\/notebook) before optimization (2503 -> 2501)","88dee086":"## Optim","d0febded":"## Create Cost matrix"}}