{"cell_type":{"4b5fc23c":"code","09b2722e":"code","dcb94f60":"code","adc778e8":"code","6e0f6dc6":"code","3f217506":"code","8b55eb07":"code","fe0ab85c":"code","e06c7a65":"code","0012ae95":"code","4c0a175e":"code","d599f509":"code","6b39f6a5":"code","d6b1d748":"code","937d04bc":"code","3b56899a":"code","bf940437":"code","f7b82243":"code","00e8d22b":"code","09381e7f":"code","70074784":"code","1144a474":"code","215e0e97":"code","66956a7b":"code","d1d17803":"code","ded8a547":"code","8eecc545":"code","5e42f28e":"code","b2f1110e":"code","3835e245":"code","f3d6ce1a":"code","50519be4":"code","f5fd5a05":"code","7af21171":"code","8ed3fe5a":"code","2f8caf11":"code","ef888147":"markdown","f484cea6":"markdown","c113ccce":"markdown","d82033d6":"markdown","fe5a0134":"markdown","2cd36f3f":"markdown","8fb58162":"markdown","77ff49b7":"markdown","2284f489":"markdown","62bac34e":"markdown","f41e9300":"markdown","fff7ec6f":"markdown","84878837":"markdown","f128d33e":"markdown","fb573863":"markdown","5ffa6227":"markdown","939d555c":"markdown","9fe87595":"markdown"},"source":{"4b5fc23c":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport scipy as sp\nimport warnings\nimport datetime\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nimport warnings \nwarnings.filterwarnings(\"ignore\")\n%matplotlib inline\n","09b2722e":"train = pd.read_csv(\"\/kaggle\/input\/mnist-handwritten-digit-classification\/train.csv\")\ntest = pd.read_csv(\"\/kaggle\/input\/mnist-handwritten-digit-classification\/test.csv\")\n","dcb94f60":"train","adc778e8":"test","6e0f6dc6":"print(train.shape)\nprint(test.shape)\n","3f217506":"train.head(5)","8b55eb07":"test.head(5)","fe0ab85c":"train.describe()","e06c7a65":"test.describe()","0012ae95":"train.info()","4c0a175e":"train.columns","d599f509":"test.value_counts()","6b39f6a5":"train.dtypes","d6b1d748":"test.dtypes","937d04bc":"X = train.drop([\"label\"],axis = 1).values\nY = train[\"label\"].values\n","3b56899a":"train.corr()","bf940437":"test.corr()","f7b82243":"plt.figure(figsize = (16,8))\nsns.histplot(Y)","00e8d22b":"plt.figure(figsize = (16,8))\nsns.distplot(Y,color='g')","09381e7f":"plt.figure(figsize = (16,8))\nsns.kdeplot(Y,shade=True)","70074784":"plt.figure(figsize = (16,8))\nsns.violinplot(Y,color='g')","1144a474":"plt.figure(figsize = (18,8))\nsns.countplot(Y)\n","215e0e97":"plt.imshow(X[10].reshape([28,28]))\n","66956a7b":"plt.imshow(X[1455].reshape([28,28]))\n","d1d17803":"X = X.reshape([42000,28,28,1])\nY = Y.reshape([42000,1])\n","ded8a547":"from keras.utils.np_utils import to_categorical \nY = to_categorical(Y, num_classes = 10)\n","8eecc545":"from sklearn.model_selection import train_test_split\nx_train,x_test,y_train,y_test=train_test_split(X,Y,random_state=10,test_size=0.1)\n","5e42f28e":"model = tf.keras.models.Sequential([\n    tf.keras.layers.Conv2D(64, (3,3), padding = 'same', activation='relu', input_shape=(28, 28, 1)),\n    tf.keras.layers.MaxPooling2D(2, 2),\n    tf.keras.layers.Dropout(0.25),\n    tf.keras.layers.Conv2D(64, (3,3), padding = 'same', activation='relu'),\n    tf.keras.layers.MaxPooling2D(2,2),\n    tf.keras.layers.Dropout(0.25),\n    tf.keras.layers.Conv2D(128, (3,3), padding = 'same', activation='relu'),\n    tf.keras.layers.MaxPooling2D(2,2),\n    tf.keras.layers.Dropout(0.25),\n    tf.keras.layers.Conv2D(128, (3,3), padding = 'same', activation='relu'),\n    tf.keras.layers.MaxPooling2D(2,2),\n    tf.keras.layers.Dropout(0.25),\n    tf.keras.layers.Flatten(),\n    tf.keras.layers.Dense(256, activation='relu'),\n    tf.keras.layers.Dropout(0.5),\n    tf.keras.layers.Dense(10, activation='softmax')\n])\n\n","b2f1110e":"        \nmodel.compile(\n    optimizer='adam',\n    loss='binary_crossentropy',        # In loss mae can also be used.\n    metrics=['binary_accuracy'],\n)\n","3835e245":"\nhistory = model.fit(x_train,y_train,batch_size=256,\n    epochs=20\n                    \n)\n","f3d6ce1a":"model.summary()\n","50519be4":"from tensorflow.keras.utils import plot_model\n\nplot_model(model, show_shapes = True)\n","f5fd5a05":"y_pred = model.predict(x_test)\ny_pred\n","7af21171":"print(y_pred>0.5)","8ed3fe5a":"# convert the training history to a dataframe\nhistory_df = pd.DataFrame(history.history)\n# use Pandas native plot method\nhistory_df['loss'].plot()\n","2f8caf11":"model.evaluate(x_test,y_test)\n","ef888147":"**TRAINING AND TESTING DATA**","f484cea6":"![](https:\/\/i.imgur.com\/rFI1tIk.gif)","c113ccce":"**CNN BUILDING**","d82033d6":"**CONCLUSION :**\n\n**So we got a good accuracy of 99.6 % keeping epochs as 20 and batch size as 256 .**\n\n**Thank you , Lets Grow More**","fe5a0134":"**MODEL FITTING**","2cd36f3f":"**COUNT PLOT**\n\n**A countplot is kind of likea histogram or a bar graph for some categorical area. It simply shows the number of occurrences of an item based on a certain type of category.**\n","8fb58162":"**MODEL COMPILING**","77ff49b7":"# IMPORTING THE LIBRARIES","2284f489":"# LOADING THE DATASET","62bac34e":"# Exploratory Data Analysis","f41e9300":"# MNIST Handwritten Digit Classification","fff7ec6f":"![](https:\/\/miro.medium.com\/max\/1400\/1*26W2Yk3cu2uz_R8BuSb_SA.png)","84878837":"**HISTOGRAM**\n\n**Histograms represent the data distribution by forming bins along the range of the data and then drawing bars to show the number of observations that fall in each bin.**","f128d33e":"![](https:\/\/i.imgur.com\/tHiVFnM.png)","fb573863":"**VIOLIN PLOT**\n\n**Violin plots are used when you want to observe the distribution of numeric data, and are especially useful when you want to make a comparison of distributions between multiple groups. The peaks, valleys, and tails of each group's density curve can be compared to see where groups are similar or different.**","5ffa6227":"**DISTPLOT**\n\n**The distplot represents the univariate distribution of data i.e. data distribution of a variable against the density distribution. The seaborn. distplot() function accepts the data variable as an argument and returns the plot with the density distribution.**\n","939d555c":"**KDEPLOT**\n\n**Kdeplot is a Kernel Distribution Estimation Plot which depicts the probability density function of the continuous or non-parametric data variables i.e. we can plot for the univariate or multiple variables altogether. Using the Python Seaborn module, we can build the Kdeplot with various functionality added to it.**\n","9fe87595":"**One Hot Encoding**"}}