{"cell_type":{"8086cbd9":"code","f00b0b15":"code","3ec38e8e":"code","d0abddf6":"code","b7e8273c":"code","2b8c54a9":"code","495f0cf8":"code","e73ecb4d":"code","9f39e62c":"code","45a65e9f":"code","fe14eabd":"code","b51f6a49":"code","f4a187b5":"code","e46aaac5":"code","afd0a4ee":"code","229fd5ba":"code","406e644e":"code","e73edf60":"code","594e7d62":"code","658412d7":"code","73b82407":"code","2862590c":"code","cb96597d":"code","80610339":"code","653cd632":"code","5cb80bd6":"code","e81f79fe":"code","1f047691":"code","30cf22b4":"markdown","ea14bd46":"markdown","9546a758":"markdown","7311ebed":"markdown","f5959546":"markdown","69aaed83":"markdown","7c90023c":"markdown","47d983cc":"markdown","aca7692e":"markdown","2c2dee81":"markdown","340bef2e":"markdown","dfddf706":"markdown","5e78e827":"markdown","3cd0046c":"markdown","d4eff11d":"markdown","a6750e62":"markdown","7048e98a":"markdown"},"source":{"8086cbd9":"!pip install gdown","f00b0b15":"import os\nimport shutil","3ec38e8e":"!git clone https:\/\/github.com\/alibalapour\/SegPC2021.git\n!git pull","d0abddf6":"os.chdir('SegPC2021')","b7e8273c":"!pip install clint\n!pip install crontab\n!pip install tablib","2b8c54a9":"!python3 -mpip install pip --upgrade\n!python3 -mpip install -r .\/requirements.txt","495f0cf8":"!gdown --id 1PhbaOW7xrLWFc2qtf5JJYMUOYzqVCm0Z\n!gdown --id 1NW5X-ppJV2cROw80OT9PhI7oa0PYMVXk\n!gdown --id 1-HBIh1ljmAVHba8UEqTfnilYqoLcULUz\n!gdown --id 15XqGpqEFRr2F-QPxBbj568X6i8Q3Jbl4\n!gdown --id 13cB1LWOyFWRdM5mCFZrILGJCungLTq5b","e73ecb4d":"os.mkdir('weights')\n\n!mv Adeeplab_256x256_sc0.50.hdf5 weights\n!mv Adeeplab_384x384_sc1.75.hdf5 weights\n!mv Adeeplab_384x384_sc2.60.hdf5 weights\n!mv Adeeplab_384x384_sc3.00.hdf5 weights\n!mv weight_sunet_all_te_800x800_pro.hdf5 weights","9f39e62c":"os.mkdir('dataset')\n!cp ..\/..\/input\/segpc2021dataset\/TCIA_SegPC_dataset\/TCIA_SegPC_dataset\/TCIA_SegPC_dataset\/test -r .\/dataset","45a65e9f":"from configparser import ConfigParser\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom tqdm import tqdm\nimport cv2, sys\nfrom PIL import Image\nfrom glob import glob\nimport pickle\nfrom pathlib import Path\nimport json\nimport gc\n\n\nimport os\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n\nimport keras\nfrom keras import backend as K\nfrom keras.callbacks import ModelCheckpoint, TensorBoard,ReduceLROnPlateau\nfrom keras import callbacks","fe14eabd":"import sys \nsys.path.append('.\/src')\n\nfrom utilities import (\n    resize_pad, sim_resize, resize, show_sbs, clean_nuc_mask,\n    crop_multi_scale_submats, do_cyto_pred_process, \n    get_pure_img_bbox, get_cyto_mask, \n    do_cyto_postprocess, get_biggest_cc_msk\n)","b51f6a49":"src = 'dataset\/test\/x\/'\ncount = 0\n\nfor i, name in enumerate(os.listdir(src)):\n    if count < 3 and Image.open(src + name).size == (2560, 1920):\n        count += 1\n        continue\n    os.remove(src + name)","f4a187b5":"CONFIG_FILE_PATH = \".\/configs\/config.json\"","e46aaac5":"with open(CONFIG_FILE_PATH, 'r') as fp:\n    config = json.load(fp)\n\nPath(config['DATA']['NPY_DIR']).mkdir(parents=True, exist_ok=True)\n    \nrun_name = config['RUN']['name']\nimsk_fn = config['RUN']['imsk_folder_name']\nfinal_imsk_fn = config['RUN']['final_imsk_folder_name']\n\nPath('.\/results').mkdir(parents=True, exist_ok=True)\nPath('.\/results\/run_{}'.format(run_name)).mkdir(parents=True, exist_ok=True)\nPath('.\/results\/run_{}\/{}'.format(run_name, imsk_fn)).mkdir(parents=True, exist_ok=True)\nPath('.\/results\/run_{}\/{}'.format(run_name, final_imsk_fn)).mkdir(parents=True, exist_ok=True)\nPath('.\/results\/run_{}\/{}\/filtered'.format(run_name, imsk_fn)).mkdir(parents=True, exist_ok=True)\n\nIMSK_DIR   = '.\/results\/run_{}\/{}\/'        .format(run_name, imsk_fn)\nF_IMSK_DIR = '.\/results\/run_{}\/{}\/filtered\/'.format(run_name, imsk_fn)\n\nCROP_SCALE_LIST = config['RUN']['crop_scale_list']\nfor sc in CROP_SCALE_LIST+[0,]:\n    Path('{}sc_{:1.2f}'.format(  IMSK_DIR, sc)).mkdir(parents=True, exist_ok=True)\n    Path('{}sc_{:1.2f}'.format(F_IMSK_DIR, sc)).mkdir(parents=True, exist_ok=True)","afd0a4ee":"DATA_CFG = config['DATA']\n\nX_path_list = glob('{}*{}'.format(config['DATA']['X_DIR'], config['DATA']['X_FILE_TYPE_EXTENSION']))\n\nX = []\nX_org = []\nX_names = []\nX_shapes = []\nfor xp in tqdm(X_path_list):\n    fn = xp.split('\/')[-1].split('.')[0]\n    X_names.append(fn)\n    \n    img = np.array(Image.open(xp))\n    X_org.append(img)\n    X_shapes.append(img.shape)\n    \n    img_ = resize(img, tuple(config['NUCS']['MODEL']['input_shape'][:2]), interpolation='linear')\n    X.append(img_)\n    \n\nX = np.array(X)\nnp.save(config['DATA']['NPY_DIR']+'X_nuc', X.astype(np.uint8))","229fd5ba":"from models.model_nuc import unet_dnspro as NucModel\n\nnuc_model = NucModel(**config['NUCS']['MODEL'])","406e644e":"prediction = nuc_model.predict(np.array(X\/255.), verbose=1)\nprediction = np.squeeze(prediction)\n\ndel nuc_model\nfor i in range(5):\n    gc.collect()\n    K.clear_session()\n\nnuc_preds = []\nfor i in tqdm(range(len(prediction))):\n    mask = np.where(prediction[i]>config['NUCS']['bth'], 1, 0)\n    cleaned_mask = clean_nuc_mask(mask)\n    nuc_preds.append(resize((255*cleaned_mask).astype(np.uint8), tuple(X_shapes[i][:2]), 'linear'))\nnuc_preds = np.array(nuc_preds)\/255.\nnuc_pred_masks = np.where(nuc_preds>config['NUCS']['bth'], 255, 0)\n\nprint(X_names[0])\nshow_sbs(X_org[0], nuc_pred_masks[0])","e73edf60":"# add predicted nucleus masks to each image\n\nX_org_pp_ch4 = []\nfor i in tqdm(range(len(X_org))):\n    x, nm = X_org[i], nuc_pred_masks[i]\n    for ch in range(3):\n        x[:,:,i] = cv2.equalizeHist(np.uint8(x[:,:,ch]))\n    x = np.concatenate([x, np.expand_dims(nm, -1)], -1)        \n    X_org_pp_ch4.append(x)\n    \nX = np.array(X_org_pp_ch4)\nM = np.array(nuc_pred_masks)\n\nprint(X.shape, M.shape)","594e7d62":"scales_cropped_data = []\nfor scale in CROP_SCALE_LIST:\n    scale_cropped_data = []\n    for i in tqdm(range(len(X_names)), desc='Scale:{:2.2f}'.format(scale)):\n        mask, image, name = nuc_pred_masks[i], X[i], X_names[i]\n        cropped_nucs_data = crop_multi_scale_submats(image, name, mask, [scale])\n        scale_cropped_data.append(cropped_nucs_data)\n    scales_cropped_data.append(scale_cropped_data)","658412d7":"_, axs = plt.subplots(2, len(scales_cropped_data), figsize=(len(scales_cropped_data)*5, 12))\nfor i, scale_cropped_data in enumerate(scales_cropped_data):\n    tmp = 1\n    simg = scale_cropped_data[0]['data'][tmp][0]['simg']\n    snmsk = scale_cropped_data[0]['data'][tmp][0]['snmsk']\n    axs[0, i].imshow(simg[:,:,:3])\n    axs[0, i].set_title('Scale:{:1.2f}'.format(CROP_SCALE_LIST[i]))\n    axs[1, i].imshow(snmsk)\nplt.show()","73b82407":"from models.model_cyt import Deeplabv3pa as CytModel\n\n\nCFG = config['CYTS']['MODELS']\ncyts_preds_scales = []\nfor scale, scale_cropped_data in zip(CROP_SCALE_LIST, scales_cropped_data):\n    \n    model_conf = {\n        'input_shape': CFG['input_shape_micro'] if scale<CFG['micro_macro_sc_th'] else CFG['input_shape_micro'],\n        'pretrained_weights': CFG['sc{:1.2f}_weights'.format(scale)]\n    }\n    model_scale_params = {\n        'binary_th': CFG['sc{:1.2f}_bth_ks'.format(scale)][0],\n        'KS'       : CFG['sc{:1.2f}_bth_ks'.format(scale)][1]\n    }\n    cyt_model = CytModel(**model_conf)\n    \n    pred_mask_nucs_cyto = []\n    for data in tqdm(scale_cropped_data, desc='Scale:{:1.2f}'.format(scale)):\n        preds_cyto_on_sub = data    \n        for i, ins in enumerate(preds_cyto_on_sub['data']):\n            for j, ins_scale in enumerate(ins):\n                x = ins_scale['simg']\n                x_shape = x.shape\n\n                x = resize_pad(x, tuple(model_conf['input_shape'][:2]))\n                x[:,:,3] = np.where(x[:,:,3]>127, 255, 0)\n                bbox = get_pure_img_bbox(x)\n                \n                pred_cyto = cyt_model.predict(np.array([x\/255]), batch_size=1, verbose=0)\n                pred_cyto = np.squeeze(pred_cyto)\n                ppred_cyto = do_cyto_pred_process(pred_cyto)\n                mask_cyto = get_cyto_mask(ppred_cyto, model_scale_params['binary_th'])\n                mask_cyto_ = do_cyto_postprocess(mask_cyto, model_scale_params['KS'])\n                mask_cyto_ = get_biggest_cc_msk(np.uint8(mask_cyto_))\n                mask_cyto_ = mask_cyto_[bbox[0]:bbox[1],bbox[2]:bbox[3]]\n                preds_cyto_on_sub['data'][i][j]['scmsk'] = mask_cyto_\n        pred_mask_nucs_cyto.append(preds_cyto_on_sub)\n    \n    del cyt_model\n    for i in range(5):\n        gc.collect()\n        K.clear_session()\n        \n    cyts_preds_scales.append(pred_mask_nucs_cyto)","2862590c":"for pred_masks_nucs_cyto, scale in zip(cyts_preds_scales, CROP_SCALE_LIST):\n    for data in tqdm(pred_masks_nucs_cyto, desc='Scale:{:1.2f}'.format(scale)):\n        preds_cyto_on_sub = data\n        meta = preds_cyto_on_sub['meta']\n        idx = 1\n        for i, ins in enumerate(preds_cyto_on_sub['data']):    \n            for j, ins_scale in enumerate(ins):\n                simg  = ins_scale['simg' ]\n                snmsk = ins_scale['snmsk']\n                scmsk = ins_scale['scmsk']\n                bbox  = ins_scale['bbox' ]\n                pure_bbox = get_pure_img_bbox(simg)\n                b = pure_bbox\n                try:\n                    pure_simg  = simg [b[0]:b[1], b[2]:b[3]]\n                    pure_snmsk = snmsk[b[0]:b[1], b[2]:b[3]]\n                    pure_scmsk = sim_resize(scmsk, (bbox[2]-bbox[0], bbox[3]-bbox[1]))\n                    pure_smsk  = np.where((pure_snmsk>0)|(pure_scmsk>0), 20, 0) \n                    pure_smsk  = pure_smsk + np.where(pure_snmsk>0, 20, 0)\n                    idxs, idys = np.where(pure_snmsk>0)\n                    pure_smsk[idxs[0], idys[0]] = 20\n                except:\n                    print(meta['image_name'], idx)\n                    continue\n                for u in np.unique(pure_smsk):\n                    if u not in [0, 20, 40]:\n                        print('Ops... image:', meta['image_name'], 'unique:', np.unique(pure_smsk))\n                fmask = np.zeros(meta['image_size'][:2], dtype=np.uint8)\n                fmask[bbox[0]:bbox[2], bbox[1]:bbox[3]] = pure_smsk\n                fn = '{}sc_{:1.2f}\/{}_{}.bmp'.format(IMSK_DIR, scale, meta['image_name'], idx)\n                cv2.imwrite(fn, fmask)\n                idx+=1","cb96597d":"for data in tqdm(pred_masks_nucs_cyto, desc='Scale:{:1.2f}'.format(0.00)):\n    preds_cyto_on_sub = data\n    \n    meta = preds_cyto_on_sub['meta']\n    idx = 1\n\n    for i, ins in enumerate(preds_cyto_on_sub['data']):\n        for j, ins_scale in enumerate(ins):\n            simg  = ins_scale['simg' ]\n            snmsk = ins_scale['snmsk']\n            scmsk = ins_scale['scmsk']\n            bbox  = ins_scale['bbox' ]\n\n            pure_bbox = get_pure_img_bbox(simg)\n            b = pure_bbox\n\n            pure_simg  = simg [b[0]:b[1], b[2]:b[3]]\n            pure_snmsk = snmsk[b[0]:b[1], b[2]:b[3]]\n\n            pure_smsk = np.where(pure_snmsk>0, 40, 0)\n            pure_smsk[:,4:] = pure_smsk[:,:-4]\n            idxs, idys = np.where(pure_snmsk>0)\n            pure_smsk[idxs[0], idys[0]] = 20\n            \n            for u in np.unique(pure_smsk):\n                if u not in [0, 20, 40]:\n                    print('Ops... image:', meta['image_name'], 'unique:', np.unique(pure_smsk))\n\n            fmask = np.zeros(meta['image_size'][:2], dtype=np.uint8)\n            fmask[bbox[0]:bbox[2], bbox[1]:bbox[3]] = pure_smsk\n\n            fn = '{}sc_{:1.2f}\/{}_{}.bmp'.format(IMSK_DIR, 0, meta['image_name'], idx)\n            cv2.imwrite(fn, fmask)\n            idx+=1","80610339":"for scale in [0,]+CROP_SCALE_LIST:\n    THS = config[\"FILTERS\"][\"sc{:1.2f}\".format(scale)] if scale > 0 else [0, 200]\n    SOURCE_DIR  = '{}sc_{:1.2f}\/'.format(  IMSK_DIR, scale)\n    REFINED_DIR = '{}sc_{:1.2f}\/'.format(F_IMSK_DIR, scale)\n    total = 0.\n    refined = 0.\n    rejected = 0.\n    file_path_list = glob(SOURCE_DIR+'*.bmp')\n    img_name_list = set([p.split('\/')[-1].split('_')[0] for p in file_path_list])\n    bar = tqdm(img_name_list, desc='Scale:{:1.2f}'.format(scale))\n    for name in bar:    \n        imsk_path_list = glob(SOURCE_DIR+name+'_*.bmp')\n        idx = 0\n        for imp in imsk_path_list:\n            total += 1\n            imsk = np.asarray(Image.open(imp))\n            nuc_area = np.where(imsk==40, 1, 0).sum()\n            cyt_area = np.where(imsk==20, 1, 0).sum()\n            cyt_to_nuc_ratio = 1.*cyt_area\/nuc_area\n            if  cyt_to_nuc_ratio > THS[1] or THS[0] > cyt_to_nuc_ratio :\n                rejected += 1.\n            else:\n                idx += 1\n                res = Image.fromarray(imsk.astype(np.uint8))\n                save_name = '{}{}_{}.bmp'.format(REFINED_DIR, name, idx)\n                res.save(save_name)\n        bar.set_description('Rejected:{:04.0f}\/{:04.0f} ({:2.3f})%'.format(rejected, total, 100.*rejected\/total))","653cd632":"FILE_TYPE_EXTENSION = '.bmp'\nTEST_DATA_X_DIR = config[\"DATA\"][\"X_DIR\"]\nTOTAL_PREDICTION_DIR = '.\/results\/run_{}\/{}\/'.format(run_name, final_imsk_fn)\npredictions_list = ['{}sc_{:1.2f}\/'.format(F_IMSK_DIR, scale) for scale in CROP_SCALE_LIST]\npredictions = []\nfor prediction_dir in predictions_list:\n    predictions += glob('{}*{}'.format(prediction_dir, FILE_TYPE_EXTENSION))\ntest_x = glob(TEST_DATA_X_DIR + '*' + FILE_TYPE_EXTENSION)\nfor tfp in tqdm(test_x):\n    fn = tfp.split('\/')[-1].split(FILE_TYPE_EXTENSION)[0]\n    preds = [p for p in predictions if '\/'+fn+'_' in p]\n    if len(preds):\n        cnt = 1\n        for pp in preds:\n            new_path = TOTAL_PREDICTION_DIR + fn + '_' + str(cnt) + FILE_TYPE_EXTENSION\n            os.system(\"cp {} {}\".format(pp, new_path))\n            cnt += 1\n    else:\n        print('There is no prediciton for the file <{}>'.format(fn+FILE_TYPE_EXTENSION))","5cb80bd6":"shutil.make_archive('results.zip', 'zip', 'results')","e81f79fe":"!python3 submission.py -s .\/results\/run_dns\/final_imsk\/ -d .\/","1f047691":"!apt-get update\n!apt-get install zip\n!zip submission.zip submission.txt","30cf22b4":"# Dataset","ea14bd46":"# Stage 1) Inference and extract nucleuses","9546a758":"# Importing of packages","7311ebed":"# Download Weights","f5959546":"# Preparation of input data for the first stage","69aaed83":"## predefined packages\n","7c90023c":"# Back candidates to orginal image coordinate\n","47d983cc":"# Stage 2)","aca7692e":"### Loading model\n","2c2dee81":"## Inference","340bef2e":"## Inference the cytoplasm for each extracted nucleus\n","dfddf706":"# Loading the configuration (conf.json)","5e78e827":"# Prelims","3cd0046c":"## Loading model\n","d4eff11d":"## Generating X for the first stage    ","a6750e62":"# Create the submission file\n","7048e98a":"## $$$ packages\n"}}