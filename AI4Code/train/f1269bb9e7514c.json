{"cell_type":{"8d9d6c7a":"code","f255185c":"code","d2a08b5b":"code","c7302028":"code","de5cdde9":"code","f9633c29":"code","f1100032":"code","d1f30ece":"code","8e274a1b":"code","f4c18377":"code","3e71a68c":"code","c7984620":"code","e7a069df":"code","9bac4073":"code","25bbdba8":"code","3d29620e":"code","22ca2965":"code","24599ce6":"code","a3b3795c":"code","eabe0d80":"code","eab6ce72":"code","cf5300a8":"code","e5c7c579":"code","1bbc29b8":"code","4fc291c5":"code","787eefdd":"code","bcabb51f":"code","31e24281":"markdown","e6aa7686":"markdown","04ef5423":"markdown","f6095467":"markdown","f658edaa":"markdown","935bb903":"markdown","6a4a1ce4":"markdown","f1e1135e":"markdown","e2a10502":"markdown","41ef7b0f":"markdown","6de1999b":"markdown","6e5a93a8":"markdown","308552e8":"markdown","d8b67d9c":"markdown","f81663f2":"markdown","5334f866":"markdown","9b18d03a":"markdown","2900c168":"markdown","51dd905f":"markdown","da0bf264":"markdown","cbf46d9c":"markdown","518ecc93":"markdown"},"source":{"8d9d6c7a":"%load_ext autoreload\n%autoreload 2","f255185c":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport inspect","d2a08b5b":"!pip install --upgrade git+https:\/\/github.com\/arjangroen\/RLC.git  # RLC is the Reinforcement Learning package","c7302028":"from RLC.move_chess.environment import Board\nfrom RLC.move_chess.agent import Piece\nfrom RLC.move_chess.learn import Reinforce","de5cdde9":"env = Board()\nenv.render()\nenv.visual_board","f9633c29":"p = Piece(piece='king')","f1100032":"r = Reinforce(p,env)","d1f30ece":"#print(inspect.getsource(r.agent.apply_policy))\ndef apply_policy(self, state, epsilon):\n        \"\"\"\n        Apply the policy of the agent\n        Args:\n            state: tuple of length 2\n            epsilon: exploration probability, 0 for greedy behavior, 1 for pure exploration\n\n        Returns:\n            the selected action for the state under the current policy\n\n        \"\"\"\n        greedy_action_value = np.max(self.policy[state[0], state[1], :])\n        greedy_indices = [i for i, a in enumerate(self.policy[state[0], state[1], :]) if\n                          a == greedy_action_value]\n        action_index = np.random.choice(greedy_indices)\n        if np.random.uniform(0, 1) < epsilon:\n            action_index = np.random.choice(range(len(self.action_space)))\n        return action_index\n\nfunc_type = type(r.agent.apply_policy) # method not function\nr.apply_policy = func_type(r.agent.apply_policy, r)","8e274a1b":"#print(inspect.getsource(r.play_episode))\n\ndef play_episode(self, state, max_steps=1e3, epsilon=0.1):\n    \"\"\"\n    Play an episode of move chess\n    :param state: tuple describing the starting state on 8x8 matrix\n    :param max_steps: integer, maximum amount of steps before terminating the episode\n    :param epsilon: exploration parameter\n    :return: tuple of lists describing states, actions and rewards in a episode\n    \"\"\"\n    self.env.state = state\n    states = []\n    actions = []\n    rewards = []\n    episode_end = False\n\n    # Play out an episode\n    count_steps = 0\n    while not episode_end:\n        count_steps += 1\n        states.append(state)\n        action_index = self.agent.apply_policy(state, epsilon)  # get the index of the next action\n        action = self.agent.action_space[action_index]\n        actions.append(action_index)\n        reward, episode_end = self.env.step(action)\n        state = self.env.state\n        rewards.append(reward)\n\n        #  avoid infinite loops\n        if count_steps > max_steps:\n            episode_end = True\n\n    return states, actions, rewards\n\nfunc_type = type(r.play_episode) # method not function\nr.play_episode = func_type(play_episode, r)","f4c18377":"#print(inspect.getsource(r.monte_carlo_learning))\n\ndef monte_carlo_learning(self, epsilon=0.1):\n        \"\"\"\n        Learn move chess through monte carlo control\n        :param epsilon: exploration rate\n        :return:\n        \"\"\"\n        state = (0, 0)\n        self.env.state = state\n\n        # Play out an episode\n        states, actions, rewards = self.play_episode(state, epsilon=epsilon)\n        \n        #print(states, actions, rewards)\n        first_visits = []\n        for idx, state in enumerate(states):\n            action_index = actions[idx]\n            if (state, action_index) in first_visits:\n                continue\n            r = np.sum(rewards[idx:])\n            if (state, action_index) in self.agent.Returns.keys():\n                self.agent.Returns[(state, action_index)].append(r)\n            else:\n                self.agent.Returns[(state, action_index)] = [r]\n            self.agent.action_function[state[0], state[1], action_index] = \\\n                np.mean(self.agent.Returns[(state, action_index)])\n            first_visits.append((state, action_index))\n        \n        #print(len(self.agent.Returns.keys()))\n        #print(self.agent.action_function.shape)\n        # Update the policy. In Monte Carlo Control, this is greedy behavior with respect to the action function\n        self.agent.policy = self.agent.action_function.copy()\n\n        \nfunc_type = type(r.monte_carlo_learning) # method not function\nr.monte_carlo_learning = func_type(monte_carlo_learning, r)","3e71a68c":"for k in range(100):\n    eps = 0.5\n    r.monte_carlo_learning(epsilon=eps)","c7984620":"for k in range(1):\n    eps = 0.1\n    r.monte_carlo_learning(epsilon=eps)\n    print(\"------------\")\n    r.visualize_policy()","e7a069df":"r.agent.action_function.max(axis=2).astype(int)","9bac4073":"p = Piece(piece='king')\nenv = Board()\nr = Reinforce(p,env)","25bbdba8":"# print(inspect.getsource(r.sarsa_td))\n\ndef sarsa_td(self, n_episodes=1000, alpha=0.01, gamma=0.9):\n        \"\"\"\n        Run the sarsa control algorithm (TD0), finding the optimal policy and action function\n        :param n_episodes: int, amount of episodes to train\n        :param alpha: learning rate\n        :param gamma: discount factor of future rewards\n        :return: finds the optimal policy for move chess\n        \"\"\"\n        print(\"-----\")\n        for k in range(n_episodes):\n            state = (0, 0)\n            self.env.state = state\n            episode_end = False\n            # go as eps \uff0c there will be less random\n            epsilon = max(1 \/ (1 + k), 0.05)\n            while not episode_end:\n                state = self.env.state\n                action_index = self.agent.apply_policy(state, epsilon)\n                action = self.agent.action_space[action_index]\n                reward, episode_end = self.env.step(action)\n                successor_state = self.env.state\n                successor_action_index = self.agent.apply_policy(successor_state, epsilon)\n\n                action_value = self.agent.action_function[state[0], state[1], action_index]\n\n                successor_action_value = self.agent.action_function[successor_state[0],\n                                                                    successor_state[1], successor_action_index]\n                q_update = alpha * (reward + gamma * successor_action_value - action_value)\n\n                self.agent.action_function[state[0], state[1], action_index] += q_update\n                \n                #print(q_update)\n                    \n                self.agent.policy = self.agent.action_function.copy()\n\n                \nfunc_type = type(r.sarsa_td) # method not function\nr.sarsa_td = func_type(sarsa_td, r)","3d29620e":"r.sarsa_td(n_episodes=1,alpha=0.2,gamma=0.9)","22ca2965":"r.visualize_policy()","24599ce6":"p = Piece(piece='king')\nenv = Board()\nr = Reinforce(p,env)","a3b3795c":"#  print(inspect.getsource(r.sarsa_lambda))\ndef sarsa_lambda(self, n_episodes=1000, alpha=0.05, gamma=0.9, lamb=0.8):\n        \"\"\"\n        Run the sarsa control algorithm (TD lambda), finding the optimal policy and action function\n        :param n_episodes: int, amount of episodes to train\n        :param alpha: learning rate\n        :param gamma: discount factor of future rewards\n        :param lamb: lambda parameter describing the decay over n-step returns\n        :return: finds the optimal move chess policy\n        \"\"\"\n        for k in range(n_episodes):\n            # only backup policy with in same eps\n            self.agent.E = np.zeros(shape=self.agent.action_function.shape)\n            state = (0, 0)\n            self.env.state = state\n            episode_end = False\n            epsilon = max(1 \/ (1 + k), 0.2)\n            action_index = self.agent.apply_policy(state, epsilon)\n            action = self.agent.action_space[action_index]\n            #print(action_index, action)\n            while not episode_end:\n                reward, episode_end = self.env.step(action)\n                successor_state = self.env.state\n                successor_action_index = self.agent.apply_policy(successor_state, epsilon)                \n                action_value = self.agent.action_function[state[0], state[1], action_index]\n                if not episode_end:\n                    successor_action_value = self.agent.action_function[successor_state[0],\n                                                                        successor_state[1], successor_action_index]\n                else:\n                    successor_action_value = 0\n                delta = reward + gamma * successor_action_value - action_value                  \n                self.agent.E[state[0], state[1], action_index] += 1\n                self.agent.action_function = self.agent.action_function + alpha * delta * self.agent.E\n                self.agent.E = gamma * lamb * self.agent.E\n                state = successor_state\n                action = self.agent.action_space[successor_action_index]\n                action_index = successor_action_index\n                #print(action)\n                self.agent.policy = self.agent.action_function.copy()\n                \nfunc_type = type(r.sarsa_lambda) # method not function\nr.sarsa_lambda = func_type(sarsa_lambda, r)","eabe0d80":"r.sarsa_lambda(n_episodes=1,alpha=0.2,gamma=0.9)","eab6ce72":"r.agent.E.shape","cf5300a8":"r.visualize_policy()","e5c7c579":"p = Piece(piece='king')\nenv = Board()\nr = Reinforce(p,env)","1bbc29b8":"#print(inspect.getsource(r.q_learning))\n\ndef q_learning(self, n_episodes=1000, alpha=0.05, gamma=0.9):\n        \"\"\"\n        Run Q-learning (also known as sarsa-max, finding the optimal policy and value function\n        :param n_episodes: int, amount of episodes to train\n        :param alpha: learning rate\n        :param gamma: discount factor of future rewards\n        :return: finds the optimal move chess policy\n        \"\"\"\n        for k in range(n_episodes):\n            state = (0, 0)\n            self.env.state = state\n            episode_end = False\n            epsilon = max(1 \/ (k + 1), 0.1)\n            while not episode_end:\n                action_index = self.agent.apply_policy(state, epsilon)\n                action = self.agent.action_space[action_index]\n                reward, episode_end = self.env.step(action)\n                successor_state = self.env.state\n                # no randomness\n                successor_action_index = self.agent.apply_policy(successor_state, -1)\n\n                action_value = self.agent.action_function[state[0], state[1], action_index]\n                \n                #   why end ep end \n                if not episode_end:\n                    successor_action_value = self.agent.action_function[successor_state[0],\n                                                                        successor_state[1], successor_action_index]\n                else:\n                    successor_action_value = 0\n                    \n                # as same a TD-sarsa\n                av_new = self.agent.action_function[state[0], state[1], action_index] + alpha * (reward +\n                                                                                                 gamma *\n                                                                                                 successor_action_value\n                                                                                                 - action_value)\n                self.agent.action_function[state[0], state[1], action_index] = av_new\n                self.agent.policy = self.agent.action_function.copy()\n                state = successor_state\n                \n                \nfunc_type = type(r.q_learning) # method not function\nr.q_learning = func_type(q_learning, r)","4fc291c5":"r.q_learning(n_episodes=1000,alpha=0.2,gamma=0.9)","787eefdd":"r.visualize_policy()","bcabb51f":"r.agent.action_function.max(axis=2).round().astype(int)","31e24281":"# Notebook II: Model-free control\nIn this notebook I use the same move-chess environment as in notebook 1. In this notebook I mentioned that policy evaluation calculates the state value by backing up the successor state values and the transition probabilities to those states. The problem is that these probabilities are usually unknown in real-world problems. Luckily there are control techniques that can work in these unknown environments. These techniques don't leverage any prior knowledge about the environment's dynamics, they are model-free.","e6aa7686":"**Demonstration**","04ef5423":"**Theory**\n* Like Policy Iteration, we can back up state-action values from the successor state action without waiting for the episode to end. \n* We update our state-action value in the direction of the successor state action value.\n* The algorithm is called SARSA: State-Action-Reward-State-Action.\n* Epsilon is gradually lowered (the GLIE property)","f6095467":"### Reinforce\n- The reinforce object contains the algorithms for solving move chess\n- The agent and the environment are attributes of the Reinforce object","f658edaa":"**Demo**  \nWe do 100 iterations of monte carlo learning while maintaining a high exploration rate of 0.5:","935bb903":"# 2.3 TD-lambda\n**Theory**  \nIn Monte Carlo we do a full-depth backup while in Temporal Difference Learning we de a 1-step backup. You could also choose a depth in-between: backup by n steps. But what value to choose for n?\n* TD lambda uses all n-steps and discounts them with factor lambda\n* This is called lambda-returns\n* TD-lambda uses an eligibility-trace to keep track of the previously encountered states\n* This way action-values can be updated in retrospect","6a4a1ce4":"**Demonstration**","f1e1135e":"**Implementation**","e2a10502":"**Implementation**","41ef7b0f":"### The agent\n- The agent is a chess Piece (king, queen, rook, knight or bishop)\n- The agent has a behavior policy determining what the agent does in what state","6de1999b":"# 2.1 Monte Carlo Control","6e5a93a8":"**Implementation**","308552e8":"### The environment\n- The state space is a 8 by 8 grid\n- The starting state S is the top-left square (0,0)\n- The terminal state F is square (5,7). \n- Every move from state to state gives a reward of minus 1\n- Naturally the best policy for this evironment is to move from S to F in the lowest amount of moves possible.","d8b67d9c":"**Theory**\n* In SARSA\/TD0, we back-up our action values with the succesor action value\n* In SARSA-max\/Q learning, we back-up using the maximum action value. ","f81663f2":"# Reinforcement Learning Chess \nReinforcement Learning Chess is a series of notebooks where I implement Reinforcement Learning algorithms to develop a chess AI. I start of with simpler versions (environments) that can be tackled with simple methods and gradually expand on those concepts untill I have a full-flegded chess AI. \n\n[**Notebook 1: Policy Iteration**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-1-policy-iteration)  \n[**Notebook 3: Q-networks**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-3-q-networks)  \n[**Notebook 4: Policy Gradients**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-4-policy-gradients)  \n[**Notebook 5: Monte Carlo Tree Search**](https:\/\/www.kaggle.com\/arjanso\/reinforcement-learning-chess-5-tree-search)  ","5334f866":"Best action value for each state:","9b18d03a":"**Demonstration**","2900c168":"**Implementation**","51dd905f":"# 2.4 Q-learning","da0bf264":"# References\n1. Reinforcement Learning: An Introduction  \n   Richard S. Sutton and Andrew G. Barto  \n   1st Edition  \n   MIT Press, march 1998\n2. RL Course by David Silver: Lecture playlist  \n   https:\/\/www.youtube.com\/watch?v=2pWv7GOvuf0&list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ","cbf46d9c":"**Theory**  \nThe basic intuition is:\n* We do not know the environment, so we sample an episode from beginning to end by running our current policy\n* We try to estimate the action-values rather than the state values. This is because we are working model-free so just knowning state values won't help us select the best actions. \n* The value of a state-action value is defined as the future returns from the first visit of that state-action\n* Based on this we can improve our policy and repeat the process untill the algorithm converges\n\n![](http:\/\/incompleteideas.net\/book\/first\/ebook\/pseudotmp5.png)","518ecc93":"# 2.2 Temporal Difference Learning "}}