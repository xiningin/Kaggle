{"cell_type":{"634bda24":"code","eb92bfdb":"code","a62845c8":"code","ddd4c137":"code","6729c5a4":"code","8c96af08":"code","96a6eb91":"markdown","9c6c4c9e":"markdown","789c5e6c":"markdown"},"source":{"634bda24":"import sys\nimport pathlib\nimport numpy as np\nimport shutil\n\nfrom sklearn.preprocessing import MinMaxScaler\nfrom keras.utils import to_categorical\nfrom sklearn.model_selection import train_test_split\n\nfrom keras.callbacks import TensorBoard, ModelCheckpoint\n\nthis = sys.modules[__name__]\nthis.logDir = None\nthis.model = None\nthis.x_train, this.x_test, this.y_train, this.y_test = None, None, None, None\n\ndef reset():\n    try:\n        shutil.rmtree(str(this.logDir))\n    except OSError as e:\n        print (\"Error: %s - %s.\" % (e.filename, e.strerror))\n\ndef load(cls, *layers, **compile):\n\tthis.model = cls(layers)\n\tthis.model.summary()\n\tckPoint = this.logDir.joinpath('checkpoint.ckpt')\n\texists = ckPoint.exists()\n\n\tif exists:\n\t\tthis.model.load_weights(str(ckPoint))\n\n\tthis.model.compile(**compile)\n\n\treturn exists\n\ndef train(batchSize, epochs=1000):\n\tmodelCheckpoint = ModelCheckpoint(\n\t\tstr(this.logDir.joinpath('checkpoint.ckpt')), save_weights_only=True, verbose=1\n\t)\n\n\ttensorboard = TensorBoard(\n\t\tlog_dir=str(this.logDir),\n\t\thistogram_freq=1,\n\t\tembeddings_freq=1,\n\t\tembeddings_layer_names=['features'],\n\t\tembeddings_metadata='metadata.tsv',\n\t\tembeddings_data=this.x_test,\n\t\tbatch_size=batchSize,\n\t\twrite_graph=True,\n\t\twrite_grads=True\n\t)\n\n\tthis.model.fit(\n\t\tthis.x_train, this.y_train,\n\t\tbatch_size=batchSize,\n\t\tepochs=epochs,\n\t\tcallbacks=[modelCheckpoint, tensorboard],\n\t\tverbose=1,\n\t\tvalidation_data=(this.x_test, this.y_test)\n\t)\n\ndef evaluate():\n\tloss, accuracy = this.model.evaluate(this.x_test, this.y_test, verbose=0)\n\tprint('\\nResults:')\n\tprint(f' > Accuracy: {round(accuracy, 3)*100}%')\n\tprint(f' > Error: {round(loss, 3)}\\n')\n\ndef init(name, x, y, outputDim, y_categorical=True):\n\n\tthis.logDir = pathlib.Path('.\/models', name)\n\tif not this.logDir.exists():\n\t\tthis.logDir.mkdir(parents=True)\n\n\tscaler = MinMaxScaler(feature_range=(0, 1))\n\tx = scaler.fit_transform(x)\n\n\tthis.x_train, this.x_test, this.y_train, this.y_test = train_test_split(\n\t\tnp.array(x), np.array(y), test_size=0.35\n\t)\n\n\twith open(str(this.logDir.joinpath('metadata.tsv')), 'w') as f:\n\t\tnp.savetxt(f, this.y_test)\n\n\tif y_categorical:\n\t\tthis.y_train = to_categorical(this.y_train, outputDim)\n\t\tthis.y_test = to_categorical(this.y_test, outputDim)\n\n\tif not this.logDir.exists():\n\t\tthis.logDir.mkdir(parents=True)\n","eb92bfdb":"from keras import Sequential\nfrom keras.layers import Dense\nfrom keras import optimizers, losses\nimport sqlite3\n\ninputDim = 4\noutputDim = 3\nbatchSize = 100\n\n### DATA ##########################\nx, y = [], []\nflowers = {'Iris-virginica': 0, 'Iris-setosa': 1, 'Iris-versicolor': 2}\nconn = sqlite3.connect('..\/input\/database.sqlite')\nfor row in conn.execute('SELECT * FROM Iris'):\n\tx.append(list(row[1:-1]))\n\ty.append(flowers[row[-1]])\n### DATA ##########################\n\ninit('iris', x, y, outputDim, y_categorical=True)","a62845c8":"reset()","ddd4c137":"exists = load(\n\tSequential,\n\n\tDense(10, activation='tanh', input_dim=inputDim, name='features'),\n\tDense(20, activation='tanh'),\n\tDense(10, activation='tanh'),\n\tDense(outputDim, activation='softmax'),\n\n\toptimizer=optimizers.Adam(),\n\tloss=losses.categorical_crossentropy,\n\tmetrics=['accuracy']\n)\n\nprint(f'\\n > Models exists: {exists}')","6729c5a4":"train(batchSize, epochs=600)","8c96af08":"evaluate()","96a6eb91":"# Model specs & train","9c6c4c9e":"# Setup utils","789c5e6c":"# Data train & test"}}