{"cell_type":{"52c2ad27":"code","4f0426c2":"code","d608d2ba":"code","b4bfd243":"code","1609a655":"code","f544b492":"code","70dc6fbf":"code","afc18613":"code","173fc130":"code","f8b5d38b":"code","a29030c0":"code","5a7381ab":"code","88d7b2dc":"code","21f965dd":"code","04db4bf8":"code","a9c40b83":"code","54223c0b":"code","e83c9e9d":"code","149ae1ab":"code","6737e3d6":"code","e59a753f":"code","0d2f3681":"code","01eb7bdd":"code","c5753dd8":"code","fddfcfcd":"markdown","d33906b4":"markdown","7f7175ce":"markdown","68d675e0":"markdown","d2454a72":"markdown","5f3a80db":"markdown","6e95f104":"markdown","95933a4b":"markdown","8a63540c":"markdown","e703c7f1":"markdown","233734f4":"markdown"},"source":{"52c2ad27":"\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n%matplotlib inline\n\nfrom math import sqrt\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n\n# Analysis imports\nfrom pandas.plotting import lag_plot\nfrom pylab import rcParams\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom pandas import DataFrame\nfrom pandas import concat\n\n# Modelling imports\nfrom statsmodels.tsa.ar_model import AR\nfrom statsmodels.tsa.arima_model import ARMA\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom fbprophet import Prophet\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM, GRU, RNN\nfrom keras.layers import Dropout","4f0426c2":"df = pd.read_csv('..\/input\/top-15-organizations-data-of-dhaka-stock-exchange\/Data_ABBANK.csv')\ndf.head()","d608d2ba":"\ndf.index  = df['date']\ndf","b4bfd243":"values = DataFrame(df['closing_price'].values)\ndataframe = concat([values.shift(1),values.shift(5),values.shift(10),values.shift(30), values], axis=1)\ndataframe.columns = ['t', 't+1', 't+5', 't+10', 't+30']\nresult = dataframe.corr()\nprint(result)","1609a655":"train_data, test_data = df[0:-60], df[-60:]\nplt.figure(figsize=(10,10))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(df['closing_price'].tail(600), 'green', label='Train data')\nplt.plot(test_data['closing_price'], 'blue', label='Test data')\nplt.legend()","f544b492":"df['closing_price']","70dc6fbf":"test_data.shape","afc18613":"train_data.closing_price.tail(30) ","173fc130":"mean_value = df['closing_price'].mean() # calculation of mean price\n\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(df['closing_price'], 'green', label='Train data')\nplt.plot(test_data['closing_price'], 'blue', label='Test data')\nplt.axhline(y=mean_value, xmin=0.864, xmax=1, color='red')\nplt.legend()\n\nplt.figure(figsize=(16,8))\nplt.grid(True)\nplt.xlabel('Dates')\nplt.ylabel('Open Prices')\nplt.plot(df['closing_price'].tail(600), 'green', label='Train data')\nplt.plot(test_data['closing_price'], 'blue', label='Test data')\nplt.axhline(y=mean_value, xmin=0.864, xmax=1, color='red')\nplt.legend()\n\nprint('MSE: '+str(mean_squared_error(test_data['closing_price'], np.full(len(test_data), mean_value))))\nprint('MAE: '+str(mean_absolute_error(test_data['closing_price'], np.full(len(test_data), mean_value))))\nprint('RMSE: '+str(sqrt(mean_squared_error(test_data['closing_price'], np.full(len(test_data), mean_value)))))","f8b5d38b":"train_arima = train_data['closing_price']\ntest_arima = test_data['closing_price']\n\nhistory = [x for x in train_arima]\ny = test_arima\n# make first prediction\npredictions = list()\nmodel = ARIMA(history, order=(1,1,0))\nmodel_fit = model.fit(disp=0)\nyhat = model_fit.forecast()[0]\npredictions.append(yhat)\nhistory.append(y[0])\n# rolling forecasts\nfor i in range(1, len(y)):\n    # predict\n    model = ARIMA(history, order=(1,1,1))\n    model_fit = model.fit(disp=0)\n    yhat = model_fit.forecast()[0]\n    # invert transformed prediction\n    predictions.append(yhat)\n    # observation\n    obs = y[i]\n    history.append(obs)\n    \nplt.figure(figsize=(14,8))\nplt.plot(df.index, df['closing_price'], color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(df.index[-600:], df['closing_price'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, y, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predictions, color = 'blue', label = 'Predicted Stock Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nprint('MSE: '+str(mean_squared_error(y, predictions)))\nprint('MAE: '+str(mean_absolute_error(y, predictions)))\nprint('RMSE: '+str(sqrt(mean_squared_error(y, predictions))))","a29030c0":"test_data.reset_index(drop=True, inplace=True)","5a7381ab":"#y_test = df.iloc[int(7200): ,0:1].values\nplt.figure(figsize=(6,3.5))\n#plt.suptitle('Sine and cosine waves', fontsize=13)\nplt.plot(predictions, color='blue', label='Predicted closing price')\nplt.plot(test_data['closing_price'], color ='red', label='Actual closing price')\nplt.xlabel('Amount of days', fontsize=10)\nplt.ylabel('Amount of price (Taka)', fontsize=10)\n#plt.xticks(rotation=0,fontsize=12)\n#plt.yticks(rotation=0,fontsize=12)\nplt.grid(True)\n#plt.savefig('ARIMA_Close_Price.jpeg')\nplt.legend()\nplt.show()","88d7b2dc":"ph_df_train = train_data.drop(['last_traded_price', 'high', 'low','opening_price',\n                               'trade','value_mn','volume','month','day_of_month',\n                               'day_of_year','day_of_week','difference'], axis=1)\nph_df_train['date'] = ph_df_train.index\nph_df_train.rename(columns={'closing_price': 'y', 'date': 'ds'}, inplace=True)\n\nprop = Prophet(changepoint_prior_scale=0.1)\nprop.fit(ph_df_train)\n# Create Future dates\nfuture_prices = prop.make_future_dataframe(periods=73)\n\n# Predict Prices\nforecast = prop.predict(future_prices)","21f965dd":"forecast['yhat']","04db4bf8":"plt.figure(figsize=(14,8))\nplt.plot(df.index, df['closing_price'], color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, test_data['closing_price'], color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, forecast['yhat'][-60:], color = 'blue', label = 'Predicted Stock Price')\nplt.fill_between(test_data.index, forecast['yhat_lower'][-60:], forecast['yhat_upper'][-60:], color='grey', label=\"Band Range\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\nplt.figure(figsize=(14,8))\nplt.plot(df.index[-600:], df['closing_price'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, test_data['closing_price'], color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, forecast['yhat'][-60:], color = 'blue', label = 'Predicted Stock Price')\nplt.fill_between(test_data.index, forecast['yhat_lower'][-60:], forecast['yhat_upper'][-60:], color='grey', label=\"Band Range\")\nplt.legend()\nplt.grid(True)\nplt.show()\nprint('MSE: '+str(mean_squared_error(test_data['closing_price'], forecast['yhat'][-60:])))\nprint('MAE: '+str(mean_absolute_error(test_data['closing_price'], forecast['yhat'][-60:])))\nprint('RMSE: '+str(sqrt(mean_squared_error(test_data['closing_price'], forecast['yhat'][-60:]))))","a9c40b83":"train = train_data.iloc[:, 1:2].values # selecting open prices\n# Feature Scaling\nscaler = MinMaxScaler()\ntrain_scaled = scaler.fit_transform(train) \n# Train dataset\ntimesteps = 7\nX_train = []\ny_train = []\nfor i in range(timesteps, train.shape[0]):\n    X_train.append(train_scaled[i-timesteps:i, 0]) # we take 30 previous prices\n    y_train.append(train_scaled[i, 0]) # and 60-th price as y value\nX_train, y_train = np.array(X_train), np.array(y_train)\n# Reshaping\nX_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))\nfrom numpy.random import seed\nseed(2019)","54223c0b":"model = Sequential()\n\n# Adding the first LSTM layer \n# Here return_sequences=True means whether to return the last output in the output sequence, or the full sequence.\n# it basically tells us that there is another(or more) LSTM layer ahead in the network.\nmodel.add(LSTM(units = 60, return_sequences = True, input_shape = (X_train.shape[1], 1)))\n# Dropout regularisation for tackling overfitting\n#model.add(Dropout(0.2))\n\nmodel.add(LSTM(units = 50))\n#model.add(Dropout(0.25))\n\n# Adding the output layer\nmodel.add(Dense(units = 1))\n\n# Compiling the RNN\n# RMSprop is a recommended optimizer as per keras documentation\n# check out https:\/\/keras.io\/optimizers\/ for more details\nmodel.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nmodel.fit(X_train, y_train, epochs = 100, batch_size = 16)","e83c9e9d":"# this will be used later while comparing and visualization\nreal_stock_price = test_data.iloc[:,1:2].values # taking open price\n# combine original train and test data vertically\n# as previous Open Prices are not present in test dataset\n# e.g. for predicting Open price for first date in test data, we will need stock open prices on timesteps previous dates  \ncombine = pd.concat((train_data['closing_price'], test_data['closing_price']), axis = 0)\n# our test inputs also contains stock open Prices of last timesteps dates (as described above)\ntest_inputs = combine[len(combine) - len(test_data) - timesteps:].values\ntest_inputs = test_inputs.reshape(-1,1)\ntest_inputs = scaler.transform(test_inputs)\n# same steps as we followed while processing training data\nX_test = []\nfor i in range(timesteps, test_data.shape[0]+timesteps):\n    X_test.append(test_inputs[i-timesteps:i, 0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))\npredicted_stock_price = model.predict(X_test)\n# inverse_transform because prediction is done on scaled inputs\npredicted_stock_price = scaler.inverse_transform(predicted_stock_price)","149ae1ab":"plt.figure(figsize=(16,8))\nplt.plot(df.index[-600:], df['closing_price'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, real_stock_price, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predicted_stock_price, color = 'blue', label = 'Predicted Stock Price')\nplt.title('Dhaka Stock Exchange Closing price Prediction')\nplt.xlabel('Time')\nplt.ylabel('Dhaka Stock Exchange Closing price')\nplt.legend()\nplt.grid(True)\n#plt.savefig('lstm_30.pdf')\nplt.show()\n\nmse = mean_squared_error(real_stock_price, predicted_stock_price)\nprint('MSE: '+str(mse))\nmae = mean_absolute_error(real_stock_price, predicted_stock_price)\nprint('MAE: '+str(mae))\nrmse = sqrt(mean_squared_error(real_stock_price, predicted_stock_price))\nprint('RMSE: '+str(rmse))","6737e3d6":"test_data.reset_index(drop=True, inplace=True)\n#y_test = df.iloc[int(7200): ,0:1].values\nplt.figure(figsize=(6,3.5))\n#plt.suptitle('Sine and cosine waves', fontsize=13)\nplt.plot(predicted_stock_price, color='blue', label='Predicted Opening Price')\nplt.plot(test_data['closing_price'], color ='red', label='Actual Opening Price')\nplt.xlabel('Amount of days', fontsize=10)\nplt.ylabel('Amount of price (Taka)', fontsize=10)\n#plt.xticks(rotation=0,fontsize=12)\n#plt.yticks(rotation=0,fontsize=12)\nplt.grid(True)\n#plt.savefig('LSTM_opening_price.jpeg')\nplt.legend()\nplt.show()","e59a753f":"model = Sequential()\n\n# Adding the first GRU layer \n# Here return_sequences=True means whether to return the last output in the output sequence, or the full sequence.\n# it basically tells us that there is another(or more) GRU layer ahead in the network.\nmodel.add(GRU(units = 60, return_sequences = True, input_shape = (X_train.shape[1], 1)))\n# Dropout regularisation for tackling overfitting\nmodel.add(Dropout(0.2))\n\nmodel.add(GRU(units = 50))\nmodel.add(Dropout(0.25))\n\n# Adding the output layer\nmodel.add(Dense(units = 1))\n\n# Compiling the RNN\n# RMSprop is a recommended optimizer as per keras documentation\n# check out https:\/\/keras.io\/optimizers\/ for more details\nmodel.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nmodel.fit(X_train, y_train, epochs = 200, batch_size = 16)","0d2f3681":"# this will be used later while comparing and visualization\nreal_stock_price_GRU = test_data.iloc[:,1:2].values # taking open price\n# combine original train and test data vertically\n# as previous Open Prices are not present in test dataset\n# e.g. for predicting Open price for first date in test data, we will need stock open prices on timesteps previous dates  \ncombine = pd.concat((train_data['closing_price'], test_data['closing_price']), axis = 0)\n# our test inputs also contains stock open Prices of last timesteps dates (as described above)\ntest_inputs = combine[len(combine) - len(test_data) - timesteps:].values\ntest_inputs = test_inputs.reshape(-1,1)\ntest_inputs = scaler.transform(test_inputs)\n# same steps as we followed while processing training data\nX_test = []\nfor i in range(timesteps, test_data.shape[0]+timesteps):\n    X_test.append(test_inputs[i-timesteps:i, 0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))\npredicted_stock_price_GRU = model.predict(X_test)\n# inverse_transform because prediction is done on scaled inputs\npredicted_stock_price_GRU = scaler.inverse_transform(predicted_stock_price_GRU)","01eb7bdd":"plt.figure(figsize=(16,8))\nplt.plot(df.index[-600:], df['closing_price'].tail(600), color='green', label = 'Train Stock Price')\nplt.plot(test_data.index, real_stock_price_GRU, color = 'red', label = 'Real Stock Price')\nplt.plot(test_data.index, predicted_stock_price_GRU, color = 'blue', label = 'Predicted Stock Price')\nplt.title('Dhaka Stock Exchange Closing price Prediction')\nplt.xlabel('Time')\nplt.ylabel('Dhaka Stock Exchange Closing price')\nplt.legend()\nplt.grid(True)\nplt.savefig('lstm_30.pdf')\nplt.show()\n\nmse = mean_squared_error(real_stock_price_GRU, predicted_stock_price_GRU)\nprint('MSE: '+str(mse))\nmae = mean_absolute_error(real_stock_price_GRU, predicted_stock_price_GRU)\nprint('MAE: '+str(mae))\nrmse = sqrt(mean_squared_error(real_stock_price_GRU, predicted_stock_price_GRU))\nprint('RMSE: '+str(rmse))","c5753dd8":"plt.figure(figsize=(16,8))\n#print('Lag: %s' % model_fit.k_ar)\nplt.plot(df.index[-100:], df['closing_price'].tail(100), color='green', label='Close price')\nplt.plot(test_data.index, test_data['closing_price'], color='red', label='Test close price')\nplt.plot(test_data.index, predicted_stock_price_GRU, color='blue', label='Predicted close price')\nplt.xlabel('Date', fontsize=10)\nplt.xticks(rotation=90,fontsize=7)\n#plt.grid(True)\nplt.legend()","fddfcfcd":"Predicted result for ARIMA model","d33906b4":"LSTM model training","7f7175ce":"Split train and test data","68d675e0":"Training data by GRU model","d2454a72":"Show the closing_price column data","5f3a80db":"Pre-process data for Prophet model","6e95f104":"Take closing_price for prediction","95933a4b":"We take 60 days data to test our models","8a63540c":"input data of ABBANK","e703c7f1":"Predicted result for LSTM model","233734f4":"Train data for ARIMA model"}}