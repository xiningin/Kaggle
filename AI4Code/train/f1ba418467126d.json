{"cell_type":{"ded49497":"code","001d9f5e":"code","b7bbd07c":"code","c3f43aff":"code","0b854218":"code","c1686fd9":"code","9675298d":"code","da474b8f":"code","7c0b9e95":"code","c07e97a5":"code","9a9b2cc6":"code","9dfe3cd3":"code","a400c688":"code","7fa92d4f":"code","04c10527":"code","6754a8b5":"code","704a3551":"code","94ace3ba":"code","7dbbd3cb":"code","4aac68be":"code","6c720f73":"code","f93c4cdc":"markdown","c32b908c":"markdown","9bec94e8":"markdown","b9914961":"markdown","8182d023":"markdown","5cd5912a":"markdown","7b6e4652":"markdown","52109c79":"markdown"},"source":{"ded49497":"import torch","001d9f5e":"#Example 1\na=torch.tensor([1])\ntorch.is_tensor(a)","b7bbd07c":"#Example 2\nb=torch.tensor([[1,1],[2,4]])\ntorch.is_tensor(b)","c3f43aff":"x=torch.ones(2,2,3)\nprint(x)\n#few more operations \n#(R,C)\ny= torch.ones(3,2)\nprint(y)\nw=torch.ones(1,2)+3\nprint(w)","0b854218":"print(torch.numel(x))\n#2*2*3\nprint(torch.numel(y))\nprint(torch.numel(w))\nprint(torch.numel(y[1]))\nprint(torch.numel(x[0][1]))\nprint(torch.numel(x[0][1][2]))\n#torch.numel(x+y)\n#to perfrom this operation both x and y should be of same size","c1686fd9":"x1 = torch.rand(2,3) \ny1 = torch.rand(3,4) ","9675298d":"print(x1)\nprint(y1)","da474b8f":"import numpy as np\nx3=np.zeros((2,2))","7c0b9e95":"print(x3)","c07e97a5":"type(x3)","9a9b2cc6":"X=torch.as_tensor(x3)","9dfe3cd3":"print(X)","a400c688":"xy=np.arange(1,8,2)\nprint(xy)\nxy1=np.arange(1,10,3)\nprint(xy1)\n#arange([start,] stop[, step,][, dtype]) \n\"\"\"start : [optional] start of interval range. By default start = 0\nstop  : end of interval range\nstep  : [optional] step size of interval. By default step size = 1,  \nFor any output out, this is the distance between two adjacent values, out[i+1] - out[i]. \ndtype : type of output array\"\"\"\n#refer https:\/\/www.geeksforgeeks.org\/numpy-arange-python\/","7fa92d4f":"A=torch.as_tensor(xy,xy1)\n#as_tensor() takes 1 positional argument but 2 were given","04c10527":"X","6754a8b5":"gen=torch.empty(X)\n#doesnt work when you pass tensor as an argument always pass shape of a tensor","704a3551":"input=torch.empty(X.shape)\nprint(input)","94ace3ba":"c=np.arange(6)\nprint(c)","7dbbd3cb":"C=torch.empty(c.shape)\nprint(C)","4aac68be":"X","6c720f73":"torch.unbind(X)","f93c4cdc":"## Reference Links\nProvide links to your references and other interesting articles about tensors\n* Official documentation for `torch.Tensor`: https:\/\/pytorch.org\/docs\/stable\/tensors.html","c32b908c":"# Function 1 - torch.is_tensor ()\n\nto check if the given input is either or tensor or not besides that \nthere are some more parameters to check if the tensor belongs to that particular data type","9bec94e8":"# Function 2 - torch.numel ()\n##https:\/\/www.codementor.io\/@packt\/how-to-perform-basic-operations-in-pytorch-code-10al39a4c4\n##refer link\nthis function is used to check the number of elements present in a tensor","b9914961":"# Function 5 - torch.unbind()\n\nThis function is used to separate the tensors with in a tensor, \nthis division or extraction of tensors can be done according to the shapes we want ","8182d023":"# Function 3 - torch.as_tensor()","5cd5912a":"# Assignment1\n\n### Pytorch functions\nTensors are a type of data structure used in linear algebra, and like vectors and matrices, you can calculate arithmetic operations with tensors. After completing this tutorial, you will know: That tensors are a generalization of matrices and are represented using n-dimensional arrays.\n\nA short introduction about PyTorch and about the chosen functions. \n- torch.is_sensor()\n- torch.numel()\n- torch.as_tensor()\n- torch.empty()\n- torch.unbind()","7b6e4652":"## Conclusion\n\nthis notebook covers some of the basics of tensors and how they work briefly, \nwhat can be the exceptions while using the pytorch is explained by the errors ","52109c79":"# Function 4 - torch.empty()\n\nthis function is used to create an empty tensor of some particular \nsize that be filled with zeros, those can intuted with ones as shown below\nThe advantage of torch.empty is that it\u2019s faster, because it will just assign the memory to the tensor without filling it with specific values. This is often used, if you need a buffer, which is guaranteed to be filled with other values later (or initialized somehow)."}}