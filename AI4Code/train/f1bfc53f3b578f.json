{"cell_type":{"be062ccc":"code","c49dd88a":"code","82cb2397":"code","16198c5a":"code","a1848adc":"code","c87e1a1a":"code","e4c76b52":"code","66ee7c08":"code","3882df23":"code","b1f828e9":"code","0d3ecad9":"code","57669de5":"code","836dc0a0":"code","72b437b6":"code","cf01f8f7":"code","8f575583":"code","464eb98b":"code","78441f8c":"code","feb335df":"code","fd0e8be7":"code","3823a2d3":"code","14c72532":"code","3489cf82":"code","d64e2dbe":"code","4a2860ef":"code","1a57d11e":"code","fec21cdc":"code","a5702847":"code","f6615222":"code","598c473c":"markdown","db4fac10":"markdown","8b99fb22":"markdown","fd7627ef":"markdown","680e987f":"markdown","ecf0bb1d":"markdown","61e891c4":"markdown"},"source":{"be062ccc":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c49dd88a":"from keras.datasets.mnist import load_data\n\n(X_train,y_train),(X_test,y_test)=load_data()\n\n\nprint('Train', X_train.shape, y_train.shape)\nprint('Test', X_test.shape, y_test.shape)","82cb2397":"import matplotlib.pyplot as plt\n\nplt.imshow(X_train[0], cmap='gray')","16198c5a":"from matplotlib import pyplot\n# load the images into memory\n(trainX, trainy), (testX, testy) = load_data()\n# plot images from the training dataset\nfor i in range(25):\n\t# define subplot\n\tpyplot.subplot(5, 5, 1 + i)\n\t# turn off axis\n\tpyplot.axis('off')\n\t# plot raw pixel data\n\tpyplot.imshow(trainX[i], cmap='gray_r')\npyplot.show()","a1848adc":"from keras.models import Sequential\nfrom keras.optimizers import Adam\nfrom keras.layers import Dense\nfrom keras.layers import Conv2D\nfrom keras.layers import Flatten\nfrom keras.layers import Dropout\nfrom keras.layers import LeakyReLU\nfrom keras.utils.vis_utils import plot_model\n\ndef define_discriminator(in_shape = (28,28,1)):\n    \n    model = Sequential()\n    model.add(Conv2D(64,(3,3),strides=(2,2),padding='same',input_shape=in_shape))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Dropout(0.4))\n    model.add(Conv2D(64, (3,3), strides=(2, 2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Dropout(0.4))\n    model.add(Flatten())\n    model.add(Dense(1, activation='sigmoid'))\n    \n    opt = Adam(lr=0.0002, beta_1=0.5)\n    model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])\n    return model\n    \n    \nmodel = define_discriminator()\nmodel.summary()\n\nplot_model(model, to_file='discriminator_plot.png', show_shapes=True, show_layer_names=True)  \n    \n    ","c87e1a1a":"trainX.shape","e4c76b52":"import numpy as np\n#The images are 2D arrays of pixels and convolutional neural networks expect 3D arrays of images as input, where each image has one or more channels.\ndef load_real_samples():\n    # load mnist dataset\n    (trainX, _), (_, _) = load_data()\n    # expand to 3d, e.g. add channels dimension\n    X = np.expand_dims(trainX, axis=-1)\n    # convert from unsigned ints to floats\n    X = X.astype('float32')\n    # scale from [0,255] to [0,1]\n    X = X \/ 255.0\n    return X","66ee7c08":"np.random.randint(0,10,8)","3882df23":"# select real samples\ndef generate_real_samples(dataset, n_samples):\n    # choose random instances\n    ix = np.random.randint(0, dataset.shape[0], n_samples)\n        #ix range from 0 to 60000   ix size =150\n    # retrieve selected images\n    X = dataset[ix]\n    # generate 'real' class labels (1)\n    y = np.ones((n_samples, 1))\n    return X, y","b1f828e9":"# generate n fake samples with class labels\ndef generate_fake_samples(n_samples):\n    # generate uniform random numbers in [0,1]\n    X = np.random.rand(28 * 28 * n_samples)\n    # reshape into a batch of grayscale images\n    X = X.reshape((n_samples, 28, 28, 1))\n    # generate 'fake' class labels (0)\n    y = np.zeros((n_samples, 1))\n    return X, y","0d3ecad9":"#The train_discriminator() function implements this, using a batch size of 256 images where 128 are real and 128 are fake each iteration.\n\n# train the discriminator model\ndef train_discriminator(model, dataset, n_iter=100, n_batch=256):\n    half_batch = int(n_batch \/ 2)\n    # manually enumerate epochs\n    for i in range(n_iter):\n        # get randomly selected 'real' samples\n        X_real, y_real = generate_real_samples(dataset, half_batch)\n        # update discriminator on real samples\n        _, real_acc = model.train_on_batch(X_real, y_real)\n        # generate 'fake' examples\n        X_fake, y_fake = generate_fake_samples(half_batch)\n        # update discriminator on fake samples\n        _, fake_acc = model.train_on_batch(X_fake, y_fake)\n        # summarize performance\n        print('>%d real=%.0f%% fake=%.0f%%' % (i+1, real_acc*100, fake_acc*100))","57669de5":"model = define_discriminator()\n# load image data\ndataset = load_real_samples()\n#      dataset size 60000*28*28*!\n# fit the model\ntrain_discriminator(model, dataset)","836dc0a0":"from keras.layers import Conv2DTranspose\nfrom keras.layers import Reshape\n\ndef define_generator(latent_dim):\n    \n    model=Sequential()\n    n_nodes = 7*7*128\n    model.add(Dense(n_nodes,input_dim=latent_dim))\n    # try to build 2 layer neural network of latent_dim inputs and n_node output\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Reshape((7, 7,128)))\n    # upsample to 14x14\n    model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    # upsample to 28x28\n    model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Conv2D(1, (7,7), activation='sigmoid', padding='same'))\n    #  generated one image of 28*28 \n    \n    return model\n \n# define the size of the latent space\nlatent_dim = 100\n# define the generator model\nmodel = define_generator(latent_dim)\n# summarize the model\nmodel.summary()\n# plot the model\nplot_model(model, to_file='generator_plot.png', show_shapes=True, show_layer_names=True)\n    \n    \n    \n    ","72b437b6":"# generate points in latent space as input for the generator\ndef generate_latent_points(latent_dim, n_samples):\n# generate points in the latent space\n    x_input = np.random.randn(latent_dim * n_samples)\n    # reshape into a batch of inputs for the network\n    x_input = x_input.reshape(n_samples, latent_dim)\n    return x_input","cf01f8f7":"# use the generator to generate n fake examples, with class labels\ndef generate_fake_samples(g_model, latent_dim, n_samples):\n    # generate points in latent space\n    x_input = generate_latent_points(latent_dim, n_samples)\n    # predict outputs\n    X = g_model.predict(x_input)\n    # create 'fake' class labels (0)\n    y = np.zeros((n_samples, 1))\n    return X, y","8f575583":"latent_dim = 100\n# define the discriminator model\nmodel = define_generator(latent_dim)\n# generate samples\nn_samples = 25\nX, _ = generate_fake_samples(model, latent_dim, n_samples)\n# plot the generated samples\nfor i in range(n_samples):\n\t# define subplot\n\tpyplot.subplot(5, 5, 1 + i)\n\t# turn off axis labels\n\tpyplot.axis('off')\n\t# plot single image\n\tpyplot.imshow(X[i, :, :, 0], cmap='gray_r')\n# show the figure\npyplot.show()","464eb98b":"\n# define the combined generator and discriminator model, for updating the generator\ndef define_gan(g_model, d_model):\n    # make weights in the discriminator not trainable\n    d_model.trainable = False\n    # connect them\n    model = Sequential()\n    # add generator\n    model.add(g_model)\n    # add the discriminator\n    model.add(d_model)\n    # compile model\n    opt = Adam(lr=0.0002, beta_1=0.5)\n    model.compile(loss='binary_crossentropy', optimizer=opt)\n    return model","78441f8c":"latent_dim = 100\n# create the discriminator\nd_model = define_discriminator()\n# create the generator\ng_model = define_generator(latent_dim)\n# create the gan\ngan_model = define_gan(g_model, d_model)\n# summarize gan model\ngan_model.summary()\n# plot gan model\nplot_model(gan_model, to_file='gan_plot.png', show_shapes=True, show_layer_names=True)","feb335df":"# train the composite model\ndef train_gan(gan_model, latent_dim, n_epochs=100, n_batch=256):\n# manually enumerate epochs\n    for i in range(n_epochs):\n        # prepare points in latent space as input for the generator\n        x_gan = generate_latent_points(latent_dim, n_batch)\n        # create inverted labels for the fake samples\n        y_gan = ones((n_batch, 1))\n        # update the generator via the discriminator's error\n        gan_model.train_on_batch(x_gan, y_gan)","fd0e8be7":"def train(g_model, d_model, gan_model, dataset, latent_dim, n_epochs=100, n_batch=256):\n\tbat_per_epo = int(dataset.shape[0] \/ n_batch)\n\thalf_batch = int(n_batch \/ 2)\n\t# manually enumerate epochs\n\tfor i in range(n_epochs):\n\t\t# enumerate batches over the training set\n\t\tfor j in range(bat_per_epo):\n\t\t\t# get randomly selected 'real' samples\n\t\t\tX_real, y_real = generate_real_samples(dataset, half_batch)\n\t\t\t# generate 'fake' examples\n\t\t\tX_fake, y_fake = generate_fake_samples(g_model, latent_dim, half_batch)\n\t\t\t# create training set for the discriminator\n\t\t\tX, y = vstack((X_real, X_fake)), vstack((y_real, y_fake))\n\t\t\t# update discriminator model weights\n\t\t\td_loss, _ = d_model.train_on_batch(X, y)\n\t\t\t# prepare points in latent space as input for the generator\n\t\t\tX_gan = generate_latent_points(latent_dim, n_batch)\n\t\t\t# create inverted labels for the fake samples\n\t\t\ty_gan = ones((n_batch, 1))\n\t\t\t# update the generator via the discriminator's error\n\t\t\tg_loss = gan_model.train_on_batch(X_gan, y_gan)\n\t\t\t# summarize loss on this batch\n\t\t\tprint('>%d, %d\/%d, d=%.3f, g=%.3f' % (i+1, j+1, bat_per_epo, d_loss, g_loss))","3823a2d3":"\ndef summarize_performance(epoch, g_model, d_model, dataset, latent_dim, n_samples=100):\n\t# prepare real samples\n\tX_real, y_real = generate_real_samples(dataset, n_samples)\n\t# evaluate discriminator on real examples\n\t_, acc_real = d_model.evaluate(X_real, y_real, verbose=0)\n\t# prepare fake examples\n\tx_fake, y_fake = generate_fake_samples(g_model, latent_dim, n_samples)\n\t# evaluate discriminator on fake examples\n\t_, acc_fake = d_model.evaluate(x_fake, y_fake, verbose=0)\n\t# summarize discriminator performance\n\tprint('>Accuracy real: %.0f%%, fake: %.0f%%' % (acc_real*100, acc_fake*100))","14c72532":"\n# train the generator and discriminator\ndef train(g_model, d_model, gan_model, dataset, latent_dim, n_epochs=100, n_batch=256):\n\tbat_per_epo = int(dataset.shape[0] \/ n_batch)\n\thalf_batch = int(n_batch \/ 2)\n\t# manually enumerate epochs\n\tfor i in range(n_epochs):\n        # evaluate the model performance, sometimes\n        if (i+1) % 10 == 0:\n            summarize_performance(i, g_model, d_model, dataset, latent_dim)","3489cf82":"filename = 'generator_model_%03d.h5' % (epoch + 1)\ng_model.save(filename)","d64e2dbe":"def save_plot(examples, epoch, n=10):\n\t# plot images\n\tfor i in range(n * n):\n\t\t# define subplot\n\t\tpyplot.subplot(n, n, 1 + i)\n\t\t# turn off axis\n\t\tpyplot.axis('off')\n\t\t# plot raw pixel data\n\t\tpyplot.imshow(examples[i, :, :, 0], cmap='gray_r')\n\t# save plot to file\n\tfilename = 'generated_plot_e%03d.png' % (epoch+1)\n\tpyplot.savefig(filename)\n\tpyplot.close()","4a2860ef":"def summarize_performance(epoch, g_model, d_model, dataset, latent_dim, n_samples=100):\n\t# prepare real samples\n\tX_real, y_real = generate_real_samples(dataset, n_samples)\n\t# evaluate discriminator on real examples\n\t_, acc_real = d_model.evaluate(X_real, y_real, verbose=0)\n\t# prepare fake examples\n\tx_fake, y_fake = generate_fake_samples(g_model, latent_dim, n_samples)\n\t# evaluate discriminator on fake examples\n\t_, acc_fake = d_model.evaluate(x_fake, y_fake, verbose=0)\n\t# summarize discriminator performance\n\tprint('>Accuracy real: %.0f%%, fake: %.0f%%' % (acc_real*100, acc_fake*100))\n\t# save plot\n\tsave_plot(x_fake, epoch)\n\t# save the generator model tile file\n\tfilename = 'generator_model_%03d.h5' % (epoch + 1)\n\tg_model.save(filename)","1a57d11e":"# example of training a gan on mnist\nfrom numpy import expand_dims\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import vstack\nfrom numpy.random import randn\nfrom numpy.random import randint\nfrom keras.datasets.mnist import load_data\nfrom keras.optimizers import Adam\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import Reshape\nfrom keras.layers import Flatten\nfrom keras.layers import Conv2D\nfrom keras.layers import Conv2DTranspose\nfrom keras.layers import LeakyReLU\nfrom keras.layers import Dropout\nfrom matplotlib import pyplot\n \n# define the standalone discriminator model\ndef define_discriminator(in_shape=(28,28,1)):\n    model = Sequential()\n    model.add(Conv2D(64, (3,3), strides=(2, 2), padding='same', input_shape=in_shape))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Dropout(0.4))\n    model.add(Conv2D(64, (3,3), strides=(2, 2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Dropout(0.4))\n    model.add(Flatten())\n    model.add(Dense(1, activation='sigmoid'))\n    # compile model\n    opt = Adam(lr=0.0002, beta_1=0.5)\n    model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])\n    return model\n \n# define the standalone generator model\ndef define_generator(latent_dim):\n    model = Sequential()\n    # foundation for 7x7 image\n    n_nodes = 128 * 7 * 7\n    model.add(Dense(n_nodes, input_dim=latent_dim))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Reshape((7, 7, 128)))\n    # upsample to 14x14\n    model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    # upsample to 28x28\n    model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(Conv2D(1, (7,7), activation='sigmoid', padding='same'))\n    return model\n \n# define the combined generator and discriminator model, for updating the generator\ndef define_gan(g_model, d_model):\n    # make weights in the discriminator not trainable\n    d_model.trainable = False\n    # connect them\n    model = Sequential()\n    # add generator\n    model.add(g_model)\n    # add the discriminator\n    model.add(d_model)\n    # compile model\n    opt = Adam(lr=0.0002, beta_1=0.5)\n    model.compile(loss='binary_crossentropy', optimizer=opt)\n    return model\n \n# load and prepare mnist training images\ndef load_real_samples():\n    # load mnist dataset\n    (trainX, _), (_, _) = load_data()\n    # expand to 3d, e.g. add channels dimension\n    X = expand_dims(trainX, axis=-1)\n    # convert from unsigned ints to floats\n    X = X.astype('float32')\n    # scale from [0,255] to [0,1]\n    X = X \/ 255.0\n    return X\n \n# select real samples\ndef generate_real_samples(dataset, n_samples):\n    # choose random instances\n    ix = randint(0, dataset.shape[0], n_samples)\n    # retrieve selected images\n    X = dataset[ix]\n    # generate 'real' class labels (1)\n    y = ones((n_samples, 1))\n    return X, y\n \n# generate points in latent space as input for the generator\ndef generate_latent_points(latent_dim, n_samples):\n    # generate points in the latent space\n    x_input = randn(latent_dim * n_samples)\n    # reshape into a batch of inputs for the network\n    x_input = x_input.reshape(n_samples, latent_dim)\n    return x_input\n \n# use the generator to generate n fake examples, with class labels\ndef generate_fake_samples(g_model, latent_dim, n_samples):\n    # generate points in latent space\n    x_input = generate_latent_points(latent_dim, n_samples)\n    # predict outputs\n    X = g_model.predict(x_input)\n    # create 'fake' class labels (0)\n    y = zeros((n_samples, 1))\n    return X, y\n \n# create and save a plot of generated images (reversed grayscale)\ndef save_plot(examples, epoch, n=10):\n    # plot images\n    for i in range(n * n):\n        # define subplot\n        pyplot.subplot(n, n, 1 + i)\n        # turn off axis\n        pyplot.axis('off')\n        # plot raw pixel data\n        pyplot.imshow(examples[i, :, :, 0], cmap='gray_r')\n    # save plot to file\n    filename = 'generated_plot_e%03d.png' % (epoch+1)\n    pyplot.savefig(filename)\n    pyplot.close()\n \n# evaluate the discriminator, plot generated images, save generator model\ndef summarize_performance(epoch, g_model, d_model, dataset, latent_dim, n_samples=100):\n    # prepare real samples\n    X_real, y_real = generate_real_samples(dataset, n_samples)\n    # evaluate discriminator on real examples\n    _, acc_real = d_model.evaluate(X_real, y_real, verbose=0)\n    # prepare fake examples\n    x_fake, y_fake = generate_fake_samples(g_model, latent_dim, n_samples)\n    # evaluate discriminator on fake examples\n    _, acc_fake = d_model.evaluate(x_fake, y_fake, verbose=0)\n    # summarize discriminator performance\n    print('>Accuracy real: %.0f%%, fake: %.0f%%' % (acc_real*100, acc_fake*100))\n    # save plot\n    save_plot(x_fake, epoch)\n    # save the generator model tile file\n    filename = 'generator_model_%03d.h5' % (epoch + 1)\n    g_model.save(filename)\n \n# train the generator and discriminator\ndef train(g_model, d_model, gan_model, dataset, latent_dim, n_epochs=100, n_batch=256):\n    bat_per_epo = int(dataset.shape[0] \/ n_batch)\n    half_batch = int(n_batch \/ 2)\n    # manually enumerate epochs\n    for i in range(n_epochs):\n        # enumerate batches over the training set\n        for j in range(bat_per_epo):\n            # get randomly selected 'real' samples\n            X_real, y_real = generate_real_samples(dataset, half_batch)\n            # generate 'fake' examples\n            X_fake, y_fake = generate_fake_samples(g_model, latent_dim, half_batch)\n            # create training set for the discriminator\n            X, y = vstack((X_real, X_fake)), vstack((y_real, y_fake))\n            # update discriminator model weights\n            d_loss, _ = d_model.train_on_batch(X, y)\n            # prepare points in latent space as input for the generator\n            X_gan = generate_latent_points(latent_dim, n_batch)\n            # create inverted labels for the fake samples\n            y_gan = ones((n_batch, 1))\n            # update the generator via the discriminator's error\n            g_loss = gan_model.train_on_batch(X_gan, y_gan)\n            # summarize loss on this batch\n            print('>%d, %d\/%d, d=%.3f, g=%.3f' % (i+1, j+1, bat_per_epo, d_loss, g_loss))\n        # evaluate the model performance, sometimes\n        if (i+1) % 10 == 0:\n            summarize_performance(i, g_model, d_model, dataset, latent_dim)\n \n# size of the latent space\nlatent_dim = 100\n# create the discriminator\nd_model = define_discriminator()\n# create the generator\ng_model = define_generator(latent_dim)\n# create the gan\ngan_model = define_gan(g_model, d_model)\n# load image data\ndataset = load_real_samples()\n# train model\ntrain(g_model, d_model, gan_model, dataset, latent_dim)","fec21cdc":"!ls","a5702847":"from keras.models import load_model\nfrom numpy.random import randn\nfrom matplotlib import pyplot\n \n# generate points in latent space as input for the generator\ndef generate_latent_points(latent_dim, n_samples):\n\t# generate points in the latent space\n\tx_input = randn(latent_dim * n_samples)\n\t# reshape into a batch of inputs for the network\n\tx_input = x_input.reshape(n_samples, latent_dim)\n\treturn x_input\n \n# create and save a plot of generated images (reversed grayscale)\ndef save_plot(examples, n):\n\t# plot images\n\tfor i in range(n * n):\n\t\t# define subplot\n\t\tpyplot.subplot(n, n, 1 + i)\n\t\t# turn off axis\n\t\tpyplot.axis('off')\n\t\t# plot raw pixel data\n\t\tpyplot.imshow(examples[i, :, :, 0], cmap='gray_r')\n\tpyplot.show()\n \n# load model\nmodel = load_model('generator_model_100.h5')\n# generate images\nlatent_points = generate_latent_points(100, 25)\n# generate images\nX = model.predict(latent_points)\n# plot the result\nsave_plot(X, 5)","f6615222":"\n# example of generating an image for a specific point in the latent space\nfrom keras.models import load_model\nfrom numpy import asarray\nfrom matplotlib import pyplot\n# load model\nmodel = load_model('generator_model_100.h5')\n# all 0s\nvector = asarray([[0.0 for _ in range(100)]])\n# generate image\nX = model.predict(vector)\n# plot the result\npyplot.imshow(X[0, :, :, 0], cmap='gray_r')\npyplot.show()","598c473c":"### The generator model is responsible for creating new, fake but plausible images of handwritten digits.\n","db4fac10":"## discriminator model.\n\nThe model must take a sample image from our dataset as input and output a classification prediction as to whether the sample is real or fake.\n\nThis is a binary classification problem:\n\n    Inputs: Image with one channel and 28\u00d728 pixels in size.\n    Outputs: Binary classification, likelihood the sample is real (or fake).\n\nThe discriminator model has two convolutional layers with 64 filters each, a small kernel size of 3, and larger than normal stride of 2. The model has no pooling layers and a single node in the output layer with the sigmoid activation function to predict whether the input sample is real or fake. The model is trained to minimize the binary cross entropy loss function, appropriate for binary classification.","8b99fb22":"### The generate_real_samples() function below will take the training dataset as an argument and will select a random subsample of images; it will also return class labels for the sample, specifically a class label of 1, to indicate real images.","fd7627ef":"#### generater uses a vector reshapes it into default size of image  ","680e987f":"### The weights in the generator model are updated based on the performance of the discriminator model.\n\nWhen the discriminator is good at detecting fake samples, the generator is updated more, and when the discriminator model is relatively poor or confused when detecting fake samples, the generator model is updated less.","ecf0bb1d":"### The generate_fake_samples() function below implements this behavior and generates images of random pixel values and their associated class label of 0, for fake","61e891c4":"### Instead, what is required is that we first update the discriminator model with real and fake samples, then update the generator via the composite model.\n\nThis requires combining elements from the train_discriminator() function defined in the discriminator section above and the train_gan() function defined above. It also requires that we enumerate over both epochs and batches within in an epoch."}}