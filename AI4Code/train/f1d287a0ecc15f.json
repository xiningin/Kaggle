{"cell_type":{"f914e5e4":"code","bb494035":"code","ef37d63e":"code","05629644":"code","f7844bc4":"code","65e07613":"code","0cde5bca":"code","b91d1d1b":"code","a4a91182":"code","db7757a6":"code","4f5f0672":"code","4f4874b3":"code","85cac4f6":"code","7652cc82":"markdown","ad3cd5d9":"markdown","094b5fa6":"markdown","8fc364cf":"markdown","eeb674a2":"markdown","e158428f":"markdown","e13525fb":"markdown","02a41da5":"markdown","d6ec64b9":"markdown","2368f671":"markdown","3d459ede":"markdown","3277d85b":"markdown","42d2c8a6":"markdown","5953004d":"markdown","cb273547":"markdown"},"source":{"f914e5e4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport random\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","bb494035":"deck = 4 * ([str(i) for i in range(2, 11)] + ['J', 'Q', 'K', 'A'])\n\nprint(deck)","ef37d63e":"table_soft_totals = [ # use when player hand has at least one ace\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #2\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #3\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #4\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #5\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #6\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #7\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #8\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #9\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #10\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #11\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #12\n    [' ',' ','H','H','H','D','D','H','H','H','H','H'], #13\n    [' ',' ','H','H','H','D','D','H','H','H','H','H'], #14\n    [' ',' ','H','H','D','D','D','H','H','H','H','H'], #15\n    [' ',' ','H','H','D','D','D','H','H','H','H','H'], #16\n    [' ',' ','H','D','D','D','D','H','H','H','H','H'], #17\n    [' ',' ','D','D','D','D','D','S','S','H','H','H'], #18\n    [' ',' ','S','S','S','S','D','S','S','S','S','S'], #19\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #20\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #21\n]    \n\ntable_hard_totals = [ # use when there are no aces\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #2\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #3\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #4\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #5\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #6\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #7\n    [' ',' ','H','H','H','H','H','H','H','H','H','H'], #8\n    [' ',' ','H','D','D','D','D','H','H','H','H','H'], #9\n    [' ',' ','D','D','D','D','D','D','D','D','H','H'], #10\n    [' ',' ','D','D','D','D','D','D','D','D','D','D'], #11\n    [' ',' ','H','H','S','S','S','H','H','H','H','H'], #12\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #13\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #14\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #15\n    [' ',' ','S','S','S','S','S','H','H','H','H','H'], #16\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #17\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #18\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #19\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #20\n    [' ',' ','S','S','S','S','S','S','S','S','S','S'], #21\n]    \n\ntable_splits = [ # used to decide if will split or not\n    # 0   1   2   3   4   5   6   7   8   9   10  A\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #0\n    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '], #1\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #2\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #3\n    [' ',' ','N','N','N','Y','Y','N','N','N','N','N'], #4\n    [' ',' ','N','N','N','N','N','N','N','N','N','N'], #5\n    [' ',' ','Y','Y','Y','Y','Y','N','N','N','N','N'], #6\n    [' ',' ','Y','Y','Y','Y','Y','Y','N','N','N','N'], #7\n    [' ',' ','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'], #8\n    [' ',' ','Y','Y','Y','Y','Y','N','Y','Y','N','N'], #9\n    [' ',' ','N','N','N','N','N','N','N','N','N','N'], #10\n    [' ',' ','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'], #11 (A)\n]\n\n# I could have used the codes directly, but when I decided to use the tables I had already written\n# most of the action functions. Creating a dictionary was easier than rewriting the code.\naction = {'H':'HIT', 'S':'STAND', 'D':'DOUBLE'}","05629644":"def shuffle_cards(shoe_size=8):\n    \"\"\"\n    Return a 'shoe' with 'shoe_size' decks, shuffled.\n    \n    In casinos, the dealer uses several decks (usually 6 to 8).\n    We can change this later to check how this affects the odds.\n    \"\"\"\n    new_shoe = shoe_size * deck\n    random.shuffle(new_shoe)\n    \n    return new_shoe\n\n\ndef hand_value(hand):\n    value = 0    \n    num_aces = sum([i == 'A' for i in hand])\n    \n    for card in hand:\n        if card.isnumeric():\n            value += int(card)\n        elif card in ['J', 'Q', 'K']:\n            value += 10\n        else: # Aces are treated as 1 at first; later they can be \"upgraded\"\n            value += 1\n    \n    if num_aces and (value <= 11):\n        value += 10 # Ace value = 11\n        \n    return value\n    ","f7844bc4":"def dealer_action(player_hand, dealer_hand):\n    if hand_value(dealer_hand) < 17:\n        action = 'HIT'\n    else:\n        action = 'STAND'\n        \n    #print('Dealer ', action)\n    return action\n","65e07613":"def player_action_stand_default(player_hand, dealer_hand):\n    # This is the initial strategy presented in the Microchallenge. Always returns 'STAND'\n    action = 'STAND'\n    #print('player ', action)\n    \n    return action\n","0cde5bca":"def should_hit(player_total, dealer_card_val, player_aces):\n    # this is the function I used in the exercise. It will be called from another function to keep same pattern\n    if player_aces:\n        if player_total >= 19:\n            return False\n        elif player_total == 18:\n            return dealer_card_val >= 9\n        else:\n            return True\n    else: # no aces\n        if player_total >= 17:\n            return False\n        elif player_total >= 13:\n            return dealer_card_val >= 7\n        elif player_total == 12:\n            return (dealer_card_val <= 3) or (dealer_card_val >= 7)\n        else:\n            return True\n\n\ndef player_action_exercise(player_hand, dealer_hand):\n    # This is the best I could get in the exercise. I am creating the function here just to check if my simulations\n    # get the same result.\n    # Calls the original function without changes, just adjusting the parameters\n\n    player_aces = sum([i == 'A' for i in player_hand])\n    player_total = hand_value(player_hand)\n    dealer_card_val = hand_value(dealer_hand)\n    \n    if should_hit(player_total, dealer_card_val, player_aces):\n        result = 'HIT'\n    else:\n        result = 'STAND'\n        \n    return result","b91d1d1b":"def player_action_with_double(player_hand, dealer_hand):\n    # Same one from the exercise, but including the DOUBLE result\n    player_aces = sum([i == 'A' for i in player_hand])\n\n    player_total = hand_value(player_hand)\n    dealer_total = hand_value(dealer_hand)\n    \n    #print(player_hand)\n    #print(dealer_hand)\n    if player_aces:\n        result = action[table_soft_totals[player_total][dealer_total]]\n    else:\n        result = action[table_hard_totals[player_total][dealer_total]]\n    \n    return result\n\ndef can_split(hand):\n    return (len(hand) == 2) and (hand_value([hand[0]]) == hand_value([hand[1]]))\n","a4a91182":"def player_action_full(player_hand, dealer_hand):\n    # Now with EVERYTHING!!!\n    player_aces = sum([i == 'A' for i in player_hand])\n\n    player_total = hand_value(player_hand)\n    dealer_total = hand_value(dealer_hand)\n\n    if can_split(player_hand):\n        card = hand_value([player_hand[0]])\n        if table_splits[card][dealer_total] == 'Y':\n            return 'SPLIT'\n    \n    if player_aces:\n        result = action[table_soft_totals[player_total][dealer_total]]\n    else:\n        result = action[table_hard_totals[player_total][dealer_total]]\n    return result\n","db7757a6":"def simulate_one_game (shoe, bet, action_function):\n    # since we will consider splits and double-downs the concept of wins\/losses does not apply anymore.\n    # instead, we will return the final balance.\n    \n    player_initial_hand = []\n    dealer_hand = []\n    \n    # deal initial cards\n    player_initial_hand.append(shoe.pop())\n    player_initial_hand.append(shoe.pop())\n        \n    dealer_hand.append(shoe.pop())\n\n    # to handle splits we will have to consider a list of player hands.\n    # everytime a SPLIT happens this list increases\n    hands_list = [player_initial_hand]\n    \n    # dealer\u00b4s actions will only happen once, so we need to keep the final hand states to compare\n    final_hands = []\n    bets = []\n    \n    # choose which function to use. Will allow us to compare different strategies\n    player_action = action_function\n\n    while len(hands_list) > 0:\n        #print(hands_list, dealer_hand)\n        current_bet = bet\n        player_hand = hands_list.pop()\n        \n        # run player actions\n        # first test: should I split?\n        if player_action(player_hand, dealer_hand) == 'SPLIT':\n            #print('SPLIT')\n            \n            # create 2 new hands and append to hands list\n            hand_1 = [player_hand[0]]\n            hand_1.append(shoe.pop())\n            \n            hand_2 = [player_hand[1]]\n            hand_2.append(shoe.pop())\n            \n            hands_list.append(hand_1)\n            hands_list.append(hand_2)\n            \n            continue # start handling hands list again\n            \n        # no split here, so let\u00b4s process until player stands or bust\n        while (hand_value(player_hand) <= 21) and (player_action(player_hand, dealer_hand) != 'STAND'):\n            action = player_action(player_hand, dealer_hand)\n            #print(action)\n            \n            if (action == 'HIT'):\n                player_hand.append(shoe.pop())\n                #print(player_hand, hand_value(player_hand))\n            elif (action == 'DOUBLE'):\n                # doubles bet and draws last card\n                current_bet = bet * 2\n                player_hand.append(shoe.pop())\n                break\n        \n        # ended the loop, so include hand and bet in final lists\n        final_hands.append(player_hand)\n        bets.append(current_bet)\n                \n    # run dealer actions\n    while (dealer_action(player_hand, dealer_hand) != 'STAND'):\n        dealer_hand.append(shoe.pop())\n        #print(dealer_hand, hand_value(dealer_hand))\n\n    #print(final_hands, dealer_hand, bets)\n        \n    # evaluate results\n    final_balance = 0\n    \n    for i, hand in enumerate(final_hands):\n        current_bet = bets[i]\n        \n        if hand_value(hand) > 21: # player busted\n            #print('Player busted!')\n            final_balance -= current_bet\n        elif hand_value(dealer_hand) > 21:\n            #print('Dealer busted!')\n            final_balance += current_bet\n        elif hand_value(dealer_hand) < hand_value(hand):\n            #print('Player won!')\n            final_balance += current_bet\n        else:\n            #print('Player lost!')\n            final_balance -= current_bet \n    \n    return final_balance    ","4f5f0672":"def simulate_games(n_games, action_function):\n    n_decks = 8\n    shoe = shuffle_cards(n_decks)\n\n    reshuffle_rate = 0.20 # when shoe hits this percentage dealer will reshuffle.\n    reshuffle_point = len(shoe) * reshuffle_rate \n    \n\n    bet_value = 1\n    balance = 0\n\n    for i in range(n_games):\n        #print('GAME ', i)\n        balance += simulate_one_game(shoe, bet_value, action_function)\n\n        if len(shoe) <= reshuffle_point:\n            #print('\\n\\nShuffling cards...\\n\\n')\n            shoe = shuffle_cards(n_decks)\n    \n    return balance","4f4874b3":"def calc_win_rate(balance, n_games):\n    # calculates the equivalent win rate from the final balance. Will be useful to compare with results in exercise\n    win_ratio = (balance + n_games) \/ 2 \/ n_games\n    \n    return win_ratio","85cac4f6":"# testing\nn_games = 1000000\n\n# Make simulations with different action functions\nvalue_1 = simulate_games(n_games, player_action_stand_default)\nvalue_2 = simulate_games(n_games, player_action_exercise)\nvalue_3 = simulate_games(n_games, player_action_with_double)\nvalue_4 = simulate_games(n_games, player_action_full)\n\nprint('Comparing results in different strategies')\nprint('STAND by default:\\t{}%'.format(calc_win_rate(value_1, n_games)*100))\nprint('Exercise:\\t\\t{}%'.format(calc_win_rate(value_2, n_games)*100))\nprint('Exercise w\/ doubles:\\t{}%'.format(calc_win_rate(value_3, n_games)*100))\nprint('FULL STRATEGY:\\t\\t{}%'.format(calc_win_rate(value_4, n_games)*100))","7652cc82":"Now the simulations.\nThe function below does most of the heavy lifting; it simulates one game, receiving the current shoe and the action function to be used as parameters.\n\nI also included a parameter to define the bet value; I might use this in the future to try to implement some card counting strategies :)","ad3cd5d9":"Now we are finally seing something different; a function that can return a DOUBLE-DOWN action!\nInstead of implement the logic through IF-ELIF-ELSE and boolean statements, it just calculates each hand's value and lookup in the correct table.\nIt also makes things slightly faster.","094b5fa6":"Next function calls simulate_one_game several times, reshuffling the shoe everytime it gets to a defined threshold.","8fc364cf":"Even though the win rate doesn't make sense anymore, we need to create a way to compare it to the Microchallenge. So I created this function to calculate the equivalent rate, based on the final balance.","eeb674a2":"Finally, a function that can also return 'SPLIT'!\nI used an additional lookup table just for that (check the begining of the code).","e158428f":"The original exercise was supposed to be solved using several conditional statements. But for more complex strategies I found it easier to use lookup tables.\n\nThe ones I used below can be found [here](http:\/\/www.blackjackapprenticeship.com\/blackjack-strategy-charts\/).\n\nI created them with paddings to make it easier to lookup.","e13525fb":"\nTrying to improve my score in the [Blackjack Microchallenge](http:\/\/https:\/\/www.kaggle.com\/kernels\/fork\/1315754) I went through some research and found out that there is more to Blackjack than just hit or stand; there are some additional actions that the player may take in the first round (when you\u00b4ve just received your first 2 cards):\n\nSPLIT - if the 2 initial cards have the same value, you can SPLIT them, creating two different hands (and increasing your bet accordingly). You can then play for each hand individually.\nDOUBLE DOWN - you double your bet and receive ONLY ONE additional card. \n\nThe code below is an improvement to the initial exercise, where we will be able to test how well these more complex strategies work out.","02a41da5":"For the dealer, we will use the same strategy as listed in the Microchallenge. This will make it easy to compare if the complex model works better or not.\nI am including the player_hand as a parameter because we can change the dealer\u00b4s action depending on that later (e.g.: stop if hand already beats the player's hand)\n\nThe rules for the dealer are:\n- The player is dealt two face-up cards. The dealer is dealt one face-up card.\n(...)\n- The dealer then deals additional cards to himself until either:\n    - The sum of the dealer's cards exceeds 21, in which case the player wins the round, or\n    - The sum of the dealer's cards is greater than or equal to 17. If the player's total is greater than the dealer's, the player wins. Otherwise, the dealer wins (even in case of a tie).","d6ec64b9":"Finally, let's test everything!!!\nWe will call the simulation function using different action functions as parameters and then compare the results.","2368f671":"The next function I tested was the best result I got in the Microchallenge. It is also based on the same table I referenced above, but without the splits and double-downs.\nTo make things easier, I just copied the function from the exercise as-is and called it from another function","3d459ede":"The function to define user actions will be passed to the simulator as a parameter, making it very easy to rerun the simulations.\n\nI created a handful of functions to define different strategies. This will allow us to evaluate and compare their results.\n\nThe first one is the initial strategy in the Microchallenge (always return 'STAND')","3277d85b":"**NEXT STEPS**\n* Double check the code for errors\n* Test different strategies (based on tables like the ones I used)\n* Evaluate the impact of the number of decks on the odds\n* Implement a way to test card counting strategies (this should work to beat the dealer)\n* Data Visualization (I still didn't get to that lesson... :) )\n\nPlease share your thoughts... any help is appreciated!","42d2c8a6":"Create a single deck. Most of the casinos use 6 to 8 decks in a Blackjack table ([they call it a shoe](http:\/\/https:\/\/en.wikipedia.org\/wiki\/Shoe_(cards)); we will see later if this increases the house odds.","5953004d":"Below I created some additional helper functions.","cb273547":"**CONCLUSION**\nThe first two results (around 38% and 42.5%, respectively) matched the exercise's numbers, which shows that at least for the less complex strategies my simulation function is correct.\n\nThe complex strategies require a lot of runs to get consistent results (n_games > 1000000). They did perform better (around 43% and 43.2%), but still not enough to beat the dealer (if my code is correct)."}}