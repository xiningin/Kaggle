{"cell_type":{"d938c8b8":"code","a1dffa32":"code","4021a351":"code","acb18d92":"code","d558bd2f":"code","bf7701fc":"code","2cfa213d":"code","c0499318":"code","6b7ce577":"code","911cb535":"code","c26839e7":"code","6f32e447":"code","ddca2fde":"code","bf368378":"code","524b7414":"markdown","72c2242e":"markdown","771d1622":"markdown","6458eb8d":"markdown"},"source":{"d938c8b8":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    print(dirname)","a1dffa32":"# nous utilisons pathlib afin de parcourir les dossiers et fichiers\nimport pathlib\n\n# nous utilisons aussi torchvision et pytorch pour le code de Data Loading\nimport torchvision\nfrom torchvision import datasets, models, transforms\nfrom torch.utils.data import Dataset, DataLoader\n\nfrom PIL import Image # pour lire les images .jpg\n\n# nous utilisons Pandas pour manipuler et creer le fichier de soumission assez rapidement\nimport pandas as pd\n\nimport numpy as np","4021a351":"# changer les chemins selon votre machine\n# TODO \n# A vous de diviser le train en deux sous ensemble train\/valid\ntrain_path = '\/kaggle\/input\/je-suis-ou\/train'\nvalid_path = '' # a changer selon le chemin dans votre machine\n\n# le chemin vers le test set\ntest_path = '\/kaggle\/input\/je-suis-ou\/test'","acb18d92":"train_transform = transforms.Compose([\n    # a vous de remplir\n    #\n    #\n    #\n    # ...\n])\n\ntest_transform = transforms.Compose([\n    # a vous de remplir\n    #\n    #\n    #\n    # ...\n])","d558bd2f":"# utilisons la classe ImageFolder afin de charger le train set\ntrain_dataset = datasets.ImageFolder(train_path, train_transform)\n\n# la classe ImageFolder assigne automatiquement un label pour chaque nom de classe (class -> idx)\nprint('class -> idx : ',train_dataset.class_to_idx)\n\n# on aura besoin d'un dictionnaire qui fait le sens inverse (idx -> class)\nidx_to_class = {train_dataset.class_to_idx[class_name]: class_name for class_name in  train_dataset.class_to_idx}\nprint('idx -> class : ',idx_to_class)","bf7701fc":"# on h\u00e9rite de la classe Dataset de PyTorch \nclass TestDataset(Dataset):\n    def __init__(self, test_path, transform=None):\n        \n        # lister toutes les images dans le repertoire test\n        # self.image_paths va etre une liste contenant des \n        # elements de type Path (pour plus d'info voir la class Path de pathlib)\n        # cela fonctionne seulement pour les versions de python >3.4\n        self.image_paths = list(pathlib.Path(test_path).glob('*.jpg'))\n        \n        # trier les noms des fichiers d'images par ordre\n        self.image_paths.sort()\n        \n        # garder la fonctions de tranform dans self pour l'utiliser dans __getitem__\n        self.transform = transform\n\n    def __getitem__(self, index):\n        # index est un nombre qui vient du dataloader (il est entre 0 et ce que retourne la methode __len__ ci-dessous)\n        # c'est donc entre 0 et le nombre d'images de test\n        img_path = self.image_paths[index]\n        \n        # retourner aussi le nom de l'image en question(i.e. '0xxxx')\n        # sans l'extension '.jpg', donc on ignore les 4 dernier caracteres du nom de l'image (.jpg) avec [:-4]\n        # par exemple, pour l'image '00037.jpg' on retourne '00037'\n        # cela va vous etre util pour generer le fichier predictions.csv\n        img_name = img_path.name[:-4] #img_path est un objet de type Path, et a donc un attribut 'name'\n        \n        # lire l'image avec PIL\n        img = Image.open(img_path)\n        \n        # appliquer les transforms s'il y'en a\n        if self.transform is not None:\n            img = self.transform(img)\n        \n        return img, img_name\n\n    def __len__(self):\n        return len(self.image_paths)","2cfa213d":"# Nous allons tester la classe TestDataset\ntest_dataset = TestDataset(test_path, transform=transforms.ToTensor()) # ici je transforme les images en Tensor pour une utilisation rapide de PyTorch Dataloader \n\n# on aura besoin d'un dataloader qui enveloppe notre objet test_dataset\ntest_loader = DataLoader(test_dataset, batch_size=16, shuffle=False, num_workers=4) # souvent le shuffle est mis a False, mais avec notre implementation, ca marche dans tous les cas","c0499318":"# on itere sur le dataloader pour r\u00e9cuperer une batch\nbatch, names = next(iter(test_loader))\n\ni = 6 # choisir une image dans la batch\nprint(names[i]) # afficher le nom de l'image\ntransforms.ToPILImage()(batch[i]) # afficher l'image correspondante \u00e0 partir de la batch","6b7ce577":"# affichons l'image a partir du dossier test et voir si c'est la meme\nnom_image = names[i]+'.jpg' # rajouter l'extension\nImage.open(test_path + '\/' + nom_image)","911cb535":"# generons une prediction aleatoire pour notre test\n\nlabel_predictions = []\nimage_names = []\nfor batch,im_names in test_loader:\n    # remplir avec des predictions aleatoires (entre 0 et 4)\n    random_preds = [np.random.randint(0, 5) for _ in range(len(batch))]\n    label_predictions.extend(random_preds) \n    \n    # retenir les noms des images\n    image_names.extend(im_names) \n\nassert len(label_predictions) == len(image_names) \nassert len(label_predictions) == len(test_dataset) # est-ce qu'on a pr\u00e9dits tous les exemples de tests ?\nprint(f'Il y a {len(label_predictions)} exemples de test')","c26839e7":"# Utilisons Pandas afin de generer un DataFrame\n\npredictions_df = pd.DataFrame(data=zip(image_names, label_predictions), columns=['image_name', 'class_label'])\npredictions_df","6f32e447":"# mais il faudra d'abord traduire les class_label en nom de classes\n# on peut utiliser le dictionnaire idx_to_class calcul\u00e9 au d\u00e9part\npredictions_df['class'] = predictions_df['class_label'].map(idx_to_class)\npredictions_df","ddca2fde":"# on drop la colonne class_label avant d'entregistrer en fichier CSV\npredictions_df = predictions_df.drop(labels=['class_label'], axis=1)","bf368378":"# enregistrer dans fichier de format CSV\n# N'OUBLIEZ PAS DE METTRE index=None\npredictions_df.to_csv('.\/mes_predictions.csv', index=None)","524b7414":"## Chargement des donn\u00e9es de Test\nPour les donn\u00e9es de test, nous n'avons pas d'\u00e9titquettes, donc la classe ImageFolder n'est pas utile.\n- Nous avons besoin des noms des images afin de cr\u00e9er le fichier de soumission","72c2242e":"# Notebooks sur Kaggle\nKaggle nous offre la possibilit\u00e9 d'utiliser Jupyter Notebook.\nLes donn\u00e9es d'entrainement et de test sont disponible en lecture seule.","771d1622":"# Generation du fichier de pr\u00e9diction\nPour chaque batch que l'on passe au model, nous gardons dans une liste, les noms des images et les labels pr\u00e9dits   \nLe r\u00e9sultats pourrait ressembler \u00e0 \u00e7a  \nimage_names   `['00000', '00001', '00002', ..., '09453']`   \nlabel_predictions   `[1, 0, 4, ..., 1]`\n","6458eb8d":"# Remarques\n- C'est \u00e0 vous de diviser l'ensemble d'entrainement en train\/valid, vous pouvez vous en inspirez de la question 1\n- Ce code est \u00e0 titre indicatif, vous n'\u00eates pas oblig\u00e9s de suivre la m\u00eame logique pour lader les donn\u00e9es"}}