{"cell_type":{"3341e798":"code","a361d1b2":"code","9354cc2e":"code","1b5fc0d4":"code","7f81974a":"code","3cc700c4":"code","209f0173":"code","45d109d3":"code","42ed18b7":"code","e70451df":"code","294ed30a":"code","57e09fe3":"code","2b09532a":"code","0083ba16":"code","cd09d961":"code","fd7e99e0":"code","d84b831b":"code","06177ea0":"code","14f3d749":"code","460eedf3":"code","5eda1f15":"code","8a5c0f34":"code","c560ccb2":"code","8aa1016d":"code","31f63858":"code","f790f23e":"code","e2c4b7da":"code","e763f502":"code","9261c27f":"code","5b28e6ec":"code","5bc4320c":"code","2a9a03a9":"code","84f243c1":"code","17a5e9cc":"code","cc102c79":"code","02f15776":"code","10dc6d4a":"code","f2fe0978":"code","b9dd9cbf":"code","6cf2dc17":"code","16f05943":"code","2d6b0dcd":"code","9c9b8bad":"code","ab5bcd8d":"code","d2b001b2":"code","bd9d0bc8":"code","3e5d338b":"code","3d48f942":"code","c2635e43":"code","5ec9b2aa":"code","75ef72fc":"code","504b91d5":"code","c7d5a406":"code","7edaa828":"code","8f742a9a":"code","eebc367f":"code","32694341":"code","0de8a952":"code","12db2a30":"code","9442d68d":"code","0323d0df":"code","444f366c":"code","25861c78":"code","e453a8a9":"code","6741dc8e":"code","5d8759e1":"code","b1fc32be":"code","c1a9ddc2":"code","0e6b2c04":"code","075549ef":"code","ff7144d7":"code","f9a8d687":"code","f79a79dc":"code","71ee3d34":"code","12965486":"code","060af2d3":"code","7ed88352":"code","3525f15f":"code","eff1cacf":"code","3f47297a":"code","36ee0fa7":"code","26e762bc":"code","767c283b":"code","dbf0d31d":"code","2ea47cc3":"code","aa86d694":"code","5476a894":"code","157e5034":"code","8963518d":"code","598c32fe":"code","153e3cf4":"code","c1202912":"code","d2b06444":"code","26f7a322":"code","287c2fe2":"code","82f68559":"code","428d610e":"code","33231e40":"code","c4e80f68":"code","5f180455":"code","f70a58b9":"code","00ffff56":"code","d199a38c":"code","ed9b8be1":"code","e7837aa8":"code","b19fc7fb":"code","0988d2e9":"code","4310d561":"code","dd582c1d":"code","af3026ff":"code","883ab924":"code","18724077":"code","c03eb786":"code","eee2f254":"code","c5abc193":"code","9ebf81ef":"code","3f86ffe4":"code","838ef6f7":"code","081b9133":"code","8c9953a3":"code","8f2b214d":"code","4d2c3751":"code","268c6461":"code","a2737def":"markdown","f2a35807":"markdown","ed94697c":"markdown","4cecb933":"markdown","77f91799":"markdown","b583f50d":"markdown","81957626":"markdown","54d86c82":"markdown","19e8431f":"markdown","81bbc3db":"markdown","671952d3":"markdown","c74282ee":"markdown","d3fc91ea":"markdown","5adf89c3":"markdown","24680044":"markdown","b2fc5274":"markdown","7441580c":"markdown","5b096aaa":"markdown","f6d75aab":"markdown","e0d0c36c":"markdown","b902d004":"markdown","beb7ca48":"markdown","530db3a1":"markdown","2ba2e072":"markdown","b690bbf7":"markdown","3d8f6054":"markdown","e0089a6f":"markdown","45572713":"markdown","2c45f11b":"markdown","b5082693":"markdown","8ef39de6":"markdown","94d61fef":"markdown","99aa18c2":"markdown","fc4e08e3":"markdown","38c78b6a":"markdown","ffd23527":"markdown","79818961":"markdown","e8148c1c":"markdown","3f943699":"markdown","63517619":"markdown","6bed0f7c":"markdown","6d442191":"markdown","225a6def":"markdown","59c78a64":"markdown","739919b2":"markdown","0a3311a4":"markdown","2da54722":"markdown","ffd6c680":"markdown","b3376524":"markdown"},"source":{"3341e798":"import numpy as np # linear algebra\nimport pandas as pd # data processing\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","a361d1b2":"# Importing the required libraries\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport itertools\nimport warnings\nwarnings.filterwarnings(\"ignore\")","9354cc2e":"def reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.\n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                #if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                #    df[col] = df[col].astype(np.float16)\n                #el\n                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        #else:\n            #df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB --> {:.2f} MB (Decreased by {:.1f}%)'.format(\n        start_mem, end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","1b5fc0d4":"train = pd.read_csv('..\/input\/pubg-ver1\/train.csv')\ntrain = reduce_mem_usage(train)\ntest = pd.read_csv('..\/input\/pubg-ver1\/test.csv')\ntest = reduce_mem_usage(test)\nprint(train.shape, test.shape)","7f81974a":"train.info()","3cc700c4":"train.tail()","209f0173":"for i in ['Id','groupId','matchId']:\n    print(f'unique [{i}] count:', train[i].nunique())","45d109d3":"#fig, axes = plt.subplots(1, 2, figsize=(12,4))\n\n#train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=axes[0])\n\n#mapper = lambda x: 'solo' if ('solo' in x) else 'duo' if ('duo' in x) or ('crash' in x) else 'squad'\n#train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=axes[1])","42ed18b7":"subset = train[train['matchId']==47710]\nsub_grp = subset[subset['groupId']==1658403]\n\n\nprint('matchId ==\\'47710\\' & groupId ==\\'1658403\\'')\nprint('-'*50)\nprint('players:',len(subset))\nprint('groups:',subset['groupId'].nunique())\nprint('maxPlace:',subset['maxPlace'].unique())\nprint('-'*50)\nprint('max-group players:',len(sub_grp))\nprint('max-group winPlacePerc:',sub_grp['winPlacePerc'].unique())\nprint('-'*50)\nprint('winPlacePerc:',subset['winPlacePerc'].sort_values().unique())","e70451df":"corr = train.corr()\nf,ax = plt.subplots(figsize=(20, 15))\nsns.heatmap(train.corr(), annot=True, fmt= '.1f',ax=ax, cmap=\"BrBG\")\nsns.set(font_scale=1.25)\nplt.show()","294ed30a":"print(\"On an average a person kills {:.4f} players, 99% of people have {} kills or less, while the maximum kills ever recorded is {}.\" .format(train['kills'].mean(), train['kills'].quantile(0.99), train['kills'].max()))","57e09fe3":"data = train.copy()\ndata.loc[data['kills'] > data['kills'].quantile(0.99)] = '8+'\nplt.figure(figsize=(15,8))\nsns.countplot(data['kills'].astype(str).sort_values())\nplt.title(\"kill Count\", fontsize=14)\nplt.show()","2b09532a":"data = train.copy()\ndata = data[data['kills']==0]\nplt.figure(figsize=(15,8))\nplt.title(\"Damage Dealt by 0 killers\",fontsize=15)\nsns.distplot(data['damageDealt'])\nplt.show()","0083ba16":"print(\"A total of {} players ({:.4f}%) have won without a single kill!\".format(len(data[data['winPlacePerc']==1]), 100*len(data[data['winPlacePerc']==1])\/len(train)))","cd09d961":"data1 = train[train['damageDealt']==0].copy()\nprint(\"A total of {} players ({:.4f}%) have won without dealing damage!\" .format(len(data1[data1['winPlacePerc']==1]), 100*len(data1[data1['winPlacePerc']==1])\/len(train)))","fd7e99e0":"kills = train.copy()\n\nkills['killsCategories'] = pd.cut(kills['kills'], [-1,0,2,5,10,60], labels= ['0_kills', '1-2_kills', '3-5_kills', '6-10_kills', '10+_kills'])\nplt.figure(figsize=(15,8))\nsns.boxplot(x='killsCategories', y='winPlacePerc', data=kills)\nplt.show()","d84b831b":"print(\"{} players ({:.4f}%) walked 0 meters. This means that either they die before even taking a step or they have just joined the game but are away from keyboard (more possible).\" .format(len(data[data['walkDistance']==0]), 100*len(data1[data1['walkDistance']==0])\/len(train)))","06177ea0":"data = train.copy()\ndata = data[data['walkDistance'] < train['walkDistance'].quantile(0.99)]\nplt.figure(figsize=(15,10))\nplt.title(\"Walking Distance Distribution\",fontsize=15)\nsns.distplot(data['walkDistance'])\nplt.show()","14f3d749":"sns.jointplot(x='winPlacePerc',y='walkDistance', data=train, height=10, ratio=3, color=\"lime\")\nplt.show()","460eedf3":"print(\"An average person drives for {:.1f}m, 99% of people have drived {}m or less, while THE RIDER rode for {}m.\".format(train[\"rideDistance\"].mean(), train[\"rideDistance\"].quantile(0.99), train[\"rideDistance\"].max()))","5eda1f15":"print(\"{} players ({:.4f}%) drived for 0 meters. This means that they like trekking more than riding.\".format(len(data[data['rideDistance'] == 0]), 100*len(data1[data1['rideDistance']==0])\/len(train)))","8a5c0f34":"sns.jointplot(x=\"winPlacePerc\", y=\"rideDistance\", data=train, height=10,ratio=3,color='y')\nplt.show()","c560ccb2":"f,ax1 = plt.subplots(figsize =(15,8))\nsns.pointplot(x='vehicleDestroys',y='winPlacePerc',data=data,color='lime',alpha=0.5)\nplt.xlabel('Count of Vehicle Destroys',fontsize = 16,color='blue')\nplt.ylabel('Win Percentage',fontsize = 16,color='blue')\nplt.title('Vehicle Destroyed\/ Win Ratio',fontsize = 20,color='blue')\nplt.grid()\nplt.show()","8aa1016d":"print(\"In the game on an average a person uses {:.1f} heal items, 99% of people use {} or less, while the doctor used {}.\".format(train['heals'].mean(), train['heals'].quantile(0.99), train['heals'].max()))\nprint(\"In the game on an average a person uses {:.1f} boost items, 99% of people use {} or less, while the doctor used {}.\".format(train['boosts'].mean(), train['boosts'].quantile(0.99), train['boosts'].max()))","31f63858":"data = train.copy()\ndata = data[data['heals'] < data['heals'].quantile(0.99)]\ndata = data[data['boosts'] < data['boosts'].quantile(.99)]\n\nf,ax1 = plt.subplots(figsize=(15,8))\nsns.pointplot(x='heals', y='winPlacePerc', data=data, color='lime', alpha=0.8)\nsns.pointplot(x='boosts', y='winPlacePerc', data=data, color='blue', alpha=0.8)\nplt.text(4,0.6,'Heals' ,color='lime', fontsize=16,style='italic')\nplt.text(4,0.55, 'Boosts',color='blue', fontsize=16,style='italic')\n\nplt.xlabel('Number of heal\/boost items',fontsize = 16,color='blue')\nplt.ylabel('Win Percentage',fontsize = 16,color='blue')\nplt.title('Heals vs Boosts',fontsize = 20,color='blue')\nplt.grid()\nplt.show()","f790f23e":"sns.jointplot(x=\"winPlacePerc\", y=\"heals\", data=train, height=10, ratio=3, color=\"lime\")\nplt.show()","e2c4b7da":"sns.jointplot(x='winPlacePerc', y='boosts', data =train , height=10,ratio=3, color='blue')\nplt.show()","e763f502":"solos = train[train['numGroups']>50] ##Solo game played by more than 50 different groups\nduos = train[train['numGroups']>25]                                              \nsquads = train[train['numGroups']<=25]# Squad game can consist a maximum of 25 groups(25x4=100)\n\nprint(\"{} ({:.2f}%) of games are solo, {} ({:.2f}%) are duo and {} ({:.2f}%) are squad games.\".format(len(solos), 100*len(solos)\/len(train), len(duos), 100*len(duos)\/len(train), len(squads), 100*len(squads)\/len(train)))","9261c27f":"f,ax1 = plt.subplots(figsize=(20,10))\nsns.pointplot(x='kills', y='winPlacePerc', data=solos, color='black', alpha=0.6)\nsns.pointplot(x='kills', y='winPlacePerc', data=duos, color='red', alpha=0.6)\nsns.pointplot(x='kills', y='winPlacePerc', data=squads, color='blue', alpha=0.6)\n\nplt.text(14,0.5,'Solos', color='black', fontsize=16)\nplt.text(14,0.45,'Duos', color='red', fontsize=16)\nplt.text(14,0.4,'Squads', color='blue', fontsize=16)\n\nplt.xlabel(\"Number Of Kills\", fontsize=15, color='blue')\nplt.ylabel(\"Wiining Percentage\", fontsize=15, color='blue')\nplt.title(\"Solo vs Duo vs Squad\", fontsize=20, color='blue')\nplt.grid()\nplt.show()","5b28e6ec":"data = train.copy()\ndata = data[data['DBNOs'] < train['DBNOs'].quantile(0.99)]\nplt.figure(figsize=(15,10))\nplt.title(\" Surviving Distribution\",fontsize=15)\nsns.distplot(data['DBNOs'])\nplt.show()","5bc4320c":"# Check row with NaN value\ntrain[train['winPlacePerc'].isnull()]","2a9a03a9":"train.drop(train[train['winPlacePerc'].isnull()].index, inplace=True)\ntrain.shape","84f243c1":"train['_totalDistance'] = train['rideDistance'] + train['walkDistance'] + train['swimDistance']\n","17a5e9cc":"## Engineer _headshot_rate feature --- headshots made per kill\ntrain['_headshot_rate'] = train['headshotKills']\/train['kills']\ntrain['_headshot_rate'] = train['_headshot_rate'].fillna(0)","cc102c79":"#Defining some functions for plotting graphs, we will be needing a lot of countplot and distplot\ndef show_countplot(column):\n    plt.figure(figsize=(15,8))\n    sns.countplot(data=train,x=column).set_title(column)\n    plt.show()\n    \ndef show_distplot(column):\n    plt.figure(figsize=(15,8))\n    sns.distplot(train[column], bins=50)\n    plt.show()","02f15776":"train[(train['kills']>=30) & (train['weaponsAcquired'] > 45) & (train['_totalDistance']<100.0)]","10dc6d4a":"# Is it even possible to kill more than 30 people without using any heals?\ntrain[(train['kills']>=30) & (train['heals']==0)]","f2fe0978":"show_countplot('kills')\n\n\ntrain.drop(train[(train['kills'] >= 40) & (train['weaponsAcquired'] > 55) & (train['_totalDistance']<100.0)].index, inplace=True)\n\ntrain.drop(train[(train['kills']>=40) & (train['weaponsAcquired'] > 55)].index, inplace=True)\n","b9dd9cbf":"#plt.figure(figsize=(15,8))\n#sns.distplot(train['_headshot_rate'], bins=50)\n#plt.show()","6cf2dc17":"# List of Hitman who made more than 10 kills and all the kills were done by headshot(perfect kill)\ndisplay(train[(train['_headshot_rate']==1) & (train['kills']>=10)].shape)\ntrain[(train['_headshot_rate']==1) & (train['kills']>=10)].head(10)\n##for now we are not deleting these players from the dataset.","16f05943":"train['_killsWithoutMoving'] = ((train['kills'] > 0) & (train['_totalDistance'] ==0))\n\n# Check players who kills without moving\ndisplay(train[train['_killsWithoutMoving']==True].shape)\ntrain[train['_killsWithoutMoving']==True].head(10)","2d6b0dcd":"train.drop(train[train['_killsWithoutMoving'] == True].index, inplace=True)","9c9b8bad":"show_distplot('longestKill')","ab5bcd8d":"train[train['longestKill'] >= 1000]\n","d2b001b2":"train.drop(train[train['longestKill'] >= 1000].index, inplace=True)","bd9d0bc8":"\ntrain[train['roadKills']>10]\n\n","3e5d338b":"train.drop(train[train['roadKills']>10].index, inplace=True)","3d48f942":"train[['walkDistance', 'rideDistance', 'swimDistance']].describe","c2635e43":"show_distplot('walkDistance')","5ec9b2aa":"#Travel Lust and Wandrer ---> They just play to roam around and explore places without killing anyone and how can they travel 13kms \n#in the game?\ntrain[(train['walkDistance']>=13000) & (train['kills']==0)]","75ef72fc":"train.drop(train[(train['walkDistance']>=13000) & (train['kills']==0)].index, inplace=True)","504b91d5":"train[(train['rideDistance'] >= 30000) & (train['kills'] == 0)]","c7d5a406":"# How is it even possible that a player is able to ride and kill without walking even a single meter ?\ntrain[(train['walkDistance']==0) & (train['rideDistance'] >0) & (train['kills'] >0)]","7edaa828":"train[(train['_totalDistance']==0)]","8f742a9a":"train.drop(train[(train['rideDistance'] >= 30000) & (train['kills'] == 0)].index, inplace=True)\ntrain.drop(train[(train['walkDistance']==0) & (train['rideDistance'] >0) & (train['kills'] >0)].index, inplace=True)\ntrain.drop(train[(train['_totalDistance']==0)].index, inplace=True)","eebc367f":"show_distplot('swimDistance')","32694341":"train[train['swimDistance'] >=2000]","0de8a952":"# How can you swim for more than 2 km without breathing?\ntrain.drop(train[train['swimDistance'] >= 2000].index, inplace=True)","12db2a30":"show_distplot('weaponsAcquired')","9442d68d":"display(train[train['weaponsAcquired'] >= 80].shape)","0323d0df":"train[train['weaponsAcquired'] >= 70].head()","444f366c":"train.drop(train[train['weaponsAcquired'] >= 70].index, inplace=True)","25861c78":"show_distplot('heals')","e453a8a9":"display(train[train['heals'] >= 40].shape)\ntrain[train['heals']>=40].head(10)","6741dc8e":"train.drop(train[train['heals'] >= 40].index, inplace=True)","5d8759e1":"train.shape","b1fc32be":"train.to_csv('cleaned_data.csv', index=False)","c1a9ddc2":"cleaned_data = pd.read_csv('cleaned_data.csv')\ncleaned_data = reduce_mem_usage(cleaned_data)","0e6b2c04":"cleaned_data.head()","075549ef":"cleaned_data['_playersJoined'] = cleaned_data.groupby('matchId')['matchId'].transform('count')\ndata = cleaned_data.copy()\ndata = data[data['_playersJoined'] > 49]\nplt.figure(figsize=(15,10))\nsns.countplot(data['_playersJoined'])\nplt.title(\"Players Joined\" , fontsize=15)\nplt.show()","ff7144d7":"# Create normalized features\ncleaned_data['_killsNorm'] = cleaned_data['kills']*((100-cleaned_data['_playersJoined'])\/100 + 1)\ncleaned_data['_damageDealtNorm'] = cleaned_data['damageDealt'] * ((100-cleaned_data['_playersJoined'])\/100 + 1)\ncleaned_data['_maxPlaceNorm'] = cleaned_data['maxPlace']*((100-cleaned_data['_playersJoined'])\/100 + 1)","f9a8d687":"# Compare standard features and normalized features\nto_show = ['Id', 'kills','_killsNorm','damageDealt', '_damageDealtNorm', 'maxPlace', '_maxPlaceNorm']\ncleaned_data[to_show][0:11]","f79a79dc":"match = cleaned_data.groupby('matchId')\ncleaned_data['_killsPerc'] = match['kills'].rank(pct=True).values\ncleaned_data['_killPlacePerc'] = match['killPlace'].rank(pct=True).values\ncleaned_data['_walkDistancePerc'] = match['walkDistance'].rank(pct=True).values\ncleaned_data['_damageDealtPerc'] = match['damageDealt'].rank(pct=True).values\n\ncleaned_data['_walkPerc_killsPerc'] = cleaned_data['_walkDistancePerc'] \/ cleaned_data['_killsPerc']\ncleaned_data.head()","71ee3d34":"corr = cleaned_data[['_killsPerc', '_killPlacePerc','_walkDistancePerc','_damageDealtPerc', '_walkPerc_killsPerc','winPlacePerc']].corr()","12965486":"plt.figure(figsize=(15,8))\nsns.heatmap(\n    corr,\n    xticklabels= corr.columns.values,\n    yticklabels= corr.columns.values,\n    annot=True,\n    linecolor='blue',\n    linewidths=0.1,\n    cmap=\"BrBG\"\n)\nplt.show()","060af2d3":"agg = cleaned_data.groupby(['groupId']).size().to_frame('players_in_team')\ncleaned_data = cleaned_data.merge(agg, how='left', on=['groupId'])\ncleaned_data['_healthItems'] = cleaned_data['heals'] + cleaned_data['boosts']\ncleaned_data['_headshotKillRate'] = cleaned_data['headshotKills'] \/ cleaned_data['kills']\ncleaned_data['_killPlaceOverMaxPlace'] = cleaned_data['killPlace'] \/ cleaned_data['maxPlace']\ncleaned_data['_killsOverWalkDistance'] = cleaned_data['kills'] \/ cleaned_data['walkDistance']\ncleaned_data['_killsOverDistance'] = cleaned_data['kills'] \/ cleaned_data['_totalDistance']\ncleaned_data.head()","7ed88352":"corr = cleaned_data[['killPlace', 'walkDistance','players_in_team','_healthItems', '_headshotKillRate', '_killPlaceOverMaxPlace', '_killsOverWalkDistance', '_killsOverDistance', 'winPlacePerc']].corr()","3525f15f":"plt.figure(figsize=(15,8))\nsns.heatmap(\n           corr,\n           xticklabels=corr.columns.values,\n           yticklabels=corr.columns.values,\n           annot=True,\n           linecolor=\"white\",\n           linewidths=0.1,\n           cmap=\"BrBG\"\n)\nplt.show()","eff1cacf":"cleaned_data.shape","3f47297a":"cleaned_data.columns","36ee0fa7":"cleaned_data.drop(['_headshotKillRate', '_killsOverDistance', '_killsOverWalkDistance'], axis=1,inplace=True)","26e762bc":"cleaned_data.head()","767c283b":"cols_to_fit = [col for col in cleaned_data.columns]\ncorr = cleaned_data[cols_to_fit].corr()\nf,ax = plt.subplots(figsize=(30,25))\nsns.heatmap(corr, annot=True, fmt='.1f' ,ax =ax, cmap=\"BrBG\")\nsns.set(font_scale=1.25)\nplt.show()","dbf0d31d":"cleaned_data.drop(['killPoints','numGroups','roadKills','teamKills','winPoints', '_playersJoined','_maxPlaceNorm','_killsWithoutMoving'], axis=1, inplace=True)","2ea47cc3":"cleaned_data.shape","aa86d694":"test.shape","5476a894":"cols_to_fit = [col for col in cleaned_data.columns]\ncorr = cleaned_data[cols_to_fit].corr()\nf,ax = plt.subplots(figsize=(30,20))\nsns.heatmap(corr, annot=True, fmt='.1f', ax=ax,cmap='BrBG')\nsns.set(font_scale=1.25)\nplt.show()","157e5034":"cleaned_data.to_csv('Highly_correlated_data.csv', index=False)","8963518d":"highly_corr = pd.read_csv('Highly_correlated_data.csv')\nhighly_corr = reduce_mem_usage(highly_corr)\n","598c32fe":"highly_corr.shape","153e3cf4":"X_train = highly_corr[highly_corr['winPlacePerc'].notnull()].reset_index(drop=True)\nX_test = highly_corr[highly_corr['winPlacePerc'].isnull()].drop(['winPlacePerc'],axis=1).reset_index(drop=True)\n\nY_train = X_train.pop('winPlacePerc')\nX_test_grp = X_test[['matchId','groupId']].copy()\ntrain_matchId = X_train['matchId']\n\n# drop matchId,groupId\nX_train.drop(['matchId','groupId','Id'], axis=1, inplace=True)\nX_test.drop(['matchId','groupId','Id'], axis=1, inplace=True)\n\nprint(X_train.shape, X_test.shape)","c1202912":"highly_corr.drop(columns=['Id'], inplace=True)","d2b06444":"sample=500000\ndf_sample = highly_corr.sample(sample)","26f7a322":"df = df_sample.drop(columns=['winPlacePerc'])\ny = df_sample['winPlacePerc']","287c2fe2":"# Function for splitting training and validation data\ndef split_vals(a, n: int ):\n    return a[:n].copy() , a[n:].copy()\nval_perc = 0.12\nn_valid = int(val_perc*sample)\nn_trn = len(df) - n_valid\n\n# Split data\nraw_train,raw_valid = split_vals(df_sample, n_trn)\nX_train , X_valid = split_vals(df, n_trn)\ny_train , y_valid = split_vals(y, n_trn)\n\n# Check dimensions of samples\nprint('Sample train shape: ', X_train.shape, \n      'Sample target shape: ', y_train.shape, \n      'Sample validation shape: ', X_valid.shape)","82f68559":"# Metric used for the PUBG competition (Mean Absolute Error (MAE))\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Function to print the MAE (Mean Absolute Error) score\ndef print_score(m : RandomForestRegressor):\n    res = ['mae train: ',mean_absolute_error(m.predict(X_train),y_train),\n          'mae valid: ', mean_absolute_error(m.predict(X_valid),y_valid)]\n    \n     #Score of the training dataset obtained using an out-of-bag estimate.\\\n    if hasattr(m,'oob_score_'):res.append(m.oob_score_)\n    print(res)","428d610e":"# Train basic mode\nm1 = RandomForestRegressor(n_estimators=40, min_samples_leaf=3, max_features='sqrt', n_jobs=-1)\nm1.fit(X_train, y_train)\nprint_score(m1)","33231e40":"def rf_feat_importance(m, df):\n    return pd.DataFrame({'cols':df.columns, 'imp':m.feature_importances_}).sort_values('imp', ascending=False)","c4e80f68":"fi = rf_feat_importance(m1, df)\nfi[:15]","5f180455":"# Plot a feature importance graph for the 15 most important features\nplot1 = fi[:15].plot('cols','imp', figsize=(14,6),legend=False, kind='barh')\nplot1","f70a58b9":"X_train.columns","00ffff56":"print(X_train.shape, y_train.shape)","d199a38c":"# Keep only significant features\nto_keep = fi[fi.imp>0.005].cols\nprint('significant Features: ', len(to_keep))\nto_keep","ed9b8be1":"# Make a DataFrame with only significant features\ndf_keep = df[to_keep].copy()\nX_train , X_valid = split_vals(df_keep,n_trn)\nX_train.shape","e7837aa8":"m2 = RandomForestRegressor(n_estimators=80, min_samples_leaf=3, max_features='sqrt', n_jobs=-1)\nm2.fit(X_train, y_train)\nprint_score(m2)","b19fc7fb":"# Get feature importances of our top features\nfi_to_keep = rf_feat_importance(m2, df_keep)\nplot2 = fi_to_keep.plot('cols','imp',figsize=(15,6), legend=True, kind='barh')\nplot2","0988d2e9":"import scipy \nfrom scipy.cluster import hierarchy as hc\n\ncorr= np.round(scipy.stats.spearmanr(df_keep).correlation,4)\ncorr_condensed = hc.distance.squareform(1-corr)\nz = hc.linkage(corr_condensed , method='average')\nfig = plt.figure(figsize=(14,10))\ndendrogram = hc.dendrogram(z, labels=df_keep.columns, orientation='left', leaf_font_size=16)\nplt.plot()","4310d561":"## Defining a function get_sample to get random sample of n rows from dataframe(df), without replacement.\ndef get_sample(df,n):\n    idxs = sorted(np.random.permutation(len(df))[:n])\n    return df.iloc[idxs].copy()","dd582c1d":"!pip install pdpbox","af3026ff":"!pip install pandas_summary","883ab924":"pip install plotnine","18724077":"df_keep.head()","c03eb786":"# plot the predictive quality of kills\nfrom pdpbox import pdp\nfrom plotnine import *\nfrom pandas_summary import DataFrameSummary\nx_all = get_sample(highly_corr, 100000)\nggplot(x_all, aes('_walkPerc_killsPerc','winPlacePerc'))+ stat_smooth(se=True, colour='red', method='mavg')\n","eee2f254":"# Plot the predictive quality of walkDistance\nx_all = get_sample(highly_corr, 100000)\nggplot(x_all, aes('_totalDistance','winPlacePerc'))+stat_smooth(se=True, colour='red', method='mavg')","c5abc193":"# Prepare data\ntrain = highly_corr.copy()\nval_perc_full = 0.20 # % to use for validation set\nn_valid_full = int(val_perc_full * len(train)) \nn_trn_full = len(train)-n_valid_full\ndf_full = train.drop(columns = ['winPlacePerc']) # all columns except target\ny = train['winPlacePerc'] # target variable\ndf_full = df_full[to_keep] # Keep only relevant features\nX_train, X_valid = split_vals(df_full, n_trn_full)\ny_train, y_valid = split_vals(y, n_trn_full)\n\n# Check dimensions of data\nprint('Sample train shape: ', X_train.shape, \n      'Sample target shape: ', y_train.shape, \n      'Sample validation shape: ', X_valid.shape)","9ebf81ef":"test.head()","3f86ffe4":"train.head()","838ef6f7":"test = pd.read_csv('..\/input\/pubg-ver1\/test.csv')\ntest = reduce_mem_usage(test)","081b9133":"test.head()","8c9953a3":"#Adding same features to test data\nagg = test.groupby(['groupId']).size().to_frame('players_in_team')\ntest = test.merge(agg, how='left', on=['groupId'])\ntest['_headshot_rate'] = test['headshotKills']\/test['kills']\ntest['_headshot_rate'] = test['_headshot_rate'].fillna(0)\ntest['_totalDistance'] = test['rideDistance'] + test['walkDistance'] + test['swimDistance']\ntest['_playersJoined'] = test.groupby('matchId')['matchId'].transform('count')\ntest['_killsNorm'] = test['kills'] * ((100-test['_playersJoined'])\/100+1)\ntest['_damageDealtNorm'] = test['damageDealt'] * ((100-test['_playersJoined'])\/100+1)\ntest['_healthItems'] = test['heals']+test['boosts']\ntest['_killsWithoutMoving'] = ((test['kills'] > 0) & (test['_totalDistance']==0))\ntest['_killPlacePerc'] = test['killPlace'].rank(pct=True).values\ntest['_killsPerc'] = test['kills'].rank(pct=True).values\ntest['_walkDistancePerc'] = test['walkDistance'].rank(pct=True).values\ntest['_walkPerc_killsPerc'] = test['_walkDistancePerc'] \/ test['_killsPerc']\ntest['_damageDealtPerc'] = test['damageDealt'].rank(pct=True).values\ntest['_killPlaceOverMaxPlace'] = test['killPlace']\/ test['maxPlace']\ntest['_killsPerc'] = test['kills'].rank(pct=True).values\ntest['_walkDistancePerc'] = test['walkDistance'].rank(pct=True).values\n","8f2b214d":"test.head()","4d2c3751":"test_pred = test[to_keep].copy()\n\ntest_pred.fillna(0, inplace=True)\ntest_pred.head()","268c6461":"#predictions = np.clip(a = m2.predict(test_pred), a_min=0.0, a_max=1.0)\n#pred_df = pd.DataFrame({'Id':test['Id'],'winPlacePerc':predictions})\n#pred_df\n#pred_df.to_csv(\"submission.csv\", index=False)","a2737def":"## 100% Headshot Kills","f2a35807":"## Sampling\n\nWe will take a sample of 500000 rows from our training set for easy debugging and exploration","ed94697c":"### Effect of Knocking (DBNO), Assisting or Reviving on Winning Percentage","4cecb933":"## Modifying the test data","77f91799":"## Effect of Killing in different Game type: Solo, Duos and Squad on Winning Percentage","b583f50d":"# Part 2: Feature Engineering","81957626":"## Analysing Healing and Boosting: Effect of Healing & Boosting on Winning Percentage","54d86c82":"## Finding Feature Importance using Random Forest","19e8431f":"### Tasks to be Performed\n**part 1: Exploratory Data Analysis**\n\n**part 2: Data Cleaning: Outlier Detection and Removal**\n\n**part 3: Feature Engineering**\n\n**part 4: Final Prediction**","81bbc3db":"## Building a Random Forest Model with top features","671952d3":"## Finding anomaly in travelling","c74282ee":"### Reduce memory Usage\n\nThe size of the PUBG dataset is pretty big for a lower\/mid-range laptop so here's a script to make the dataset smaller without losing information.This script of reducing size is taken from the prewritten kernels [here](https:\/\/www.kaggle.com\/gemartin\/load-data-reduce-memory-usage)\nIt uses the following approach:\n* Iterate over every Column\n* Determine If the column is numeric\n* Determine if the column can be represented by an integer\n* Find the min and the max value\n* Determine and apply the smallest datatype that can fit the range of values\n\nThis reduces the dataset from approx. 900 MB to 466 MB","d3fc91ea":"It seems most of the people cannot even make a single kill. But atleast they deal with some damage","5adf89c3":"## Creating a basic Random Forest Model","24680044":"## Killing without Moving\n**Identify the fraudsters who can making kills without even moving.**","b2fc5274":"Create a new feature 'headshot_rate'. We see that the most players score in the 0 to 10% region","7441580c":"The scatter plot below indicates there is a high correlation between running and winning percentage.**the longer you\u2019re alive, the more you run and more is the chance of winning.**\n\n### jointplot\nA marginal plot or joint plot allows to study the relationship between 2 numeric variables.","5b096aaa":"### Detecting Anomalies in Walking","f6d75aab":"## Inhuman Kills\n\nSome rows in our dataset have weird characteristics. The players could be fraudsters, maniacs or just anomalies. Removing these outliers will likely improve results","e0d0c36c":"##  PUBG-Finish Placement Prediction\n\nIn a PUBG game, up to 100 players start in each match (matchId). Players (Id) can be on teams (groupId) which get ranked at the end of the game (winPlacePerc) based on how many other teams are still alive when they are eliminated.\n\n### Goal:\nIn this notebook i have a definite role what to do with the data.Everyone is aware of famous Tancent Game PUBG, So here we are mainly Performing the PUBG data analysis and answering the questions below:\n\n* Does killing more people increases the chance of winning the game?\n\n* How do we catch the fraudsters in the game?\n\n* Can we predict the finishing position of a player in the game?","b902d004":"## Defining function for calculating Mean Absolute Error (MAE)","beb7ca48":"### Analysing Running","530db3a1":"The scatter plot above indicates there is a small correlation between driving and winning\nNext,,Theoretically, if a player is able to destroy the vehicle it indicates the he\/she is skilled.","2ba2e072":"## Part 1:\n\n### Unique count of Id,groupId,matchId","b690bbf7":"## Modifying the test Data","3d8f6054":"## Part 2: Data Cleaning: Outlier Detection and Removal ","e0089a6f":"## Loading CSV Files to DataFrame","45572713":"## Loading The Data","2c45f11b":"## Detecting Anomalies in Riding","b5082693":"## Analyse Riding","8ef39de6":"****Inference****: Both healing and boosts have a high correlation with winning, however boosts matter more. Both the plots shows abnormal behaviour at 0","94d61fef":"## Please stay upto last and be patient to load it.\n### Have a read and be kind to Upvote this notebook if you like the content.","99aa18c2":"## Part 3: Feature Engineering\n### Adding\/Removing some new Features and finding their correlation with the winPlacePer","fc4e08e3":"## Anomalies detection in Supplies (WeaponAcquired)","38c78b6a":"## Part 4: Final Prediction\n\n**Problem Statement**: You must create a model which predicts **players' finishing placemen**t based on their final stats, on a scale from 1 (first place) to 0 (last place.\n\n**Target variable**: winPlacePerc - This is a **percentile winning placement**, where 1 corresponds to 1st place, and 0 corresponds to last place in the match..In a game of PUBG, each team gets assigned a percentile value so there should approximatly be the same cout of 0s, 0.5s, 1s etc. (there might be irregularities in the distribution due imbalance in team sizes or number of teams). We should expect to see a uniform distribution for all percentile scores value, and a gaussian distribution with mean 0.5 for the average percentile score per match. \n","ffd23527":"## Dataset Description\n\n For the purposes of this exploratory analysis we\u2019re only going to be looking at the training data set.\n \n* **groupId** - Integer ID to identify a group within a match.\n* **matchId** - Integer ID to identify match. There are no matches that are in both the training and testing set.\n* **assists** - Number of times you helped your friend when he killed an enemy\n* **boosts** - Number of boost items used.\n* **damageDealt** - Total damage dealt\n* **DBNOs** - Number of enemy players knocked\n* **headshotKills** - Number of enemies you killed with headshots.\n* **killStreaks** - Max number of enemy players killed in a short amount of time.\n* **maxPlace** - Worst placement we have data for in the match. \n* **rideDistance** - Total distance traveled in vehicles (measured in meters).\n* **teamKills** - Number of times you are by killed your teammate.\n\n\n* * **winPlacePerc** - The target of prediction (Target Variable). This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match.","79818961":"## Anomalies in Heals\n\nMost players us 5 healing items or less. We can again recognize some weird anomalies","e8148c1c":"Well there are few people who win without even making a single kill or dealing with damage","3f943699":"## Longest Kill\nMost kills are made from a distance of 100 meters or closer.However there are some players (outliers) who make a kill from more than 1km away.","63517619":"## Anomalies in Killing:\nThe use of automated aiming software is without a doubt one of the most powerful cheats that can be used in Playerunknowns Battlegrounds at this time.\n\n**Calculating the total Distance travelled by a player which is the sum total of rideDistance, walkDistance and swimDistance**","6bed0f7c":"## Analysing Healing and boosting","6d442191":"## Generating a Dendogram to view highly correlated features","225a6def":"## Check Correlation of the feature with Winning Percentage","59c78a64":"## Road Kills","739919b2":"## Normalizing the features\n\nNow that we have a feature '_playersJoined' we can normalize other features based on the amount of players. Features that can be valuable to normalize are:\n1. kills\n2. daamageDealt\n3. maxPlace","0a3311a4":"### So this is all for this notebook kernel. Some codes in between was not known to me. So this is the kernel in which I have learnt about implementing Dendrogram and also learnt about ggplot from sources..and many more.\n## I will be happy if you find this notebook useful and please leave an Upvote of motivation and Encouragement. ","2da54722":"## Outlier Detection and Anamolies\n\n* Many kills without moving\n* Many roadkills while driving a very short distance\n* uspiciously high number of kills","ffd6c680":"## Effect of Killing on Winning percentage\n\n\nAs shown below by the increasing mean of win percentage placement, we found that kill count was correlated with our target variable","b3376524":"## Split target variable, validation data"}}