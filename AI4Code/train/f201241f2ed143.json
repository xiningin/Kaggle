{"cell_type":{"ac48f050":"code","fe21d666":"code","ee7a7a6f":"code","e3bb1418":"code","739e56e4":"code","51a5f746":"code","642f4df4":"code","04bcaf7b":"code","1c23b7a5":"markdown"},"source":{"ac48f050":"import pandas as pd, numpy as np\nimport os","fe21d666":"paths = [\n    \"..\/input\/rfcx-best-performing-public-kernels\/kkiller_inference-tpu-rfcx-audio-detection-fast_0861.csv\",\n    \"..\/input\/rfcx-best-performing-public-kernels\/submission_khoongweihao_0845.csv\",\n#     \"..\/input\/rfcx-best-performing-public-kernels\/submission_mekhdigakhramanian_0824.csv\",\n]\n\nweights = np.array([0.6, 0.4])\nsum(weights)","ee7a7a6f":"df = pd.read_csv(paths[0]).sort_values(\"recording_id\").reset_index(drop=True)\ndf.head()","e3bb1418":"cols = [f\"s{i}\" for i in range(24)]","739e56e4":"scores = []\nfor path in paths:\n    df = pd.read_csv(path).sort_values(\"recording_id\").reset_index(drop=True)\n    score = np.empty((len(df), 24))\n    o = df[cols].values.argsort(1)\n    score[np.arange(len(df))[:, None], o] = np.arange(24)[None]\n    scores.append(score)\nscores = np.stack(scores)\nscores.shape","51a5f746":"sub_score = np.sum(scores*weights[:, None, None], 0)\nprint(sub_score.shape)\nsub_score","642f4df4":"sub = pd.DataFrame(sub_score, columns=cols)\nsub[\"recording_id\"] = df[\"recording_id\"]\nsub = sub[[\"recording_id\"] + cols]\nprint(sub.shape)\nsub.head()","04bcaf7b":"sub.to_csv(\"submission.csv\", index=False)","1c23b7a5":"This comp's metric is different from others and must be well understood in order to design good bagging schemes. One of it's characteristics is that it **does not depend** on the absolute values of the predicted scores. Only their order is relevant. Hence, to bag serveal models, we just need to sort the scores and use their ranks.\n\nIn this work, I'll be proposing an order based bagging scheme that seems to perform very well. You can try it yourself !"}}