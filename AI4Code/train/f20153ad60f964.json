{"cell_type":{"cbdc540a":"code","e54cd19b":"code","871fc554":"code","4d591f61":"code","cc7647b4":"code","d77005c4":"code","ed569cf7":"code","a0f9920c":"code","a2619c0b":"code","a969bdd5":"markdown","ba5b5901":"markdown","ea46e0f1":"markdown","e7dda838":"markdown","6bf10afe":"markdown","00d65512":"markdown","9291ee2f":"markdown","287a8119":"markdown","06a7b7fd":"markdown","9843f11e":"markdown","dc068202":"markdown","9ac98f75":"markdown"},"source":{"cbdc540a":"# essa parte \u00e9 onde ocorre a importa\u00e7\u00e3o dos dados que vai alimentar o banco de dados.\nimport numpy as np\nimport pandas as pd \nfrom matplotlib import pyplot as plt\n\n # parte onde ele armazena a os dados lido na tabela de ranking  na variavel ranking\nrankings = pd.read_csv('..\/input\/fifa-international-soccer-mens-ranking-1993now\/fifa_ranking.csv')\nrankings = rankings.loc[:,['rank', 'country_full', 'country_abrv', 'cur_year_avg_weighted', 'rank_date', \n                           'two_year_ago_weighted', 'three_year_ago_weighted']]\nrankings = rankings.replace({\"IR Iran\": \"Iran\"})\nrankings['weighted_points'] =  rankings['cur_year_avg_weighted'] + rankings['two_year_ago_weighted'] + rankings['three_year_ago_weighted']\nrankings['rank_date'] = pd.to_datetime(rankings['rank_date'])\n\n # parte onde ele armazena a os dados lido na tabela resultados  na variavel partidas \nmatches = pd.read_csv('..\/input\/international-football-results-from-1872-to-2017\/results.csv')\nmatches =  matches.replace({'Germany DR': 'Germany', 'China': 'China PR'})\nmatches['date'] = pd.to_datetime(matches['date'])\n\n# parte onde ele armazena a os dados lidos na tabela de jogos da copa de 2018 \nworld_cup = pd.read_csv('..\/input\/fifa-worldcup-2018-dataset\/World Cup 2018 Dataset.csv')\nworld_cup = world_cup.loc[:, ['Team', 'Group', 'First match \\nagainst', 'Second match\\n against', 'Third match\\n against']]\nworld_cup = world_cup.dropna(how='all')\nworld_cup = world_cup.replace({\"IRAN\": \"Iran\", \n                               \"Costarica\": \"Costa Rica\", \n                               \"Porugal\": \"Portugal\", \n                               \"Columbia\": \"Colombia\", \n                               \"Korea\" : \"Korea Republic\"})\nworld_cup = world_cup.set_index('Team')","e54cd19b":"# atualiza\u00e7\u00e3o do rank diario\nrankings = rankings.set_index(['rank_date'])\\\n            .groupby(['country_full'], group_keys=False)\\\n            .resample('D').first()\\\n            .fillna(method='ffill')\\\n            .reset_index()\n\nmatches = matches.merge(rankings, \n                        left_on=['date', 'home_team'], \n                        right_on=['rank_date', 'country_full'])\nmatches = matches.merge(rankings, \n                        left_on=['date', 'away_team'], \n                        right_on=['rank_date', 'country_full'], \n                        suffixes=('_home', '_away'))","871fc554":"matches['rank_difference'] = matches['rank_home'] - matches['rank_away']\nmatches['average_rank'] = (matches['rank_home'] + matches['rank_away'])\/2\nmatches['point_difference'] = matches['weighted_points_home'] - matches['weighted_points_away']\nmatches['score_difference'] = matches['home_score'] - matches['away_score']\nmatches['is_won'] = matches['score_difference'] > 0 \nmatches['is_stake'] = matches['tournament'] != 'Friendly'\nmax_rest = 30\nmatches['rest_days'] = matches.groupby('home_team').diff()['date'].dt.days.clip(0,max_rest).fillna(max_rest)\nmatches['wc_participant'] = matches['home_team'] * matches['home_team'].isin(world_cup.index.tolist())\nmatches['wc_participant'] = matches['wc_participant'].replace({'':'Other'})\nmatches = matches.join(pd.get_dummies(matches['wc_participant']))","4d591f61":"from sklearn import linear_model\nfrom sklearn import ensemble\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, roc_curve, roc_auc_score\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX, y = matches.loc[:,['average_rank', 'rank_difference', 'point_difference', 'is_stake']], matches['is_won']\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42)\n\nlogreg = linear_model.LogisticRegression(C=1e-5)\nfeatures = PolynomialFeatures(degree=2)\nmodel = Pipeline([\n    ('polynomial_features', features),\n    ('logistic_regression', logreg)\n])\nmodel = model.fit(X_train, y_train)\n\nfpr, tpr, _ = roc_curve(y_test, model.predict_proba(X_test)[:,1])\nplt.figure(figsize=(15,5))\nax = plt.subplot(1,3,1)\nax.plot([0, 1], [0, 1], 'k--')\nax.plot(fpr, tpr)\nax.set_title('AUC score is {0:0.2}'.format(roc_auc_score(y_test, model.predict_proba(X_test)[:,1])))\nax.set_aspect(1)\n\nax = plt.subplot(1,3,2)\ncm = confusion_matrix(y_test, model.predict(X_test))\nax.imshow(cm, cmap='Blues', clim = (0, cm.max())) \n\nax.set_xlabel('Predicted label')\nax.set_title('Performance on the Test set')\n\nax = plt.subplot(1,3,3)\ncm = confusion_matrix(y_train, model.predict(X_train))\nax.imshow(cm, cmap='Blues', clim = (0, cm.max())) \nax.set_xlabel('Predicted label')\nax.set_title('Performance on the Training set')\npass","cc7647b4":"features = ['average_rank', 'rank_difference', 'point_difference']\nwrongs = y_test != model.predict(X_test)\n\nfor feature in features:\n    plt.figure()\n    plt.title(feature)\n    X_test.loc[wrongs, feature].plot.kde()\n    X.loc[:, feature].plot.kde()\n    plt.legend(['wrongs', 'all'])\n    \nprint(\"Stakes distribution in the wrong predictions\")\nprint(X_test.loc[wrongs, 'is_stake'].value_counts() \/ wrongs.sum())\nprint(\"Stakes distribution overall\")\nprint(X['is_stake'].value_counts() \/ X.shape[0])","d77005c4":"# Definir uma pequena marge de seguran\u00e7a para prever o empate do que a vit\u00f3ria.\nmargin = 0.05\n\n# Definir os ranks no momento da copa do mundo de 2018.\nworld_cup_rankings = rankings.loc[(rankings['rank_date'] == rankings['rank_date'].max()) & \n                                    rankings['country_full'].isin(world_cup.index.unique())]\nworld_cup_rankings = world_cup_rankings.set_index(['country_full'])","ed569cf7":"from itertools import combinations\n\nopponents = ['First match \\nagainst', 'Second match\\n against', 'Third match\\n against']\n\nworld_cup['points'] = 0\nworld_cup['total_prob'] = 0\n\nfor group in set(world_cup['Group']):\n    print('___Starting group {}:___'.format(group))\n    for home, away in combinations(world_cup.query('Group == \"{}\"'.format(group)).index, 2):\n        print(\"{} vs. {}: \".format(home, away), end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        home_rank = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        row['average_rank'] = (home_rank + opp_rank) \/ 2\n        row['rank_difference'] = home_rank - opp_rank\n        row['point_difference'] = home_points - opp_points\n        \n        home_win_prob = model.predict_proba(row)[:,1][0]\n        world_cup.loc[home, 'total_prob'] += home_win_prob\n        world_cup.loc[away, 'total_prob'] += 1-home_win_prob\n        \n        points = 0\n        if home_win_prob <= 0.5 - margin:\n            print(\"{} wins with {:.2f}\".format(away, 1-home_win_prob))\n            world_cup.loc[away, 'points'] += 3\n        if home_win_prob > 0.5 - margin:\n            points = 1\n        if home_win_prob >= 0.5 + margin:\n            points = 3\n            world_cup.loc[home, 'points'] += 3\n            print(\"{} wins with {:.2f}\".format(home, home_win_prob))\n        if points == 1:\n            print(\"Draw\")\n            world_cup.loc[home, 'points'] += 1\n            world_cup.loc[away, 'points'] += 1","a0f9920c":"pairing = [0,3,4,7,8,11,12,15,1,2,5,6,9,10,13,14]\n\nworld_cup = world_cup.sort_values(by=['Group', 'points', 'total_prob'], ascending=False).reset_index()\nnext_round_wc = world_cup.groupby('Group').nth([0, 1]) \nnext_round_wc = next_round_wc.reset_index()\nnext_round_wc = next_round_wc.loc[pairing]\nnext_round_wc = next_round_wc.set_index('Team')\n\nfinals = ['round_of_16', 'quarterfinal', 'semifinal', 'final']\n\nlabels = list()\nodds = list()\n\nfor f in finals:\n    print(\"___Starting of the {}___\".format(f))\n    iterations = int(len(next_round_wc) \/ 2)\n    winners = []\n\n    for i in range(iterations):\n        home = next_round_wc.index[i*2]\n        away = next_round_wc.index[i*2+1]\n        print(\"{} vs. {}: \".format(home,\n                                   away), \n                                   end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        home_rank = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        row['average_rank'] = (home_rank + opp_rank) \/ 2\n        row['rank_difference'] = home_rank - opp_rank\n        row['point_difference'] = home_points - opp_points\n\n        home_win_prob = model.predict_proba(row)[:,1][0]\n        if model.predict_proba(row)[:,1] <= 0.5:\n            print(\"{0} wins with probability {1:.2f}\".format(away, 1-home_win_prob))\n            winners.append(away)\n        else:\n            print(\"{0} wins with probability {1:.2f}\".format(home, home_win_prob))\n            winners.append(home)\n\n        labels.append(\"{}({:.2f}) vs. {}({:.2f})\".format(world_cup_rankings.loc[home, 'country_abrv'], \n                                                        1\/home_win_prob, \n                                                        world_cup_rankings.loc[away, 'country_abrv'], \n                                                        1\/(1-home_win_prob)))\n        odds.append([home_win_prob, 1-home_win_prob])\n                \n    next_round_wc = next_round_wc.loc[winners]\n    print(\"\\n\")","a2619c0b":"import networkx as nx\nimport pydot\nfrom networkx.drawing.nx_pydot import graphviz_layout\n\nnode_sizes = pd.DataFrame(list(reversed(odds)))\nscale_factor = 0.3 \nG = nx.balanced_tree(2, 3)\npos = graphviz_layout(G, prog='twopi', args='')\ncentre = pd.DataFrame(pos).mean(axis=1).mean()\n\nplt.figure(figsize=(10, 10))\nax = plt.subplot(1,1,1)\ncircle_positions = [(235, 'black'), (180, 'blue'), (120, 'red'), (60, 'yellow')]\n[ax.add_artist(plt.Circle((centre, centre), \n                          cp, color='grey', \n                          alpha=0.2)) for cp, c in circle_positions]\n\n# desenhar o primeiro gr\u00e1fico\nnx.draw(G, pos, \n        node_color=node_sizes.diff(axis=1)[1].abs().pow(scale_factor), \n        node_size=node_sizes.diff(axis=1)[1].abs().pow(scale_factor)*2000, \n        alpha=1, \n        cmap='Reds',\n        edge_color='black',\n        width=10,\n        with_labels=False)\n\n# desenhar a chave de final\nshifted_pos = {k:[(v[0]-centre)*0.9+centre,(v[1]-centre)*0.9+centre] for k,v in pos.items()}\nnx.draw_networkx_labels(G, \n                        pos=shifted_pos, \n                        bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"black\", lw=.5, alpha=1),\n                        labels=dict(zip(reversed(range(len(labels))), labels)))\n\ntexts = ((10, 'Best 16', 'black'), (70, 'Quarter-\\nfinal', 'blue'), (130, 'Semifinal', 'red'), (190, 'Final', 'yellow'))\n[plt.text(p, centre+20, t, \n          fontsize=12, color='grey', \n          va='center', ha='center') for p,t,c in texts]\nplt.axis('equal')\nplt.title('Single-elimination phase\\npredictions with fair odds', fontsize=20)\nplt.show()","a969bdd5":"# Prever o vencedor da Copa do Mundo FIFA 2018\n**Objetivos **:\nprever o resultado da Copa do Mundo FIFA 2018\n\n **M\u00e9todo**:\n- Foi utilizado o Kaggle para modelar o resultado de certos jogos entre equipes, de acordo com sua classifica\u00e7\u00e3o, pontos e a diferen\u00e7a de pontos ponderada com o oponente.\n- Este modelo tem a fun\u00e7\u00e3o de prever o resultado das rodadas do grupo e, em seguida, a fase de elimina\u00e7\u00e3o \u00fanica.","ba5b5901":"# Conclus\u00e3o\n\n  Ap\u00f3s a analise realizada e verificarmos como funciona um sistema de chaveamento \/ mata - mata de uma copa do mundo. A base de dados utilizada neste programa gera estatisticas baseadas em par\u00e2metros pr\u00e9 definidos com base no hist\u00f3rico de jogos das sele\u00e7\u00f5es, gols, vit\u00f3rias, derrotas e etc. Em cima de desse banco de dados os valores s\u00e3o estipulados e assim gera-se a probabilidade de uma sele\u00e7\u00e3o ganhar da outra como no exemplo: Portugal vc. Iran: Portugal wins with 0,65. \n  Foi utilizado o modelo de regress\u00e3o simples, que estuda a rela\u00e7\u00e3o entre duas vari\u00e1veis quaisquer.     Chamamos a vari\u00e1vel X de vari\u00e1vel Independente, e Y de vari\u00e1vel Dependente. Assim, estaremos estabelecendo que nosso intuito \u00e9 observar como X varia a partir de varia\u00e7\u00f5es em Y. Os dados analizados s\u00e3o estatisticas que ser\u00e3o verificadas para gerar um resultado final (Ganhador da Copa do Mundo de 2018). As probabilidades podem ser alteradas dependendo do banco de dados do hist\u00f3rico de cada sele\u00e7\u00e3o em cima dos fatores citados acima.\n  Neste modelo temos variaveis de entrada sendo algumas como: Previous appearances, History with first oponente goals, Rank, etc. E a variavel de sa\u00edda que \u00e9 o ganhador.\n  Com base em tudo o estudo concluimos que um sistema desses a probabilidade de acertar um vencedor de um campeonato se torna \"mais f\u00e1cil\" e mais preciso por termos todo um hist\u00f3rico baseado em anos de jogos e resultados.\n\n\n\n","ea46e0f1":"# Atualiza\u00e7\u00e3o do rank\nEsta parte \u00e9 utilizad para atualizar os dados de rank diario.\n","e7dda838":"## Fase de Grupos","6bf10afe":"# Calculos de probabilidade.\nEsta parte \u00e9 utilizada para atualizar realiza\u00e7\u00e3o dos calculos de propabilidade o time vencer o jogo.\n","00d65512":"## Etapa onde ocorre a simula\u00e7\u00e3o dos jogos Eliminat\u00f3rios.","9291ee2f":"# Simula\u00e7\u00e3o da Copa do Mundo","287a8119":"Calculo de previs\u00f5es erradas.","06a7b7fd":"Os 3 gr\u00e1ficos demonstram a margem de erro dos calculos de previs\u00f5es.  a diferen\u00e7a de pontua\u00e7\u00e3o m\u00e9dia por jogo, a diferen\u00e7a de rank da FIFA, e o ultimo demonstra a diferen\u00e7a de pontua\u00e7\u00e3o por jogos","9843f11e":"# Vizualiza\u00e7\u00e3o da Fase Eliminat\u00f3ria","dc068202":"# E \/ S de dados\n\nFoi utilizado tr\u00eas conjuntos de dados\n\n- Classifica\u00e7\u00f5es da FIFA de 1993 a 2018 ([Tadhg Fitzgerald](https:\/\/www.kaggle.com\/tadhgfitzgerald))\n>  \u00e9 uma classifica\u00e7\u00e3o que muda mensalmente, baseado no desempenho da equipe em cima dos jogos realizados.\n(http:\/\/www.sportingintelligence.com\/2014\/06\/20\/upsets-giant-killings-adios-bye-bye-fifa-rankings-still-ahead-in-predicting-results-200601\/)\n\n- Jogos internacionais de futebol de 1872 a 2018 ([Mart J\u00fcrisoo](https:\/\/www.kaggle.com\/martj42))\n> Utilizado para analizar o quanto a diferen\u00e7a de pontos, classifica\u00e7\u00f5es e a classifica\u00e7\u00e3o atual da equipe afetam o resultado de uma partida\n\n- Conjunto de dados da Copa do Mundo FIFA 2018 ([Nuggs](https:\/\/www.kaggle.com\/ahmedelnaggar))\n> Utilizado para obter a chave dos grupos da copa do mundo.\n\n","9ac98f75":"# Modelagem\n\nFoi utilizado uma logica de regress\u00e3o simples."}}