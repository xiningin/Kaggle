{"cell_type":{"5b47fff1":"code","569406e2":"code","32d01ff7":"code","4c58260e":"code","62e8e0f7":"code","14916f19":"code","54801791":"code","954167b3":"code","a1fe4d38":"code","2fa1bf39":"code","4d2c9b35":"code","b34d3afe":"code","8aa7dfed":"code","7a1a997f":"code","153ed576":"code","38f51176":"code","a227ed97":"code","1ece9ba7":"code","36fe6789":"code","166d15ff":"code","913ab4e5":"code","9bf33730":"code","b5cd22c9":"code","ce4d5d01":"code","988d6c58":"markdown","2e7dfb06":"markdown","3408564e":"markdown","162c05f6":"markdown","ec84ecae":"markdown","a7586f23":"markdown","a98782dd":"markdown","5d86b9af":"markdown","aad754a5":"markdown","dd56d085":"markdown","2acb89f9":"markdown"},"source":{"5b47fff1":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","569406e2":"# Importing Libraries\nimport pandas as pd\nimport re\nfrom fuzzywuzzy import fuzz","32d01ff7":"# Import CSV\nWORKING_DIR = '\/kaggle\/input\/payment-id-ndsc-2020\/'\nbank_statement = pd.read_csv(WORKING_DIR + 'bank_statement.csv')\ncheckout = pd.read_csv(WORKING_DIR + 'checkout.csv')\nprint(bank_statement.shape, checkout.shape)","4c58260e":"# Removing Special Characters\nbank_statement.desc = bank_statement.desc.apply(lambda x: re.sub(r\"[^a-zA-Z0-9]+\", ' ', x))\ncheckout.buyer_name = checkout.buyer_name.apply(lambda x: re.sub(r\"[^a-zA-Z0-9]+\", ' ', x))\nbank_statement.desc = bank_statement.desc.apply(lambda x: re.sub(r\"TRANSFER\", '', x))\ncheckout.buyer_name = checkout.buyer_name.apply(lambda x: re.sub(r\"TRANSFER\", '', x))","62e8e0f7":"# Sorting amount by value\nbank_statement = bank_statement.sort_values(by=['stmt_amount'])\ncheckout = checkout.sort_values(by=['ckt_amount'])\n\n# Converting the description and buyer name to SET\nbank_statement.desc = bank_statement.desc.apply(lambda x: set(x.split()))\ncheckout.buyer_name = checkout.buyer_name.apply(lambda x: set(x.split()))","14916f19":"checkout.head(30)","54801791":"bank_statement.head(30)","954167b3":"# Sorted List of Prices\nprices = sorted(list(set(checkout.ckt_amount)))","a1fe4d38":"# Matching the price & description\nbs, co = bank_statement.values.tolist(), checkout.values.tolist(), \ncurr_bank, curr_trans, pend_bank, pend_trans = [], [], [], []\nanswer = []\nno_ans_trans, no_ans_bank = [], []\nfor price in prices:\n    while bs and bs[0][1] == price:\n        curr_bank.append(bs.pop(0))\n    while co and co[0][1] == price:\n        curr_trans.append(co.pop(0))\n\n    for trans in curr_trans:\n        found = False\n        curname = trans[2]\n        bk = list(filter(lambda x: x[2].intersection(curname), curr_bank))\n        if bk:\n            b = max(bk, key= lambda x: len(x[2].intersection(curname)))\n            answer.append((trans, b))\n            curr_bank.remove(b)\n        else:\n            no_ans_trans.append(trans)\n            \n    no_ans_bank.extend(curr_bank)\n            \n    curr_bank, curr_trans = [], []","2fa1bf39":"# Number of transaction that does not match\nprint(len(no_ans_bank), len(no_ans_trans))","4d2c9b35":"no_ans_bank[:10]","b34d3afe":"no_ans_trans[:10]","8aa7dfed":"# Getting IDs of transaction that does not match\nno_id_bank, no_id_trans = [], []\nfor x in range(len(no_ans_bank)):\n    no_id_bank.append(no_ans_bank[x][0])\n    no_id_trans.append(no_ans_trans[x][0])","7a1a997f":"# Getting subset of dataframe that previously has no match\ncheckout2 = checkout[checkout['ckt_id'].isin(no_id_trans)]\nbank_statement2 = bank_statement[bank_statement['stmt_id'].isin(no_id_bank)]","153ed576":"bank_statement2.head()","38f51176":"checkout2.head()","a227ed97":"# Converting Set to string\nbank_statement2['desc'] = bank_statement2['desc'].apply(lambda x: ' '.join(sorted(list(x))))\ncheckout2['buyer_name'] = checkout2['buyer_name'].apply(lambda x: ' '.join(sorted(list(x))))","1ece9ba7":"bank_statement2.head()","36fe6789":"checkout2.head()","166d15ff":"prices = sorted(list(set(checkout2.ckt_amount)))","913ab4e5":"# Applying Fuzzy Search\nbs2, co2 = bank_statement2.values.tolist(), checkout2.values.tolist(), \ncurr_bank2, curr_trans2 = [], []\nanswer2 = []\nfor price in prices:\n    while bs2 and bs2[0][1] == price:\n        curr_bank2.append(bs2.pop(0))\n    while co2 and co2[0][1] == price:\n        curr_trans2.append(co2.pop(0))\n    for trans in curr_trans2:\n        curname = trans[2]\n        b = max(curr_bank2, key= lambda x: fuzz.partial_ratio(curname, x[2]))\n        answer2.append((trans, b))\n        curr_bank2.remove(b)\n    curr_bank2, curr_trans2 = [], []","9bf33730":"pd.DataFrame(answer2).to_csv('analysis.csv')","b5cd22c9":"# Construct final dataframe\nfs1 = [(x[0][0], x[1][0]) for x in answer]\nfs2 = [(x[0][0], x[1][0]) for x in answer2]\nfs = pd.DataFrame(fs1+fs2)\nfs.columns=['ckt_id', 'stmt_id']\nfs=fs[['stmt_id', 'ckt_id']]","ce4d5d01":"# Output CSV\nprint(fs.shape)\nfs.to_csv('\/kaggle\/working\/finalanswer.csv', index=False)","988d6c58":"FUZZY FUZZY FUZZY","2e7dfb06":"TEEHEE","3408564e":"We will remove special characters and \"TRANSFER\" as after our first run, these characters are just causing the data to be noisy. It kinda improved the accuracy by a tiny bit. ","162c05f6":"### Matching Price and Description","ec84ecae":"We worked the solution locally and would like to publish it here for everyone's benefit. \n\nOur general attempt is basically:\n1. If we find common tokens (words) between buyer's name and transaction description, we will consider it a match (quite greedy, huh). Bank transaction will be then removed and cannot be used by other transactions accounts (Haven't tested whether this is a good idea or not). \n2. Those that can't find a pair will be matched up using fuzzy match. \n\nWe do not do fuzzy match from the beginning as we thought it would be computationally too expensive and imperfect.","a7586f23":"We sort the values for efficiency and convert the strings to sets for better data structure and better time complexity.","a98782dd":"Our greedy code resulted in 3k lost transactions. Not bad. ","5d86b9af":"1. Go through the unique prices one by one\n2. For each price, query all the bank statements and transactions\n3. For each transaction, find a bank statement that matches best.\n4. For every lost child in a mall, put them in the nursery until the parents' pick him up. Just kidding. If the transaction cannot find a fitting bank statement, it will be stored to be processed later using fuzzy search.","aad754a5":"### Improving with Fuzzy Search (for transaction that does not match)\n\nP.S. Admittedly, this part is inefficient as this was done by a second team member. He needs to reshape the data to something he understands.","dd56d085":"Here's for you to debug whether your fuzzy works or not.","2acb89f9":"From a simple glance below, we can see that we kinda separated confusing transactions and bank statements properly (meaning, none of the pairs are split between the lost group below and the found group above)"}}