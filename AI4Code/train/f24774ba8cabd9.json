{"cell_type":{"960a005a":"code","ab8384df":"code","86433d24":"code","5d10fefb":"code","b8fe7035":"code","54a49109":"code","2cd1e896":"code","b777ba14":"code","1abc8203":"code","bfbcf0db":"code","8823ae2d":"code","fb213cec":"code","231305fe":"code","6442c68c":"code","91a722d3":"code","90bc6572":"code","ce5b066a":"code","ff10ab42":"markdown","c419f6eb":"markdown"},"source":{"960a005a":"import collections\n\nimport random","ab8384df":"Nucleotides = [\"A\", \"C\", \"G\", \"T\"]\n\nDNA_ReverseComplement = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}\n\nDNA_Codons = {\n    # 'M' - START, '_' - STOP\n    \"GCT\": \"A\", \"GCC\": \"A\", \"GCA\": \"A\", \"GCG\": \"A\",\n    \"TGT\": \"C\", \"TGC\": \"C\",\n    \"GAT\": \"D\", \"GAC\": \"D\",\n    \"GAA\": \"E\", \"GAG\": \"E\",\n    \"TTT\": \"F\", \"TTC\": \"F\",\n    \"GGT\": \"G\", \"GGC\": \"G\", \"GGA\": \"G\", \"GGG\": \"G\",\n    \"CAT\": \"H\", \"CAC\": \"H\",\n    \"ATA\": \"I\", \"ATT\": \"I\", \"ATC\": \"I\",\n    \"AAA\": \"K\", \"AAG\": \"K\",\n    \"TTA\": \"L\", \"TTG\": \"L\", \"CTT\": \"L\", \"CTC\": \"L\", \"CTA\": \"L\", \"CTG\": \"L\",\n    \"ATG\": \"M\",\n    \"AAT\": \"N\", \"AAC\": \"N\",\n    \"CCT\": \"P\", \"CCC\": \"P\", \"CCA\": \"P\", \"CCG\": \"P\",\n    \"CAA\": \"Q\", \"CAG\": \"Q\",\n    \"CGT\": \"R\", \"CGC\": \"R\", \"CGA\": \"R\", \"CGG\": \"R\", \"AGA\": \"R\", \"AGG\": \"R\",\n    \"TCT\": \"S\", \"TCC\": \"S\", \"TCA\": \"S\", \"TCG\": \"S\", \"AGT\": \"S\", \"AGC\": \"S\",\n    \"ACT\": \"T\", \"ACC\": \"T\", \"ACA\": \"T\", \"ACG\": \"T\",\n    \"GTT\": \"V\", \"GTC\": \"V\", \"GTA\": \"V\", \"GTG\": \"V\",\n    \"TGG\": \"W\",\n    \"TAT\": \"Y\", \"TAC\": \"Y\",\n    \"TAA\": \"_\", \"TAG\": \"_\", \"TGA\": \"_\"\n}\n\n# NM_000207.3 Homo sapiens insulin (INS), transcript variant 1, mRNA\nNM_000207_3 = \"AGCCCTCCAGGACAGGCTGCATCAGAAGAGGCCATCAAGCAGATCACTGTCCTTCTGCCATGGCCCTGTGGATGCGCCTCCTGCCCCTGCTGGCGCTGCTGGCCCTCTGGGGACCTGACCCAGCCGCAGCCTTTGTGAACCAACACCTGTGCGGCTCACACCTGGTGGAAGCTCTCTACCTAGTGTGCGGGGAACGAGGCTTCTTCTACACACCCAAGACCCGCCGGGAGGCAGAGGACCTGCAGGTGGGGCAGGTGGAGCTGGGCGGGGGCCCTGGTGCAGGCAGCCTGCAGCCCTTGGCCCTGGAGGGGTCCCTGCAGAAGCGTGGCATTGTGGAACAATGCTGTACCAGCATCTGCTCCCTCTACCAGCTGGAGAACTACTGCAACTAGACGCAGCCCGCAGGCAGCCCCACACCCGCCGCCTCCTGCACCGAGAGAGATGGAATAAAGCCCTTGAACCAGC\"\n","86433d24":"# Check the sequence to make sure it is a DNA String\ndef validateSeq(dna_seq):\n    \"\"\"Check the sequence to make sure it is a valid DNA string\"\"\"\n    tmpseq = dna_seq.upper()\n    for nuc in tmpseq:\n        if nuc not in Nucleotides:\n            return False\n    return tmpseq","5d10fefb":"def countNucFrequency(seq):\n    #tmpFreqDict = {\"A\": 0, \"C\": 0, \"G\": 0, \"T\": 0}\n    #for nuc in seq:\n    #   tmpFreqDict[nuc] += 1\n    #return tmpFreqDict\n    return dict(collections.Counter(seq))","b8fe7035":"def transcription(seq):\n    \"\"\" DNA -> RNA Transcription\"\"\"\n    return seq.replace(\"T\",\"U\")","54a49109":"def reverse_completment(seq):\n    #return ''.join(DNA_ReverseComplement[nuc] for nuc in seq)[::-1]\n    # Pythonic approach. A little bit faster solution\n    mapping =str.maketrans('ATCG','TAGC')\n    return seq.translate(mapping)[::-1]","2cd1e896":"def gc_content(seq):\n    \"\"\"GC Content in a DNA\/RNA sequence\"\"\"\n    return round((seq.count('C') +seq.count('G'))\/len(seq)*100)","b777ba14":"def gc_content_subsec(seq, k=20):\n    \"\"\"GC content in a DNA\/RNA sub-sequence length k. k=20 by default\"\"\"\n    res = []\n    for i in range(0, len(seq) - k + 1, k):\n        subseq = seq[i: i+ k]\n        res.append(gc_content(subseq))\n    return res","1abc8203":"def translate_seq(seq, init_pos = 0):\n    \"\"\"Translates a DNA sequence into a aminoacid sequence\"\"\"\n    return [DNA_Codons[seq[pos: pos+3]] for pos in range(init_pos,len(seq)-2,3)]","bfbcf0db":"def condon_usage(seq,aminoacid):\n    \"\"\"Provides the frequency of each condon encoding a given aminoacid in a DNA sequencs\"\"\"\n    tmpList = []\n    for i in range(0,len(seq) - 2, 3):\n        if DNA_Codons[seq[i: i + 3]] == aminoacid:\n            tmpList.append(seq[i:i + 3])\n    freqDict = dict(collections.Counter(tmpList))\n    totalWight = sum(freqDict.values())\n    for seq in freqDict:\n        freqDict[seq] = round(freqDict[seq]\/totalWight, 2)\n    return freqDict","8823ae2d":"def gen_reading_frames(seq):\n    \"\"\"Generate the six reading frames of a DNA sequence, including reverse complement\"\"\"\n    frames = []\n    frames.append(translate_seq(seq, 0))\n    frames.append(translate_seq(seq, 1))\n    frames.append(translate_seq(seq, 2))\n    frames.append(translate_seq(reverse_completment(seq), 0))\n    frames.append(translate_seq(reverse_completment(seq), 1))\n    frames.append(translate_seq(reverse_completment(seq), 2))\n    return frames","fb213cec":"def proteins_from_rf(aa_seq):\n    \"\"\"Compute all possible proteins in an aminoacid seq and return a list of possible proteins\"\"\"\n    current_prot = []\n    proteins = []\n    for aa in aa_seq:\n        if aa ==\"_\":\n            # STOP accumulating amino acids if _ - STOPwas found\n            if current_prot:\n                for p in current_prot:\n                    proteins.append(p)\n                current_prot = []\n        else:\n            # START accumulating amino acids if M - START was found\n            if aa ==\"M\":\n                current_prot.append(\"\")\n            for i in range(len(current_prot)):\n                current_prot[i] += aa\n    return proteins","231305fe":"def all_proteins_from_orfs(seq, startReadPos=0, endReadPos=0, ordered= False):\n    \"\"\"Compute all possible proteins for all open reading frames\"\"\"\n    \"\"\"Protine Search DB: https:\/\/www.ncbi.nlm.nih.gov\/nuccore\/NM_001185097.2\"\"\"\n    \"\"\"API can be used to pull protein info\"\"\"\n    if endReadPos >startReadPos:\n        rfs = gen_reading_frames(seq[startReadPos:endReadPos])\n    else:\n        rfs =gen_reading_frames(seq)\n    res = []\n    for rf in rfs:\n        prots = proteins_from_rf(rf)\n        for p in prots:\n            res.append(p)\n    if ordered:\n        return sorted(res, key=len, reverse=True)\n    return res","6442c68c":"def colored(seq):\n    bcolors = {\n        'A': '\\033[92m',\n        'C': '\\033[94m',\n        'G': '\\033[93m',\n        'T': '\\033[91m',\n        'U': '\\033[91m',\n        'reset': '\\033[0;0m'\n    }\n    tmpStr = \"\"\n    for nuc in seq:\n        if nuc in bcolors:\n            tmpStr += bcolors[nuc] + nuc\n        else:\n            tmpStr += bcolors['reset'] + nuc\n    return tmpStr + '\\033[0;0m'","91a722d3":"randDNAStr = ''.join([random.choice(Nucleotides) for nuc in range(50)])\n\nDNAstr =validateSeq(randDNAStr)","90bc6572":"print(f\"\\n Sequence: {colored(DNAstr)} \\n\")\n","ce5b066a":"print(f\"[1] + Sequence Length: {len(DNAstr)}\\n\")\nprint(f\"[2] + Nucleotide Frequency: {countNucFrequency(DNAstr)}\\n\")\nprint(f\"[3] + DNA\/RNA Transcription: {colored(transcription(DNAstr))}\\n\")\nprint(f\"[4] + DNA string + Reverse Complement: \\n5' {colored(DNAstr)} 3'\")\nprint(f\"   {''.join((['|' for  c in range(len(DNAstr))]))}\")\nprint(f\"3' {colored(reverse_completment(DNAstr))} 5'\\n\")\nprint(f\"[5] + GC Content: {gc_content(DNAstr)}%\\n\")\n\nprint(f\"[6] + GC Content in Subsection k=5: {gc_content_subsec(DNAstr,k=5)}\\n\")\nprint(f\"[7] + Aminoacids Sequence from DNA: {translate_seq(DNAstr,0)}\\n\")\nprint(f\"[8] + Condon frequency (L): {condon_usage(DNAstr,'L')}\\n\")\nprint(f\"[9] + Reading_frames:\")\nfor frame in gen_reading_frames(DNAstr):\n    print(frame)\n\ntest_rf_frame = ['L', 'M', 'F', 'E', 'F', 'T', 'M', 'F', 'G', 'Y', '_', 'T', 'E', 'L', 'H', 'C']\nprint(proteins_from_rf(test_rf_frame))\n\nprint(\"\\n[10] + All prots in 6 open reading frames:\")\nfor prot in all_proteins_from_orfs(NM_000207_3,0,0,True):\n    print (f'{prot}')","ff10ab42":"# **DNA Tootkit**\n\nThese are basic processes on DNA sequence","c419f6eb":"**Structures**"}}