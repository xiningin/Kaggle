{"cell_type":{"f9824303":"code","78a4e024":"code","3d19aea5":"code","7b97f205":"code","a7329908":"code","b95c956b":"code","340d9fdc":"code","b2432c00":"code","ed5a0519":"code","994ce0d6":"code","80ed577a":"code","3fc346f6":"code","0a9f5d37":"code","e0f31b30":"code","d094ba8b":"code","780f7554":"code","ada9b790":"code","9c2770d7":"code","63c3c617":"code","d9d350db":"code","8eba3612":"code","b439a8c2":"code","f3ea72e2":"code","eb1d3e92":"code","1a52aecb":"code","bed36820":"code","2b3fd842":"code","8a20156f":"code","ca201a82":"markdown","c511ca7c":"markdown","1078cecd":"markdown","1558ed25":"markdown","452deda3":"markdown","b62b8e84":"markdown","3366b362":"markdown","620cfba5":"markdown"},"source":{"f9824303":"from __future__ import print_function\n\n\"\"\"This file contains code for use with \"Think Bayes\",\nby Allen B. Downey, available from greenteapress.com\n\nCopyright 2012 Allen B. Downey\nLicense: GNU GPLv3 http:\/\/www.gnu.org\/licenses\/gpl.html\n\"\"\"\n\n\"\"\"This file contains class definitions for:\n\nHist: represents a histogram (map from values to integer frequencies).\n\nPmf: represents a probability mass function (map from values to probs).\n\n_DictWrapper: private parent class for Hist and Pmf.\n\nCdf: represents a discrete cumulative distribution function\n\nPdf: represents a continuous probability density function\n\n\"\"\"\n\nimport bisect\nimport copy\nimport logging\nimport math\nimport numpy\nimport random\n\nimport scipy.stats\nfrom scipy.special import erf, erfinv, gammaln\n\nROOT2 = math.sqrt(2)\n\ndef RandomSeed(x):\n    \"\"\"Initialize the random and numpy.random generators.\n\n    x: int seed\n    \"\"\"\n    random.seed(x)\n    numpy.random.seed(x)\n    \n\ndef Odds(p):\n    \"\"\"Computes odds for a given probability.\n\n    Example: p=0.75 means 75 for and 25 against, or 3:1 odds in favor.\n\n    Note: when p=1, the formula for odds divides by zero, which is\n    normally undefined.  But I think it is reasonable to define Odds(1)\n    to be infinity, so that's what this function does.\n\n    p: float 0-1\n\n    Returns: float odds\n    \"\"\"\n    if p == 1:\n        return float('inf')\n    return p \/ (1 - p)\n\n\ndef Probability(o):\n    \"\"\"Computes the probability corresponding to given odds.\n\n    Example: o=2 means 2:1 odds in favor, or 2\/3 probability\n\n    o: float odds, strictly positive\n\n    Returns: float probability\n    \"\"\"\n    return o \/ (o + 1)\n\n\ndef Probability2(yes, no):\n    \"\"\"Computes the probability corresponding to given odds.\n\n    Example: yes=2, no=1 means 2:1 odds in favor, or 2\/3 probability.\n    \n    yes, no: int or float odds in favor\n    \"\"\"\n    return float(yes) \/ (yes + no)\n\n\nclass Interpolator(object):\n    \"\"\"Represents a mapping between sorted sequences; performs linear interp.\n\n    Attributes:\n        xs: sorted list\n        ys: sorted list\n    \"\"\"\n\n    def __init__(self, xs, ys):\n        self.xs = xs\n        self.ys = ys\n\n    def Lookup(self, x):\n        \"\"\"Looks up x and returns the corresponding value of y.\"\"\"\n        return self._Bisect(x, self.xs, self.ys)\n\n    def Reverse(self, y):\n        \"\"\"Looks up y and returns the corresponding value of x.\"\"\"\n        return self._Bisect(y, self.ys, self.xs)\n\n    def _Bisect(self, x, xs, ys):\n        \"\"\"Helper function.\"\"\"\n        if x <= xs[0]:\n            return ys[0]\n        if x >= xs[-1]:\n            return ys[-1]\n        i = bisect.bisect(xs, x)\n        frac = 1.0 * (x - xs[i - 1]) \/ (xs[i] - xs[i - 1])\n        y = ys[i - 1] + frac * 1.0 * (ys[i] - ys[i - 1])\n        return y\n\n\nclass _DictWrapper(object):\n    \"\"\"An object that contains a dictionary.\"\"\"\n\n    def __init__(self, values=None, name=''):\n        \"\"\"Initializes the distribution.\n\n        hypos: sequence of hypotheses\n        \"\"\"\n        self.name = name\n        self.d = {}\n\n        # flag whether the distribution is under a log transform\n        self.log = False\n\n        if values is None:\n            return\n\n        init_methods = [\n            self.InitPmf,\n            self.InitMapping,\n            self.InitSequence,\n            self.InitFailure,\n            ]\n\n        for method in init_methods:\n            try:\n                method(values)\n                break\n            except AttributeError:\n                continue\n\n        if len(self) > 0:\n            self.Normalize()\n\n    def InitSequence(self, values):\n        \"\"\"Initializes with a sequence of equally-likely values.\n\n        values: sequence of values\n        \"\"\"\n        for value in values:\n            self.Set(value, 1)\n\n    def InitMapping(self, values):\n        \"\"\"Initializes with a map from value to probability.\n\n        values: map from value to probability\n        \"\"\"\n        for value, prob in values.items():\n            self.Set(value, prob)\n\n    def InitPmf(self, values):\n        \"\"\"Initializes with a Pmf.\n\n        values: Pmf object\n        \"\"\"\n        for value, prob in values.Items():\n            self.Set(value, prob)\n\n    def InitFailure(self, values):\n        \"\"\"Raises an error.\"\"\"\n        raise ValueError('None of the initialization methods worked.')\n\n    def __len__(self):\n        return len(self.d)\n\n    def __iter__(self):\n        return iter(self.d)\n\n    def keys(self):\n        return iter(self.d)\n\n    def __contains__(self, value):\n        return value in self.d\n\n    def Copy(self, name=None):\n        \"\"\"Returns a copy.\n\n        Make a shallow copy of d.  If you want a deep copy of d,\n        use copy.deepcopy on the whole object.\n\n        Args:\n            name: string name for the new Hist\n        \"\"\"\n        new = copy.copy(self)\n        new.d = copy.copy(self.d)\n        new.name = name if name is not None else self.name\n        return new\n\n    def Scale(self, factor):\n        \"\"\"Multiplies the values by a factor.\n\n        factor: what to multiply by\n\n        Returns: new object\n        \"\"\"\n        new = self.Copy()\n        new.d.clear()\n\n        for val, prob in self.Items():\n            new.Set(val * factor, prob)\n        return new\n\n    def Log(self, m=None):\n        \"\"\"Log transforms the probabilities.\n        \n        Removes values with probability 0.\n\n        Normalizes so that the largest logprob is 0.\n        \"\"\"\n        if self.log:\n            raise ValueError(\"Pmf\/Hist already under a log transform\")\n        self.log = True\n\n        if m is None:\n            m = self.MaxLike()\n\n        for x, p in self.d.items():\n            if p:\n                self.Set(x, math.log(p \/ m))\n            else:\n                self.Remove(x)\n\n    def Exp(self, m=None):\n        \"\"\"Exponentiates the probabilities.\n\n        m: how much to shift the ps before exponentiating\n\n        If m is None, normalizes so that the largest prob is 1.\n        \"\"\"\n        if not self.log:\n            raise ValueError(\"Pmf\/Hist not under a log transform\")\n        self.log = False\n\n        if m is None:\n            m = self.MaxLike()\n\n        for x, p in self.d.items():\n            self.Set(x, math.exp(p - m))\n\n    def GetDict(self):\n        \"\"\"Gets the dictionary.\"\"\"\n        return self.d\n\n    def SetDict(self, d):\n        \"\"\"Sets the dictionary.\"\"\"\n        self.d = d\n\n    def Values(self):\n        \"\"\"Gets an unsorted sequence of values.\n\n        Note: one source of confusion is that the keys of this\n        dictionary are the values of the Hist\/Pmf, and the\n        values of the dictionary are frequencies\/probabilities.\n        \"\"\"\n        return self.d.keys()\n\n    def Items(self):\n        \"\"\"Gets an unsorted sequence of (value, freq\/prob) pairs.\"\"\"\n        return self.d.items()\n\n    def Render(self):\n        \"\"\"Generates a sequence of points suitable for plotting.\n\n        Returns:\n            tuple of (sorted value sequence, freq\/prob sequence)\n        \"\"\"\n        return zip(*sorted(self.Items()))\n\n    def Print(self):\n        \"\"\"Prints the values and freqs\/probs in ascending order.\"\"\"\n        for val, prob in sorted(self.d.items()):\n            print(val, prob)\n\n    def Set(self, x, y=0):\n        \"\"\"Sets the freq\/prob associated with the value x.\n\n        Args:\n            x: number value\n            y: number freq or prob\n        \"\"\"\n        self.d[x] = y\n\n    def Incr(self, x, term=1):\n        \"\"\"Increments the freq\/prob associated with the value x.\n\n        Args:\n            x: number value\n            term: how much to increment by\n        \"\"\"\n        self.d[x] = self.d.get(x, 0) + term\n\n    def Mult(self, x, factor):\n        \"\"\"Scales the freq\/prob associated with the value x.\n\n        Args:\n            x: number value\n            factor: how much to multiply by\n        \"\"\"\n        self.d[x] = self.d.get(x, 0) * factor\n\n    def Remove(self, x):\n        \"\"\"Removes a value.\n\n        Throws an exception if the value is not there.\n\n        Args:\n            x: value to remove\n        \"\"\"\n        del self.d[x]\n\n    def Total(self):\n        \"\"\"Returns the total of the frequencies\/probabilities in the map.\"\"\"\n        total = sum(self.d.values())\n        return total\n\n    def MaxLike(self):\n        \"\"\"Returns the largest frequency\/probability in the map.\"\"\"\n        return max(self.d.values())\n\n\nclass Hist(_DictWrapper):\n    \"\"\"Represents a histogram, which is a map from values to frequencies.\n\n    Values can be any hashable type; frequencies are integer counters.\n    \"\"\"\n\n    def Freq(self, x):\n        \"\"\"Gets the frequency associated with the value x.\n\n        Args:\n            x: number value\n\n        Returns:\n            int frequency\n        \"\"\"\n        return self.d.get(x, 0)\n\n    def Freqs(self, xs):\n        \"\"\"Gets frequencies for a sequence of values.\"\"\"\n        return [self.Freq(x) for x in xs]\n\n    def IsSubset(self, other):\n        \"\"\"Checks whether the values in this histogram are a subset of\n        the values in the given histogram.\"\"\"\n        for val, freq in self.Items():\n            if freq > other.Freq(val):\n                return False\n        return True\n\n    def Subtract(self, other):\n        \"\"\"Subtracts the values in the given histogram from this histogram.\"\"\"\n        for val, freq in other.Items():\n            self.Incr(val, -freq)\n\n\nclass Pmf(_DictWrapper):\n    \"\"\"Represents a probability mass function.\n    \n    Values can be any hashable type; probabilities are floating-point.\n    Pmfs are not necessarily normalized.\n    \"\"\"\n\n    def Prob(self, x, default=0):\n        \"\"\"Gets the probability associated with the value x.\n\n        Args:\n            x: number value\n            default: value to return if the key is not there\n\n        Returns:\n            float probability\n        \"\"\"\n        return self.d.get(x, default)\n\n    def Probs(self, xs):\n        \"\"\"Gets probabilities for a sequence of values.\"\"\"\n        return [self.Prob(x) for x in xs]\n\n    def MakeCdf(self, name=None):\n        \"\"\"Makes a Cdf.\"\"\"\n        return MakeCdfFromPmf(self, name=name)\n\n    def ProbGreater(self, x):\n        \"\"\"Probability that a sample from this Pmf exceeds x.\n\n        x: number\n\n        returns: float probability\n        \"\"\"\n        t = [prob for (val, prob) in self.d.items() if val > x]\n        return sum(t)\n\n    def ProbLess(self, x):\n        \"\"\"Probability that a sample from this Pmf is less than x.\n\n        x: number\n\n        returns: float probability\n        \"\"\"\n        t = [prob for (val, prob) in self.d.items() if val < x]\n        return sum(t)\n\n    def __lt__(self, obj):\n        \"\"\"Less than.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        if isinstance(obj, _DictWrapper):\n            return PmfProbLess(self, obj)\n        else:\n            return self.ProbLess(obj)\n\n    def __gt__(self, obj):\n        \"\"\"Greater than.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        if isinstance(obj, _DictWrapper):\n            return PmfProbGreater(self, obj)\n        else:\n            return self.ProbGreater(obj)\n\n    def __ge__(self, obj):\n        \"\"\"Greater than or equal.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        return 1 - (self < obj)\n\n    def __le__(self, obj):\n        \"\"\"Less than or equal.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        return 1 - (self > obj)\n\n    def __eq__(self, obj):\n        \"\"\"Equal to.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        if isinstance(obj, _DictWrapper):\n            return PmfProbEqual(self, obj)\n        else:\n            return self.Prob(obj)\n\n    def __ne__(self, obj):\n        \"\"\"Not equal to.\n\n        obj: number or _DictWrapper\n\n        returns: float probability\n        \"\"\"\n        return 1 - (self == obj)\n\n    def Normalize(self, fraction=1.0):\n        \"\"\"Normalizes this PMF so the sum of all probs is fraction.\n\n        Args:\n            fraction: what the total should be after normalization\n\n        Returns: the total probability before normalizing\n        \"\"\"\n        if self.log:\n            raise ValueError(\"Pmf is under a log transform\")\n\n        total = self.Total()\n        if total == 0.0:\n            raise ValueError('total probability is zero.')\n            logging.warning('Normalize: total probability is zero.')\n            return total\n\n        factor = float(fraction) \/ total\n        for x in self.d:\n            self.d[x] *= factor\n\n        return total\n\n    def Random(self):\n        \"\"\"Chooses a random element from this PMF.\n\n        Returns:\n            float value from the Pmf\n        \"\"\"\n        if len(self.d) == 0:\n            raise ValueError('Pmf contains no values.')\n\n        target = random.random()\n        total = 0.0\n        for x, p in self.d.items():\n            total += p\n            if total >= target:\n                return x\n\n        # we shouldn't get here\n        assert False\n\n    def Mean(self):\n        \"\"\"Computes the mean of a PMF.\n\n        Returns:\n            float mean\n        \"\"\"\n        mu = 0.0\n        for x, p in self.d.items():\n            mu += p * x\n        return mu\n\n    def Var(self, mu=None):\n        \"\"\"Computes the variance of a PMF.\n\n        Args:\n            mu: the point around which the variance is computed;\n                if omitted, computes the mean\n\n        Returns:\n            float variance\n        \"\"\"\n        if mu is None:\n            mu = self.Mean()\n\n        var = 0.0\n        for x, p in self.d.items():\n            var += p * (x - mu) ** 2\n        return var\n\n    def MaximumLikelihood(self):\n        \"\"\"Returns the value with the highest probability.\n\n        Returns: float probability\n        \"\"\"\n        prob, val = max((prob, val) for val, prob in self.Items())\n        return val\n\n    def CredibleInterval(self, percentage=90):\n        \"\"\"Computes the central credible interval.\n\n        If percentage=90, computes the 90% CI.\n\n        Args:\n            percentage: float between 0 and 100\n\n        Returns:\n            sequence of two floats, low and high\n        \"\"\"\n        cdf = self.MakeCdf()\n        return cdf.CredibleInterval(percentage)\n\n    def __add__(self, other):\n        \"\"\"Computes the Pmf of the sum of values drawn from self and other.\n\n        other: another Pmf\n\n        returns: new Pmf\n        \"\"\"\n        try:\n            return self.AddPmf(other)\n        except AttributeError:\n            return self.AddConstant(other)\n\n    def AddPmf(self, other):\n        \"\"\"Computes the Pmf of the sum of values drawn from self and other.\n\n        other: another Pmf\n\n        returns: new Pmf\n        \"\"\"\n        pmf = Pmf()\n        for v1, p1 in self.Items():\n            for v2, p2 in other.Items():\n                pmf.Incr(v1 + v2, p1 * p2)\n        return pmf\n\n    def AddConstant(self, other):\n        \"\"\"Computes the Pmf of the sum a constant and  values from self.\n\n        other: a number\n\n        returns: new Pmf\n        \"\"\"\n        pmf = Pmf()\n        for v1, p1 in self.Items():\n            pmf.Set(v1 + other, p1)\n        return pmf\n\n    def __sub__(self, other):\n        \"\"\"Computes the Pmf of the diff of values drawn from self and other.\n\n        other: another Pmf\n\n        returns: new Pmf\n        \"\"\"\n        pmf = Pmf()\n        for v1, p1 in self.Items():\n            for v2, p2 in other.Items():\n                pmf.Incr(v1 - v2, p1 * p2)\n        return pmf\n\n    def Max(self, k):\n        \"\"\"Computes the CDF of the maximum of k selections from this dist.\n\n        k: int\n\n        returns: new Cdf\n        \"\"\"\n        cdf = self.MakeCdf()\n        cdf.ps = [p ** k for p in cdf.ps]\n        return cdf\n\n    def __hash__(self):\n        # FIXME\n        # This imitates python2 implicit behaviour, which was removed in python3\n\n        # Some problems with an id based hash:\n        # looking up different pmfs with the same contents will give different values\n        # looking up a new Pmf will always produce a keyerror\n\n        # A solution might be to make a \"FrozenPmf\" immutable class (like frozenset)\n        # and base a hash on a tuple of the items of self.d\n        return id(self)\n\nclass Joint(Pmf):\n    \"\"\"Represents a joint distribution.\n\n    The values are sequences (usually tuples)\n    \"\"\"\n\n    def Marginal(self, i, name=''):\n        \"\"\"Gets the marginal distribution of the indicated variable.\n\n        i: index of the variable we want\n\n        Returns: Pmf\n        \"\"\"\n        pmf = Pmf(name=name)\n        for vs, prob in self.Items():\n            pmf.Incr(vs[i], prob)\n        return pmf\n\n    def Conditional(self, i, j, val, name=''):\n        \"\"\"Gets the conditional distribution of the indicated variable.\n\n        Distribution of vs[i], conditioned on vs[j] = val.\n\n        i: index of the variable we want\n        j: which variable is conditioned on\n        val: the value the jth variable has to have\n\n        Returns: Pmf\n        \"\"\"\n        pmf = Pmf(name=name)\n        for vs, prob in self.Items():\n            if vs[j] != val: continue\n            pmf.Incr(vs[i], prob)\n\n        pmf.Normalize()\n        return pmf\n\n    def MaxLikeInterval(self, percentage=90):\n        \"\"\"Returns the maximum-likelihood credible interval.\n\n        If percentage=90, computes a 90% CI containing the values\n        with the highest likelihoods.\n\n        percentage: float between 0 and 100\n\n        Returns: list of values from the suite\n        \"\"\"\n        interval = []\n        total = 0\n\n        t = [(prob, val) for val, prob in self.Items()]\n        t.sort(reverse=True)\n\n        for prob, val in t:\n            interval.append(val)\n            total += prob\n            if total >= percentage \/ 100.0:\n                break\n\n        return interval\n\n\ndef MakeJoint(pmf1, pmf2):\n    \"\"\"Joint distribution of values from pmf1 and pmf2.\n\n    Args:\n        pmf1: Pmf object\n        pmf2: Pmf object\n\n    Returns:\n        Joint pmf of value pairs\n    \"\"\"\n    joint = Joint()\n    for v1, p1 in pmf1.Items():\n        for v2, p2 in pmf2.Items():\n            joint.Set((v1, v2), p1 * p2)\n    return joint\n\n\ndef MakeHistFromList(t, name=''):\n    \"\"\"Makes a histogram from an unsorted sequence of values.\n\n    Args:\n        t: sequence of numbers\n        name: string name for this histogram\n\n    Returns:\n        Hist object\n    \"\"\"\n    hist = Hist(name=name)\n    [hist.Incr(x) for x in t]\n    return hist\n\n\ndef MakeHistFromDict(d, name=''):\n    \"\"\"Makes a histogram from a map from values to frequencies.\n\n    Args:\n        d: dictionary that maps values to frequencies\n        name: string name for this histogram\n\n    Returns:\n        Hist object\n    \"\"\"\n    return Hist(d, name)\n\n\ndef MakePmfFromList(t, name=''):\n    \"\"\"Makes a PMF from an unsorted sequence of values.\n\n    Args:\n        t: sequence of numbers\n        name: string name for this PMF\n\n    Returns:\n        Pmf object\n    \"\"\"\n    hist = MakeHistFromList(t)\n    d = hist.GetDict()\n    pmf = Pmf(d, name)\n    pmf.Normalize()\n    return pmf\n\n\ndef MakePmfFromDict(d, name=''):\n    \"\"\"Makes a PMF from a map from values to probabilities.\n\n    Args:\n        d: dictionary that maps values to probabilities\n        name: string name for this PMF\n\n    Returns:\n        Pmf object\n    \"\"\"\n    pmf = Pmf(d, name)\n    pmf.Normalize()\n    return pmf\n\n\ndef MakePmfFromItems(t, name=''):\n    \"\"\"Makes a PMF from a sequence of value-probability pairs\n\n    Args:\n        t: sequence of value-probability pairs\n        name: string name for this PMF\n\n    Returns:\n        Pmf object\n    \"\"\"\n    pmf = Pmf(dict(t), name)\n    pmf.Normalize()\n    return pmf\n\n\ndef MakePmfFromHist(hist, name=None):\n    \"\"\"Makes a normalized PMF from a Hist object.\n\n    Args:\n        hist: Hist object\n        name: string name\n\n    Returns:\n        Pmf object\n    \"\"\"\n    if name is None:\n        name = hist.name\n\n    # make a copy of the dictionary\n    d = dict(hist.GetDict())\n    pmf = Pmf(d, name)\n    pmf.Normalize()\n    return pmf\n\n\ndef MakePmfFromCdf(cdf, name=None):\n    \"\"\"Makes a normalized Pmf from a Cdf object.\n\n    Args:\n        cdf: Cdf object\n        name: string name for the new Pmf\n\n    Returns:\n        Pmf object\n    \"\"\"\n    if name is None:\n        name = cdf.name\n\n    pmf = Pmf(name=name)\n\n    prev = 0.0\n    for val, prob in cdf.Items():\n        pmf.Incr(val, prob - prev)\n        prev = prob\n\n    return pmf\n\n\ndef MakeMixture(metapmf, name='mix'):\n    \"\"\"Make a mixture distribution.\n\n    Args:\n      metapmf: Pmf that maps from Pmfs to probs.\n      name: string name for the new Pmf.\n\n    Returns: Pmf object.\n    \"\"\"\n    mix = Pmf(name=name)\n    for pmf, p1 in metapmf.Items():\n        for x, p2 in pmf.Items():\n            mix.Incr(x, p1 * p2)\n    return mix\n\n\ndef MakeUniformPmf(low, high, n):\n    \"\"\"Make a uniform Pmf.\n\n    low: lowest value (inclusive)\n    high: highest value (inclusize)\n    n: number of values\n    \"\"\"\n    pmf = Pmf()\n    for x in numpy.linspace(low, high, n):\n        pmf.Set(x, 1)\n    pmf.Normalize()\n    return pmf\n\n\nclass Cdf(object):\n    \"\"\"Represents a cumulative distribution function.\n\n    Attributes:\n        xs: sequence of values\n        ps: sequence of probabilities\n        name: string used as a graph label.\n    \"\"\"\n\n    def __init__(self, xs=None, ps=None, name=''):\n        self.xs = [] if xs is None else xs\n        self.ps = [] if ps is None else ps\n        self.name = name\n\n    def Copy(self, name=None):\n        \"\"\"Returns a copy of this Cdf.\n\n        Args:\n            name: string name for the new Cdf\n        \"\"\"\n        if name is None:\n            name = self.name\n        return Cdf(list(self.xs), list(self.ps), name)\n\n    def MakePmf(self, name=None):\n        \"\"\"Makes a Pmf.\"\"\"\n        return MakePmfFromCdf(self, name=name)\n\n    def Values(self):\n        \"\"\"Returns a sorted list of values.\n        \"\"\"\n        return self.xs\n\n    def Items(self):\n        \"\"\"Returns a sorted sequence of (value, probability) pairs.\n\n        Note: in Python3, returns an iterator.\n        \"\"\"\n        return zip(self.xs, self.ps)\n\n    def Append(self, x, p):\n        \"\"\"Add an (x, p) pair to the end of this CDF.\n\n        Note: this us normally used to build a CDF from scratch, not\n        to modify existing CDFs.  It is up to the caller to make sure\n        that the result is a legal CDF.\n        \"\"\"\n        self.xs.append(x)\n        self.ps.append(p)\n\n    def Shift(self, term):\n        \"\"\"Adds a term to the xs.\n\n        term: how much to add\n        \"\"\"\n        new = self.Copy()\n        new.xs = [x + term for x in self.xs]\n        return new\n\n    def Scale(self, factor):\n        \"\"\"Multiplies the xs by a factor.\n\n        factor: what to multiply by\n        \"\"\"\n        new = self.Copy()\n        new.xs = [x * factor for x in self.xs]\n        return new\n\n    def Prob(self, x):\n        \"\"\"Returns CDF(x), the probability that corresponds to value x.\n\n        Args:\n            x: number\n\n        Returns:\n            float probability\n        \"\"\"\n        if x < self.xs[0]: return 0.0\n        index = bisect.bisect(self.xs, x)\n        p = self.ps[index - 1]\n        return p\n\n    def Value(self, p):\n        \"\"\"Returns InverseCDF(p), the value that corresponds to probability p.\n\n        Args:\n            p: number in the range [0, 1]\n\n        Returns:\n            number value\n        \"\"\"\n        if p < 0 or p > 1:\n            raise ValueError('Probability p must be in range [0, 1]')\n\n        if p == 0: return self.xs[0]\n        if p == 1: return self.xs[-1]\n        index = bisect.bisect(self.ps, p)\n        if p == self.ps[index - 1]:\n            return self.xs[index - 1]\n        else:\n            return self.xs[index]\n\n    def Percentile(self, p):\n        \"\"\"Returns the value that corresponds to percentile p.\n\n        Args:\n            p: number in the range [0, 100]\n\n        Returns:\n            number value\n        \"\"\"\n        return self.Value(p \/ 100.0)\n\n    def Random(self):\n        \"\"\"Chooses a random value from this distribution.\"\"\"\n        return self.Value(random.random())\n\n    def Sample(self, n):\n        \"\"\"Generates a random sample from this distribution.\n        \n        Args:\n            n: int length of the sample\n        \"\"\"\n        return [self.Random() for i in range(n)]\n\n    def Mean(self):\n        \"\"\"Computes the mean of a CDF.\n\n        Returns:\n            float mean\n        \"\"\"\n        old_p = 0\n        total = 0.0\n        for x, new_p in zip(self.xs, self.ps):\n            p = new_p - old_p\n            total += p * x\n            old_p = new_p\n        return total\n\n    def CredibleInterval(self, percentage=90):\n        \"\"\"Computes the central credible interval.\n\n        If percentage=90, computes the 90% CI.\n\n        Args:\n            percentage: float between 0 and 100\n\n        Returns:\n            sequence of two floats, low and high\n        \"\"\"\n        prob = (1 - percentage \/ 100.0) \/ 2\n        interval = self.Value(prob), self.Value(1 - prob)\n        return interval\n\n    def _Round(self, multiplier=1000.0):\n        \"\"\"\n        An entry is added to the cdf only if the percentile differs\n        from the previous value in a significant digit, where the number\n        of significant digits is determined by multiplier.  The\n        default is 1000, which keeps log10(1000) = 3 significant digits.\n        \"\"\"\n        # TODO(write this method)\n        raise UnimplementedMethodException()\n\n    def Render(self):\n        \"\"\"Generates a sequence of points suitable for plotting.\n\n        An empirical CDF is a step function; linear interpolation\n        can be misleading.\n\n        Returns:\n            tuple of (xs, ps)\n        \"\"\"\n        xs = [self.xs[0]]\n        ps = [0.0]\n        for i, p in enumerate(self.ps):\n            xs.append(self.xs[i])\n            ps.append(p)\n\n            try:\n                xs.append(self.xs[i + 1])\n                ps.append(p)\n            except IndexError:\n                pass\n        return xs, ps\n\n    def Max(self, k):\n        \"\"\"Computes the CDF of the maximum of k selections from this dist.\n\n        k: int\n\n        returns: new Cdf\n        \"\"\"\n        cdf = self.Copy()\n        cdf.ps = [p ** k for p in cdf.ps]\n        return cdf\n\n\ndef MakeCdfFromItems(items, name=''):\n    \"\"\"Makes a cdf from an unsorted sequence of (value, frequency) pairs.\n\n    Args:\n        items: unsorted sequence of (value, frequency) pairs\n        name: string name for this CDF\n\n    Returns:\n        cdf: list of (value, fraction) pairs\n    \"\"\"\n    runsum = 0\n    xs = []\n    cs = []\n\n    for value, count in sorted(items):\n        runsum += count\n        xs.append(value)\n        cs.append(runsum)\n\n    total = float(runsum)\n    ps = [c \/ total for c in cs]\n\n    cdf = Cdf(xs, ps, name)\n    return cdf\n\n\ndef MakeCdfFromDict(d, name=''):\n    \"\"\"Makes a CDF from a dictionary that maps values to frequencies.\n\n    Args:\n       d: dictionary that maps values to frequencies.\n       name: string name for the data.\n\n    Returns:\n        Cdf object\n    \"\"\"\n    return MakeCdfFromItems(d.items(), name)\n\n\ndef MakeCdfFromHist(hist, name=''):\n    \"\"\"Makes a CDF from a Hist object.\n\n    Args:\n       hist: Pmf.Hist object\n       name: string name for the data.\n\n    Returns:\n        Cdf object\n    \"\"\"\n    return MakeCdfFromItems(hist.Items(), name)\n\n\ndef MakeCdfFromPmf(pmf, name=None):\n    \"\"\"Makes a CDF from a Pmf object.\n\n    Args:\n       pmf: Pmf.Pmf object\n       name: string name for the data.\n\n    Returns:\n        Cdf object\n    \"\"\"\n    if name == None:\n        name = pmf.name\n    return MakeCdfFromItems(pmf.Items(), name)\n\n\ndef MakeCdfFromList(seq, name=''):\n    \"\"\"Creates a CDF from an unsorted sequence.\n\n    Args:\n        seq: unsorted sequence of sortable values\n        name: string name for the cdf\n\n    Returns:\n       Cdf object\n    \"\"\"\n    hist = MakeHistFromList(seq)\n    return MakeCdfFromHist(hist, name)\n\n\nclass UnimplementedMethodException(Exception):\n    \"\"\"Exception if someone calls a method that should be overridden.\"\"\"\n\n\nclass Suite(Pmf):\n    \"\"\"Represents a suite of hypotheses and their probabilities.\"\"\"\n\n    def Update(self, data):\n        \"\"\"Updates each hypothesis based on the data.\n\n        data: any representation of the data\n\n        returns: the normalizing constant\n        \"\"\"\n        for hypo in list(self.Values()):\n            like = self.Likelihood(data, hypo)\n            self.Mult(hypo, like)\n        return self.Normalize()\n\n    def LogUpdate(self, data):\n        \"\"\"Updates a suite of hypotheses based on new data.\n\n        Modifies the suite directly; if you want to keep the original, make\n        a copy.\n\n        Note: unlike Update, LogUpdate does not normalize.\n\n        Args:\n            data: any representation of the data\n        \"\"\"\n        for hypo in self.Values():\n            like = self.LogLikelihood(data, hypo)\n            self.Incr(hypo, like)\n\n    def UpdateSet(self, dataset):\n        \"\"\"Updates each hypothesis based on the dataset.\n\n        This is more efficient than calling Update repeatedly because\n        it waits until the end to Normalize.\n\n        Modifies the suite directly; if you want to keep the original, make\n        a copy.\n\n        dataset: a sequence of data\n\n        returns: the normalizing constant\n        \"\"\"\n        for data in dataset:\n            for hypo in self.Values():\n                like = self.Likelihood(data, hypo)\n                self.Mult(hypo, like)\n        return self.Normalize()\n\n    def LogUpdateSet(self, dataset):\n        \"\"\"Updates each hypothesis based on the dataset.\n\n        Modifies the suite directly; if you want to keep the original, make\n        a copy.\n\n        dataset: a sequence of data\n\n        returns: None\n        \"\"\"\n        for data in dataset:\n            self.LogUpdate(data)\n\n    def Likelihood(self, data, hypo):\n        \"\"\"Computes the likelihood of the data under the hypothesis.\n\n        hypo: some representation of the hypothesis\n        data: some representation of the data\n        \"\"\"\n        raise UnimplementedMethodException()\n\n    def LogLikelihood(self, data, hypo):\n        \"\"\"Computes the log likelihood of the data under the hypothesis.\n\n        hypo: some representation of the hypothesis\n        data: some representation of the data\n        \"\"\"\n        raise UnimplementedMethodException()\n\n    def Print(self):\n        \"\"\"Prints the hypotheses and their probabilities.\"\"\"\n        for hypo, prob in sorted(self.Items()):\n            print(hypo, prob)\n\n    def MakeOdds(self):\n        \"\"\"Transforms from probabilities to odds.\n\n        Values with prob=0 are removed.\n        \"\"\"\n        for hypo, prob in self.Items():\n            if prob:\n                self.Set(hypo, Odds(prob))\n            else:\n                self.Remove(hypo)\n\n    def MakeProbs(self):\n        \"\"\"Transforms from odds to probabilities.\"\"\"\n        for hypo, odds in self.Items():\n            self.Set(hypo, Probability(odds))\n\n\ndef MakeSuiteFromList(t, name=''):\n    \"\"\"Makes a suite from an unsorted sequence of values.\n\n    Args:\n        t: sequence of numbers\n        name: string name for this suite\n\n    Returns:\n        Suite object\n    \"\"\"\n    hist = MakeHistFromList(t)\n    d = hist.GetDict()\n    return MakeSuiteFromDict(d)\n\n\ndef MakeSuiteFromHist(hist, name=None):\n    \"\"\"Makes a normalized suite from a Hist object.\n\n    Args:\n        hist: Hist object\n        name: string name\n\n    Returns:\n        Suite object\n    \"\"\"\n    if name is None:\n        name = hist.name\n\n    # make a copy of the dictionary\n    d = dict(hist.GetDict())\n    return MakeSuiteFromDict(d, name)\n\n\ndef MakeSuiteFromDict(d, name=''):\n    \"\"\"Makes a suite from a map from values to probabilities.\n\n    Args:\n        d: dictionary that maps values to probabilities\n        name: string name for this suite\n\n    Returns:\n        Suite object\n    \"\"\"\n    suite = Suite(name=name)\n    suite.SetDict(d)\n    suite.Normalize()\n    return suite\n\n\ndef MakeSuiteFromCdf(cdf, name=None):\n    \"\"\"Makes a normalized Suite from a Cdf object.\n\n    Args:\n        cdf: Cdf object\n        name: string name for the new Suite\n\n    Returns:\n        Suite object\n    \"\"\"\n    if name is None:\n        name = cdf.name\n\n    suite = Suite(name=name)\n\n    prev = 0.0\n    for val, prob in cdf.Items():\n        suite.Incr(val, prob - prev)\n        prev = prob\n\n    return suite\n\n\nclass Pdf(object):\n    \"\"\"Represents a probability density function (PDF).\"\"\"\n\n    def Density(self, x):\n        \"\"\"Evaluates this Pdf at x.\n\n        Returns: float probability density\n        \"\"\"\n        raise UnimplementedMethodException()\n\n    def MakePmf(self, xs, name=''):\n        \"\"\"Makes a discrete version of this Pdf, evaluated at xs.\n\n        xs: equally-spaced sequence of values\n\n        Returns: new Pmf\n        \"\"\"\n        pmf = Pmf(name=name)\n        for x in xs:\n            pmf.Set(x, self.Density(x))\n        pmf.Normalize()\n        return pmf\n\n\nclass GaussianPdf(Pdf):\n    \"\"\"Represents the PDF of a Gaussian distribution.\"\"\"\n\n    def __init__(self, mu, sigma):\n        \"\"\"Constructs a Gaussian Pdf with given mu and sigma.\n\n        mu: mean\n        sigma: standard deviation\n        \"\"\"\n        self.mu = mu\n        self.sigma = sigma\n\n    def Density(self, x):\n        \"\"\"Evaluates this Pdf at x.\n\n        Returns: float probability density\n        \"\"\"\n        return EvalGaussianPdf(x, self.mu, self.sigma)\n\n\nclass EstimatedPdf(Pdf):\n    \"\"\"Represents a PDF estimated by KDE.\"\"\"\n\n    def __init__(self, sample):\n        \"\"\"Estimates the density function based on a sample.\n\n        sample: sequence of data\n        \"\"\"\n        self.kde = scipy.stats.gaussian_kde(sample)\n\n    def Density(self, x):\n        \"\"\"Evaluates this Pdf at x.\n\n        Returns: float probability density\n        \"\"\"\n        return self.kde.evaluate(x)\n\n    def MakePmf(self, xs, name=''):\n        ps = self.kde.evaluate(xs)\n        pmf = MakePmfFromItems(zip(xs, ps), name=name)\n        return pmf\n\n\ndef Percentile(pmf, percentage):\n    \"\"\"Computes a percentile of a given Pmf.\n\n    percentage: float 0-100\n    \"\"\"\n    p = percentage \/ 100.0\n    total = 0\n    for val, prob in pmf.Items():\n        total += prob\n        if total >= p:\n            return val\n\n\ndef CredibleInterval(pmf, percentage=90):\n    \"\"\"Computes a credible interval for a given distribution.\n\n    If percentage=90, computes the 90% CI.\n\n    Args:\n        pmf: Pmf object representing a posterior distribution\n        percentage: float between 0 and 100\n\n    Returns:\n        sequence of two floats, low and high\n    \"\"\"\n    cdf = pmf.MakeCdf()\n    prob = (1 - percentage \/ 100.0) \/ 2\n    interval = cdf.Value(prob), cdf.Value(1 - prob)\n    return interval\n\n\ndef PmfProbLess(pmf1, pmf2):\n    \"\"\"Probability that a value from pmf1 is less than a value from pmf2.\n\n    Args:\n        pmf1: Pmf object\n        pmf2: Pmf object\n\n    Returns:\n        float probability\n    \"\"\"\n    total = 0.0\n    for v1, p1 in pmf1.Items():\n        for v2, p2 in pmf2.Items():\n            if v1 < v2:\n                total += p1 * p2\n    return total\n\n\ndef PmfProbGreater(pmf1, pmf2):\n    \"\"\"Probability that a value from pmf1 is less than a value from pmf2.\n\n    Args:\n        pmf1: Pmf object\n        pmf2: Pmf object\n\n    Returns:\n        float probability\n    \"\"\"\n    total = 0.0\n    for v1, p1 in pmf1.Items():\n        for v2, p2 in pmf2.Items():\n            if v1 > v2:\n                total += p1 * p2\n    return total\n\n\ndef PmfProbEqual(pmf1, pmf2):\n    \"\"\"Probability that a value from pmf1 equals a value from pmf2.\n\n    Args:\n        pmf1: Pmf object\n        pmf2: Pmf object\n\n    Returns:\n        float probability\n    \"\"\"\n    total = 0.0\n    for v1, p1 in pmf1.Items():\n        for v2, p2 in pmf2.Items():\n            if v1 == v2:\n                total += p1 * p2\n    return total\n\n\ndef RandomSum(dists):\n    \"\"\"Chooses a random value from each dist and returns the sum.\n\n    dists: sequence of Pmf or Cdf objects\n\n    returns: numerical sum\n    \"\"\"\n    total = sum(dist.Random() for dist in dists)\n    return total\n\n\ndef SampleSum(dists, n):\n    \"\"\"Draws a sample of sums from a list of distributions.\n\n    dists: sequence of Pmf or Cdf objects\n    n: sample size\n\n    returns: new Pmf of sums\n    \"\"\"\n    pmf = MakePmfFromList(RandomSum(dists) for i in range(n))\n    return pmf\n\n\ndef EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)\n\n\ndef MakeGaussianPmf(mu, sigma, num_sigmas, n=201):\n    \"\"\"Makes a PMF discrete approx to a Gaussian distribution.\n    \n    mu: float mean\n    sigma: float standard deviation\n    num_sigmas: how many sigmas to extend in each direction\n    n: number of values in the Pmf\n\n    returns: normalized Pmf\n    \"\"\"\n    pmf = Pmf()\n    low = mu - num_sigmas * sigma\n    high = mu + num_sigmas * sigma\n\n    for x in numpy.linspace(low, high, n):\n        p = EvalGaussianPdf(x, mu, sigma)\n        pmf.Set(x, p)\n    pmf.Normalize()\n    return pmf\n\n\ndef EvalBinomialPmf(k, n, p):\n    \"\"\"Evaluates the binomial pmf.\n\n    Returns the probabily of k successes in n trials with probability p.\n    \"\"\"\n    return scipy.stats.binom.pmf(k, n, p)\n    \n\ndef EvalPoissonPmf(k, lam):\n    \"\"\"Computes the Poisson PMF.\n\n    k: number of events\n    lam: parameter lambda in events per unit time\n\n    returns: float probability\n    \"\"\"\n    return scipy.stats.poisson.pmf(k, lam)\n\n\ndef MakePoissonPmf(lam, high, step=1):\n    \"\"\"Makes a PMF discrete approx to a Poisson distribution.\n\n    lam: parameter lambda in events per unit time\n    high: upper bound of the Pmf\n\n    returns: normalized Pmf\n    \"\"\"\n    pmf = Pmf()\n    for k in range(0, high + 1, step):\n        p = EvalPoissonPmf(k, lam)\n        pmf.Set(k, p)\n    pmf.Normalize()\n    return pmf\n\n\ndef EvalExponentialPdf(x, lam):\n    \"\"\"Computes the exponential PDF.\n\n    x: value\n    lam: parameter lambda in events per unit time\n\n    returns: float probability density\n    \"\"\"\n    return lam * math.exp(-lam * x)\n\n\ndef EvalExponentialCdf(x, lam):\n    \"\"\"Evaluates CDF of the exponential distribution with parameter lam.\"\"\"\n    return 1 - math.exp(-lam * x)\n\n\ndef MakeExponentialPmf(lam, high, n=200):\n    \"\"\"Makes a PMF discrete approx to an exponential distribution.\n\n    lam: parameter lambda in events per unit time\n    high: upper bound\n    n: number of values in the Pmf\n\n    returns: normalized Pmf\n    \"\"\"\n    pmf = Pmf()\n    for x in numpy.linspace(0, high, n):\n        p = EvalExponentialPdf(x, lam)\n        pmf.Set(x, p)\n    pmf.Normalize()\n    return pmf\n\n\ndef StandardGaussianCdf(x):\n    \"\"\"Evaluates the CDF of the standard Gaussian distribution.\n    \n    See http:\/\/en.wikipedia.org\/wiki\/Normal_distribution\n    #Cumulative_distribution_function\n\n    Args:\n        x: float\n                \n    Returns:\n        float\n    \"\"\"\n    return (erf(x \/ ROOT2) + 1) \/ 2\n\n\ndef GaussianCdf(x, mu=0, sigma=1):\n    \"\"\"Evaluates the CDF of the gaussian distribution.\n    \n    Args:\n        x: float\n\n        mu: mean parameter\n        \n        sigma: standard deviation parameter\n                \n    Returns:\n        float\n    \"\"\"\n    return StandardGaussianCdf(float(x - mu) \/ sigma)\n\n\ndef GaussianCdfInverse(p, mu=0, sigma=1):\n    \"\"\"Evaluates the inverse CDF of the gaussian distribution.\n\n    See http:\/\/en.wikipedia.org\/wiki\/Normal_distribution#Quantile_function  \n\n    Args:\n        p: float\n\n        mu: mean parameter\n        \n        sigma: standard deviation parameter\n                \n    Returns:\n        float\n    \"\"\"\n    x = ROOT2 * erfinv(2 * p - 1)\n    return mu + x * sigma\n\n\nclass Beta(object):\n    \"\"\"Represents a Beta distribution.\n\n    See http:\/\/en.wikipedia.org\/wiki\/Beta_distribution\n    \"\"\"\n    def __init__(self, alpha=1, beta=1, name=''):\n        \"\"\"Initializes a Beta distribution.\"\"\"\n        self.alpha = alpha\n        self.beta = beta\n        self.name = name\n\n    def Update(self, data):\n        \"\"\"Updates a Beta distribution.\n\n        data: pair of int (heads, tails)\n        \"\"\"\n        heads, tails = data\n        self.alpha += heads\n        self.beta += tails\n\n    def Mean(self):\n        \"\"\"Computes the mean of this distribution.\"\"\"\n        return float(self.alpha) \/ (self.alpha + self.beta)\n\n    def Random(self):\n        \"\"\"Generates a random variate from this distribution.\"\"\"\n        return random.betavariate(self.alpha, self.beta)\n\n    def Sample(self, n):\n        \"\"\"Generates a random sample from this distribution.\n\n        n: int sample size\n        \"\"\"\n        size = n,\n        return numpy.random.beta(self.alpha, self.beta, size)\n\n    def EvalPdf(self, x):\n        \"\"\"Evaluates the PDF at x.\"\"\"\n        return x ** (self.alpha - 1) * (1 - x) ** (self.beta - 1)\n\n    def MakePmf(self, steps=101, name=''):\n        \"\"\"Returns a Pmf of this distribution.\n\n        Note: Normally, we just evaluate the PDF at a sequence\n        of points and treat the probability density as a probability\n        mass.\n\n        But if alpha or beta is less than one, we have to be\n        more careful because the PDF goes to infinity at x=0\n        and x=1.  In that case we evaluate the CDF and compute\n        differences.\n        \"\"\"\n        if self.alpha < 1 or self.beta < 1:\n            cdf = self.MakeCdf()\n            pmf = cdf.MakePmf()\n            return pmf\n\n        xs = [i \/ (steps - 1.0) for i in range(steps)]\n        probs = [self.EvalPdf(x) for x in xs]\n        pmf = MakePmfFromDict(dict(zip(xs, probs)), name)\n        return pmf\n\n    def MakeCdf(self, steps=101):\n        \"\"\"Returns the CDF of this distribution.\"\"\"\n        xs = [i \/ (steps - 1.0) for i in range(steps)]\n        ps = [scipy.special.betainc(self.alpha, self.beta, x) for x in xs]\n        cdf = Cdf(xs, ps)\n        return cdf\n\n\nclass Dirichlet(object):\n    \"\"\"Represents a Dirichlet distribution.\n\n    See http:\/\/en.wikipedia.org\/wiki\/Dirichlet_distribution\n    \"\"\"\n\n    def __init__(self, n, conc=1, name=''):\n        \"\"\"Initializes a Dirichlet distribution.\n\n        n: number of dimensions\n        conc: concentration parameter (smaller yields more concentration)\n        name: string name\n        \"\"\"\n        if n < 2:\n            raise ValueError('A Dirichlet distribution with '\n                             'n<2 makes no sense')\n\n        self.n = n\n        self.params = numpy.ones(n, dtype=numpy.float) * conc\n        self.name = name\n\n    def Update(self, data):\n        \"\"\"Updates a Dirichlet distribution.\n\n        data: sequence of observations, in order corresponding to params\n        \"\"\"\n        m = len(data)\n        self.params[:m] += data\n\n    def Random(self):\n        \"\"\"Generates a random variate from this distribution.\n\n        Returns: normalized vector of fractions\n        \"\"\"\n        p = numpy.random.gamma(self.params)\n        return p \/ p.sum()\n\n    def Likelihood(self, data):\n        \"\"\"Computes the likelihood of the data.\n\n        Selects a random vector of probabilities from this distribution.\n\n        Returns: float probability\n        \"\"\"\n        m = len(data)\n        if self.n < m:\n            return 0\n\n        x = data\n        p = self.Random()\n        q = p[:m] ** x\n        return q.prod()\n\n    def LogLikelihood(self, data):\n        \"\"\"Computes the log likelihood of the data.\n\n        Selects a random vector of probabilities from this distribution.\n\n        Returns: float log probability\n        \"\"\"\n        m = len(data)\n        if self.n < m:\n            return float('-inf')\n\n        x = self.Random()\n        y = numpy.log(x[:m]) * data\n        return y.sum()\n\n    def MarginalBeta(self, i):\n        \"\"\"Computes the marginal distribution of the ith element.\n\n        See http:\/\/en.wikipedia.org\/wiki\/Dirichlet_distribution\n        #Marginal_distributions\n\n        i: int\n\n        Returns: Beta object\n        \"\"\"\n        alpha0 = self.params.sum()\n        alpha = self.params[i]\n        return Beta(alpha, alpha0 - alpha)\n\n    def PredictivePmf(self, xs, name=''):\n        \"\"\"Makes a predictive distribution.\n\n        xs: values to go into the Pmf\n\n        Returns: Pmf that maps from x to the mean prevalence of x\n        \"\"\"\n        alpha0 = self.params.sum()\n        ps = self.params \/ alpha0\n        return MakePmfFromItems(zip(xs, ps), name=name)\n\n\ndef BinomialCoef(n, k):\n    \"\"\"Compute the binomial coefficient \"n choose k\".\n\n    n: number of trials\n    k: number of successes\n\n    Returns: float\n    \"\"\"\n    return scipy.misc.comb(n, k)\n\n\ndef LogBinomialCoef(n, k):\n    \"\"\"Computes the log of the binomial coefficient.\n\n    http:\/\/math.stackexchange.com\/questions\/64716\/\n    approximating-the-logarithm-of-the-binomial-coefficient\n\n    n: number of trials\n    k: number of successes\n\n    Returns: float\n    \"\"\"\n    return n * log(n) - k * log(k) - (n - k) * log(n - k)\n\n","78a4e024":"pmf = Pmf()\n\nfor x in [*range(1,7)]:\n    pmf.Set(x, 1\/6.0)","3d19aea5":"pmf","7b97f205":"pfm = Pmf()\n\npmf.Set('Bowl 1', 0.5)\npmf.Set('Bowl 2', 0.5)","a7329908":"pmf.Mult('Bowl 1', 0.75)\npmf.Mult('Bowl 2', 0.5)","b95c956b":"pmf.Normalize()","340d9fdc":"pmf.Prob('Bowl 1')","b2432c00":"class Cookie(Pmf):\n    \"\"\"A map from string bowl ID to probablity.\"\"\"\n\n    def __init__(self, hypos):\n        \"\"\"Initialize self.\n        hypos: sequence of string bowl IDs\n        \"\"\"\n        Pmf.__init__(self)\n        for hypo in hypos:\n            self.Set(hypo, 1)\n        self.Normalize()\n        \n    def Update(self, data):\n        for hypo in self.Values():\n            like = self.Likelihood(data, hypo)\n            self.Mult(hypo, like)\n        self.Normalize()\n        \n    mixes = {\n        'Bowl 1': {\n            'vanilla': 0.75,\n            'chocolate': 0.25\n        },\n        'Bowl 2': {\n            'vanilla': 0.5,\n            'chocolate': 0.5\n        }\n\n    }\n        \n    def Likelihood(self, data, hypo):\n        mix = self.mixes[hypo]\n        like = mix[data]\n        return like","ed5a0519":"hypos = ['Bowl 1', 'Bowl 2']\npmf = Cookie(hypos)\n\npmf.Prob('Bowl 1')","994ce0d6":"pmf.Update('vanilla')","80ed577a":"for hypo, prob in pmf.Items():\n    print(f'{hypo}: {prob}')","3fc346f6":"dataset = ['vanilla', 'chocolate', 'vanilla']\nfor data in  dataset:\n    pmf.Update(data)","0a9f5d37":"for hypo, prob in pmf.Items():\n    print(f'{hypo}: {prob}')","e0f31b30":"class Monty(Pmf):\n    \"\"\"A map from string bowl ID to probablity.\"\"\"\n\n    def __init__(self, hypos):\n        \"\"\"Initialize self.\n        hypos: sequence of string bowl IDs\n        \"\"\"\n        Pmf.__init__(self)\n        for hypo in hypos:\n            self.Set(hypo, 1)\n        self.Normalize()\n        \n    def Update(self, data):\n        for hypo in self.Values():\n            like = self.Likelihood(data, hypo)\n            self.Mult(hypo, like)\n        self.Normalize()\n        \n        \n    def Likelihood(self, data, hypo):\n        if hypo == data:\n            return 0\n        elif hypo == 'A':\n            return 0.5\n        else:\n            return 1","d094ba8b":"hypos = 'ABC'\npmf = Monty(hypos)","780f7554":"data = 'B'\npmf.Update(data)","ada9b790":"for hypo, prob in pmf.Items():\n    print(f'{hypo}: {prob}')","9c2770d7":"class Monty(Suite):\n    def Likelihood(self, data, hypo):\n        \"\"\"Computes the likelihood of the data under the hypothesis.\n        hypo: string name of the door where the prize is\n        data: string name of the door Monty opened\n        \"\"\"\n        if hypo == data:\n            return 0\n        elif hypo == 'A':\n            return 0.5\n        else:\n            return 1","63c3c617":"suite = Monty('ABC')\n\nsuite.Update('C')","d9d350db":"for hypo, prob in suite.Items():\n    print(f'{hypo}: {prob}')","8eba3612":"class M_and_M(Suite):\n\n    mix94 = {\n        'brown': 30,\n        'yellow': 20,\n        'red': 20,\n        'green': 10,\n        'orange': 10,\n        'tan': 10,\n    }\n    mix96 = {\n        'blue': 24,\n        'yellow': 14,\n        'red': 13,\n        'green': 20,\n        'orange': 16,\n        'brown': 13,\n    }\n    \n    hypoA = {\n    'bag1': mix94,\n    'bag2': mix96,\n    }\n    hypoB = {\n        'bag1': mix96,\n        'bag2': mix94,\n    }\n\n    hypotheses = {\n        'A': hypoA,\n        'B': hypoB\n    }\n\n    def Likelihood(self, data, hypo):\n        \"\"\"Computes the likelihood of the data under the hypothesis.\n        hypo: string name of the door where the prize is\n        data: string name of the door Monty opened\n        \"\"\"\n        bag, color = data\n        mix = self.hypotheses[hypo][bag]\n        like = mix[color]\n        return like","b439a8c2":"sum(M_and_M.mix96.values())","f3ea72e2":"suite = M_and_M('AB')","eb1d3e92":"suite.Print()","1a52aecb":"suite.Update(('bag1', 'yellow'))","bed36820":"suite.Print()","2b3fd842":"suite.Update(('bag2', 'green'))","8a20156f":"suite.Print()","ca201a82":"### Encapsulate Framework","c511ca7c":"### Bayseian Framework","1078cecd":"### Cookie Problem","1558ed25":"### M&M Problem","452deda3":"# Think Bayes by Allen B. Downey - Practice Notebook","b62b8e84":"# thinkbayes.py Package\nhttps:\/\/github.com\/AllenDowney\/ThinkBayes\/blob\/master\/code\/thinkbayes.py","3366b362":"### Monty Hall Problem","620cfba5":"## Distributions"}}