{"cell_type":{"0e396abb":"code","f7af8a0e":"code","0b4a8857":"code","680c0c86":"code","ea6b3efc":"code","eaf44127":"code","5d142e49":"code","f3be9aba":"code","8091a0ef":"code","a9050bb4":"code","e6230c17":"code","9468ca3a":"code","e0d84810":"code","346ca867":"code","d20cac09":"code","2cd37b8e":"code","a20e3ba5":"code","b65c09a6":"code","f0494f97":"code","c2dd7712":"code","c94c57f5":"code","5818905b":"code","aeb665e8":"code","02bec19f":"code","6c47c9d4":"code","0473c8cb":"code","693d71d5":"code","83d2eacb":"code","4bcd476d":"code","cbf2f5e8":"code","becaa57d":"code","d05f5091":"code","356e9ff1":"code","94b0c559":"code","525d8668":"code","4aff4615":"code","42685865":"code","7045bd21":"code","e0a45761":"code","53bc0281":"code","b8b895d1":"code","c8f27332":"code","35005fe3":"code","e19fc0b0":"code","d7369e57":"code","851c3deb":"code","01dc9ae6":"code","c6a945c0":"code","28556b7c":"code","0950eb04":"code","f3b72870":"code","8fb12769":"code","f1d44751":"code","e8318592":"code","ec56ff3b":"code","d2865a8e":"code","47975649":"code","d39c7116":"code","82f2cdce":"code","c94ea0cd":"code","1bf170cd":"code","1579a51e":"code","d033fd40":"code","d5e9ccac":"code","a53061e5":"code","72918a54":"code","669484f8":"code","011940aa":"code","d17d1d65":"code","639b72a8":"code","4d6c28a4":"code","20953a6a":"code","f5aaaed8":"code","97b403e4":"code","2be34fbf":"code","684f97be":"code","beff9dc5":"code","93960e12":"code","8e827b01":"code","5577d8a1":"code","362b9b1e":"code","ac5d27d7":"code","bce9078b":"code","2638bc2c":"code","d3c10b71":"code","ae5a6067":"code","695d8402":"code","b3b7a2b5":"code","c742496c":"code","cea548b0":"code","042da2a8":"code","e5bc41e3":"code","f1f23337":"code","4b59842c":"code","d197f8f5":"code","3960dcae":"code","bee1fa05":"code","6c6430f3":"code","3c74785f":"code","39e25165":"code","308a5797":"code","1580e181":"code","ff1a1b3f":"code","b803f74a":"code","13e4229e":"code","d8ec7d84":"code","4ba8ee1b":"code","ba6ee27d":"code","678f1fa0":"code","cf6c02a0":"code","940e6178":"code","a48db5ca":"code","1d84be11":"code","cb538c5e":"code","161df9e4":"code","8afde996":"code","ade9e4e9":"code","b33c8ebd":"code","7cb6608a":"code","d0a29aed":"code","b978acbf":"code","3fdbabcb":"code","807ba39e":"code","badd7eb8":"code","1ce7f534":"code","55521b62":"code","d4e87f32":"code","2a4ff071":"markdown","d59ac8b1":"markdown","f71c0d81":"markdown","99c3ba54":"markdown","e9273892":"markdown","7e89a43e":"markdown","8c361650":"markdown","b11cd7b4":"markdown","50e2628b":"markdown","ed1b988f":"markdown","7ee7e551":"markdown","5f27070a":"markdown","bf9e3027":"markdown","7b76d398":"markdown","ca5a7c71":"markdown","d30b7ca0":"markdown","4ea586bc":"markdown","544dbc7f":"markdown","08760076":"markdown","0bf72084":"markdown","04699f11":"markdown","bcdcbce2":"markdown","3241ea6b":"markdown","956b8494":"markdown","5ab71e1f":"markdown","0f9d11b4":"markdown","1f3ad2f1":"markdown","2fefe267":"markdown","ab6d51d7":"markdown","dde11c47":"markdown","eb439704":"markdown","9949c0fe":"markdown","3c9d4598":"markdown","46ba22e8":"markdown","a747f96f":"markdown","7126ea7d":"markdown","a41bbe66":"markdown","7ecd03e9":"markdown","8db14cd5":"markdown","c94be608":"markdown","239e7de7":"markdown","16748587":"markdown","a3be4c05":"markdown","7f0c36fa":"markdown","4aaa7bd5":"markdown","ca72cf47":"markdown","0718ceb7":"markdown","34fc55eb":"markdown","f8ee64a8":"markdown","1a94d1bb":"markdown","93a9d85a":"markdown","19118e05":"markdown"},"source":{"0e396abb":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f7af8a0e":"from matplotlib import pyplot as plt\nimport seaborn as sns\nfrom statsmodels.tsa.stattools import adfuller\nimport statsmodels.api as sm\nfrom scipy import stats\nfrom itertools import product\nimport warnings\n\nwarnings.filterwarnings('ignore')","0b4a8857":"df = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv')\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv')","680c0c86":"print('Dimension du 1er fichier',df.shape)\nprint('Dimension du 2eme fichier',df2.shape)","ea6b3efc":"frames=[df, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)\nprint(data.shape)\ndata.head(3)","eaf44127":"import datetime, pytz\n#define a conversion function for the native timestamps in the csv file\ndef dateparse (time_in_secs):    \n    return pytz.utc.localize(datetime.datetime.fromtimestamp(float(time_in_secs)))\n\n\ndata1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndata2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)","5d142e49":"# intervalle de temps concern\u00e9 data1\nprint(data1.Timestamp.min(), data1.Timestamp.max())\n\n#intervalle data2\nprint(data2.Timestamp.min(), data2.Timestamp.max())","f3be9aba":"frames=[data1, data2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)\nprint(data.shape)\ndata.head(3)","8091a0ef":"data.info()","a9050bb4":"#visualisation\ndata=data.sort_values(by='Timestamp', ascending=True)\ndata_corr=data.copy()\ndata.head(3)\n","e6230c17":"# G\u00e9n\u00e9re des grosse erreurs (modifier le temps pris en compte par 3 courbes journalieres (min\/moyenne\/max))\n'''import plotly.express as px\n\nfig = px.line(data, x='Timestamp', y='Weighted_Price')\nfig.show()\n'''","9468ca3a":"# On remplace les nan par la valeur 0 quand il n'y a pas de transaction de bitcoin\ndata['Volume_(BTC)'].fillna(value=0, inplace=True)\ndata['Volume_(Currency)'].fillna(value=0, inplace=True)\ndata['Weighted_Price'].fillna(value=0, inplace=True)\n\n# on attribue des valeurs aux donn\u00e9es OHLC qui sont des donn\u00e9es continues\n# on remplace les valeurs manquantes avec la suivante\ndata['Open'].fillna(method='backfill', inplace=True)\ndata['High'].fillna(method='backfill', inplace=True)\ndata['Low'].fillna(method='backfill', inplace=True)\ndata['Close'].fillna(method='backfill', inplace=True)","e0d84810":"# conversion timestamp\ndata.Timestamp = pd.to_datetime(data.Timestamp, unit='s')\n\n# conversion jours\ndata.index = data.Timestamp\ndata = data.resample('D').mean()\n\n#conversion mois\ndata_month = data.resample('M').mean()\n\n#conversion ann\u00e9e\ndata_year = data.resample('A-DEC').mean()","346ca867":"data.head()","d20cac09":"# intervalle de temps concern\u00e9 df\ndata.index.min(), data.index.max()","2cd37b8e":"#variation du prix du bitcoin (1er df)\nfig = plt.figure(figsize=(20,5))\n#variation quotidienne\nplt.subplot(131)\nplt.plot(data.Weighted_Price, '-', label='Quotidien')\nplt.legend()\n#variation mensuelle\nplt.subplot(132)\nplt.plot(data_month.Weighted_Price, '-', label='Mensuel')\nplt.legend()\n#variation annuelle\nplt.subplot(133)\nplt.plot(data_year.Weighted_Price, '-', label='Annuel')\nplt.legend()\nplt.suptitle('Variation des prix du bitcoin')\n# plt.tight_layout()\nplt.show()","a20e3ba5":"# variation quotidienne du prix du bitcoin pour le 1er df\nfig = plt.figure(figsize=(20,5))\nplt.plot(data.Weighted_Price, '-', label='Quotidien')\nplt.legend()\nplt.suptitle('Variation quotidienne des prix du bitcoin')\nplt.grid(linestyle='dotted')\nplt.show()","b65c09a6":"plt.figure(figsize=(20,15))\ndata.High.plot(kind='line',color='g',label='high',linewidth=1,alpha=0.5,grid=True,linestyle=':')\ndata.Low.plot(color='r',label='Low',linewidth=1,alpha=0.5,linestyle='-.',grid=True)\nplt.legend('upper right')\nplt.suptitle('Bitcoin')\nplt.show()","f0494f97":"f,ax=plt.subplots(figsize=(10,10))\nsns.heatmap(data_corr.corr(),annot=True,linewidths=.5,fmt='.1f',ax=ax)\nplt.show()","c2dd7712":"# meilleure visualisation de decomposition STL\nplt.style.use('seaborn-poster')\n\n#plt.figure(figsize=(20,15))\nsm.tsa.seasonal_decompose(data_month.Weighted_Price).plot()\nplt.title('decomposition saison du df')\nplt.show()","c94c57f5":"# test de dickey fuller\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(data_month.Weighted_Price)[1])\n# Transformtion Box-Cox \ndata_month['Weighted_Price_box'], lmbda = stats.boxcox(data_month.Weighted_Price)\nprint(\"Dickey\u2013Fuller test: p=%f\" % sm.tsa.stattools.adfuller(data_month.Weighted_Price)[1])","5818905b":"data.head()","aeb665e8":"# fonction definition recherche crois\u00e9e\ndef my_xgb(data, target, params):\n    \n    # cr\u00e9e X & y\n    X = data.drop(target, axis=1)\n    y = data[target]\n    \n    # mise a l'\u00e9chelle X\n    scaler = StandardScaler()\n    scaler.fit(X)\n    X_scaled = scaler.transform(X)\n    \n    # XGBoost classifier \n    xgb_clf = xgb.XGBClassifier()\n    \n    # recherche grille \n    kf = KFold(n_splits=10, random_state=42, shuffle=True)\n    gridsearch = GridSearchCV(xgb_clf, param_grid=params, scoring=\"accuracy\", cv=kf, return_train_score=True)\n    gridsearch.fit(X_scaled, y)\n    \n    # Return the gridsearch results plus the scaler\n    return gridsearch, scaler","02bec19f":"import seaborn as sns\nimport matplotlib.pyplot as plt\nfrom fbprophet import Prophet\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error","6c47c9d4":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)","0473c8cb":"frames=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)","693d71d5":"#regle Timestamp en fonction des heures\ndata['Timestamp'] = data['Timestamp'].dt.tz_localize(None)\ndata = data.groupby([pd.Grouper(key='Timestamp', freq='H')]).first().reset_index()\ndata = data.set_index('Timestamp')\ndata = data[['Weighted_Price']]\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)","83d2eacb":"# graphe de variation des prix train\/test sets\nplt.style.use('fivethirtyeight')\n_ = data.plot(style='', figsize=(15,5), title='Prix du bitcoin(donn\u00e9s des heure)')","4bcd476d":"#detemination de la date limite train\/test set suivant le ratio 70\/30\nprint(data.shape)\ndata.head(51000)\n","cbf2f5e8":"# selection de la date de s\u00e9paration des train\/test sets\nsplit_date = '25-Oct-2017'\ndata_train = data.loc[data.index <= split_date].copy()\ndata_test = data.loc[data.index > split_date].copy()","becaa57d":"# graphe de variation des prix train\/test sets\n_ = data_test.rename(columns={'Weighted_Price': 'Test Set'}).join(data_train.rename(columns={'Weighted_Price': 'Training Set'}), how='outer').plot(figsize=(15,5), title='Variation du prix du bitcoin(donn\u00e9s des heure)', style='')","d05f5091":"# selection de la date de s\u00e9paration des train\/test sets\nsplit_date = '31-Oct-2018'\ndata_train = data.loc[data.index <= split_date].copy()\ndata_test = data.loc[data.index > split_date].copy()","356e9ff1":"# graphe de variation des prix train\/test sets\n_ = data_test.rename(columns={'Weighted_Price': 'Test Set'}).join(data_train.rename(columns={'Weighted_Price': 'Training Set'}), how='outer').plot(figsize=(15,5), title='Variation du prix du bitcoin(donn\u00e9s des heure)', style='')","94b0c559":"#Creation fonction timeseries a partir dun index de date\n\ndef create_features(df, label=None):\n    df['date'] = df.index\n    df['hour'] = df['date'].dt.hour\n    df['dayofweek'] = df['date'].dt.dayofweek\n    df['quarter'] = df['date'].dt.quarter\n    df['month'] = df['date'].dt.month\n    df['year'] = df['date'].dt.year\n    df['dayofyear'] = df['date'].dt.dayofyear\n    df['dayofmonth'] = df['date'].dt.day\n    df['weekofyear'] = df['date'].dt.weekofyear\n    \n    X = df[['hour','dayofweek','quarter','month','year',\n           'dayofyear','dayofmonth','weekofyear']]\n    if label:\n        y = df[label]\n        return X, y\n    return X","525d8668":"# introduction de la configuration du XGBoost\nX_train, y_train = create_features(data_train, label='Weighted_Price')\nX_test, y_test = create_features(data_test, label='Weighted_Price')","4aff4615":"# prediction XGBoost\n\nimport xgboost as xgb\nfrom xgboost import plot_importance, plot_tree\nfrom sklearn.model_selection import RandomizedSearchCV, GridSearchCV\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold\nfrom xgboost import XGBClassifier\n\n\nparams = {\n        'min_child_weight': [1, 5, 10],\n        'gamma': [0.5, 1, 1.5, 2, 5],\n        'subsample': [0.6, 0.8, 1.0],\n        'colsample_bytree': [0.6, 0.8, 1.0],\n        'max_depth': [3, 4, 5]\n        }","42685865":"model =  xgb.XGBRegressor(objective ='reg:squarederror',min_child_weight=10, booster='gbtree', colsample_bytree = 0.3, learning_rate = 0.1, max_depth = 5, alpha = 10, n_estimators = 100)\n\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)], early_stopping_rounds=50, verbose=True)","7045bd21":"# jointure des donn\u00e9es test\/train\ndata_test['Weighted_Price_Prediction'] = model.predict(X_test)\ndata_all = pd.concat([data_test, data_train], sort=False)\ndata_all","e0a45761":"#introduction donn\u00e9es finales pour comparer les modeles\nfinal_data = data_all\nfinal_data = final_data.reset_index()","53bc0281":"#Comparaison entre modeles\nfinal_data = pd.merge(final_data, data_all, sort=False)\nfinal_data = final_data.rename(columns={'Weighted_Price_Prediction': 'xgboost'})\nfinal_data = final_data[['Timestamp','Weighted_Price','xgboost']]\nfinal_data","b8b895d1":"#visualisation pr\u00e9diction\/r\u00e9elles\n_ = data_all[['Weighted_Price','Weighted_Price_Prediction']].plot(figsize=(15, 5))","c8f27332":"# selection de la date de s\u00e9paration des train\/test sets\nsplit_date = '04-Jul-2019'\ndata_train = data.loc[data.index <= split_date].copy()\ndata_test = data.loc[data.index > split_date].copy()","35005fe3":"# graphe de variation des prix train\/test sets\n_ = data_test.rename(columns={'Weighted_Price': 'Test Set'}).join(data_train.rename(columns={'Weighted_Price': 'Training Set'}), how='outer').plot(figsize=(15,5), title='Variation du prix du bitcoin(donn\u00e9s des heure)', style='')","e19fc0b0":"# introduction de la configuration du XGBoost\nX_train, y_train = create_features(data_train, label='Weighted_Price')\nX_test, y_test = create_features(data_test, label='Weighted_Price')","d7369e57":"# prediction XGBoost\n\nimport xgboost as xgb\nfrom xgboost import plot_importance, plot_tree\n\nmodel =  xgb.XGBRegressor(objective ='reg:squarederror',min_child_weight=10, booster='gbtree', colsample_bytree = 0.3, learning_rate = 0.1, max_depth = 5, alpha = 10, n_estimators = 100)\n\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)], early_stopping_rounds=50, verbose=True)","851c3deb":"# jointure des donn\u00e9es test\/train\ndata_test['Weighted_Price_Prediction'] = model.predict(X_test)\ndata_all = pd.concat([data_test, data_train], sort=False)\ndata_all","01dc9ae6":"#visualisation pr\u00e9diction\/r\u00e9elles\n_ = data_all[['Weighted_Price','Weighted_Price_Prediction']].plot(figsize=(15, 5))","c6a945c0":"from statsmodels.tsa.stattools import adfuller\nfrom scipy.stats import boxcox\n\n### test Dickey-Fuller\ndef DFTest(series):\n    testdf = adfuller(series)\n    print(\"DF test p-value : %.16f\" %testdf[1] )","28556b7c":"from scipy import stats\nimport statsmodels.api as sm\nimport warnings\nfrom itertools import product","0950eb04":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)\nframes=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)","f3b72870":"data['Open'].fillna(method='backfill', inplace=True)\ndata['High'].fillna(method='backfill', inplace=True)\ndata['Low'].fillna(method='backfill', inplace=True)\ndata['Close'].fillna(method='backfill', inplace=True)\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)\ndata['Volume_(BTC)'].fillna(method='backfill', inplace=True)\ndata['Volume_(Currency)'].fillna(method='backfill', inplace=True)","8fb12769":"data['Timestamp'] = data['Timestamp'].dt.tz_localize(None)\ndata = data.groupby([pd.Grouper(key='Timestamp', freq='M')]).first().reset_index()\ndata = data.set_index('Timestamp')\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)","f1d44751":"plt.figure(figsize=[20,8])\nplt.title('Variation prix bicoin par mois')\nplt.plot(data.Weighted_Price, '-', label='By Months')\nplt.show()","e8318592":"#plt.figure(figsize=(20,15))\nsm.tsa.seasonal_decompose(data_month.Weighted_Price).plot()\nplt.title('decomposition saison du df')\nplt.show()","ec56ff3b":"print(\"Test Dickey\u2013Fuller : p=%f\" % sm.tsa.stattools.adfuller(data.Weighted_Price)[1])\nDFTest(data.Weighted_Price)","d2865a8e":"from statsmodels.graphics.tsaplots import plot_acf\nfrom statsmodels.graphics.tsaplots import plot_pacf\nfrom matplotlib import pyplot\npyplot.figure(figsize=(20,8))\npyplot.subplot(211)\nplot_acf(data.Weighted_Price, ax=pyplot.gca(),lags=40)\npyplot.subplot(212)\nplot_pacf(data.Weighted_Price, ax=pyplot.gca(), lags=50)\npyplot.show()","47975649":"prices = data.Weighted_Price\nprices_log = np.log(prices)\nDFTest(prices_log)","d39c7116":"prices_log_r = prices_log - prices_log.shift(12)\nprices_log_r.dropna(inplace = True)\n\nDFTest(prices_log_r)","82f2cdce":"prices_box_cox_, lambda_ = boxcox(prices)\nprices_box_cox = pd.Series(data = prices_box_cox_, index = data.index) \nDFTest(prices_box_cox)\nprint('lambda value:', lambda_)\n","c94ea0cd":"prices_box_cox_r = prices_box_cox - prices_box_cox.shift(12)\nprices_box_cox_r.dropna(inplace = True)\n\nDFTest(prices_box_cox_r)\n","1bf170cd":"from statsmodels.tsa.stattools import acf, pacf\n\nplt.figure(figsize = (14,7)) \na = acf(prices_log_r)\np = pacf(prices_log_r)\n\nplt.subplot(221)\nsns.lineplot(data = a)\nplt.axhline(y=0, linestyle='--', color='gray')\nplt.grid(linestyle='dotted')\nplt.title('Courbe ACF')\n\nplt.subplot(222)\nsns.lineplot(data = p)\nplt.axhline(y=0, linestyle='--', color='gray')\nplt.grid(linestyle='dotted')\nplt.title('Courbe PACF')\nplt.show()","1579a51e":"from statsmodels.tsa.arima_model import ARIMA\n\na = [[1,2,3], [1],[1,2,3]]\nparams = list(product(*a))\n\nresults = []   \nmin_aic = float('inf')\nbest_param = []\n\n# checking different set of params for best fit\nfor param in params:\n    try:\n        model = ARIMA(prices_log, order = param).fit(disp = -1)\n    except LinAlgError:\n        print('Rejected Parameters:', param)\n        continue\n    except ValueError:\n        print('Rejected Parameters:', param)\n        continue\n    if(min_aic > model.aic):\n        min_aic = model.aic\n        best_param = param\n        best_model = model\n        \n    results.append([param, model.aic])\n\nprint(best_param,min_aic)\nprint(results)\n\nprint(best_model.fittedvalues)\n\nplt.figure(figsize=(16,8))\nsns.lineplot(data = prices_log_r, color = 'blue')\nsns.lineplot(data = best_model.fittedvalues, color = 'red')\nplt.grid(linestyle='dotted')\nplt.title('Valeurs du meilleur modele (rouge) VS. valeur prix apres trandformation log')\nplt.show()","d033fd40":"fitted_values = best_model.fittedvalues\nfitted_values = fitted_values.cumsum()\n\nfitted_values = fitted_values + prices_log[0]\n\nfinal_values = np.exp(fitted_values)\n\nd = {'prices' : prices, 'prices_log' : prices_log, 'price_log_r' : prices_log_r, 'fitted_values' : fitted_values, 'final_values' : final_values}\nsummaryDF = pd.DataFrame(data = d)\n\nplt.figure(figsize=(16,8))\nsns.lineplot(data = summaryDF['prices'], color = 'blue', label='r\u00e9elle')\nsns.lineplot(data = summaryDF['final_values'], color = 'red', label='predite')\nplt.grid(linestyle='dotted')\nplt.title('valeurs pr\u00e9dites(rouge) \/ valeurs r\u00e9elles')\nplt.show()","d5e9ccac":"# Initialisation parametres\nQs = range(0, 2)\nqs = range(0, 3)\nPs = range(0, 3)\nps = range(0, 3)\nD=1\nd=1\nparameters = product(ps, qs, Ps, Qs)\nparameters_list = list(parameters)\nlen(parameters_list)\n\n# Selection Modele\nresults = []\nbest_aic = float(\"inf\")\nwarnings.filterwarnings('ignore')\nfor param in parameters_list:\n    try:\n        model=sm.tsa.statespace.SARIMAX(data.Weighted_Price, order=(param[0], d, param[1]), \n                                        seasonal_order=(param[2], D, param[3], 12),enforce_stationarity=False,\n                                            enforce_invertibility=False).fit(disp=-1)\n    except ValueError:\n        #print('wrong parameters:', param)\n        continue\n    aic = model.aic\n    if aic < best_aic:\n        best_model = model\n        best_aic = aic\n        best_param = param\n    results.append([param, model.aic])","a53061e5":"# Meilleurs modeles\nresult_table = pd.DataFrame(results)\nresult_table.columns = ['parameters', 'aic']\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\nprint(best_model.summary())","72918a54":"print(\"Test Dickey\u2013Fuller : p=%f\" % sm.tsa.stattools.adfuller(best_model.resid)[1])","669484f8":"#figure r\u00e9sidus meilleur modele\nfig = plt.figure(figsize=(20,8))\nbest_model.resid.plot()\nfig.suptitle('Residus meilleur modele')\nplt.show()","011940aa":"#graphe comparatif pr\u00e9cdiction valeurs r\u00e9elles\ndf_month2 = data[['Weighted_Price']]\nfuture = pd.DataFrame()\ndf_month2 = pd.concat([df_month2, future])\ndf_month2['forecast'] = best_model.predict(start=0, end=200)\nplt.figure(figsize=(15,7))\ndf_month2.Weighted_Price.plot()\ndf_month2.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title('Comparatif Prediction\/Donn\u00e9es r\u00e9elles des variation du bitcoin ')\nplt.ylabel('$')\nplt.show()","d17d1d65":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)\nframes=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)","639b72a8":"#regle Timestamp en fonction des heures\ndata['Timestamp'] = data['Timestamp'].dt.tz_localize(None)\ndata = data.groupby([pd.Grouper(key='Timestamp', freq='H')]).first().reset_index()\ndata = data.set_index('Timestamp')\ndata = data[['Weighted_Price']]\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)","4d6c28a4":"_ = data.plot(style='', figsize=(15,5), title='Prix du bitcoin(donn\u00e9s des heure)')","20953a6a":"split_date = '04-Jul-2018'\ndata_train = data.loc[data.index <= split_date].copy()\ndata_test = data.loc[data.index > split_date].copy()","f5aaaed8":"# graphe de variation des prix train\/test sets\n_ = data_test.rename(columns={'Weighted_Price': 'Test Set'}).join(data_train.rename(columns={'Weighted_Price': 'Training Set'}), how='outer').plot(figsize=(15,5), title='Variation du prix du bitcoin(donn\u00e9s des heure)', style='')","97b403e4":"#import de la librairie Prophet\nfrom fbprophet import Prophet","2be34fbf":"# configuration du modele d'entrainement\n# On renomme les colonnes selon les normes de Prophet\ndata_train = data_train.reset_index().rename(columns={'Timestamp':'ds', 'Weighted_Price':'y'})\n\nm = Prophet()\nm.fit(data_train)","684f97be":"# prediction sur l'ensemble training set\ndata_test_fcst = m.predict(df=data_test.reset_index().rename(columns={'Timestamp':'ds'}))","beff9dc5":"# graphe de la prediction \nf, ax = plt.subplots()\nf.set_figheight(12)\nf.set_figwidth(15)\nfig = m.plot(data_test_fcst, ax=ax)","93960e12":"# composantes temporelles\nfig = m.plot_components(data_test_fcst)","8e827b01":"# graphe pr\u00e9diction\/r\u00e9elles\nf, ax = plt.subplots(1)\nf.set_figheight(12)\nf.set_figwidth(15)\nax.scatter(data_test.index, data_test['Weighted_Price'], color='r')\nfig = m.plot(data_test_fcst, ax=ax)","5577d8a1":"start_date='01-Apr-2018'\nsplit_date = '01-Feb-2020'","362b9b1e":"data_boost=data.copy()","ac5d27d7":"#regle Timestamp en fonction des heures\ndata_boost['Timestamp'] = data_boost['Timestamp'].dt.tz_localize(None)\ndata_boost = data_boost.groupby([pd.Grouper(key='Timestamp', freq='H')]).first().reset_index()\ndata_boost = data_boost.set_index('Timestamp')\ndata_boost = data_boost[['Weighted_Price']]\ndata_boost['Weighted_Price'].fillna(method='backfill', inplace=True)","bce9078b":"data_train = data_boost.loc[(data_boost.index <= split_date) & (data_boost.index > start_date)].copy()\ndata_test = data_boost.loc[(data_boost.index > split_date)].copy()","2638bc2c":"# introduction de la configuration du XGBoost\nX_train, y_train = create_features(data_train, label='Weighted_Price')\nX_test, y_test = create_features(data_test, label='Weighted_Price')","d3c10b71":"model =  xgb.XGBRegressor(objective ='reg:squarederror',min_child_weight=10, booster='gbtree', colsample_bytree = 0.3, learning_rate = 0.1, max_depth = 5, alpha = 10, n_estimators = 100)\n\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)], early_stopping_rounds=50, verbose=True)","ae5a6067":"# jointure des donn\u00e9es test\/train\ndata_test['Weighted_Price_Prediction'] = model.predict(X_test)\ndata_all = pd.concat([data_test, data_train], sort=False)\ndata_all","695d8402":"#Comparaison entre modeles\nfinal_data = pd.merge(final_data, data_all, sort=False)\nfinal_data = final_data.rename(columns={'Weighted_Price_Prediction': 'xgboost'})\nfinal_data = final_data[['Timestamp','Weighted_Price','xgboost']]\nfinal_data","b3b7a2b5":"#visualisation pr\u00e9diction\/r\u00e9elles\n_ = data_all[['Weighted_Price','Weighted_Price_Prediction']].plot(figsize=(15, 5))","c742496c":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)\nframes=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)\nraw_data=data.copy()","cea548b0":"data['Open'].fillna(method='backfill', inplace=True)\ndata['High'].fillna(method='backfill', inplace=True)\ndata['Low'].fillna(method='backfill', inplace=True)\ndata['Close'].fillna(method='backfill', inplace=True)\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)\ndata['Volume_(BTC)'].fillna(method='backfill', inplace=True)\ndata['Volume_(Currency)'].fillna(method='backfill', inplace=True)","042da2a8":"data['Timestamp'] = data['Timestamp'].dt.tz_localize(None)\ndata = data.groupby([pd.Grouper(key='Timestamp', freq='M')]).first().reset_index()\ndata = data.set_index('Timestamp')\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)","e5bc41e3":"data=data.loc[data.index > start_date]","f1f23337":"plt.figure(figsize=[20,8])\nplt.title('Variation prix bicoin par mois')\nplt.plot(data.Weighted_Price, '-', label='By Months')\nplt.show()","4b59842c":"#plt.figure(figsize=(20,15))\nsm.tsa.seasonal_decompose(data_month.Weighted_Price).plot()\nplt.title('decomposition saison du df')\nplt.show()","d197f8f5":"print(\"Test Dickey\u2013Fuller : p=%f\" % sm.tsa.stattools.adfuller(data.Weighted_Price)[1])\nDFTest(data.Weighted_Price)","3960dcae":"prices = data.Weighted_Price\nprices_log = np.log(prices)\nDFTest(prices_log)","bee1fa05":"prices_box_cox_, lambda_ = boxcox(prices)\nprices_box_cox = pd.Series(data = prices_box_cox_, index = data.index) \nDFTest(prices_box_cox)\nprint('lambda value:', lambda_)","6c6430f3":"prices_box_cox_r = prices_box_cox - prices_box_cox.shift(12)\nprices_box_cox_r.dropna(inplace = True)\n\nDFTest(prices_box_cox_r)","3c74785f":"a = [[1,2,3], [1],[1,2,3]]\nparams = list(product(*a))\n\nresults = []   \nmin_aic = float('inf')\nbest_param = []\n\n# checking different set of params for best fit\nfor param in params:\n    try:\n        model = ARIMA(prices_log, order = param).fit(disp = -1)\n    except LinAlgError:\n        print('Rejected Parameters:', param)\n        continue\n    except ValueError:\n        print('Rejected Parameters:', param)\n        continue\n    if(min_aic > model.aic):\n        min_aic = model.aic\n        best_param = param\n        best_model = model\n        \n    results.append([param, model.aic])\n\nprint(best_param,min_aic)\nprint(results)\n\nprint(best_model.fittedvalues)\n\nplt.figure(figsize=(16,8))\nsns.lineplot(data = prices_log_r, color = 'blue')\nsns.lineplot(data = best_model.fittedvalues, color = 'red')\nplt.grid(linestyle='dotted')\nplt.title('Valeurs du meilleur modele (rouge) VS. valeur prix apres trandformation log')\nplt.show()","39e25165":"fitted_values = best_model.fittedvalues\nfitted_values = fitted_values.cumsum()\n\nfitted_values = fitted_values + prices_log[0]\n\nfinal_values = np.exp(fitted_values)\n\nd = {'prices' : prices, 'prices_log' : prices_log, 'price_log_r' : prices_log_r, 'fitted_values' : fitted_values, 'final_values' : final_values}\nsummaryDF = pd.DataFrame(data = d)\n\nplt.figure(figsize=(16,8))\nsns.lineplot(data = summaryDF['prices'], color = 'blue', label='r\u00e9elle')\nsns.lineplot(data = summaryDF['final_values'], color = 'red', label='predite')\nplt.grid(linestyle='dotted')\nplt.title('valeurs pr\u00e9dites(rouge) \/ valeurs r\u00e9elles')\nplt.show()","308a5797":"# Initialisation parametres\nQs = range(0, 2)\nqs = range(0, 3)\nPs = range(0, 3)\nps = range(0, 3)\nD=1\nd=1\nparameters = product(ps, qs, Ps, Qs)\nparameters_list = list(parameters)\nlen(parameters_list)\n\n# Selection Modele\nresults = []\nbest_aic = float(\"inf\")\nwarnings.filterwarnings('ignore')\nfor param in parameters_list:\n    try:\n        model=sm.tsa.statespace.SARIMAX(data.Weighted_Price, order=(param[0], d, param[1]), \n                                        seasonal_order=(param[2], D, param[3], 12),enforce_stationarity=False,\n                                            enforce_invertibility=False).fit(disp=-1)\n    except ValueError:\n        #print('wrong parameters:', param)\n        continue\n    aic = model.aic\n    if aic < best_aic:\n        best_model = model\n        best_aic = aic\n        best_param = param\n    results.append([param, model.aic])","1580e181":"# Meilleurs modeles\nresult_table = pd.DataFrame(results)\nresult_table.columns = ['parameters', 'aic']\nprint(result_table.sort_values(by = 'aic', ascending=True).head())\nprint(best_model.summary())","ff1a1b3f":"print(\"Test Dickey\u2013Fuller : p=%f\" % sm.tsa.stattools.adfuller(best_model.resid)[1])","b803f74a":"#figure r\u00e9sidus meilleur modele\nfig = plt.figure(figsize=(20,8))\nbest_model.resid.plot()\nfig.suptitle('Residus meilleur modele')\nplt.show()","13e4229e":"#graphe comparatif pr\u00e9cdiction valeurs r\u00e9elles\ndf_month2 = data[['Weighted_Price']]\nfuture = pd.DataFrame()\ndf_month2 = pd.concat([df_month2, future])\ndf_month2['forecast'] = best_model.predict(start=0, end=200)\nplt.figure(figsize=(15,7))\ndf_month2.Weighted_Price.plot()\ndf_month2.forecast.plot(color='r', ls='--', label='Predicted Weighted_Price')\nplt.legend()\nplt.title('Comparatif Prediction\/Donn\u00e9es r\u00e9elles des variation du bitcoin ')\nplt.ylabel('$')\nplt.show()","d8ec7d84":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)\nframes=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)\nraw_data=data.copy()","4ba8ee1b":"data.info()","ba6ee27d":"#regle Timestamp en fonction des heures\ndata['Timestamp'] = data['Timestamp'].dt.tz_localize(None)\ndata = data.groupby([pd.Grouper(key='Timestamp', freq='H')]).first().reset_index()\ndata = data.set_index('Timestamp')\ndata = data[['Weighted_Price']]\ndata['Weighted_Price'].fillna(method='backfill', inplace=True)","678f1fa0":"data=data.loc[data.index > start_date]","cf6c02a0":"_ = data.plot(style='', figsize=(15,5), title='Prix du bitcoin(donn\u00e9s des heure)')","940e6178":"\ndata_train = data.loc[(data.index <= split_date)].copy()\ndata_test = data.loc[data.index > split_date].copy()","a48db5ca":"# graphe de variation des prix train\/test sets\n_ = data_test.rename(columns={'Weighted_Price': 'Test Set'}).join(data_train.rename(columns={'Weighted_Price': 'Training Set'}), how='outer').plot(figsize=(15,5), title='Variation du prix du bitcoin(donn\u00e9s des heure)', style='')","1d84be11":"# configuration du modele d'entrainement\n# On renomme les colonnes selon les normes de Prophet\ndata_train = data_train.reset_index().rename(columns={'Timestamp':'ds', 'Weighted_Price':'y'})\n\nm = Prophet()\nm.fit(data_train)","cb538c5e":"# prediction sur l'ensemble training set\ndata_test_fcst = m.predict(df=data_test.reset_index().rename(columns={'Timestamp':'ds'}))","161df9e4":"# graphe de la prediction \nf, ax = plt.subplots()\nf.set_figheight(8)\nf.set_figwidth(15)\nfig = m.plot(data_test_fcst, ax=ax)","8afde996":"# composantes temporelles\nfig = m.plot_components(data_test_fcst)","ade9e4e9":"# graphe pr\u00e9diction\/r\u00e9elles\nf, ax = plt.subplots(1)\nf.set_figheight(8)\nf.set_figwidth(15)\nax.scatter(data_test.index, data_test['Weighted_Price'], color='r')\nfig = m.plot(data_test_fcst, ax=ax)","b33c8ebd":"start_date='01-Apr-2019'\nsplit_date = '01-Apr-2020'","7cb6608a":"df1 = pd.read_csv('..\/input\/bitcoin-historical-data\/coinbaseUSD_1-min_data_2014-12-01_to_2019-01-09.csv', parse_dates=[0], date_parser=dateparse)\ndf2 = pd.read_csv('..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2020-04-22.csv', parse_dates=[0], date_parser=dateparse)\nframes=[df1, df2]\ndata=pd.concat(frames).drop_duplicates().reset_index(drop=True)\nraw_data=data.copy()","d0a29aed":"# erreur intentionnelle \nx=","b978acbf":"\ndata_test=raw_data.copy()\ndata_test['Timestamp'] = data_test['Timestamp'].dt.tz_localize(None)","3fdbabcb":"data_test","807ba39e":"data_test.rename(columns={'Timestamp': 'ds', 'Weighted_Price': 'y'},inplace=True)\ndata_test['ds'] = pd.to_datetime(data_test['ds'])\ndata_test['y']=data_test['y'].astype(float)","badd7eb8":"data_test.head(1)","1ce7f534":"import datetime\nimport pytz\nimport datetime\n\nx = datetime.datetime.now()\nx","55521b62":"#Fit the model \ndf_prophet = Prophet(changepoint_prior_scale=0.15, daily_seasonality=True)\ndf_prophet.fit(data_test)","d4e87f32":"fcast_time=365   # 1 year\ndf_forecast = df_prophet.make_future_dataframe(periods= fcast_time, freq='D')\ndf_forecast","2a4ff071":"# Pr\u00e9sentation et objectifs","d59ac8b1":"#### Transformation de Box-Cox","f71c0d81":"On peut douter de la qualit\u00e9 de cette selection de date, tant elle n'est pas repr\u00e9sentative de la tendance entre 2018 et 2020. La pr\u00e9diction qui en aurait d\u00e9coul\u00e9 n'aurait fait que croitre. <br>\nIl s'agit de choisir un date plus coh\u00e9rente, deux intervalles pourraeint convenir, celui entre aout et novembre 2018 et un autre vers mi 2019.\nOn choisit une date dans l'un de ces deux intervalles (je choisis le 31 octobre 2018 -date des 10 ans du bitcoin-)","99c3ba54":"## Chargement des fichiers csv et visualisation des premieres valeurs","e9273892":"Prophet est un modele pr\u00e9dictif d\u00e9velopp\u00e9 par Facebook de time seies. Il est bas\u00e9 sur un mod\u00e8le additif o\u00f9 les tendances non lin\u00e9aires sont adapt\u00e9es aux saisonnalit\u00e9 quotidiennes, annuelles et hebdomadaires, ainsi que les effets des vacances.<br>\nLe fonctionnement de Prophet est s'am\u00e9liore des s\u00e9ries temporelles qui ont de forts effets saisonniers et plusieurs saisons de donn\u00e9es historiques. Prophet r\u00e9siste aux donn\u00e9es manquantes et aux changements de tendance, et g\u00e8re g\u00e9n\u00e9ralement bien les valeurs aberrantes. <br>\nDoc Prophet: [Fonctionnement et documentation Prophet](https:\/\/facebook.github.io\/prophet\/)\n","7e89a43e":"## Autre date de test 31\/10\/2018 - 10 ans du Bitcoin","8c361650":"### Configuration Prophet:\nOn doit n\u00e9c\u00e9ssairement avoir un dataframe compos\u00e9 de deux colonnes 'ds' et 'y'.<br>\nds correspondant au datestamp et y devant correspondre a une valeur num\u00e9rique et repr\u00e9sente la variable qu'on veut pr\u00e9dire","b11cd7b4":"### transformation logarithmique","50e2628b":" # Deuxieme modele ","ed1b988f":"Maintenant qu'on a obtenu des r\u00e9sultats satisfaisants au test de Dickey-Fuller, tracons les graphes ACF\/PACF des dfonctions transform\u00e9es afin d'avoir une id\u00e9e de comment \u00e2ram\u00e9trer Arima","7ee7e551":"## Interpr\u00e9tation graphique de la valeur du bitcoin: \n- Stable entre 2011 et 2017;\n- Forte augmentation durant l'ann\u00e9e 2017 jusqu'a atteindre sa valeur maximale fin 2017 (pres de 20000 dollars\/unit\u00e9);\n- Forte chute d\u00e9but 2018, puis stagnation 7500 dollars\/unit\u00e9 dans le courant d'ann\u00e9e et nouvelle chute fin d'ann\u00e9e;\n- Hausse d\u00e9but 2019 et depuis mai \"stabilisation\" ","5f27070a":"## Conversion du Timestamp","bf9e3027":"# Tests","7b76d398":"Les s\u00e9ries temporelles ont plusieurs caract\u00e9ristiques cl\u00e9s telles que la tendance, la saisonnalit\u00e9 et le bruit.La pr\u00e9vision est le processus de pr\u00e9diction de l'avenir, bas\u00e9 sur les donn\u00e9es pass\u00e9es et pr\u00e9sentes.\n\nDans ce notebook, nous tentons d'effectuer une analyse de s\u00e9ries temporelles sur les donn\u00e9es historiques du prix du Bitcoin. On voit, que les prix du Bitcoin \u00e9taient assez volatils et incoh\u00e9rents avec le temps. Il est tr\u00e8s difficile d'effectuer une analyse de s\u00e9ries chronologiques sur de telles donn\u00e9es volatiles. Mais ici, on essaye d'explorer diff\u00e9rents mod\u00e8les de pr\u00e9vision de s\u00e9ries temporelles.\n\n- Pr\u00e9vision de s\u00e9ries chronologiques avec XGBoost\n- Pr\u00e9vision de s\u00e9ries chronologiques avec ARIMA\n- Pr\u00e9vision de s\u00e9ries chronologiques avec Facebook Prophet\n","ca5a7c71":"On fixe le 25 octobre 2017 comme date de s\u00e9paration cette date repr\u00e9sentant le sueil du ratio 70\/30. Et on introduit les donn\u00e9es de test et d'entrainement","d30b7ca0":"grid = GridSearchCV(estimator=xgb, param_grid=params, scoring='roc_auc', n_jobs=4, cv=skf.split(X,Y), verbose=3 )","4ea586bc":"### Visualisation des variation des prix du bitcoin en fonction de la date ","544dbc7f":"Manifestement sur l'ensemble des modeles qu'on a introduit, on n'aobtient pas de r\u00e9sultat tres significatifs.<br>\nPour obtenir de meilleurs r\u00e9sultats on peut imaginer deux hypotheses: \n- intervalle de donn\u00e9es plus r\u00e9duit\n- prediction sur une courte p\u00e9riode (10 jours\/1 mois)","08760076":"# Mod\u00e8les pr\u00e9dictifs","0bf72084":"Les donn\u00e9es du dataframe comporte 6,43 millions des lignes et de 8 variables informant sur les prix du bitcoin a un instant pr\u00e9cis.","04699f11":"# Arima","bcdcbce2":"# XGBoost\nXGBoost est une impl\u00e9mentation d'arbres de d\u00e9cision \u00e0 gradient am\u00e9lior\u00e9 con\u00e7us pour sa vitesse et ses performances. On regarde dans quelle mesure XGBoost fonctionne pour pr\u00e9dire les valeurs de cette s\u00e9rie temporelle","3241ea6b":"## Selection de date limite train\/test set","956b8494":"### interpr\u00e9tation (doc: https:\/\/people.duke.edu\/~rnau\/411arim.htm)\nNous d\u00e9duisons du graphique que L'ACF et le PACF se rapprochent de z\u00e9ro tandis que le d\u00e9calage approche 1.<br>\nEssai diff\u00e9rentes valeurs de p et q <br>\nD = 1","5ab71e1f":"# Analyse Exploratoire","0f9d11b4":"On dispose de 2 fichiers csv qui determinent les transactions de bitcoin dans une p\u00e9riode d\u00e9finie entre le 31\/12\/2011 et le 22\/04\/2020 avec des mises a jour minute par minute.<br>\nL'horodatage se fait en temps Unix","1f3ad2f1":"## Corr\u00e9lation entre les variables","2fefe267":"## Remarques:","ab6d51d7":"# Tests\npas assez de RAM !\n","dde11c47":"Nous utilisons le mod\u00e8le ARIMA pour analyser d'abord nos s\u00e9ries chronologiques. Nous savons que pour cela, nous avons besoin que notre s\u00e9rie soit stationnaire. Nous utilisons donc les techniques d\u00e9crites ci-dessous pour r\u00e9aliser si notre s\u00e9rie est stationnaire:\n-  d\u00e9composition saisonni\u00e8re pour visualiser les composantes saisonni\u00e8res et tendancielles des s\u00e9ries chronologiques. Nous visons \u00e0 obtenir un r\u00e9sidu ind\u00e9pendant de tendances et de saisonnalit\u00e9.\n- test de Dicky Fuller consid\u00e8re l'hypoth\u00e8se nulle que la s\u00e9rie chronologique consid\u00e9r\u00e9e n'est pas stationnaire. Si la valeur de p est suffisamment faible (inf\u00e9rieure \u00e0 0,05) lors du test d'hypoth\u00e8se, alors seulement nous rejetons l'hypoth\u00e8se nulle et on peut consid\u00e9rons la s\u00e9rie comme stationnaire","eb439704":"Le Bitcoin est la plus ancienne crypto-monnaie, publi\u00e9e pour la premi\u00e8re fois en open source en 2009 par Satoshi Nakamoto. C'est un support d\u00e9centralis\u00e9 d'\u00e9change num\u00e9rique, avec des transactions v\u00e9rifi\u00e9es et enregistr\u00e9es publiquement (blockchain).L'int\u00e9ret r\u00e9side dans le fait qu'il n'y a pas besoin d'une autorit\u00e9 de tenue de dossiers  ou d'un interm\u00e9diaire central. Les blocs de transaction contiennent un hachage cryptographique des blocs de transaction pr\u00e9c\u00e9dents et sont donc \"encha\u00een\u00e9s\" ensemble, cela sert d'enregistrement de toutes les transactions. Comme pour toute devise, le trading de bitcoins et les instruments financiers ont rapidement suivi l'adoption publique du bitcoin. \n\n\n\n","9949c0fe":"# Dataset Bitcoin","3c9d4598":"## ARIMA","46ba22e8":"## XGBoost","a747f96f":"## Autre date: 04\/07\/2019 ","7126ea7d":"## D\u00e9composition STL (tendence\/saisonnalit\u00e9\/r\u00e9sidu) et visualisation ","a41bbe66":"## Prophet","7ecd03e9":"On a clairement vu que la s\u00e9rie temporelle n'estt pas stationnaire.\nIl faut essayer de la rendre stationnaire c'est a dire que la moyenne de la variance reste constante en fonction du temps. On utilise un test de Dickey-Fuller pour savoir la stationarit\u00e9 ou non.","8db14cd5":"Au vu des r\u00e9sultats des pr\u00e9dictions pr\u00e9c\u00e9dentes qui ne sont pas d'une pr\u00e9cision suffisante, on choisit de ne consid\u00e9rer que les valeurs a partir de 2018, et on observera les r\u00e9sultats des valeurs pr\u00e9dites du prix du Bitcoin","c94be608":"Le but de ce notebook est de pr\u00e9dire les prix du Bitcoin en s'aidant de diff\u00e9rents mod\u00e8les pr\u00e9dictifs, afin de determiner lequel est le plus performant.<br>\nLa difficult\u00e9 r\u00e9side dans le fait que le bitcoin est tres volatile.<br>\nOn proc\u00e9dera tout d'abord \u00e0 une analyse exploratoire des donn\u00e9es puis une analyse des s\u00e9ries temporelles avant d'introduire diff\u00e9rents modeles pr\u00e9dictifs","239e7de7":"On obtient une valeur de p=0.3 avec le Test de DF donc on ne peut pas consid\u00e9rer la s\u00e9rie comme stationnaire","16748587":"On s'interesse a la saisonalit\u00e9 donc on utilisera les donn\u00e9es mensuelles","a3be4c05":"## Import de librairies","7f0c36fa":"## Un bref historique du bitcoin\n- 2008, le  domaine bitcoin.org a \u00e9t\u00e9 enregistr\u00e9.\n- novembre 2010, le capital social de Bitcoin atteint 1 million dollars. Son taux de change: 0,50 USD par BTC.\n- juin 2011, taux 10 USD\/BTC. \n- mars 2013, taux 32 USD\/BTC.\n- avril 2013, taux 100 USD\/BTC.\n- f\u00e9vrier 2015, taux 260 USD\/BTC.\n- janvier 2017, franchit taux 1000 USD\/BTC\n- juin 2017, taux d\u00e9passe 3000 USD\/BTC.\n- decembre 2017, taux 10000 USD\/BTC.\n- fin d\u00e9cembre 2017, Bitcoin atteint un niveau record, mais n'atteint pas 20 000 USD.\n- 28 d\u00e9cembre 2017, le taux du bitcoin chute apres une aznnonce de la Cor\u00e9e du Sud du controle du prix \n- novembre 2018, taux 6300 USD\/BT","4aaa7bd5":"## Fusion des deux dataframes et suppression des valeurs dupliqu\u00e9es","ca72cf47":"Pr\u00e9traitement: remplacement des NaN par des z\u00e9ros et des donn\u00e9es suivantes.","0718ceb7":"## Infos sur les dates des deux dataframes","34fc55eb":"Guide pour les s\u00e9ries temporelles: https:\/\/www.analyticsvidhya.com\/blog\/2016\/02\/time-series-forecasting-codes-python\/","f8ee64a8":"Maintenant qu'on a obtenue la stationnarirt\u00e9, il faut faire une selection de modele\n\nFonction d'autocorr\u00e9lation - ACF: Le graphique r\u00e9sume la corr\u00e9lation d'une observation avec des valeurs de d\u00e9calage. L'axe des x montre le d\u00e9calage et l'axe des y montre le coefficient de corr\u00e9lation entre -1 et 1 pour la corr\u00e9lation n\u00e9gative et positive\nFonction d'autocorr\u00e9lation partielle - PACF: Le graphique r\u00e9sume les corr\u00e9lations d'une observation avec des valeurs de d\u00e9calage qui ne sont pas prises en compte par les observations ant\u00e9rieures. On peut obtenir une image de base de l'intervalle de param\u00e8tres, puis d\u00e9cider quels sont les meilleurs p, q, d pour ARIMA","1a94d1bb":"#### Split date","93a9d85a":"## Interpr\u00e9tation de la d\u00e9composition:\non constate effectivement beaucoup de bruit dans l'annalyse saisonni\u00e8re lors des periodes de forte variatoin de prix","19118e05":"### Prophet"}}