{"cell_type":{"1db661e3":"code","72b10917":"code","8684e868":"code","76ffda4d":"code","d352d192":"code","5ebd9395":"code","1fae609b":"code","a3525b95":"code","42d73103":"code","8ff33063":"code","975ca7a6":"code","0b4010ec":"markdown","416a6089":"markdown","88dddc83":"markdown","5c49e548":"markdown","d5b9b9a2":"markdown","6601a66c":"markdown","f1ba9df8":"markdown","62deaab0":"markdown","444deaae":"markdown","f6be8922":"markdown","afb1ef82":"markdown"},"source":{"1db661e3":"from PIL import Image \nImage.open(\"..\/input\/rfmrfm\/1_MCGPMFD7MTClqDem06mkcQ.png\")","72b10917":"# Installing required libraries\n\nimport datetime as dt\nimport pandas as pd\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Making the appearance settings of the printouts\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.float_format', lambda x: '%.5f' % x)","8684e868":"pip install openpyxl","76ffda4d":"# Load data into pandas dataframe..\n\ndf = pd.read_excel(\"\/kaggle\/input\/online\/online_retail.xlsx\", sheet_name=\"Year 2010-2011\")\ndf.head()","d352d192":"# Describe of data sets\n\ndef check_df(dataframe):\n    print(f\"\"\"\n        ##################### Shape #####################\\n\\n\\t{dataframe.shape}\\n\\n\n        ##################### Types #####################\\n\\n{dataframe.dtypes}\\n\\n\n        ##################### Head #####################\\n\\n{dataframe.head(3)}\\n\\n\n        ##################### NA #####################\\n\\n{dataframe.isnull().sum()}\\n\\n\n        ##################### Quantiles #####################\\n\\n{dataframe.quantile([0, 0.05, 0.50, 0.95, 0.99, 1]).T}\\n\\n\"\"\")\ncheck_df(df)","5ebd9395":"def outlier_thresholds(dataframe, variable):\n    \"\"\"\n    It allows us to catch outliers.\n    It determines the upper and lower limits over the quarterly values.\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    low limit: low limit\n                It subtracts 1.5 times the interquartile range from quantile(0.01)\n    \n    up_limit:  up limit: \n                It adds up 1.5 times the interquartile value from quantile(0.99)\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with replace_with_thresholds.\n    \n    \"\"\"\n    quartile1 = dataframe[variable].quantile(0.01)\n    quartile3 = dataframe[variable].quantile(0.99)\n    interquantile_range = quartile3 - quartile1\n    up_limit = quartile3 + 1.5 * interquantile_range\n    low_limit = quartile1 - 1.5 * interquantile_range\n    return low_limit, up_limit\n\n\ndef replace_with_thresholds(dataframe, variable):\n    \"\"\"\n    Replaces captured outliers according to the defined upper and lower limit\n    \n    Parameters\n    ------\n    dataframe: dataframe\n                The dataframe from which variable names are to be retrieved\n    variable: variable\n                The variable from which has outlier value\n                    \n    Returns\n    ------\n    None\n                \n    Notes\n    ------\n    It alone is not enough to get rid of outliers. It works with outlier_thresholds.\n    \n    \"\"\"\n    low_limit, up_limit = outlier_thresholds(dataframe, variable)\n    # dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit\n    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit\n    \n    \ndef data_prep(dataframe):\n    dataframe.dropna(axis=0, inplace=True)\n    dataframe = dataframe[~dataframe[\"Invoice\"].str.startswith(\"C\", na=False)]\n    dataframe = dataframe[dataframe[\"Quantity\"] > 0]\n    replace_with_thresholds(dataframe, \"Quantity\")\n    replace_with_thresholds(dataframe, \"Price\")\n    dataframe[\"TotalPrice\"] = dataframe[\"Quantity\"] * dataframe[\"Price\"]\n    return dataframe\n\ndf = data_prep(df)\ndf.head()","1fae609b":"# Recency: the difference between today and the customer's last purchase date, in days\n# Frequency: total number of purchases.\n# Monetary: total spend by the customer.\n\ndf[\"InvoiceDate\"].max() # The date on which the analysis should be performed.\ntoday_date = dt.datetime(2011, 12, 11)\n\nrfm= df.groupby(\"Customer ID\").agg({'InvoiceDate': lambda date: (today_date - date.max()).days,\n                                    'Quantity': lambda num: num.nunique(),\n                                    'TotalPrice': lambda price: price.sum()})\n\nrfm.columns = ['recency', 'frequency', \"monetary\"]\nrfm = rfm[(rfm['monetary'] > 0)] # condition\nrfm.head()","a3525b95":"# We assign 5 points to the date close to the date of analysis.\nrfm[\"recency_score\"] = pd.qcut(rfm['recency'], 5, labels=[5, 4, 3, 2, 1])\n\n# We give 1 point to customers with low shopping frequency.\n# NOTE : Monetary is not processed because it is not used in segment definition.\nrfm[\"frequency_score\"] = pd.qcut(rfm[\"frequency\"].rank(method=\"first\"), 5, labels=[1, 2, 3, 4, 5])\n\n# Defining segments\nrfm['rfm_segment'] = rfm['recency_score'].astype(str) + rfm['frequency_score'].astype(str) # make them categorical\nrfm.head()","42d73103":"seg_map = {\n        r'[1-2][1-2]': 'hibernating',\n        r'[1-2][3-4]': 'at_risk',\n        r'[1-2]5': 'cant_loose',\n        r'3[1-2]': 'about_to_sleep',\n        r'33': 'need_attention',\n        r'[3-4][4-5]': 'loyal_customers',\n        r'41': 'promising',\n        r'51': 'new_customers',\n        r'[4-5][2-3]': 'potential_loyalists',\n        r'5[4-5]': 'champions'\n    }\n    \nrfm['rfm_segment'] = rfm['rfm_segment'].replace(seg_map, regex=True)\nrfm = rfm[[\"recency\", \"frequency\", \"monetary\", \"rfm_segment\"]] # we take the names above\nrfm.head()","8ff33063":"# Visualization of RFM Segments\nsgm= rfm[\"rfm_segment\"].value_counts()\nplt.figure()\nsns.barplot(x=sgm.index,y=sgm.values)\nplt.xticks(rotation=90)\nplt.title('Customer Segmentation')\nplt.show()","975ca7a6":"rfm[[\"rfm_segment\", \"recency\", \"frequency\", \"monetary\"]].groupby(\"rfm_segment\").agg([\"mean\", \"count\"])\nrfm[rfm[\"rfm_segment\"] == \"cant_loose\"].head()\nrfm[rfm[\"rfm_segment\"] == \"about_to_sleep\"].head()\nrfm[rfm[\"rfm_segment\"] == \"new_customers\"].head()","0b4010ec":"### Recency-Frequency-Monetary","416a6089":"**Thank you for taking the time.**","88dddc83":"# Analyzing the top 3 important segments","5c49e548":"This Online Retail II data set contains all the transactions occurring for a UK-based and registered, non-store online retail between 01\/12\/2009 and 09\/12\/2011.\nThe company mainly sells unique all-occasion gift-ware.\nMany customers of the company are wholesalers.\n\n#  Variables\n\n* **InvoiceNo:** Invoice number. Nominal. A 6-digit integral number uniquely assigned to each transaction. If this code starts with the letter 'c', it indicates a cancellation.\n* **StockCode:** Product (item) code. Nominal. A 5-digit integral number uniquely assigned to each distinct product.\n* **Description:** Product (item) name. Nominal.\n* **Quantity:** The quantities of each product (item) per transaction. Numeric.\n* **InvoiceDate:** Invice date and time. Numeric. The day and time when a transaction was generated.\n* **UnitPrice:** Unit price. Numeric. Product price per unit in sterling (\u00c2\u00a3).\n* **CustomerID:** Customer number. Nominal. A 5-digit integral number uniquely assigned to each customer.\n* **Country:** Country name. Nominal. The name of the country where a customer resides.\n","d5b9b9a2":"RFM is a customer segmentation model that allows you to segment your customers based on their past purchasing behavior.\nIt is a score that consists of the initials of the words Recency, Frequency, Monetary, and is formed by combining these three metrics after calculating them.\n\n* **Recency:** When was the last time the customer made a purchase? A customer who has made a recent purchase will be more receptive to sent messages.\n* **Frequency:** How often does the customer buy? Frequent shopping shows that the customer is satisfied with the service received.\n* **Monetary:** How much total did the customer spend on his purchases? Monetary grading helps distinguish high-stakes shoppers from low-shoppers.\n","6601a66c":"# Data Preparation","f1ba9df8":"# RFM Metrics","62deaab0":"# Business Problem with Customer Segmentation (RFM ANALYSIS)","444deaae":"# What is RFM Analysis?","f6be8922":"# Calculations RFM Scores and Defining Segments","afb1ef82":"# Giving a name of RFM scores"}}