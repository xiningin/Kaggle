{"cell_type":{"9a5206b3":"code","ae2d3d08":"code","20082a03":"code","0ce67794":"code","59b79b1a":"code","3d09db41":"markdown","fd6d5501":"markdown","6f4a7255":"markdown","592f309c":"markdown","40daf132":"markdown","71d77d55":"markdown","451f2a71":"markdown","f9be52b8":"markdown","7e6c2c24":"markdown","b26ae625":"markdown","0505d495":"markdown","310d2c69":"markdown"},"source":{"9a5206b3":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# Any results you write to the current directory are saved as output.","ae2d3d08":"def knapSack(W, wt, val, n):\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n    # Jika weight dari item ke-n lebih besar daripada kapasitas Knapsack W,\n    # maka item tersebut tidak dapat dimasukan kedalam optimal solution\n    if (wt[n-1] > W) :\n        return knapSack(W, wt, val, n-1)\n    \n    # return nilai maksimum dari dua kemungkinan:\n    # item ke-n dimasukan\n    # tidak dimasukan\n    else:\n        return max(val[n-1] + knapSack(W-wt[n-1] , wt , val , n-1), \n                   knapSack(W , wt , val , n-1)) \n","20082a03":"def knapSack(W, wt, val, n): \n    K = [[0 for x in range(W+1)] for x in range(n+1)] \n  \n    for i in range(n+1): \n        for w in range(W+1): \n            if i==0 or w==0: \n                K[i][w] = 0\n            elif wt[i-1] <= w: \n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w] \n        print(K[i])\n  \n    return K[n][W] \n\nprint(knapSack(10, [3,10,5,25], [2,32,4,35], 4))","0ce67794":"# Python 3 Program to find length of the  \n# Longest Common Increasing Subsequence (LCIS) \n  \n# Returns the length and the LCIS of two \n# arrays arr1[0..n-1] and arr2[0..m-1] \ndef LCIS(arr1, n, arr2, m): \n  \n    # table[j] is going to store length of LCIS \n    # ending with arr2[j]. We initialize it as 0, \n    table = [[]] * m \n    for j in range(m): \n        table[j] = []\n  \n    # Traverse all elements of arr1[] \n    for i in range(n): \n      \n        # Initialize current length of LCIS \n#         current = 0\n        current = []\n  \n        # For each element of arr1[],  \n        # traverse all elements of arr2[]. \n        for j in range(m): \n              \n            # If both the array have same elements. \n            # Note that we don't break the loop here. \n            if (arr1[i] == arr2[j]): \n                if (len(current) + 1 > len(table[j])): \n                    temp = current[:]\n                    temp.append(arr2[j])\n                    table[j] = temp\n#                     table[j] = current + 1\n  \n            # Now seek for previous smaller common \n            # element for current element of arr1  \n            if (arr1[i] > arr2[j]):\n                if (len(table[j]) > len(current)): \n#                     current = table[j] \n                    current = table[j]\n  \n    # The maximum value in table[]  \n    # is out result \n    return max([(len(x), x) for x in table])[1]\n#     return [len(x) for x in table]\n\nL1 = [2,3,4,1,41,22,12,5,59,23]\nL2 = [3,4,2,1,2,34,41,56,63,59]\n\nprint(LCIS(L2, len(L2), L1, len(L1)))","59b79b1a":"def LongestPal(str):\n    n = len(str)\n    pali = \"\"\n    reverse = \"\"\n    palLen = 0\n    \n    for i in range(n):\n        for j in range(i+1,n+1):\n            substr = str[i:j]\n            rev = substr[::-1]\n            substrLen = len(substr)\n        \n            if rev in str:\n                if str.find(rev,j) != -1:\n                    if substrLen > palLen:\n                        palLen = substrLen\n                        pal = substr\n                        reverse = rev\n    \n    return [pal, reverse]\n\nLongestPal(\"REVERSE\")\n","3d09db41":"### PR 4 DAA\n#### Anggota\n#### Ezza Ardiala - 1606875844\n#### Muhammad Volyando Belvadra - 1606918326","fd6d5501":"3. Rancang dan analisis kompleksitas sebuah algoritma yang efisien untuk mendapatkan panjang dari \u201csubstring\u201d terpanjang yang susunan asli dan susunan kebalikannya muncul pada suatu string tanpa ada karakter yang overlap. Sebagai contoh jika diberikan string \u201cALGORITHM\u201d, maka keluaran yang dihasilkan adalah 0. Jika diberikan string \u201cRECURSION\u201d, maka keluaran yang dihasilkan adalah 1 (untuk \u201cR\u201d dan \u201cR\u201d), dan jika diberikan string \u201cRESERVE\u201d, maka keluarannya adalah 2 (untuk \u201cRE\u201d dan \u201cER\u201d, bukan 3 untuk \u201cRES\u201d dan \u201cSER\u201d).","6f4a7255":"c. Jika urutan dari n buah barang secara increasing berdasarkan berat sama dengan urutannya secara decreasing berdasarkan harga, bagaimana pendekatan yang efisien untuk permasalahan ini? Jelaskan kebenaran dan kompleksitasnya.","592f309c":"Implementasi diatas selalu menghitung subproblem yang sama secara berulang-ulang dan menyebabkan kompleksitas yang besar yaitu O(2^n). Oleh karena itu diimplementasikan dynamic programming yang menyimpan subproblem kedalam suatu array sehingga dapat mengoptimasi kompleksitas menjadi O(nW)","40daf132":"#### Jawaban\nAlgoritma tidak dapat berjalan karena bilangan riil dapat berupa bilangan yang mempunyai koma atau desimal. ini akan menyebabkan masalah pada implementasi terutama pada bagian ``K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]).`` Pada bagian ini index yang dicari bisa berupa riil. Jika bilangan riil masih ingin digunakan, harus ada suatu kompromi dimana bilangan riil tersebut akan dibulatkan.","71d77d55":"b. Jika berat barang dapat berupa bilangan riil, apakah pendekatan DP yang telah Anda buat dapat berjalan untuk kasus ini? Jika dapat, isu apa yang Anda temukan? Jika tidak, berikan penjelasan dan bagaimana ide penyelesaiannya?","451f2a71":"#### Jawaban\nStrategi: Solusi simpel yang dapat dilakukan adalah mengambil semua subset dari item yang ada dan mengkalkulasi berat total dan nilai dari subset tersebut. Dari semua subset pilih subset yang memiliki nilai lebih kecil dari W. Dari subset yang lebih kecil dari W, pilih nilai maksimum terbaik. Didapatkan implementasi algoritma sebagai berikut:","f9be52b8":"#### Jawaban\n\nStrategi dari penyelesaian LCIS pada masalah ini adalah dengan menggunakan dynamic programming. Algoritma ini akan menyimpan LCIS pada setiap indeks di arr2. Selain itu, terdapat array table[] sedemikian hingga table[j] menyimpan list of LCIS yang berakhir pada arr2[j]. Algoritma ini kemudian mengembalikan list LCIS yang memiliki panjang paling maksimal pada array table[]. Kompleksitas dari algoritma ini adalah O(nm) dengan n dan m merupakan panjang array1 dan array2 berturut-turut. ","7e6c2c24":"#### Jawaban\n\nSecara sederhana, algoritma ini mengambil substring yang ada pada string tersebut lalu membalikkan substringnya. Setelah dibalikkan, akan dicari reverse substring tersebut pada sisa string yang ada. Jika ditemukan, maka hasil akan disimpan. Kompleksitas dari algoritma ini adalah $O(n^2)$. ","b26ae625":"1. Knapsack 0-1 adalah sebuah permasalahan pengambilan \ud835\udc5a buah barang dari \ud835\udc5b buah barang untuk dimasukkan ke dalam sebuah kantong dengan kapasitas \ud835\udc4a sedemikian hingga total berat \ud835\udc5a buah barang tidak melebihi kapasitas kantong dan diperoleh total harga barang yang paling maksimal. Diketahui setiap barang memiliki informasi berat barang \ud835\udc4f\ud835\udc56 dan harga barang \u210e\ud835\udc56 berupa bilangan bulat tak negatif. \n\n   a. Selesaikan permasalahan ini dengan pendekatan Dynamic Programming (DP) dalam waktu \ud835\udc42(\ud835\udc5b\ud835\udc4a). Jelaskan strategi & kompleksitas penyelesaian yang Anda lakukan. ","0505d495":"2. Diberikan dua buah array X[1\u2026m] dan Y[1\u2026n] yang berisi bilangan bulat. Longest Common Increasing Subsequence (LCIS) adalah sebuah common sequence terpanjang yang setiap digitnya terurut menaik. Jika LCIS (X,Y) = Z[1\u2026k], maka berlaku Z[i] < Z[i+1] untuk setiap i = 1, 2, 3, \u2026 k-1. Rancang dan analisis kompleksitas sebuah algoritma yang efisien untuk menghitung panjang dari LCIS(X,Y). Sebagai contoh LCIS dari [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3] dan [1, 4, 1, 4, 2, 1, 3, 5, 6, 2, 3, 7, 3, 0, 9, 5] adalah[1, 4, 5, 6, 7, 9].\n","310d2c69":"#### Jawaban\nUntuk modifikasi masalah seperti ini, pendekatan menggunakan Greedy lebih menguntungkan jika dibandingkan dengan dynamic programming. Dengan pendekatan greedy, pilihan yang akan diambil adalah pilihan greedy yaitu pilihan yang mempertimbangkan profit yang paling besar. Kompleksitas waktu yang akan dihasilkan adalah O(n). "}}