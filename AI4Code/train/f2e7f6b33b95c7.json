{"cell_type":{"bdcaecf2":"code","bddeef1b":"code","eca8150e":"code","8cc056cb":"code","6a55bc47":"code","88113479":"code","022f8854":"code","fb0a2709":"code","a0f03813":"markdown","85d0000a":"markdown","6db9c8ba":"markdown","1247854d":"markdown","47d8eece":"markdown","d0061951":"markdown","a371f12f":"markdown"},"source":{"bdcaecf2":"import IPython\nIPython.display.Video('cluster-kmeans-example-blobs.mp4',embed=True,html_attributes=\"loop autoplay controls style='width: 100%'\")","bddeef1b":"import random\nimport math\nimport numpy as np\nimport pandas as pd\nfrom scipy.spatial import distance \n        \ndef fit_kmeans_iterable( X, stop=0.2, max_iter=20, k=3, verbose=True, anim=False, animFramesBefore=5, animFramesAfter=5 ):\n    \"\"\"Find kmeans clusters for the input dataset\n    \n    Parameters\n    ----------\n    X : list of points\n        array of points to find the clusters in (accept: list, numpy or pandas)\n    stop : float\n        stop processing if the clusters move less than this distance\n    max_iter : int\n        stop processing after this number of iteractions\n    k : int\n        number of clusters to find\n    verbose : bool\n        print some messages during processing\n    anim: bool : bool = False\n        return intermediary frames\n    animFramesBefore : int = 30\n        repeat first frame \n    animFramesBefore : int = 30\n        repeat last frame\n    \n    Return Values\n    -------------\n       generator object -> (centroids, centroid_x_points, centroid_x_avgdist, step)             \n    \n    \"\"\"    \n    \n    _centroids = []\n    _centroid_x_points = []\n    _centroid_x_avgdist = []\n\n    if isinstance(X, pd.DataFrame):\n        X = X.to_numpy()\n\n    X = list(X)\n        \n    _centroids = []\n    for centroid_number in range(k):\n        _centroids.append( random.sample( X, 1 )[0] )        \n    \n    if anim:\n        stop = stop\/10\n        max_iter = max_iter*10\n    \n    iter = 0\n       \n    change = stop+1\n    while True:        \n\n        # preserva os centroides antigos para permitir o c\u00e1lculo de dist\u00e2ncia\n        centroids_old = list(_centroids)\n\n        if verbose: print( f'centroid={_centroids}' )     \n        if verbose: print( f'itera\u00e7\u00e3o={iter}' )     \n\n        ##############################################################\n        # PARTE 1:\n        # Associa os pontos aos centroides e calcula a dist\u00e2ncia m\u00e9dia\n        ##############################################################\n\n        # inicializa vari\u00e1veis \n        _centroid_x_points = []\n        _centroid_x_avgdist = []\n        for centroid_number in range(k):\n            _centroid_x_points.append([])\n            _centroid_x_avgdist.append(0)\n\n        for x in X:                \n\n            # calcula a dist\u00e2ncia para do ponto x para cada centroide\n            distances = []            \n            for centroid in _centroids:           \n                distances.append( distance.euclidean( centroid, x ) )\n                           # a dist\u00e2ncia euclideana \u00e9 basicamente pit\u00e1goras \n                           # (quadrado da hipotenusa = soma dos quadadros dos catetos)\n                           # leia-se: sqtr((x1 - x2)^2 + (y1 - y2)^2 (z1 - z2)^2 (...))\n\n            # associa o ponto ao centroide mais pr\u00f3ximo\n            centroid_number = np.argmin( distances )\n            _centroid_x_points[ centroid_number ].append( x )  \n\n            # totaliza as dist\u00e2ncias do ponto x ao centroid\n            _centroid_x_avgdist[ centroid_number ] = _centroid_x_avgdist[ centroid_number ] + distances[ centroid_number ]\n\n        # c\u00e1lculo da dist\u00e2ncia m\u00e9dia\n        for centroid_number in range(k):\n            if len(  _centroid_x_points[ centroid_number ] ) == 0:\n                _centroid_x_avgdist[ centroid_number ] = math.nan\n            else:\n                _centroid_x_avgdist[ centroid_number ] = _centroid_x_avgdist[ centroid_number ] \/ len( _centroid_x_points[ centroid_number ] )\n\n        if anim:                \n            yield ( _centroids, _centroid_x_points, _centroid_x_avgdist, iter )\n\n        ##############################\n        # PARTE 2 \n        # Condi\u00e7\u00f5es de Sa\u00edda\n        ##############################\n\n        # Na itera\u00e7\u00e3o anterior nenhum centroid se moveu mais que a dist\u00e2ncia stop \n        if change < stop:\n            yield ( _centroids, _centroid_x_points, _centroid_x_avgdist, iter )\n            break\n            \n        # N\u00e3o foi alcan\u00e7ado o limite m\u00e1ximo de itera\u00e7\u00f5es\n        if( iter > max_iter ):\n            yield ( _centroids, _centroid_x_points, _centroid_x_avgdist, iter )\n            break\n\n        ######################################################\n        # PARTE 3 \n        # Move o centroide para o centro dos pontos associados\n        ######################################################\n        iter = iter + 1\n        change = 0.0                \n        # para cada centroid calcula a nova posi\u00e7\u00e3o \n        for centroid_number in range(k):            \n            points = _centroid_x_points[ centroid_number ]\n\n            if len(points) > 0:\n                new_center = np.average( points, axis=0 )\n            else:\n                new_center = random.sample( X, 1 )[0]\n        \n            if anim:\n                new_center = np.average( [ new_center, _centroids[ centroid_number ] ], axis=0, weights=[0.1,0.9] )\n            \n            \n                \n            if verbose: print( f' n={centroid_number} points={len(points)} c={new_center}' )\n                \n            _centroids[ centroid_number ] = new_center\n\n            change = max( \n                distance.euclidean( \n                    _centroids[centroid_number], \n                    centroids_old[centroid_number]\n                ), \n                change \n            )\n\ndef fit_kmeans( X, stop=0.2, max_iter=20, k=3, verbose=True, anim=False, animFramesBefore=30, animFramesAfter=30 ):\n    \"\"\"Find kmeans clusters for the input dataset\n    \n    Parameters\n    ----------\n    X : list of points\n        array of points to find the clusters in (accept: list, numpy or pandas)\n    stop : float\n        stop processing if the clusters move less than this distance\n    max_iter : int\n        stop processing after this number of iteractions\n    k : int\n        number of clusters to find\n    verbose : bool\n        print some messages during processing\n    anim: bool : bool = False\n        return intermediary frames\n    animFramesBefore : int = 30\n        repeat first frame \n    animFramesBefore : int = 30\n        repeat last frame\n    \n    Return Values\n    -------------\n       generator object -> (centroids, centroid_x_points, centroid_x_avgdist, step)             \n    \n    \"\"\"\n    \n    if anim:\n        return list( fit_kmeans_iterable(X, stop, max_iter, k, verbose, True, animFramesBefore, animFramesAfter ) )\n    else:\n        return next( fit_kmeans_iterable(X, stop, max_iter, k, verbose, False, animFramesBefore, animFramesAfter ) )\n    \n   ","eca8150e":"help(fit_kmeans)","8cc056cb":"def bloco():\n    \n    %matplotlib inline\n    import random\n    from sklearn import datasets;\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import FuncAnimation\n    import IPython\n    \n    random.seed(13)\n    \n    X, yTrue = datasets.make_blobs(\n        n_samples=1000,\n        centers=[ [random.uniform(0,32), random.uniform(0,15) ] for i in range(7)], \n        n_features=2,\n        random_state=5\n    )        \n  \n    random.seed(16)\n  \n    fig = plt.figure(\n        figsize=(12,5),\n        dpi=100,\n        frameon=True\n    ) \n\n    def anim_init():\n        print('init')\n\n    def anim_update( data ):     \n        centroids, centroid_x_points, centroid_x_avgdist, step = data \n        print(step, end=';')\n        \n        hsv = plt.cm.get_cmap('hsv', len(centroid_x_points)+1)\n        \n        plt.clf()\n        plt.title( f\"Teste do KMeans com makeblobs (step={step\/10})\")      \n        #plt.xticks(())\n        #plt.yticks(())\n        #plt.box(False)\n\n        ax = fig.subplots()\n        #ax.set_axis_off()\n        plt.subplots_adjust(left=-0.001, right=1.001, top=0.9, bottom=-0.005)\n        #fig.patch.set_visible(False)\n        #ax.patch.set_visible(False)\n        #ax.get_xaxis().set_ticks([])\n        #ax.get_yaxis().set_ticks([])\n        #ax.set_xlabel('random y (makeblobs)')\n        #ax.set_ylabel('random y (makeblobs)')\n        ax.set_xlim([0,32])\n        ax.set_ylim([0,15])\n\n        res = []\n\n        ax.scatter(                        \n                [ X[j][0] for j in range(len(X)) ],\n                [ X[j][1] for j in range(len(X)) ],\n                color='#c0c0c0',\n                marker='.',\n                s=4,\n                label=f'Sem cluster'\n            )\n        \n        for cluster_id in range(0,len(centroid_x_points)):\n            \n            ax.scatter(                        \n                [ centroid_x_points[cluster_id][j][0] for j in range(len(centroid_x_points[cluster_id])) ],\n                [ centroid_x_points[cluster_id][j][1] for j in range(len(centroid_x_points[cluster_id])) ],\n                color=hsv(cluster_id),\n                marker='o',\n                s=16,\n                label=f'Cluster {cluster_id}'\n            )\n            \n            ax.add_patch( plt.Circle((centroids[cluster_id][0],centroids[cluster_id][1]), fill=False, radius=centroid_x_avgdist[cluster_id], color=hsv(cluster_id) ) )\n            \n            ax.scatter(                        \n                [ centroids[cluster_id][0] ],\n                [ centroids[cluster_id][1] ],\n                color='#000000',\n                marker='o',\n                s=32\n            )\n            \n            \n        ax.legend()\n\n    anim = FuncAnimation(\n        fig=fig,\n        func=anim_update,\n        frames=fit_kmeans_iterable(X,k=7,animFramesAfter=30,animFramesBefore=3,anim=True,verbose=False),\n        save_count=140,\n        interval=500,\n        blit=False\n    )\n    video = anim.save('cluster-kmeans-example-blobs.mp4')\n    #video = anim.to_html5_video()\n    #return IPython.display.HTML(video)\n    #IPython.display.clear_output(wait=True)       \n    #IPython.display.display(html)\n\n    plt.close() \n    \n    #IPython.display.clear_output(wait=True)       \n    \nbloco()","6a55bc47":"def bloco():\n    \n    global df\n    \n    from datetime import datetime\n    import pandas as pd\n    import os\n    pd.options.display.max_columns = None\n        \n    if os.path.isfile('\/kaggle\/input\/us-counties-covid-19-dataset\/us-counties.csv'):\n        file = '\/kaggle\/input\/us-counties-covid-19-dataset\/us-counties.csv'\n    elif os.path.isfile( 'dataset-covid19\/us-counties-covid-19-dataset.csv' ):\n        file = 'dataset-covid19\/us-counties-covid-19-dataset.csv'\n    else:\n        raise Exception('Por favor, inclua o arquivo de dados em dataset-covid19\/us-counties-covid-19-dataset.csv')\n        \n    df = pd.read_csv( file,\n             #nrows=1000 \n        )\n\n    df.insert( 1, \"wday\", df['date'].apply( lambda x: int(datetime.strptime(x,'%Y-%m-%d').strftime('%w')) ) )\n    df.insert( 1, \"mday\", df['date'].apply( lambda x: int(datetime.strptime(x,'%Y-%m-%d').strftime('%d')) ) )\n   \n    df = df.dropna()   \n    df = df.sample( 1500 )\n    \n    return df\n    \nbloco()","88113479":"def bloco():\n    \n    %matplotlib inline\n    from sklearn import datasets;\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import FuncAnimation\n    import IPython\n    \n    \n    X = df[ ['cases', 'deaths' ] ].to_numpy()\n  \n    random.seed(16)\n  \n    fig = plt.figure(\n        figsize=(12,5),\n        dpi=100,\n        frameon=True\n    ) \n\n    centroids, centroid_x_points, centroid_x_avgdist, step = fit_kmeans(\n        X,k=3,animFramesAfter=30,animFramesBefore=3,anim=False,verbose=False\n    )\n    \n\n    hsv = plt.cm.get_cmap('hsv', len(centroid_x_points)+1)\n\n    plt.clf()\n    plt.title( f\"Casos x Mortes Covid19\")      \n    plt.xticks(())\n    plt.yticks(())\n    #plt.box(False)\n\n    ax = fig.subplots()\n    #ax.set_axis_off()\n    #plt.subplots_adjust(left=-0.001, right=1.001, top=0.9, bottom=-0.005)\n    #fig.patch.set_visible(False)\n    #ax.patch.set_visible(False)\n    #ax.get_xaxis().set_ticks([])\n    #ax.get_yaxis().set_ticks([])\n    ax.set_xlabel('casos')\n    ax.set_ylabel('mortes')\n    #ax.set_xlim([0,22000])\n    ax.set_ylim([0,10000])\n    #plt.yscale('log')\n    #plt.xscale('log') \n\n    res = []\n\n    ax.scatter(                        \n            [ X[j][0] for j in range(len(X)) ],\n            [ X[j][1] for j in range(len(X)) ],\n            color='#c0c0c0',\n            marker='.',\n            s=4,\n            label=f'Sem cluster'\n        )\n\n    for cluster_id in range(0,len(centroid_x_points)):\n\n        ax.scatter(                        \n            [ centroid_x_points[cluster_id][j][0] for j in range(len(centroid_x_points[cluster_id])) ],\n            [ centroid_x_points[cluster_id][j][1] for j in range(len(centroid_x_points[cluster_id])) ],\n            color=hsv(cluster_id),\n            marker='o',\n            s=16,\n            label=f'Cluster {cluster_id}'\n        )\n\n        ax.add_patch( plt.Circle((centroids[cluster_id][0],centroids[cluster_id][1]), fill=False, radius=centroid_x_avgdist[cluster_id], color=hsv(cluster_id) ) )\n\n        ax.scatter(                        \n            [ centroids[cluster_id][0] ],\n            [ centroids[cluster_id][1] ],\n            color='#000000',\n            marker='o',\n            s=32\n        )\n\n\n    ax.legend()\n    \n    plt.show()\n    \n    \nbloco()","022f8854":"#","fb0a2709":"import os\nos.remove(\"tmp.gif\")","a0f03813":"## 2. O Algoritmo\n\nA classe abaixo cont\u00e9m uma implementa\u00e7\u00e3o comentada do algoritmo que, em resumo faz:\n* Mapeia as colunas do dataset de entrada como eixos de um espa\u00e7o n-dimensional.\n* Define \"k\" centroides, inicialmente retirando com a coordenada de pontos sorteados aleat\u00f3riamente;\n* Refina os centroids:\n * Associa todos os pontos ao centroide mais pr\u00f3ximo usando dist\u00e2ncia euclidiana;\n * Recaulcula a posi\u00e7\u00e3o do centroid como a m\u00e9dia das posi\u00e7\u00f5es dos pontos associados;\n* Executa este refinamento at\u00e9 que:\n  * Nenhum centroid tenha se movido mais que a dist\u00e2ncia \"stop\" \n  * N\u00e3o tenha sido alcan\u00e7ado o limite m\u00e1ximo de execu\u00e7\u00f5es \"max_iter\"\n\nExiste uma exce\u00e7\u00e3o quando os dois ou mais centroides acabam muito pr\u00f3ximos. Neste caso pode acontecer de nenhum ponto ser associado ao centroide. Neste caso um ponto aleat\u00f3rio ser\u00e1 sorteado novamente para subsitiu\u00ed-lo. ","85d0000a":"# 4. O exemplo com a base de casos x mortes por covid19 nos munic\u00edpios americanos\n\n## 4.1. Importa\u00e7\u00e3o dos dados \n\nOs dados usados usados nesta demonstra\u00e7\u00e3o s\u00e3o de casos e mortes por covid19 por munic\u00edpio dos Estados Unidos. ","6db9c8ba":"## 4.2. Modelo\nNo exemplo abaixo, procuramos agrupamentos entre casos e mortes.\n\nA anima\u00e7\u00e3o abaixo ilustra como os pontos v\u00e3o se reposicionando. Em cada itera\u00e7\u00e3o o modelo encontra os pontos mais pr\u00f3ximos do centroide e reposiciona o centroide no centro dos pontos selecionados. Isto faz o modelo espalhar os pontos.\n","1247854d":"# 3.1 Testes do Algoritmo\n\nEste bloco gera a anima\u00e7\u00e3o do in\u00edcio do notebook","47d8eece":"## 5 Considera\u00e7\u00f5es Finais\n\nEsquecendo por um minuto como o Kmeans funciona, ampliando a regiao azul e vemelha, o que eu vejo s\u00e3o poss\u00edveis agrupamentos com significados em linhas. Existem tr\u00eas grandes tent\u00e2culos. Estes tent\u00e1culos me parecem muito mais significativos para comparar munic\u00edpios que tem \u00edndices de mortes menores e podem ser encontradas caracter\u00edstiacas no mundo real que expliquem isto. Melhores hospitais? Diferen\u00e7as Culturais? Testagem mais ampla que aumenta o denominador? Cidades mais afastadas que demoram a receber as novas variantes, portanto se beneficiam das demais?\n\nMas o algoritmo KMeans n\u00e3o tem condi\u00e7\u00f5es de detectar isto pois forma c\u00edrculos. Da forma que est\u00e1, o K-Means detectou zonas mais ou menos baseadas na quantidade de casos. Aumentando o \"k\" identificamos apenas mais zonas desta mesma forma, subdividindo mais o gr\u00e1fico.","d0061951":"# O Algoritmo KMeans","a371f12f":"## 1. Introdu\u00e7\u00e3o\n\nEsta \u00e9 uma implementa\u00e7\u00e3o do algoritmo KMeans usada para ilustrar seu funcionamento interno.\n\nNeste exemplo, apenas temos a inten\u00e7\u00e3o de explicar o algoritmo. Para uso em produ\u00e7\u00e3o, sugerimos usar uma implementa\u00e7\u00e3o mais madura como o [sklearn.cluster.KMeans][1].\n\nO artigo [Wikipedia KMeans article][2] tem uma boa explica\u00e7\u00e3o da matem\u00e1tica do algoritmo KMeans, bem como varia\u00e7\u00f5es e refer\u00eancias para maiores detalhes. \n\n\n  [1]: https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.cluster.KMeans.html\n  [2]: https:\/\/en.wikipedia.org\/wiki\/K-means_clustering"}}