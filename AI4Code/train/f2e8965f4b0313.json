{"cell_type":{"843540a6":"code","6b24158a":"code","5c95bb53":"code","a093efa9":"code","c1e74315":"code","4c9be810":"code","ec0c1cff":"code","c14bb5b1":"code","04f33e7c":"code","145ee55d":"code","cf8a0d10":"code","d78bce34":"code","9c211c7d":"code","eecd6526":"code","d75065f4":"code","359fdd36":"code","f3a70ff7":"code","b1a48c96":"code","04ac3445":"code","4219b646":"code","aa3d27ec":"code","ecdcda37":"code","b6ab477b":"code","ce61e127":"markdown","a4f5b52a":"markdown","a78a1ba7":"markdown","3fa23138":"markdown","e044249a":"markdown","b9765d35":"markdown","5640c028":"markdown","c2d1685e":"markdown","a3a710d6":"markdown","a57bf235":"markdown","be39ac4b":"markdown","b320952a":"markdown","027d51f9":"markdown","5000beed":"markdown","75c3811a":"markdown"},"source":{"843540a6":"# a few of the images error out duing reading this must be installed to parse all the dicom files\n!pip install python-gdcm","6b24158a":"%matplotlib inline\nfrom fastai.basics import *\nfrom fastai.vision.all import *\nfrom fastai.data.transforms import *\nfrom fastai.medical.imaging import *\n# import pydicom,kornia,skimage\nfrom tqdm.auto import tqdm\n\ntry:\n    import cv2\n    cv2.setNumThreads(0)\nexcept: pass\nfrom pydicom.dataset import FileDataset\n\nfrom matplotlib import patches, patheffects\nfrom itertools import chain\n\nDATA_ROOT = Path(\"..\/input\/siim-covid19-detection\/\")","5c95bb53":"dicom_files = get_dicom_files(DATA_ROOT \/ \"train\")\nprint(f\"There are {len(dicom_files)} images in the all of subdirectories.\")\n","a093efa9":"dicom_files = dicom_files[:50]","c1e74315":"# Convert DICOM to PNG via openCV\nfrom concurrent.futures import ThreadPoolExecutor, as_completed, ProcessPoolExecutor\nfrom skimage import exposure\nimport cv2\nimport os\n\ntry:\n    os.mkdir(\".\/train_png\")\nexcept Exception:\n    print(\"already exists\")\n\ndef process_img(img_file):\n    img_id = str(img_file).split(\"\/\")[-1].split(\".\")[0]\n    dimg = img_file.dcmread()\n    \n    img = dimg.pixel_array\n    # Convert the data so that the bones are white in all the images\n    # https:\/\/www.kaggle.com\/raddar\/convert-dicom-to-np-array-the-correct-way\n    # from comment by @raddar\n    if dimg.PhotometricInterpretation == \"MONOCHROME1\":\n        img = np.amax(img) - img\n    img = exposure.equalize_adapthist(img, clip_limit=0.03) # optimize the contrast\n    # resize image\n    resized = cv2.resize(img*255, (1024, 1024), interpolation = cv2.INTER_LANCZOS4)\n    cv2.imwrite(f\".\/train_png\/{img_id}.png\", resized)\n    return img_id, dimg.pixel_array.shape\n\nimage_sizes = dict()\n# for img_file in tqdm(dicom_files):\n#     img_id, img_shape = process_img(img_file)\n#     image_sizes[img_id] = img_shape\nwith ThreadPoolExecutor(max_workers=4) as ex:\n    results = [ex.submit(process_img, img_file) for img_file in dicom_files]\n    for f in tqdm(as_completed(results), total=len(dicom_files)):\n        img_id, img_shape = f.result()\n        image_sizes[img_id] = img_shape","4c9be810":"train_image_level = pd.read_csv(DATA_ROOT \/ \"train_image_level.csv\")\ntrain_study_level = pd.read_csv(DATA_ROOT \/ \"train_study_level.csv\", index_col='id')","ec0c1cff":"print(len(train_study_level))\ntrain_image_level.head(2)","c14bb5b1":"print(len(train_study_level))\ntrain_study_level.head(2)","04f33e7c":"# setting it to the index makes the id disappear after merge\ntrain_study_level['StudyInstanceUID'] = train_study_level.apply(lambda x : x.name.split('_')[0], axis = 1)\ntrain_study_level['study_outcome'] = train_study_level[['Negative for Pneumonia', 'Typical Appearance',\n       'Indeterminate Appearance', 'Atypical Appearance']].idxmax(axis=1)\n\ndf_train = pd.merge(train_image_level,train_study_level[[\"study_outcome\", \"StudyInstanceUID\"]],how='left',on='StudyInstanceUID')\n# merging idea from https:\/\/www.kaggle.com\/southsakura\/covid19\ndf_train['image_id'] = df_train.id.apply(lambda x: x.split('_')[0]) # remove the suffix\n# df_train.set_index('id', inplace=True)\n\n# evaluate the boxes into a normal dict if possible, else convert it to 0 0 1 1 as just like in label\ndf_train['boxes'] = df_train['boxes'].map(lambda x: eval(x) if isinstance(x, str) else eval(\"[{'x': 0, 'y': 0, 'width': 1, 'height': 1}]\"))\n\ndf_train.head(5)\n","145ee55d":"df_train = df_train[df_train.image_id.apply(lambda x: x in image_sizes)]","cf8a0d10":"df_boxes = df_train.explode('boxes') # explode is a one-to-many mapping of iterable data\n\n# apply(pd.Series) parses the dictionary in one column into multiple columns \n# https:\/\/stackoverflow.com\/questions\/38231591\/split-explode-a-column-of-dictionaries-into-separate-columns-with-pandas \ndf_boxes = pd.concat([df_boxes.drop(['boxes'], axis=1), df_boxes['boxes'].apply(pd.Series)], axis=1) \n\ndf_boxes.head(10)","d78bce34":"df_boxes['x_min'] =  df_boxes.x\ndf_boxes['y_min'] =  df_boxes.y\ndf_boxes['x_max'] =  df_boxes.x + df_boxes.width\ndf_boxes['y_max'] =  df_boxes.y + df_boxes.height\n","9c211c7d":"df_boxes['tp_x'] = df_boxes.image_id.apply(lambda x: image_sizes[x][1])\ndf_boxes['tp_y'] = df_boxes.image_id.apply(lambda x: image_sizes[x][0])\nfor k in ['x_min', 'x_max']:\n    df_boxes[k+\"_norm\"] = df_boxes[k] \/ df_boxes.tp_x\nfor k in ['y_min', 'y_max']:\n    df_boxes[k+\"_norm\"] = df_boxes[k] \/ df_boxes.tp_y","eecd6526":"df_boxes.to_csv('.\/train_boxes.csv')","d75065f4":"# check for one-hot encoding\nfor j,row in train_study_level.iterrows():\n    obs = row[['Negative for Pneumonia',\n       'Typical Appearance', 'Indeterminate Appearance',\n       'Atypical Appearance']]\n    assert sum(obs.values) == 1","359fdd36":"# the information in \"boxes\" and \"label\" agree\nfor _, row in df_train.iterrows():\n    if isinstance(row.boxes, str):\n        boxes = json.loads(row.boxes.replace(\"\\'\", \"\\\"\"))\n        labels = row.label.split('opacity')\n        labels = [*filter(lambda x: x!=\"\", labels)]\n        labels = [*map(lambda x: x.lstrip().rstrip(), labels)]\n        assert len(boxes) == len(labels)\n        for b, l in zip(boxes, labels):\n            assert l.split()[0] == \"1\"\n            assert abs(float(l.split()[3]) - (b['x'] + b['width']))<0.1\n            assert abs(float(l.split()[4]) - (b['y'] + b['height']))<0.1\n","f3a70ff7":"df_boxes[df_boxes.study_outcome==\"Atypical Appearance\"]","b1a48c96":"# A simple lookup table to find the dicom files using the ids\nid_to_dicom = dict()\nfor k in dicom_files:\n    img_id = str(k).split(\"\/\")[-1].split(\".\")[0]\n    id_to_dicom[img_id] = k","04ac3445":"# drawing helper functions inspired by the fastai tutorials\ndef bb_hw(a):\n    return np.array([a[1], a[0], a[3] - a[1], a[2] - a[0]])\n\ndef draw_outline(o, lw=1):\n    o.set_path_effects(\n        [patheffects.Stroke(linewidth=lw, foreground=\"black\"), patheffects.Normal()]\n    )\n\ndef draw_rect(ax, b: list):\n    patch = ax.add_patch(\n        patches.Rectangle(b[:2], *b[-2:], fill=False, edgecolor=\"white\", lw=2)\n    )\n    draw_outline(patch, 4)\n\n\ndef draw_text(ax, xy: list, txt: str, sz=14):\n    text = ax.text(*xy, txt, va=\"top\", color=\"white\", fontsize=sz, weight=\"bold\")\n    draw_outline(text)\n\n\ndef get_boxes_scale(ax, df, image_id, px_x=1024, px_y=1024):\n    \"\"\"\n    look for image_id in a df and add all of the boxes to the plot on ax\n    \"\"\"\n    \n    for _, row in df[df.image_id == image_id].iterrows():\n        if row.x == 0 and row.y == 0:\n            continue\n        x,y = row.x_min_norm * px_x, row.y_min_norm * px_y\n        w,h = (row.x_max_norm - row.x_min_norm) * px_x, (row.y_max_norm - row.y_min_norm) * px_y\n        \n        patch = ax.add_patch(\n            patches.Rectangle((x,y), w, h, fill=False, edgecolor=\"white\", lw=2)\n        )\n        draw_outline(patch, 2)\n        draw_text(\n            ax, (x, y), row[\"study_outcome\"].split()[0]\n        )\n\ndef get_boxes_orig(ax, df, image_id):\n    \"\"\"\n    look for image_id in a df and add all of the boxes to the plot on ax\n    \"\"\"\n    for _, row in df[df.image_id == image_id].iterrows():\n        if row.x == 0 and row.y == 0:\n            continue\n    \n        patch = ax.add_patch(\n            patches.Rectangle((row.x, row.y), row.width, row.height, fill=False, edgecolor=\"white\", lw=2)\n        )\n        draw_outline(patch, 2)\n        draw_text(\n            ax, (row.x, row.y), row[\"study_outcome\"].split()[0]\n        )\n\n\ndef show_dicom(dimg: FileDataset, figsize=None, ax=None):\n    \"\"\"read the dicom data then \"\"\"\n    im = dimg.pixel_array\n    if not ax:\n        fig, ax = plt.subplots(figsize=figsize)\n    ax.imshow(im, cmap='gray')\n    ax.set_axis_off()\n    ax.set_title(\"Original\")\n    get_boxes_orig(ax, df_boxes, dimg.SOPInstanceUID)\n    \n\ndef show_png(img_id, figsize=None, ax=None):\n    im = cv2.imread(f\".\/train_png\/{img_id}.png\")\n    if not ax:\n        fig, ax = plt.subplots(figsize=figsize)\n    ax.imshow(im, cmap='gray')\n    ax.set_axis_off()\n    ax.set_title(\"Processed\")\n    get_boxes_scale(ax, df_boxes, img_id)\n        \ndef show_img_by_id(img_id: str, **kwargs):\n    img = id_to_dicom[img_id]\n    dimg = img.dcmread()\n    fig, (ax1, ax2) = plt.subplots(1,2, figsize=(12,6))\n    show_dicom(dimg, ax=ax1)\n    show_png(dimg.SOPInstanceUID, ax=ax2)\n    fig.suptitle(img_id)","4219b646":"for iid in np.unique(df_boxes[df_boxes.study_outcome==\"Typical Appearance\"].image_id.values)[:10]:\n    show_img_by_id(iid)","aa3d27ec":"df_train[df_train.StudyInstanceUID == \"79c3bf957d49\"]","ecdcda37":"for iid in np.unique(df_boxes[df_boxes.study_outcome==\"Indeterminate Appearance\"].image_id.values)[:10]:\n    show_img_by_id(iid)","b6ab477b":"for iid in np.unique(df_boxes[df_boxes.study_outcome==\"Negative for Pneumonia\"].image_id.values)[:10]:\n    show_img_by_id(iid)","ce61e127":"For this example notebook we will filter for the images where the size has been measured.","a4f5b52a":"## Paranoia checks","a78a1ba7":"# Plotting and investigation of the images\n\nAfter the images have been processed it becomes a bit easier to look at them carefully.\n\nWe will plot both the original and scaled + enhanced image to see exactly what we are looking for.","3fa23138":"## Multiple images from studies\nNote that for the two images `4cbc17936e7d` and `582c442e440b`  with no boxes, they belong to a study `79c3bf957d49` which has boxes in another image.\n\nSo during training it will probably make sense to drop such images from the data set.","e044249a":"# Preprocessing\n\nA challenge for me at the start of this challenge Additionally the original image and csv files are a both bit hard to work with.\nThe goal of this notebook is to parse the input data into a format that is easier for the variouse object detection apis.\n\nAdditionally, I think it's always a good idea to have a look at the image to see if a non-radiologist can pick out some patterns in the boxed areas.\nAt the contrast levels for the original dicome images, this was very difficult for me to do personally.\nSo I used `skimage`'s `exposure` module to change the contrast level of the input images.  I also converted all of these image into PNG files so it is easier to look at hundreds of them in a browser.\n\n\nThis notebook will primarily show a few things:\n1. How the image can be rescaled and how the contrast level can be adjusted to maximum visibility of the data. (note that we rescale instead of cropped since we are doing object detection and the bounding boxes can often sit near the edges of the image)\n2. The study-level and image-level dataframes can be combined with the image size information to arrive at a master dataframe that is a bit more verbose but much easier to work with.\n\nThis notebook will show how we arrive at the data transformations, but we will only do this for 50 images in the set since these transformations are pretty expensive, the full result of these transformations will be uploaded as a different dataset.\n\nThe processed PNG files will be saved in `train_png` and a new dataframe where each row is a specific bonding box (so the same image can have multiple rows) is saved in `train_boxes.csv`.\n\nUsing the processed PNG files we will look at the images and see if we can figure out any patterns.\n\nThe dataset containing the parsed training and test images are shown here:\nhttps:\/\/www.kaggle.com\/jmmshn\/siim-covid19-png1024  (need to rerun for the monochrome fix)\n\nUpdates:\nThe data must be converted so that high and low values mean the same thing across different images. \nThanks to comment by @radar.\n\n```\n    if dimg.PhotometricInterpretation == \"MONOCHROME1\":\n        img = np.amax(img) - img\n```\nDetailed explanation can be found here:\nhttps:\/\/www.kaggle.com\/raddar\/convert-dicom-to-np-array-the-correct-way\n","b9765d35":"From these images, I think we are mostly looking for anything that obstructs our view of the bronchioles.","5640c028":"### Reading the image sizes\n\nWe will need the shape of the images returned int (n_rows, n_cols) for the pixel data.\n\n\nThe normal method, commented out below, took around 20 mins on the kaggle cloud.\n\nThe multi-process method finished in around 9 mins.","c2d1685e":"The CSV files can be parsed into pandas, note the the `id` fields in both have suffixes indicating whether it is a study id or a image id.","a3a710d6":"We can first convert the data to list of dictionaries and then `explode` that list to get one row for each box in our dataset.","a57bf235":"Reading the dicom files can be done easily with the `fastai` API.\nThe `get_dicom_files` function returns a list-like object that will go through all the images in a folder recursively","be39ac4b":"These dataframes can be combined based on the `StudyInstanceUID` value which is just the study id with the extra suffix.\n\nThe data in `boxes` are in string format, and should be converted into (x_min, y_min, x_max, y_max) format and turned into a new row for each box.\nNote that for `boxes == NaN` we will convert to `0 0 1 1` just like in `label`.","b320952a":"### Save the dataframe to a csv file","027d51f9":"### Save the image sizes of each image into the dataframe\n\n","5000beed":"The following error message occured around the 4000 block of data\n```\n\/opt\/conda\/lib\/python3.7\/site-packages\/pydicom\/pixel_data_handlers\/numpy_handler.py:341: UserWarning: The length of the pixel data in the dataset (13262360 bytes) indicates it contains excess padding. 216296 bytes will be removed from the end of the data\n  warnings.warn(msg)\n```","75c3811a":"In this notebook, we will only use the first 100 files but the full set of data will be parsed and uploaded.\n"}}