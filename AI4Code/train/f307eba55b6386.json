{"cell_type":{"70618c2a":"code","7b472865":"code","4a059e42":"code","5a6b2d77":"code","2e6f104a":"code","404466ce":"code","55f7bf71":"code","ac3f5f9f":"code","0e83eede":"code","3ce1344d":"code","5cb75da1":"code","5833822f":"code","54dbf672":"code","02e899fb":"code","82393243":"code","f36dd8b7":"code","66205bc2":"code","37de3cc7":"code","c1dd0ddf":"code","4be15947":"code","77bd4a4e":"code","d1437518":"markdown","496b2042":"markdown","240b5d4f":"markdown","394efea6":"markdown","3da9f88f":"markdown","ad4c4c2c":"markdown","a25d03a9":"markdown","c6385caa":"markdown","3d0fd6d2":"markdown"},"source":{"70618c2a":"import numpy as np\nimport pickle\nimport cv2\nfrom os import listdir\nfrom sklearn.preprocessing import LabelBinarizer\nfrom keras.models import Sequential\nfrom keras.layers.normalization import BatchNormalization\nfrom keras.layers.convolutional import Conv2D\nfrom keras.layers.convolutional import MaxPooling2D\nfrom keras.layers.core import Activation, Flatten, Dropout, Dense\nfrom keras import backend as K\nfrom keras.preprocessing.image import ImageDataGenerator\nfrom keras.optimizers import Adam\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import img_to_array\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.model_selection import train_test_split\nimport matplotlib.pyplot as plt","7b472865":"EPOCHS = 25\nINIT_LR = 1e-3\nBS = 32\ndefault_image_size = tuple((256, 256))\nimage_size = 0\ndirectory_root = '..\/input\/plantvillage\/'\nwidth=256\nheight=256\ndepth=3","4a059e42":"def convert_image_to_array(image_dir):\n    try:\n        image = cv2.imread(image_dir)\n        if image is not None :\n            image = cv2.resize(image, default_image_size)   \n            return img_to_array(image)\n        else :\n            return np.array([])\n    except Exception as e:\n        print(f\"Error : {e}\")\n        return None","5a6b2d77":"image_list, label_list = [], []\ntry:\n    print(\"[INFO] Loading images ...\")\n    root_dir = listdir(directory_root)\n    for directory in root_dir :\n        # remove .DS_Store from list\n        if directory == \".DS_Store\" :\n            root_dir.remove(directory)\n\n    for plant_folder in root_dir :\n        plant_disease_folder_list = listdir(f\"{directory_root}\/{plant_folder}\")\n        \n        for disease_folder in plant_disease_folder_list :\n            # remove .DS_Store from list\n            if disease_folder == \".DS_Store\" :\n                plant_disease_folder_list.remove(disease_folder)\n\n        for plant_disease_folder in plant_disease_folder_list:\n            print(f\"[INFO] Processing {plant_disease_folder} ...\")\n            plant_disease_image_list = listdir(f\"{directory_root}\/{plant_folder}\/{plant_disease_folder}\/\")\n                \n            for single_plant_disease_image in plant_disease_image_list :\n                if single_plant_disease_image == \".DS_Store\" :\n                    plant_disease_image_list.remove(single_plant_disease_image)\n\n            for image in plant_disease_image_list[:250]:\n                image_directory = f\"{directory_root}\/{plant_folder}\/{plant_disease_folder}\/{image}\"\n                if image_directory.endswith(\".jpg\") == True or image_directory.endswith(\".JPG\") == True:\n                    image_list.append(convert_image_to_array(image_directory))\n                    label_list.append(plant_disease_folder)\n    print(\"[INFO] Image loading completed\")  \nexcept Exception as e:\n    print(f\"Error : {e}\")","2e6f104a":"image_size = len(image_list)\nimage_size","404466ce":"label_binarizer = LabelBinarizer()\nimage_labels = label_binarizer.fit_transform(label_list)\npickle.dump(label_binarizer,open('label_transform.pkl', 'wb'))\nn_classes = len(label_binarizer.classes_)","55f7bf71":"print(label_binarizer.classes_)","ac3f5f9f":"np_image_list = np.array(image_list, dtype=np.float16) \/ 225.0","0e83eede":"print(\"[INFO] Spliting data to train, test\")\nx_train, x_test, y_train, y_test = train_test_split(np_image_list, image_labels, test_size=0.2, random_state = 42) ","3ce1344d":"aug = ImageDataGenerator(\n    rotation_range=25, width_shift_range=0.1,\n    height_shift_range=0.1, shear_range=0.2, \n    zoom_range=0.2,horizontal_flip=True, \n    fill_mode=\"nearest\")","5cb75da1":"from __future__ import print_function\nimport keras\nfrom keras.models import Sequential\nfrom keras import layers\nfrom keras.datasets import mnist\nfrom keras import backend as K\n","5833822f":"from keras.layers import GlobalAveragePooling2D, Reshape, Dense, multiply, Permute\nfrom keras import backend as K\n\n\ndef squeeze_excite_block(input, ratio=16):\n    ''' Create a squeeze-excite block\n    Args:\n        input: input tensor\n        filters: number of output filters\n        k: width factor\n\n    Returns: a keras tensor\n    '''\n    init = input\n    channel_axis = 1 if K.image_data_format() == \"channels_first\" else -1\n    filters = init._keras_shape[channel_axis]\n    se_shape = (1, 1, filters)\n\n    se = GlobalAveragePooling2D()(init)\n    se = Reshape(se_shape)(se)\n    se = Dense(filters \/\/ ratio, activation='relu', kernel_initializer='he_normal', use_bias=False)(se)\n    se = Dense(filters, activation='sigmoid', kernel_initializer='he_normal', use_bias=False)(se)\n\n    if K.image_data_format() == 'channels_first':\n        se = Permute((3, 1, 2))(se)\n\n    x = multiply([init, se])\n    return x","54dbf672":"from keras.layers import GlobalAveragePooling2D, Reshape, Dense, multiply, Permute\nfrom keras import backend as K\n\n\ndef squeeze_excite_block(input, ratio=16):\n    ''' Create a squeeze-excite block\n    Args:\n        input: input tensor\n        filters: number of output filters\n        k: width factor\n\n    Returns: a keras tensor\n    '''\n    init = input\n    channel_axis = 1 if K.image_data_format() == \"channels_first\" else -1\n    filters = init._keras_shape[channel_axis]\n    se_shape = (1, 1, filters)\n\n    se = GlobalAveragePooling2D()(init)\n    se = Reshape(se_shape)(se)\n    se = Dense(filters \/\/ ratio, activation='relu', kernel_initializer='he_normal', use_bias=False)(se)\n    se = Dense(filters, activation='sigmoid', kernel_initializer='he_normal', use_bias=False)(se)\n\n    if K.image_data_format() == 'channels_first':\n        se = Permute((3, 1, 2))(se)\n\n    x = multiply([init, se])\n    return x","02e899fb":"class squeezeExcitation(layers.Layer):\n    WEIGHTS_PATH = ''\n    WEIGHTS_PATH_NO_TOP = ''\n\n\n    def _conv2d_bn(self,x,\n                   filters,\n                   num_row,\n                   num_col,\n                   padding='same',\n                   strides=(1, 1),\n                   name=None):\n        \"\"\"Utility function to apply conv + BN.\n        # Arguments\n            x: input tensor.\n            filters: filters in `Conv2D`.\n            num_row: height of the convolution kernel.\n            num_col: width of the convolution kernel.\n            padding: padding mode in `Conv2D`.\n            strides: strides in `Conv2D`.\n            name: name of the ops; will become `name + '_conv'`\n                for the convolution and `name + '_bn'` for the\n                batch norm layer.\n        # Returns\n            Output tensor after applying `Conv2D` and `BatchNormalization`.\n        \"\"\"\n        if name is not None:\n            bn_name = name + '_bn'\n            conv_name = name + '_conv'\n        else:\n            bn_name = None\n            conv_name = None\n        if K.image_data_format() == 'channels_first':\n            bn_axis = 1\n        else:\n            bn_axis = 3\n        x = Conv2D(\n            filters, (num_row, num_col),\n            strides=strides,\n            padding=padding,\n            use_bias=False,\n            name=conv_name)(x)\n        x = BatchNormalization(axis=bn_axis, scale=False, name=bn_name)(x)\n        x = Activation('relu', name=name)(x)\n        return x\n\n\n    def SEInceptionV3(self,include_top=True,\n                      weights=None,\n                      input_tensor=None,\n                      input_shape=None,\n                      pooling=None,\n                      classes=1000):\n        \"\"\"Instantiates the Squeeze and Excite Inception v3 architecture.\n        # Arguments\n            include_top: whether to include the fully-connected\n                layer at the top of the network.\n            weights: one of `None` (random initialization)\n                or \"imagenet\" (pre-training on ImageNet).\n            input_tensor: optional Keras tensor (i.e. output of `layers.Input()`)\n                to use as image input for the model.\n            input_shape: optional shape tuple, only to be specified\n                if `include_top` is False (otherwise the input shape\n                has to be `(299, 299, 3)` (with `channels_last` data format)\n                or `(3, 299, 299)` (with `channels_first` data format).\n                It should have exactly 3 inputs channels,\n                and width and height should be no smaller than 139.\n                E.g. `(150, 150, 3)` would be one valid value.\n            pooling: Optional pooling mode for feature extraction\n                when `include_top` is `False`.\n                - `None` means that the output of the model will be\n                    the 4D tensor output of the\n                    last convolutional layer.\n                - `avg` means that global average pooling\n                    will be applied to the output of the\n                    last convolutional layer, and thus\n                    the output of the model will be a 2D tensor.\n                - `max` means that global max pooling will\n                    be applied.\n            classes: optional number of classes to classify images\n                into, only to be specified if `include_top` is True, and\n                if no `weights` argument is specified.\n        # Returns\n            A Keras model instance.\n        # Raises\n            ValueError: in case of invalid argument for `weights`,\n                or invalid input shape.\n        \"\"\"\n        if weights not in {'imagenet', None}:\n            raise ValueError('The `weights` argument should be either '\n                             '`None` (random initialization) or `imagenet` '\n                             '(pre-training on ImageNet).')\n\n        if weights == 'imagenet' and include_top and classes != 1000:\n            raise ValueError('If using `weights` as imagenet with `include_top`'\n                             ' as true, `classes` should be 1000')\n\n        # Determine proper input shape\n        input_shape = _obtain_input_shape(\n            input_shape,\n            default_size=299,\n            min_size=139,\n            data_format=K.image_data_format(),\n            require_flatten=include_top)\n\n        if input_tensor is None:\n            img_input = Input(shape=input_shape)\n        else:\n            if not K.is_keras_tensor(input_tensor):\n                img_input = Input(tensor=input_tensor, shape=input_shape)\n            else:\n                img_input = input_tensor\n\n        if K.image_data_format() == 'channels_first':\n            channel_axis = 1\n        else:\n            channel_axis = 3\n\n        x = _conv2d_bn(img_input, 32, 3, 3, strides=(2, 2), padding='valid')\n        x = _conv2d_bn(x, 32, 3, 3, padding='valid')\n        x = _conv2d_bn(x, 64, 3, 3)\n        x = MaxPooling2D((3, 3), strides=(2, 2))(x)\n\n        x = _conv2d_bn(x, 80, 1, 1, padding='valid')\n        x = _conv2d_bn(x, 192, 3, 3, padding='valid')\n        x = MaxPooling2D((3, 3), strides=(2, 2))(x)\n\n        # mixed 0, 1, 2: 35 x 35 x 256\n        branch1x1 = _conv2d_bn(x, 64, 1, 1)\n\n        branch5x5 = _conv2d_bn(x, 48, 1, 1)\n        branch5x5 = _conv2d_bn(branch5x5, 64, 5, 5)\n\n        branch3x3dbl = _conv2d_bn(x, 64, 1, 1)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n\n        branch_pool = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n        branch_pool = _conv2d_bn(branch_pool, 32, 1, 1)\n        x = layers.concatenate(\n            [branch1x1, branch5x5, branch3x3dbl, branch_pool],\n            axis=channel_axis,\n            name='mixed0')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 1: 35 x 35 x 256\n        branch1x1 = _conv2d_bn(x, 64, 1, 1)\n\n        branch5x5 = _conv2d_bn(x, 48, 1, 1)\n        branch5x5 = _conv2d_bn(branch5x5, 64, 5, 5)\n\n        branch3x3dbl = _conv2d_bn(x, 64, 1, 1)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n\n        branch_pool = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n        branch_pool = _conv2d_bn(branch_pool, 64, 1, 1)\n        x = layers.concatenate(\n            [branch1x1, branch5x5, branch3x3dbl, branch_pool],\n            axis=channel_axis,\n            name='mixed1')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 2: 35 x 35 x 256\n        branch1x1 = _conv2d_bn(x, 64, 1, 1)\n\n        branch5x5 = _conv2d_bn(x, 48, 1, 1)\n        branch5x5 = _conv2d_bn(branch5x5, 64, 5, 5)\n\n        branch3x3dbl = _conv2d_bn(x, 64, 1, 1)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n\n        branch_pool = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n        branch_pool = _conv2d_bn(branch_pool, 64, 1, 1)\n        x = layers.concatenate(\n            [branch1x1, branch5x5, branch3x3dbl, branch_pool],\n            axis=channel_axis,\n            name='mixed2')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 3: 17 x 17 x 768\n        branch3x3 = _conv2d_bn(x, 384, 3, 3, strides=(2, 2), padding='valid')\n\n        branch3x3dbl = _conv2d_bn(x, 64, 1, 1)\n        branch3x3dbl = _conv2d_bn(branch3x3dbl, 96, 3, 3)\n        branch3x3dbl = _conv2d_bn(\n            branch3x3dbl, 96, 3, 3, strides=(2, 2), padding='valid')\n\n        branch_pool = MaxPooling2D((3, 3), strides=(2, 2))(x)\n        x = layers.concatenate(\n            [branch3x3, branch3x3dbl, branch_pool], axis=channel_axis, name='mixed3')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 4: 17 x 17 x 768\n        branch1x1 = _conv2d_bn(x, 192, 1, 1)\n\n        branch7x7 = _conv2d_bn(x, 128, 1, 1)\n        branch7x7 = _conv2d_bn(branch7x7, 128, 1, 7)\n        branch7x7 = _conv2d_bn(branch7x7, 192, 7, 1)\n\n        branch7x7dbl = _conv2d_bn(x, 128, 1, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 128, 7, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 128, 1, 7)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 128, 7, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 1, 7)\n\n        branch_pool = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n        branch_pool = _conv2d_bn(branch_pool, 192, 1, 1)\n        x = layers.concatenate(\n            [branch1x1, branch7x7, branch7x7dbl, branch_pool],\n            axis=channel_axis,\n            name='mixed4')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 5, 6: 17 x 17 x 768\n        for i in range(2):\n            branch1x1 = _conv2d_bn(x, 192, 1, 1)\n\n            branch7x7 = _conv2d_bn(x, 160, 1, 1)\n            branch7x7 = _conv2d_bn(branch7x7, 160, 1, 7)\n            branch7x7 = _conv2d_bn(branch7x7, 192, 7, 1)\n\n            branch7x7dbl = _conv2d_bn(x, 160, 1, 1)\n            branch7x7dbl = _conv2d_bn(branch7x7dbl, 160, 7, 1)\n            branch7x7dbl = _conv2d_bn(branch7x7dbl, 160, 1, 7)\n            branch7x7dbl = _conv2d_bn(branch7x7dbl, 160, 7, 1)\n            branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 1, 7)\n\n            branch_pool = AveragePooling2D(\n                (3, 3), strides=(1, 1), padding='same')(x)\n            branch_pool = _conv2d_bn(branch_pool, 192, 1, 1)\n            x = layers.concatenate(\n                [branch1x1, branch7x7, branch7x7dbl, branch_pool],\n                axis=channel_axis,\n                name='mixed' + str(5 + i))\n\n            # squeeze and excite block\n            x = squeeze_excite_block(x)\n\n        # mixed 7: 17 x 17 x 768\n        branch1x1 = _conv2d_bn(x, 192, 1, 1)\n\n        branch7x7 = _conv2d_bn(x, 192, 1, 1)\n        branch7x7 = _conv2d_bn(branch7x7, 192, 1, 7)\n        branch7x7 = _conv2d_bn(branch7x7, 192, 7, 1)\n\n        branch7x7dbl = _conv2d_bn(x, 192, 1, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 7, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 1, 7)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 7, 1)\n        branch7x7dbl = _conv2d_bn(branch7x7dbl, 192, 1, 7)\n\n        branch_pool = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n        branch_pool = _conv2d_bn(branch_pool, 192, 1, 1)\n        x = layers.concatenate(\n            [branch1x1, branch7x7, branch7x7dbl, branch_pool],\n            axis=channel_axis,\n            name='mixed7')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 8: 8 x 8 x 1280\n        branch3x3 = _conv2d_bn(x, 192, 1, 1)\n        branch3x3 = _conv2d_bn(branch3x3, 320, 3, 3,\n                               strides=(2, 2), padding='valid')\n\n        branch7x7x3 = _conv2d_bn(x, 192, 1, 1)\n        branch7x7x3 = _conv2d_bn(branch7x7x3, 192, 1, 7)\n        branch7x7x3 = _conv2d_bn(branch7x7x3, 192, 7, 1)\n        branch7x7x3 = _conv2d_bn(\n            branch7x7x3, 192, 3, 3, strides=(2, 2), padding='valid')\n\n        branch_pool = MaxPooling2D((3, 3), strides=(2, 2))(x)\n        x = layers.concatenate(\n            [branch3x3, branch7x7x3, branch_pool], axis=channel_axis, name='mixed8')\n\n        # squeeze and excite block\n        x = squeeze_excite_block(x)\n\n        # mixed 9: 8 x 8 x 2048\n        for i in range(2):\n            branch1x1 = _conv2d_bn(x, 320, 1, 1)\n\n            branch3x3 = _conv2d_bn(x, 384, 1, 1)\n            branch3x3_1 = _conv2d_bn(branch3x3, 384, 1, 3)\n            branch3x3_2 = _conv2d_bn(branch3x3, 384, 3, 1)\n            branch3x3 = layers.concatenate(\n                [branch3x3_1, branch3x3_2], axis=channel_axis, name='mixed9_' + str(i))\n\n            branch3x3dbl = _conv2d_bn(x, 448, 1, 1)\n            branch3x3dbl = _conv2d_bn(branch3x3dbl, 384, 3, 3)\n            branch3x3dbl_1 = _conv2d_bn(branch3x3dbl, 384, 1, 3)\n            branch3x3dbl_2 = _conv2d_bn(branch3x3dbl, 384, 3, 1)\n            branch3x3dbl = layers.concatenate(\n                [branch3x3dbl_1, branch3x3dbl_2], axis=channel_axis)\n\n            branch_pool = AveragePooling2D(\n                (3, 3), strides=(1, 1), padding='same')(x)\n            branch_pool = _conv2d_bn(branch_pool, 192, 1, 1)\n            x = layers.concatenate(\n                [branch1x1, branch3x3, branch3x3dbl, branch_pool],\n                axis=channel_axis,\n                name='mixed' + str(9 + i))\n\n            # squeeze and excite block\n            x = squeeze_excite_block(x)\n\n        if include_top:\n            # Classification block\n            x = GlobalAveragePooling2D(name='avg_pool')(x)\n            x = Dense(classes, activation='softmax', name='predictions')(x)\n        else:\n            if pooling == 'avg':\n                x = GlobalAveragePooling2D()(x)\n            elif pooling == 'max':\n                x = GlobalMaxPooling2D()(x)\n\n        # Ensure that the model takes into account\n        # any potential predecessors of `input_tensor`.\n        if input_tensor is not None:\n            inputs = get_source_inputs(input_tensor)\n        else:\n            inputs = img_input\n        # Create model.\n        model = Model(inputs, x, name='inception_v3')\n\n        return model\n\n\n    def preprocess_input(self,x):\n        x \/= 255.\n        x -= 0.5\n        x *= 2.\n        return x","82393243":"model = Sequential()\ninputShape = (height, width, depth)\nchanDim = -1\nif K.image_data_format() == \"channels_first\":\n    inputShape = (depth, height, width)\n    chanDim = 1\nmodel.add(Conv2D(32, (3, 3), padding=\"same\",input_shape=inputShape))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization(axis=chanDim))\nmodel.add(MaxPooling2D(pool_size=(3, 3)))\nmodel.add(squeezeExcitation())\nmodel.add(Dropout(0.25))\nmodel.add(Conv2D(64, (3, 3), padding=\"same\"))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization(axis=chanDim))\nmodel.add(squeezeExcitation())\nmodel.add(Conv2D(64, (3, 3), padding=\"same\"))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization(axis=chanDim))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(squeezeExcitation())\nmodel.add(Dropout(0.25))\nmodel.add(Conv2D(128, (3, 3), padding=\"same\"))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization(axis=chanDim))\nmodel.add(squeezeExcitation())\nmodel.add(Conv2D(128, (3, 3), padding=\"same\"))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization(axis=chanDim))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(squeezeExcitation())\nmodel.add(Dropout(0.25))\nmodel.add(Flatten())\nmodel.add(Dense(1024))\nmodel.add(Activation(\"relu\"))\nmodel.add(BatchNormalization())\nmodel.add(Dropout(0.5))\nmodel.add(Dense(n_classes))\nmodel.add(Activation(\"softmax\"))","f36dd8b7":"model.summary()","66205bc2":"opt = Adam(lr=INIT_LR, decay=INIT_LR \/ EPOCHS)\n# distribution\nmodel.compile(loss=\"binary_crossentropy\", optimizer=opt,metrics=[\"accuracy\"])\n# train the network\nprint(\"[INFO] training network...\")","37de3cc7":"history = model.fit_generator(\n    aug.flow(x_train, y_train, batch_size=BS),\n    validation_data=(x_test, y_test),\n    steps_per_epoch=len(x_train) \/\/ BS,\n    epochs=EPOCHS, verbose=1\n    )","c1dd0ddf":"acc = history.history['acc']\nval_acc = history.history['val_acc']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\nepochs = range(1, len(acc) + 1)\n#Train and validation accuracy\nplt.plot(epochs, acc, 'b', label='Training accurarcy')\nplt.plot(epochs, val_acc, 'r', label='Validation accurarcy')\nplt.title('Training and Validation accurarcy')\nplt.legend()\n\nplt.figure()\n#Train and validation loss\nplt.plot(epochs, loss, 'b', label='Training loss')\nplt.plot(epochs, val_loss, 'r', label='Validation loss')\nplt.title('Training and Validation loss')\nplt.legend()\nplt.show()","4be15947":"print(\"[INFO] Calculating model accuracy\")\nscores = model.evaluate(x_test, y_test)\nprint(f\"Test Accuracy: {scores[1]*100}\")","77bd4a4e":"# save the model to disk\nprint(\"[INFO] Saving model...\")\npickle.dump(model,open('cnn_model.pkl', 'wb'))","d1437518":"Transform Image Labels uisng [Scikit Learn](http:\/\/scikit-learn.org\/)'s LabelBinarizer","496b2042":"Get Size of Processed Image","240b5d4f":"Model Summary","394efea6":"Model Accuracy","3da9f88f":"Fetch images from directory","ad4c4c2c":"Print the classes","a25d03a9":"Function to convert images to array","c6385caa":"Save model using Pickle","3d0fd6d2":"Import neccessary packages"}}