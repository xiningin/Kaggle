{"cell_type":{"ce07c46c":"code","b4787ec7":"code","54b5f874":"code","e6213c23":"code","ede7c60d":"code","96977719":"code","8254f06a":"code","2cd7ea70":"code","935a0737":"code","1dcd6de7":"code","5132347f":"code","7285c492":"code","79d218e4":"code","0c152595":"code","77b7835b":"code","07ec67a1":"code","64694ee4":"code","8add746e":"code","0495da91":"code","6d52a322":"code","a01c78af":"code","b9aabee2":"markdown","c0ce6d79":"markdown","597619e0":"markdown","1ac3fa26":"markdown","6e580027":"markdown","51dfc9fe":"markdown","3640eb71":"markdown","9da0386e":"markdown","79bb998c":"markdown","65c8fec1":"markdown","d4e435ac":"markdown","cb36f1ca":"markdown","446a9f4d":"markdown","1f8143de":"markdown","45459cb2":"markdown","1209cb45":"markdown","db6a40cc":"markdown"},"source":{"ce07c46c":"import pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\nfrom sklearn.model_selection import train_test_split, KFold, StratifiedKFold\nfrom sklearn.metrics import accuracy_score, roc_auc_score,log_loss\nfrom sklearn.model_selection import StratifiedKFold\nfrom lightgbm import LGBMClassifier\nfrom catboost import CatBoostClassifier\nfrom xgboost import XGBClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import RidgeClassifier\nfrom sklearn.neighbors import NearestCentroid\nfrom sklearn.neighbors import RadiusNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression","b4787ec7":"train_df = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/train.csv')\ntest_df = pd.read_csv('..\/input\/tabular-playground-series-may-2021\/test.csv')","54b5f874":"X = train_df.drop(['id', 'target'], axis=1)\nle =LabelEncoder()\ntrain_df['target'] = le.fit_transform(train_df['target'])\ny = train_df['target']","e6213c23":"results_dict = {}\ndef model_benchmarking(model,model_name,N_SPLITS,X,y):\n    eval_list = []\n    kf = StratifiedKFold(n_splits = N_SPLITS)\n    for fold, (train_idx, val_idx) in enumerate(kf.split(X, y)):    \n        # Prepare training and validation data\n        X_train = X.iloc[train_idx].reset_index(drop=True)\n        X_val = X.iloc[val_idx].reset_index(drop=True)\n        y_train = y.iloc[train_idx].reset_index(drop=True)\n        y_val = y.iloc[val_idx].reset_index(drop=True)\n        trained_model = model.fit(X_train,y_train)\n        pred = trained_model.predict_proba(X_val)\n        evaluation = log_loss(y_val,pred)\n        eval_list.append(evaluation)\n    results_dict[model_name] = eval_list\n    return eval_list","ede7c60d":"xgb = XGBClassifier()\nxgb_score = model_benchmarking(xgb,\"xgboost\",5,X,y)","96977719":"print(\"xgb logloss: \",np.mean(xgb_score))","8254f06a":"lgbm = LGBMClassifier()\nlgbm_score = model_benchmarking(lgbm,\"lgbm\",5,X,y)","2cd7ea70":"print(\"lgbm logloss: \",np.mean(lgbm_score))","935a0737":"catb = CatBoostClassifier()\ncatb_score = model_benchmarking(catb,\"catboost\",5,X,y)","1dcd6de7":"print(\"catboost logloss: \",np.mean(catb_score))","5132347f":"knn = KNeighborsClassifier()\nknn_score = model_benchmarking(knn,\"knn\",5,X,y)","7285c492":"print(\"knn logloss: \",np.mean(knn_score))","79d218e4":"decitree = DecisionTreeClassifier()\ndecitree_score = model_benchmarking(decitree,\"Decision_Tree\",5,X,y)","0c152595":"print(\"Decision Tree logloss: \",np.mean(decitree_score))","77b7835b":"randomforest = RandomForestClassifier()\nrandomforest_score = model_benchmarking(randomforest,\"random_forest\",5,X,y)","07ec67a1":"print(\"random forest  logloss: \",np.mean(randomforest_score))","64694ee4":"logreg = LogisticRegression()\nlogreg_score = model_benchmarking(logreg,\"Logistic_Regression\",5,X,y)","8add746e":"print(\"Logistic Regression logloss: \",np.mean(logreg_score))","0495da91":"df = pd.DataFrame.from_dict(results_dict)","6d52a322":"result_df = df.mean().sort_values(ascending=True).to_frame(\"avg logloss\")\nfig = go.Figure(data=[go.Table(header=dict(values=[\"Model\",\"Avg LogLoss\"]),\n                 cells=dict(values=[result_df.index,result_df[\"avg logloss\"]]))\n                     ])\nfig.update_layout(\n    title=\"Benchmark Results\")\nfig.show()","a01c78af":"# fig = px.box(df)\n# fig.update_layout(\n#     title=\"Benchmark Results\",\n#     xaxis_title=\"Models\",\n#     yaxis_title=\"Log Loss\"\n# )\n# fig.show()","b9aabee2":"### label encoding ","c0ce6d79":"## Decision Tree","597619e0":"## xgboost","1ac3fa26":"# model testing ","6e580027":"### the best model at baseline is catboost followed by lgbm  \n#### to be continued with more models \ud83d\ude0a............","51dfc9fe":"A simple script to do cross validaion with StratifiedKFold using for loop","3640eb71":"## catboost","9da0386e":"To keep this at baseline i am not going to preprocess the data as of now \n<br>\nwill add feature engineering steps in future versions of this notebook","79bb998c":"# results of benchmark test","65c8fec1":"# welcome to model benchmarking\n#### this notebooks focus is on benchmarking baselines for every single model possible for tps may 2021,if you have any models to suggest comment below and i can add it into this notebook for everyone to see \ud83d\ude01\n![testing_gif](https:\/\/cdn2.hubspot.net\/hubfs\/2621212\/job-benchmarking-basics.gif)\n### TODO for future versions\n1. add and test feature engieering \n2. add more models!!!! ","d4e435ac":"# data preprocessing ","cb36f1ca":"## Logistic Regression","446a9f4d":"## knn","1f8143de":"## Random Forest","45459cb2":"## lgbm","1209cb45":"### import data","db6a40cc":"# benchmarking code"}}