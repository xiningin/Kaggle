{"cell_type":{"6efb219e":"code","26dee1dc":"code","d92850ac":"code","af340052":"code","18a45361":"code","29c2e04d":"code","7e52490b":"code","223e28a0":"code","9fd8b6e7":"code","8b11f004":"code","6e3ca492":"code","c69c3f14":"code","d70285fe":"code","91601537":"code","038f3129":"code","6d197638":"code","645aaf5d":"code","7250fbdc":"code","e121ef62":"code","fdb5052d":"code","50b14953":"code","0c32f9c3":"code","1198dd3e":"code","60a27688":"code","2746cdb8":"code","fc96b7f8":"code","03420535":"code","f4b14d06":"code","40170839":"code","0a48390f":"code","2b758bee":"code","64898be6":"markdown","0910d452":"markdown","fd78e36d":"markdown","452b3d46":"markdown","a27a6d54":"markdown","d769b49c":"markdown","b8c0e4c3":"markdown","f76604dc":"markdown","94ff7675":"markdown","45b6b4f0":"markdown","ce628775":"markdown","f0dd3a10":"markdown","19475c3d":"markdown","3f175a5b":"markdown","5ebaba69":"markdown","9f1f6c8a":"markdown"},"source":{"6efb219e":"pip install -U lightautoml","26dee1dc":"%matplotlib inline\n\n# Standard python libraries\nimport os\nimport time\nimport re\n\n# Installed libraries\nimport numpy as np\nimport pandas as pd\nfrom sklearn.metrics import mean_squared_log_error\nfrom sklearn.model_selection import train_test_split\nimport torch\nimport matplotlib.pyplot as plt\n\n# Imports from our package\nfrom lightautoml.automl.presets.tabular_presets import TabularAutoML, TabularUtilizedAutoML\nfrom lightautoml.tasks import Task","d92850ac":"N_THREADS = 4 # threads cnt for lgbm and linear models\nN_FOLDS = 5 # folds cnt for AutoML\nRANDOM_STATE = 42 # fixed random state for various reasons\nTEST_SIZE = 0.2 # Test size for metric check\nTIMEOUT = 7200 # Time in seconds for automl run","af340052":"np.random.seed(RANDOM_STATE)\ntorch.set_num_threads(N_THREADS)","18a45361":"%%time\n\ntrain_data = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/train.csv')\ntrain_data.head()","29c2e04d":"test_data = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/test.csv')\ntest_data.head()","7e52490b":"submission = pd.read_csv('..\/input\/house-prices-advanced-regression-techniques\/sample_submission.csv')\nsubmission.head()","223e28a0":"def create_extra_features(data):\n    data[\"SqFtPerRoom\"] = data[\"GrLivArea\"] \/ (data[\"TotRmsAbvGrd\"] +\n                                               data[\"FullBath\"] +\n                                               data[\"HalfBath\"] +\n                                               data[\"KitchenAbvGr\"])\n\n    data['Total_Home_Quality'] = data['OverallQual'] + data['OverallCond']\n\n    data['Total_Bathrooms'] = (data['FullBath'] + (0.5 * data['HalfBath']) +\n                                   data['BsmtFullBath'] + (0.5 * data['BsmtHalfBath']))\n\n    data[\"HighQualSF\"] = data[\"1stFlrSF\"] + data[\"2ndFlrSF\"]\n    return data\n\ntrain_data = create_extra_features(train_data)\ntest_data = create_extra_features(test_data)","9fd8b6e7":"tr_data, te_data = train_test_split(train_data, \n                                     test_size=TEST_SIZE,\n                                     random_state=RANDOM_STATE)\nprint('Data splitted. Parts sizes: tr_data = {}, te_data = {}'.format(tr_data.shape, te_data.shape))","8b11f004":"%%time\n\ntask = Task('reg', loss = 'rmsle', metric = 'rmsle')","6e3ca492":"%%time\n\nroles = {\n    'target': 'SalePrice',\n    'drop': ['Id'],\n}","c69c3f14":"%%time \n\ncnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2005))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(tr_data, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(te_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n    \n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(te_data['SalePrice'].values, test_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(te_data['SalePrice'].values, test_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('Holdout score: {}'.format(rmsle_usual))\n    print('Holdout score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","d70285fe":"test_pred_full_0 = test_pred_full.copy() \/ cnt_trained","91601537":"plt.figure(figsize = (20, 10))\nplt.plot(range(1, cnt_trained + 1), [res[0] for res in results], color = 'b', linewidth = 2, label = 'Usual LightAutoML model RMSLE')\nplt.plot(range(1, cnt_trained + 1), [res[1] for res in results], color = 'g', linewidth = 2, label = 'RMSLE for averaged LightAutoMLs')\nplt.grid()\nplt.legend()\nplt.title('LightAutoML RMSLE vs. averaged LightAutoMLs composition RMSLE')\nplt.xlabel('Iteration number')\nplt.ylabel('RMSLE')\nplt.show()","038f3129":"mean_rmsle = np.mean([res[0] for res in results])\nmean_rmsle","6d197638":"differences = np.array([res[1] - mean_rmsle for res in results])","645aaf5d":"plt.figure(figsize = (20, 10))\nplt.plot(range(1, cnt_trained + 1), differences, color = 'g', linewidth = 2, label = 'Difference')\nplt.plot(range(1, cnt_trained + 1), [np.mean(differences[0:i+1]) for i in range(len(differences))], 'b-.', linewidth = 2, label = 'Cumulative mean difference')\nplt.plot(range(1, cnt_trained + 1), [0.0 for res in results], 'r--', linewidth = 2, label = 'Zero line')\nplt.grid()\nplt.legend()\nplt.title('Difference between mean LightAutoML RMSLE and averaged LightAutoMLs composition RMSLE at each iteration')\nplt.xlabel('Iteration number')\nplt.ylabel('RMSLE difference')\nplt.show()","7250fbdc":"data_with_pseudolabels = te_data.copy()\ndata_with_pseudolabels['SalePrice'] = test_pred_full_0.copy() \n\nnew_dataset = pd.concat([tr_data, data_with_pseudolabels]).sample(frac = 1, random_state = 13).reset_index(drop = True)\nprint(tr_data.shape, new_dataset.shape)","e121ef62":"tr_data['SalePrice'].describe()","fdb5052d":"new_dataset['SalePrice'].describe()","50b14953":"%%time \n\ncnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2005))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(new_dataset, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(te_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n    \n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(te_data['SalePrice'].values, test_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(te_data['SalePrice'].values, test_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('Holdout score: {}'.format(rmsle_usual))\n    print('Holdout score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","0c32f9c3":"%%time\n\nplt.figure(figsize = (20, 10))\nplt.plot(range(1, cnt_trained + 1), [res[0] for res in results], color = 'b', linewidth = 2, label = 'Usual LightAutoML model RMSLE')\nplt.plot(range(1, cnt_trained + 1), [res[1] for res in results], color = 'g', linewidth = 2, label = 'RMSLE for averaged LightAutoMLs')\nplt.grid()\nplt.legend()\nplt.title('LightAutoML RMSLE vs. averaged LightAutoMLs composition RMSLE')\nplt.xlabel('Iteration number')\nplt.ylabel('RMSLE')\nplt.show()","1198dd3e":"mean_rmsle = np.mean([res[0] for res in results])\nmean_rmsle","60a27688":"differences = np.array([res[1] - mean_rmsle for res in results])","2746cdb8":"plt.figure(figsize = (20, 10))\nplt.plot(range(1, cnt_trained + 1), differences, color = 'g', linewidth = 2, label = 'Difference')\nplt.plot(range(1, cnt_trained + 1), [np.mean(differences[0:i+1]) for i in range(len(differences))], 'b-.', linewidth = 2, label = 'Cumulative mean difference')\nplt.plot(range(1, cnt_trained + 1), [0.0 for res in results], 'r--', linewidth = 2, label = 'Zero line')\nplt.grid()\nplt.legend()\nplt.title('Difference between mean LightAutoML RMSLE and averaged LightAutoMLs composition RMSLE at each iteration')\nplt.xlabel('Iteration number')\nplt.ylabel('RMSLE difference')\nplt.show()","fc96b7f8":"%%time \n\ncnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2010))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(train_data, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]\n    \n    # Check scores for current predict and aggregated one\n    rmsle_usual = mean_squared_log_error(train_data['SalePrice'].values, oof_pred.data[:, 0]) ** 0.5\n    rmsle_full = mean_squared_log_error(train_data['SalePrice'].values, oof_pred_full \/ cnt_trained) ** 0.5\n    results.append((rmsle_usual, rmsle_full, rmsle_full - rmsle_usual))\n    \n    print('Check scores...')\n    print('OOF score: {}'.format(rmsle_usual))\n    print('OOF score full: {}'.format(rmsle_full))\n    print('Difference: {}'.format(rmsle_full - rmsle_usual))","03420535":"test_pred_full_0 = test_pred_full.copy() \/ cnt_trained","f4b14d06":"# create pseudolabelled dataset from real test data\ntest_data_with_pseudolabels = test_data.copy()\ntest_data_with_pseudolabels['SalePrice'] = test_pred_full_0\n\n# combine all together\nfull_dataset = pd.concat([train_data, test_data_with_pseudolabels]).sample(frac = 1, random_state = 13).reset_index(drop = True)\nprint(train_data.shape, full_dataset.shape)","40170839":"%%time \n\ncnt_trained = 0\nresults = []\nrs_list = list(range(2000, 2007))\nfor it, rs in enumerate(rs_list):\n    print('=' * 30)\n    print('START RANDOM_STATE = {}'.format(rs))\n    print('=' * 30)\n    \n    # Train AutoML\n    automl = TabularAutoML(task = task, \n                       timeout = TIMEOUT,\n                       cpu_limit = N_THREADS,\n                       general_params = {'use_algos': ['lgb', 'lgb_tuned', 'cb', 'cb_tuned']},\n                       reader_params = {'n_jobs': N_THREADS, 'cv': N_FOLDS, 'random_state': rs},\n                        verbose = 1)\n    oof_pred = automl.fit_predict(full_dataset, roles = roles)\n    \n    # Predict on test\n    test_pred = automl.predict(test_data)\n    cnt_trained += 1\n    \n    # Save predictions\n    if it == 0:\n        oof_pred_full = oof_pred.data[:, 0].copy()\n        test_pred_full = test_pred.data[:, 0].copy()\n    else:\n        oof_pred_full += oof_pred.data[:, 0]\n        test_pred_full += test_pred.data[:, 0]","0a48390f":"submission['SalePrice'] = test_pred_full \/ cnt_trained\nsubmission.to_csv('LightAutoML_pseudolabelled_multistart.csv', index = False)","2b758bee":"submission","64898be6":"## Step 7. Train LightAutoML on full training dataset and pseudolabelled real test data","0910d452":"## Step 4. Graphical check","fd78e36d":"# Step 0.4. Data load ","452b3d46":"## Step 11. Prepare submission","a27a6d54":"## Step 2. Setup columns roles","d769b49c":"## Step 3. Create AutoML from preset and train on 80% of data","b8c0e4c3":"# Step 0.3. Fix torch number of threads and numpy seed ","f76604dc":"## Step 6. New graphical check with pseudo label trained LightAutoML model","94ff7675":"# Step 0.2. Parameters ","45b6b4f0":"# ========= AutoML preset usage =========\n\n\n## Step 1. Create Task","ce628775":"## Step 5. Create AutoML with pseudo labelled data from holdout\n\nBelow we use Pseudo labelling technique - we use trained model to predict for holdout data and change the real target with these predictions. After this change we train new automl model on both train data with real target and holdout data with pseudo-target:","f0dd3a10":"# Step 0.0. Install LightAutoML","19475c3d":"# Step 0.5. Add new features","3f175a5b":"# Step 0.6. Data splitting for train-test ","5ebaba69":"# Step 0.1. Import necessary libraries ","9f1f6c8a":"## Step 8. Pseudolabel train on full train and test datasets"}}