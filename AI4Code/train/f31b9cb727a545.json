{"cell_type":{"c6edffff":"code","4beeb3e5":"code","360618a7":"code","fbf04545":"code","aab35c9f":"code","f7c9cbb8":"code","9a425158":"code","3c4e6927":"code","22b20711":"code","88914dd9":"code","f363b6f5":"code","25fe2e64":"code","0ad847cb":"code","7f7d5981":"code","884d9baf":"code","74311e4e":"code","b0efd991":"code","a92e6e34":"code","501cda49":"code","de830e63":"code","b24a2925":"code","ed98bc17":"code","5b3558f6":"code","1813fae1":"code","ba0077a8":"code","418fb780":"code","39ab4617":"code","40828473":"code","952f9402":"markdown","a60f6179":"markdown","0b6a2b2a":"markdown","43616d8a":"markdown","173d426a":"markdown","35d6d8da":"markdown","4c5aa011":"markdown","4ee7693c":"markdown","aab2ab03":"markdown","197e889b":"markdown","7ac74e06":"markdown","b73d2441":"markdown"},"source":{"c6edffff":"!pip install --upgrade pip","4beeb3e5":"!pip install -q tensorflow_datasets","360618a7":"import numpy as np\n\nimport tensorflow_datasets as tfds\nimport tensorflow as tf\n\ntfds.disable_progress_bar()","fbf04545":"import matplotlib.pyplot as plt\n\ndef plot_graphs(history, metric):\n  plt.plot(history.history[metric])\n  plt.plot(history.history['val_'+metric], '')\n  plt.xlabel(\"Epochs\")\n  plt.ylabel(metric)\n  plt.legend([metric, 'val_'+metric])","aab35c9f":"dataset, info = tfds.load('imdb_reviews', with_info=True,\n                          as_supervised=True)\ntrain_dataset, test_dataset = dataset['train'], dataset['test']\n\ntrain_dataset.element_spec","f7c9cbb8":"for example, label in train_dataset.take(1):\n  print('text: ', example.numpy())\n  print('label: ', label.numpy())","9a425158":"BUFFER_SIZE = 10000\nBATCH_SIZE = 64","3c4e6927":"train_dataset = train_dataset.shuffle(BUFFER_SIZE).batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)\ntest_dataset = test_dataset.batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)","22b20711":"for example, label in train_dataset.take(1):\n  print('texts: ', example.numpy()[:3])\n  print()\n  print('labels: ', label.numpy()[:3])","88914dd9":"VOCAB_SIZE=1500\nencoder = tf.keras.layers.experimental.preprocessing.TextVectorization(\n    max_tokens=VOCAB_SIZE)\nencoder.adapt(train_dataset.map(lambda text, label: text))","f363b6f5":"vocab = np.array(encoder.get_vocabulary())\nvocab[:30]","25fe2e64":"encoded_example = encoder(example)[:3].numpy()\nencoded_example","0ad847cb":"for n in range(3):\n  print(\"Original: \", example[n].numpy())\n  print(\"Round-trip: \", \" \".join(vocab[encoded_example[n]]))\n  print()","7f7d5981":"#multi-layer lstm\nmodel = tf.keras.Sequential([\n    encoder,\n    tf.keras.layers.Embedding(\n        input_dim=len(encoder.get_vocabulary()),\n        output_dim=64,\n        # Use masking to handle the variable sequence lengths\n        mask_zero=True),\n    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64,  return_sequences=True)),\n    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(32)),\n    tf.keras.layers.Dense(64, activation='relu'),\n    tf.keras.layers.Dropout(0.5),\n    tf.keras.layers.Dense(1)\n])","884d9baf":"print([layer.supports_masking for layer in model.layers])","74311e4e":"# predict on a sample text without padding.\n\nsample_text = ('The movie was cool. The animation and the graphics '\n               'were out of this world. I would recommend this movie.')\npredictions = model.predict(np.array([sample_text]))\nprint(predictions[0])","b0efd991":"# predict on a sample text with padding\n\npadding = \"the \" * 2000\npredictions = model.predict(np.array([sample_text, padding]))\nprint(predictions[0])","a92e6e34":"model.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),\n              optimizer=tf.keras.optimizers.Adamax(1e-3),\n              metrics=['accuracy'])","501cda49":"history = model.fit(train_dataset, epochs=2,\n                    validation_data=test_dataset, \n                    validation_steps=4)","de830e63":"test_loss, test_acc = model.evaluate(test_dataset)\n\nprint('Test Loss: {}'.format(test_loss))\nprint('Test Accuracy: {}'.format(test_acc))","b24a2925":"plt.figure(figsize=(16,8))\nplt.subplot(1,2,1)\nplot_graphs(history, 'accuracy')\nplt.ylim(None,1)\nplt.subplot(1,2,2)\nplot_graphs(history, 'loss')\nplt.ylim(0,None)","ed98bc17":"sample_text = ('The movie was cool. The animation and the graphics '\n               'were out of this world. I would recommend this movie.')\npredictions = model.predict(np.array([sample_text]))","5b3558f6":"model = tf.keras.Sequential([\n    encoder,\n    tf.keras.layers.Embedding(len(encoder.get_vocabulary()), 64, mask_zero=True),\n    tf.keras.layers.Bidirectional(tf.keras.layers.GRU(64,  return_sequences=True)),\n    tf.keras.layers.Bidirectional(tf.keras.layers.GRU(32)),\n    tf.keras.layers.Dense(64, activation='relu'),\n    tf.keras.layers.Dropout(0.5),\n    tf.keras.layers.Dense(1)\n])","1813fae1":"model.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),\n              optimizer=tf.keras.optimizers.Adamax(1e-3),\n              metrics=['accuracy'])","ba0077a8":"history = model.fit(train_dataset, epochs=2,\n                    validation_data=test_dataset,\n                    validation_steps=4)","418fb780":"test_loss, test_acc = model.evaluate(test_dataset)\n\nprint('Test Loss: {}'.format(test_loss))\nprint('Test Accuracy: {}'.format(test_acc))","39ab4617":"# predict on a sample text without padding.\n\nsample_text = ('The movie was not good. The animation and the graphics '\n                    'were terrible. I would not recommend this movie.')\npredictions = model.predict(np.array([sample_text]))\nprint(predictions)","40828473":"plt.figure(figsize=(16,6))\nplt.subplot(1,2,1)\nplot_graphs(history, 'accuracy')\nplt.subplot(1,2,2)\nplot_graphs(history, 'loss')","952f9402":"**If the prediction is >= 0.0, it is positive else it is negative.**","a60f6179":"# Create the model Using multi layer LSTM","0b6a2b2a":"*The embedding layer uses masking to handle the varying sequence-lengths. All the layers after the Embedding support masking.*","43616d8a":"# Text encoder","173d426a":"**The raw text loaded by tensorfow datasets (tfds) needs to be processed before it can be used in a model. The simplest way to process text for training is using the experimental.preprocessing.TextVectorization layer.**","35d6d8da":"# Train the model","4c5aa011":"**The first layer is the encoder, which converts the text to a sequence of token indices. After the encoder is an embedding layer. An embedding layer stores one vector per word. When called, it converts the sequences of word indices to sequences of vectors. These vectors are trainable. After training (on enough data), words with similar meanings often have similar vectors.**\n\n> A recurrent neural network (RNN) processes sequence input by iterating through the elements. RNNs pass the outputs from one timestep to their input on the next timestep.","4ee7693c":"**This is done to confirm that this works as expected and a sentence is evaluated twice. First, alone so there's no padding to mask.**","aab2ab03":"**IMDB large movie review dataset is a binary classification dataset where all the reviews have either a positive or negative sentiment.**","197e889b":"# Train the model using Gated Recurrent Unit","7ac74e06":"# Input Pipeline","b73d2441":"**Once the vocabulary is set, the layer can encode text into indices. The tensors of indices are 0-padded to the longest sequence in the batch, unless a fixed output_sequence_length is set beforehand**"}}