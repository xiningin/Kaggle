{"cell_type":{"1101df70":"code","e4962770":"code","07d0b9bd":"code","a2d9e13b":"code","cdcef729":"code","2e4b7c1d":"code","db677181":"code","39d0302d":"code","8a6a9257":"code","c65d9281":"code","9390b59a":"code","c260a80d":"code","6fe4d58b":"code","dbe9e1ff":"code","63111c3c":"code","01bf92c1":"code","7a4cfdd6":"code","05694ecc":"code","304e9222":"code","533c1980":"code","1aa6b6a5":"code","ebb1f18e":"code","d3a5de1f":"code","c0e0a4ec":"code","c3ed0eb4":"code","eb98ff6d":"code","5f92b059":"code","a5c139e5":"code","3acc418c":"code","f32f33fc":"code","480d108f":"code","fb21b137":"code","57ec2097":"code","5602a5c9":"code","8410635d":"code","c6c2a725":"code","3093f942":"code","a18c1ee9":"code","41ab1699":"code","bb234863":"code","37023f60":"code","371f2efa":"code","db331744":"code","fddfff04":"code","11a1a2f6":"code","9e60a0ee":"code","8c5db5e5":"code","7efcf470":"code","43b74a46":"code","60ed2b96":"code","5d692054":"code","c0d9ecfe":"code","fcdd4fce":"code","e83b66be":"code","c0eb9611":"code","8e54c31c":"code","9a8edc8a":"code","1739e853":"code","76b0add0":"code","3129ed26":"code","f6a7c8a1":"code","19804da6":"code","deb4f45a":"code","76fce75b":"markdown","c74481ce":"markdown","6b9220bb":"markdown","4576cd71":"markdown","b29d6a2f":"markdown","765f23f8":"markdown","608f6758":"markdown","a55ee6aa":"markdown","be192d43":"markdown","5f368cca":"markdown","7aa743b9":"markdown","f79f1fa0":"markdown","aacb0282":"markdown","42140ab3":"markdown","7b81134c":"markdown","f725d14f":"markdown","7b484bd6":"markdown","387f3afd":"markdown","61625c23":"markdown","88df2c3d":"markdown","559107c3":"markdown","a545694e":"markdown","1d82dbaf":"markdown","f7363567":"markdown","013ea648":"markdown","159ccad6":"markdown","552a10bd":"markdown","25ce593b":"markdown","ddd1f01a":"markdown","07ac7d20":"markdown","d3cd24f3":"markdown","384bf0cb":"markdown","b783ce7e":"markdown","f345af3a":"markdown"},"source":{"1101df70":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport os","e4962770":"# List files available\nprint(os.listdir(\"..\/input\/\"))","07d0b9bd":"filepath = \"..\/input\/creditcard.csv\"\ndf = pd.read_csv(filepath, engine=\"python\")","a2d9e13b":"df.shape","cdcef729":"df.head()","2e4b7c1d":"plt.figure(figsize=(15,7))\nsns.distplot(df[df[\"Class\"]==1][\"Amount\"])\nplt.title(\"Distribution of fraudulent payment amount\")\nplt.legend()\nplt.show()","db677181":"def time_decompo(x):\n    nb_min, nb_secs = x\/\/60, x%60\n    nb_hour, nb_mins = nb_min\/\/60, nb_min%60\n    nb_day, nb_hours = nb_hour\/\/24, nb_hour%24\n    return nb_day, nb_hours, nb_mins, nb_secs","39d0302d":"df.apply(lambda x: [1, 2], axis=1)\ndf[\"Day\"] = df[\"Time\"].apply(lambda x: time_decompo(x)[0])\ndf[\"Hour\"] = df[\"Time\"].apply(lambda x: time_decompo(x)[1])\ndf[\"Min\"] = df[\"Time\"].apply(lambda x: time_decompo(x)[2])\ndf[\"Sec\"] = df[\"Time\"].apply(lambda x: time_decompo(x)[3])","8a6a9257":"plt.figure(figsize=(15,7))\nsns.scatterplot(x=df[df[\"Class\"]==1][\"Hour\"], y=df[df[\"Class\"]==1][\"Amount\"])\nplt.title(\"Amount of credit card payment depending on Hour\")\nplt.legend()\nplt.show()","c65d9281":"plt.figure(figsize=(15,7))\nsns.distplot(df[\"Hour\"])\nplt.title(\"Distribution of payment hour\")\nplt.show()","9390b59a":"plt.figure(figsize=(15,7))\nplt.subplots_adjust(hspace=0.4)\n\nsns.distplot(df[df[\"Class\"]==1][\"Hour\"], label=\"fraudulent\", bins=20)\nsns.distplot(df[df[\"Class\"]==0][\"Hour\"], label=\"non fraudulent\", bins=20)\nplt.title(\"Distribution of fraudulent payment hour\")\n\nplt.legend()\nplt.show()","c260a80d":"def night_time(x):\n    if x < 7 or x > 0:\n        return 1\n    else:\n        return 0","6fe4d58b":"df[\"NightTime\"] = df[\"Hour\"].apply(lambda x: night_time(x)) ","dbe9e1ff":"df.shape","63111c3c":"column_drop = [\"Day\", \"Min\", \"Sec\"]\ndf = df.drop(column_drop, axis=1)","01bf92c1":"y = df[\"Class\"]\nX = df.drop(\"Class\", axis=1)","7a4cfdd6":"from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nX = scaler.fit_transform(X=X)","05694ecc":"X.shape","304e9222":"X_centered = X - X.mean()","533c1980":"from sklearn.decomposition import PCA\npca = PCA(n_components=3)\nX_pca = pca.fit_transform(X_centered)","1aa6b6a5":"pca.explained_variance_ratio_.sum()","ebb1f18e":"plt.figure()\nplt.scatter(X_pca[y==0][:,0], X_pca[y==0][:,1], label=\"non fraudulent\")\nplt.scatter(X_pca[y==1][:,0], X_pca[y==1][:,1], label=\"fraudulent\")\nplt.legend(loc=0)\nplt.title('PCA projection n_dym = 2')\nplt.show()","d3a5de1f":"# Let's create a 3d-plot\n%matplotlib inline \n#to print inlin mode rather than notebook mode\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(X_pca[y==0][:,0], X_pca[y==0][:,1], X_pca[y==0][:,2], label=\"non fraudulent\")\nax.scatter(X_pca[y==1][:,0], X_pca[y==1][:,1], X_pca[y==1][:,2], label=\"fraudulent\") \n\nplt.legend(loc=0)\nplt.title('PCA projection n_dym = 3')\nplt.show()","c0e0a4ec":"y.sum(), y.count()","c3ed0eb4":"X_sample = (pd.DataFrame(df)).sample(n=1000)","eb98ff6d":"y_sample = y[X_sample.index]","5f92b059":"from sklearn.manifold import TSNE\ntsne = TSNE(n_components=3)\nX_tsne = tsne.fit_transform(X_sample)","a5c139e5":"X_tsne.shape","3acc418c":"# Then we plot the results of t-SNE\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nax.scatter(X_tsne[y_sample==0][:,0], X_tsne[y_sample==0][:,1], X_tsne[y_sample==0][:,2], label=\"non fraudulent\")\nax.scatter(X_tsne[y_sample==1][:,0], X_tsne[y_sample==1][:,1], X_tsne[y_sample==1][:,2], label=\"fraudulent\") \n\nplt.legend(loc=0)\nplt.title('t-SNE projection')\nplt.show()","f32f33fc":"X.shape","480d108f":"from sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)","fb21b137":"print(f\"Ratio of Class 1 in y: {round((y_train.sum()\/len(y_train))*100, 2)} %\")","57ec2097":"from imblearn.under_sampling import RandomUnderSampler","5602a5c9":"rus = RandomUnderSampler(sampling_strategy='auto', return_indices=False, random_state=0, replacement=False, ratio=0.01)","8410635d":"X_undersamp, y_undersamp = rus.fit_resample(X_train, y_train)\nX_undersamp.shape, y_undersamp.shape","c6c2a725":"print(f\"Ratio of Class 1 in y_undersamp: {round((y_undersamp.sum()\/len(y_undersamp))*100, 2)} %\")","3093f942":"from imblearn import over_sampling\nsmote = over_sampling.SMOTE(k_neighbors=5, ratio=0.01, random_state=0)","a18c1ee9":"X_oversamp, y_oversamp = smote.fit_resample(X_train, y_train)\nX_oversamp.shape, y_oversamp.shape","41ab1699":"print(f\"Ratio of Class 1 in y_oversamp: {round((y_oversamp.sum()\/len(y_oversamp))*100, 2)} %\")","bb234863":"from sklearn.metrics import f1_score, classification_report","37023f60":"from sklearn.linear_model import LogisticRegression\nlr = LogisticRegression()\nlr.fit(X_oversamp, y_oversamp)\ny_pred_lr = lr.predict_proba(X_test)[:,1]","371f2efa":"print(classification_report(y_test,np.round(y_pred_lr)))","db331744":"import xgboost as xgb\nxg = xgb.XGBClassifier()\nxg.fit(X_oversamp, y_oversamp)\ny_pred_xg = xg.predict_proba(X_test)[:,1]","fddfff04":"print(classification_report(y_test, np.round(y_pred_xg)))","11a1a2f6":"import lightgbm as lgb\nlgbm = lgb.LGBMClassifier()\nlgbm.fit(X_oversamp, y_oversamp)\ny_pred_lgbm = lgbm.predict_proba(X_test)[:,1]","9e60a0ee":"print(classification_report(y_test, np.round(y_pred_lgbm)))","8c5db5e5":"from sklearn.metrics import precision_recall_curve, auc\nprecision_lr, recall_lr, thresholds_lr = precision_recall_curve(y_test, y_pred_lr)\nprecision_xg, recall_xg, thresholds_xg = precision_recall_curve(y_test, y_pred_xg)\nprecision_lgbm, recall_lgbm, thresholds_lgbm = precision_recall_curve(y_test, y_pred_lgbm)\n\nprint(f\"Logistic Regression AUPRC: {auc(recall_lr, precision_lr)}\")\nprint(f\"XG Boost AUPRC: {auc(recall_xg, precision_xg)}\")\nprint(f\"LGBM AUPRC: {auc(recall_lgbm, precision_lgbm)}\")","7efcf470":"plt.figure(figsize=(15,7))\nplt.plot(recall_lr, precision_lr, label=\"Logistic regression\", linewidth=2)\nplt.plot(recall_xg, precision_xg, label=\"XG Boost\", linewidth=2)\nplt.plot(recall_lgbm, precision_lgbm, label=\"LGBM\", linewidth=2)\nplt.title(\"Precision recall curve\")\nplt.xlabel(\"Recall\")\nplt.ylabel(\"Precision\")\nplt.legend()\nplt.show()","43b74a46":"X_train = X[y==0][:5000]","60ed2b96":"X_train.shape","5d692054":"X_test_outliers = X[y==1]\nX_test_inliers = X[y==0][1000:5000]\nX_test = np.concatenate([X_test_outliers, X_test_inliers])","c0d9ecfe":"X_test.shape","fcdd4fce":"y_test = np.zeros(len(X_test_outliers)+len(X_test_inliers))\ny_test[:len(X_test_outliers)] = 1","e83b66be":"print(f\"Contanination ratio: {(y.sum()\/len(y))*100}\")","c0eb9611":"from sklearn.neighbors import LocalOutlierFactor\nLOF = LocalOutlierFactor(n_neighbors=20, contamination=0.0017, novelty=True) \n#depending on novelty you fit your model differently, \n#        if novelty = False you can do fit_predict(X)\n#        if novelty = True we need to prepare our X_tain \/ X_test as done above\nLOF.fit(X_train)\ny_predLOF = LOF.predict(X_test)","8e54c31c":"y_predLOF[y_predLOF == 1] = 0\ny_predLOF[y_predLOF == -1] = 1","9a8edc8a":"n_errors = (y_predLOF != y_test).sum()\nX_scores = LOF.negative_outlier_factor_\nn_errors, LOF.offset_","1739e853":"y_test.sum(), len(y_test)","76b0add0":"print(classification_report(y_test, y_predLOF))","3129ed26":"from sklearn.ensemble import IsolationForest","f6a7c8a1":"IF = IsolationForest(n_estimators=100, contamination=0.0018, behaviour='new', random_state=0)\nIF.fit(X_train)\ny_predIF = IF.predict(X_test)","19804da6":"y_predIF[y_predIF == 1] = 0\ny_predIF[y_predIF == -1] = 1","deb4f45a":"print(classification_report(y_test, y_predIF))","76fce75b":"<h2> PCA","c74481ce":"We would like to get more out of the Time feature, to be able to analyze if the time has a influence on the fraudulent payment.","6b9220bb":"<h3> We define a X_train containing only inliers","4576cd71":"Base on that distribution we can assess H=0 -> H=22H","b29d6a2f":"<h2> Data viz with the new time features","765f23f8":"<h2> Split of X_train, X_test","608f6758":"<h1> Hyperparameters Optimization","a55ee6aa":"<h2> LGBM","be192d43":"\n<h1> Features preparation","5f368cca":"<h2> Area under precision curve","7aa743b9":"<h2> TSNE","f79f1fa0":"<h2> Precision recall curve","aacb0282":"<h2> Random oversampling: SMOTE","42140ab3":"<h2> XG Boost","7b81134c":"<h2> Analyze of the Outliers","f725d14f":"<h1> Anomaly detection model","7b484bd6":"<h2> Undersampling","387f3afd":"<h2> Local Outlier Factor (LOF)","61625c23":"<h3> We adapt our target y_test to our new made X_test","88df2c3d":"<h1> Model Training","559107c3":"<h2> Data viz","a545694e":"<h1> EDA","1d82dbaf":"<h2> Time feature creation","f7363567":"<h1> Handle imbalance Data","013ea648":"<h2> Scalling of data","159ccad6":"<h3> We define a X_test containing outliers and inliers","552a10bd":"<h2> Create specific X_train, X_test, y_test dedicated to anomaly detection model","25ce593b":"<h3> We eveluate the ratio of outliers to define the contanimation","ddd1f01a":"<h1> Reduction of dimenssion (PCA \/ TSNE)","07ac7d20":"<h2> Logistic Regression","d3cd24f3":"<h1> Model Metrics","384bf0cb":"We can clearly noticed that there are more fraudulent payment during the night, It could be interresting to categorize by day and night the hour","b783ce7e":"<h2> Isolation Forest","f345af3a":"<h2> Features selection"}}