{"cell_type":{"19122841":"code","1388c8c0":"code","65fb80ae":"code","01d5a78a":"code","e8f0ebc3":"code","f028be6c":"code","f6f7d4ae":"code","5ef5cd93":"code","9a932d0f":"code","fba1ecfd":"code","254b1428":"code","f87fc838":"code","69fe8c5f":"code","0eb546e3":"code","f97c46fc":"code","23223be0":"code","a59f2e94":"code","5354581b":"code","19c4f711":"code","0bf5132f":"code","8bd3a912":"code","0e88a530":"code","ea2e6423":"code","5d9b3415":"code","b31d3e0a":"code","9fe49483":"code","e1ceb169":"code","28fee485":"code","36e38e81":"code","792c5c21":"code","dfd0c266":"code","d1e6e954":"code","75a58c1d":"code","9bfe9476":"code","44aca607":"code","283dc047":"code","08c20ec7":"code","97aa3645":"code","536ebe51":"code","d0f712b7":"code","ff7b4599":"code","22d5cc26":"code","04307374":"code","ea4eecb8":"code","f9a31d07":"code","89064eb8":"code","1dba19f6":"code","28f29152":"code","0925cfeb":"code","a95437e0":"code","029c6e5f":"code","597b9192":"code","aa9ca0ec":"code","866149e4":"code","06202722":"code","f8d89cf5":"code","b2590f63":"code","d04390f5":"code","232ac3aa":"code","a0bd498f":"code","dad819cd":"code","11b3fb8f":"code","4b034bcf":"code","5e63a979":"code","5d718682":"code","3e9e872c":"code","0fe8b5ef":"code","4e18f9a1":"code","6a4da661":"code","c6bb4ef8":"code","26cacf9a":"code","133e7258":"code","7df9a255":"code","63e7c5b0":"code","2f6ba6dd":"code","a56a562e":"code","423e24db":"code","d8440469":"code","ad5e1b38":"code","82adb839":"code","85eaf1b1":"code","71a15033":"code","a72b87b8":"code","f8e215d6":"code","51fa216f":"code","20227603":"code","76b96526":"code","9dc9bd00":"code","2b766ab2":"code","2b3ba466":"code","21acbb06":"code","69e6398a":"code","36943979":"markdown","78dcefbc":"markdown","e0ad6076":"markdown","8b20bf9d":"markdown","1a49fd42":"markdown","34ff3450":"markdown","86fbbb27":"markdown","eb046d39":"markdown","09fba84b":"markdown","12d08fcc":"markdown","a43425a8":"markdown","da4395ef":"markdown","186c3db4":"markdown","66886a85":"markdown","acf61178":"markdown","3cb968a7":"markdown","935625c7":"markdown","d486d888":"markdown","e8d6ae39":"markdown","dbbc2d0f":"markdown","f62d5124":"markdown","9963b6d4":"markdown","cd3c4737":"markdown","a9070497":"markdown","a519c0a0":"markdown","96fdbb0d":"markdown","952ee5de":"markdown","2f3e9f98":"markdown","ebf9929c":"markdown","95b35de2":"markdown","93eafc1b":"markdown","6b296cb5":"markdown","cb2a8cb7":"markdown","210400f3":"markdown","84094619":"markdown","d8b05542":"markdown","6e1f1dff":"markdown","46ecfefc":"markdown","37950260":"markdown","702faed5":"markdown","c196f2a5":"markdown","a68e35af":"markdown","18d4af7a":"markdown","877130ce":"markdown","2221cdad":"markdown","512d36da":"markdown","eb19008e":"markdown","59b775e5":"markdown","34e41d80":"markdown","50b9d40d":"markdown","145db3ed":"markdown","1e28affd":"markdown","7f1c31b8":"markdown","1315c279":"markdown","048101fa":"markdown"},"source":{"19122841":"\nimport dask.dataframe as dd#similar to pandas\n\nimport pandas as pd#pandas to create small dataframes \n\nimport folium #open street map\n\nimport datetime #Convert to unix time\n\nimport time #Convert to unix time\n\nimport numpy as np#Do aritmetic operations on arrays\n\nimport matplotlib\n# matplotlib.use('nbagg') : matplotlib uses this protocall which makes plots more user intractive like zoom in and zoom out\nmatplotlib.use('nbagg')\nimport matplotlib.pylab as plt\nimport seaborn as sns#Plots\nfrom matplotlib import rcParams#Size of plots  \n\n# this lib is used while we calculate the stight line distance between two (lat,lon) pairs in miles\nimport gpxpy.geo #Get the haversine distance\n\nfrom sklearn.cluster import MiniBatchKMeans, KMeans#Clustering\nimport math\nimport pickle\nimport os\n\nmingw_path = 'C:\\\\Program Files\\\\mingw-w64\\\\x86_64-5.3.0-posix-seh-rt_v4-rev0\\\\mingw64\\\\bin'\nos.environ['PATH'] = mingw_path + ';' + os.environ['PATH']\n\nimport xgboost as xgb\n\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import mean_absolute_error\nimport warnings\nwarnings.filterwarnings(\"ignore\")","1388c8c0":"#Looking at the features\nmonth = dd.read_csv('yellow_tripdata_2015-01.csv')\nprint(month.columns)","65fb80ae":"# However unlike Pandas, operations on dask.dataframes don't trigger immediate computation, \n# instead they add key-value pairs to an underlying Dask graph. Recall that in the diagram below, \n# circles are operations and rectangles are results.\n\nmonth.visualize()","01d5a78a":"month.fare_amount.sum().visualize()","e8f0ebc3":"#table below shows few datapoints along with all our features\nmonth.head(5)","f028be6c":"# Plotting pickup cordinates which are outside the bounding box of New-York \n# I will collect all the points outside the bounding box of newyork city to outlier_locations\noutlier_locations = month[((month.pickup_longitude <= -74.15) | (month.pickup_latitude <= 40.5774)| \\\n                   (month.pickup_longitude >= -73.7004) | (month.pickup_latitude >= 40.9176))]\n\n# creating a map with the a base location\n\nmap_osm = folium.Map(location=[40.734695, -73.990372], tiles='Stamen Toner')\n\n# I will spot only first 100 outliers on the map, plotting all the outliers will take more time\nsample_locations = outlier_locations.head(10000)\nfor i,j in sample_locations.iterrows():\n    if int(j['pickup_latitude']) != 0:\n        folium.Marker(list((j['pickup_latitude'],j['pickup_longitude']))).add_to(map_osm)\nmap_osm","f6f7d4ae":"# Plotting dropoff cordinates which are outside the bounding box of New-York \n# we will collect all the points outside the bounding box of newyork city to outlier_locations\noutlier_locations = month[((month.dropoff_longitude <= -74.15) | (month.dropoff_latitude <= 40.5774)| \\\n                   (month.dropoff_longitude >= -73.7004) | (month.dropoff_latitude >= 40.9176))]\n\n# creating a map with the a base location\n# read more about the folium here: http:\/\/folium.readthedocs.io\/en\/latest\/quickstart.html\n\n# note: you dont need to remember any of these, you dont need indeepth knowledge on these maps and plots\n\nmap_osm = folium.Map(location=[40.734695, -73.990372], tiles='Stamen Toner')\n\n# we will spot only first 100 outliers on the map, plotting all the outliers will take more time\nsample_locations = outlier_locations.head(10000)\nfor i,j in sample_locations.iterrows():\n    if int(j['pickup_latitude']) != 0:\n        folium.Marker(list((j['dropoff_latitude'],j['dropoff_longitude']))).add_to(map_osm)\nmap_osm","5ef5cd93":"#The timestamps are converted to unix so as to get duration(trip-time) & speed also pickup-times in unix are used while binning \n\n# in our data we have time in the formate \"YYYY-MM-DD HH:MM:SS\" we convert thiss sting to python time formate and then into unix time stamp\ndef convert_to_unix(s):\n    return time.mktime(datetime.datetime.strptime(s, \"%Y-%m-%d %H:%M:%S\").timetuple())\n\n\n\n# we return a data frame which contains the columns\n# 1.'passenger_count' : self explanatory\n# 2.'trip_distance' : self explanatory\n# 3.'pickup_longitude' : self explanatory\n# 4.'pickup_latitude' : self explanatory\n# 5.'dropoff_longitude' : self explanatory\n# 6.'dropoff_latitude' : self explanatory\n# 7.'total_amount' : total fair that was paid\n# 8.'trip_times' : duration of each trip\n# 9.'pickup_times : pickup time converted into unix time \n# 10.'Speed' : velocity of each trip\ndef return_with_trip_times(month):\n    duration = month[['tpep_pickup_datetime','tpep_dropoff_datetime']].compute()\n    #pickups and dropoffs to unix time\n    duration_pickup = [convert_to_unix(x) for x in duration['tpep_pickup_datetime'].values]\n    duration_drop = [convert_to_unix(x) for x in duration['tpep_dropoff_datetime'].values]\n    #calculate duration of trips\n    durations = (np.array(duration_drop) - np.array(duration_pickup))\/float(60)\n\n    #append durations of trips and speed in miles\/hr to a new dataframe\n    new_frame = month[['passenger_count','trip_distance','pickup_longitude','pickup_latitude','dropoff_longitude','dropoff_latitude','total_amount']].compute()\n    \n    new_frame['trip_times'] = durations\n    new_frame['pickup_times'] = duration_pickup\n    new_frame['Speed'] = 60*(new_frame['trip_distance']\/new_frame['trip_times'])\n    \n    return new_frame\n\n# print(frame_with_durations.head())\n#  passenger_count\ttrip_distance\tpickup_longitude\tpickup_latitude\tdropoff_longitude\tdropoff_latitude\ttotal_amount\ttrip_times\tpickup_times\tSpeed\n#   1                  1.59\t      -73.993896        \t40.750111    \t-73.974785      \t40.750618           \t17.05   \t 18.050000\t1.421329e+09\t5.285319\n#   1               \t3.30    \t-74.001648      \t40.724243   \t-73.994415      \t40.759109           \t17.80   \t19.833333\t1.420902e+09\t9.983193\n#   1               \t1.80     \t-73.963341      \t40.802788     \t-73.951820      \t40.824413           \t10.80   \t10.050000\t1.420902e+09\t10.746269\n#   1               \t0.50    \t-74.009087      \t40.713818    \t-74.004326       \t40.719986           \t4.80    \t1.866667\t1.420902e+09\t16.071429\n#   1               \t3.00    \t-73.971176      \t40.762428    \t-74.004181      \t40.742653           \t16.30   \t19.316667\t1.420902e+09\t9.318378\nframe_with_durations = return_with_trip_times(month)","9a932d0f":"# the skewed box plot shows us the presence of outliers \nsns.boxplot(y=\"trip_times\", data =frame_with_durations)\nplt.show()","fba1ecfd":"#calculating 0-100th percentile to find a the correct percentile value for removal of outliers\nfor i in range(0,100,10):\n    var =frame_with_durations[\"trip_times\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint (\"100 percentile value is \",var[-1])","254b1428":"#looking further from the 99th percecntile\nfor i in range(90,100):\n    var =frame_with_durations[\"trip_times\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint (\"100 percentile value is \",var[-1])","f87fc838":"#removing data based on our analysis and TLC regulations\nframe_with_durations_modified=frame_with_durations[(frame_with_durations.trip_times>1) & (frame_with_durations.trip_times<720)]","69fe8c5f":"#box-plot after removal of outliers\nsns.boxplot(y=\"trip_times\", data =frame_with_durations_modified)\nplt.show()","0eb546e3":"#pdf of trip-times after removing the outliers\nsns.FacetGrid(frame_with_durations_modified,size=6) \\\n      .map(sns.kdeplot,\"trip_times\") \\\n      .add_legend();\nplt.show();","f97c46fc":"#converting the values to log-values to chec for log-normal\nimport math\nframe_with_durations_modified['log_times']=[math.log(i) for i in frame_with_durations_modified['trip_times'].values]","23223be0":"#pdf of log-values\nsns.FacetGrid(frame_with_durations_modified,size=6) \\\n      .map(sns.kdeplot,\"log_times\") \\\n      .add_legend();\nplt.show();","a59f2e94":"#Q-Q plot for checking if trip-times is log-normal\nscipy.stats.probplot(frame_with_durations_modified['log_times'].values, plot=plt)\nplt.show()","5354581b":"# check for any outliers in the data after trip duration outliers removed\n# box-plot for speeds with outliers\nframe_with_durations_modified['Speed'] = 60*(frame_with_durations_modified['trip_distance']\/frame_with_durations_modified['trip_times'])\nsns.boxplot(y=\"Speed\", data =frame_with_durations_modified)\nplt.show()","19c4f711":"#calculating speed values at each percntile 0,10,20,30,40,50,60,70,80,90,100 \nfor i in range(0,100,10):\n    var =frame_with_durations_modified[\"Speed\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","0bf5132f":"#calculating speed values at each percntile 90,91,92,93,94,95,96,97,98,99,100\nfor i in range(90,100):\n    var =frame_with_durations_modified[\"Speed\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","8bd3a912":"#calculating speed values at each percntile 99.0,99.1,99.2,99.3,99.4,99.5,99.6,99.7,99.8,99.9,100\nfor i in np.arange(0.0, 1.0, 0.1):\n    var =frame_with_durations_modified[\"Speed\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(99+i,var[int(len(var)*(float(99+i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","0e88a530":"#removing further outliers based on the 99.9th percentile value\nframe_with_durations_modified=frame_with_durations[(frame_with_durations.Speed>0) & (frame_with_durations.Speed<45.31)]","ea2e6423":"#avg.speed of cabs in New-York\nsum(frame_with_durations_modified[\"Speed\"]) \/ float(len(frame_with_durations_modified[\"Speed\"]))","5d9b3415":"# up to now I have removed the outliers based on trip durations and cab speeds\n# lets try if there are any outliers in trip distances\n# box-plot showing outliers in trip-distance values\nsns.boxplot(y=\"trip_distance\", data =frame_with_durations_modified)\nplt.show()","b31d3e0a":"#calculating trip distance values at each percntile 0,10,20,30,40,50,60,70,80,90,100 \nfor i in range(0,100,10):\n    var =frame_with_durations_modified[\"trip_distance\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","9fe49483":"#calculating trip distance values at each percntile 90,91,92,93,94,95,96,97,98,99,100\nfor i in range(90,100):\n    var =frame_with_durations_modified[\"trip_distance\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","e1ceb169":"#calculating trip distance values at each percntile 99.0,99.1,99.2,99.3,99.4,99.5,99.6,99.7,99.8,99.9,100\nfor i in np.arange(0.0, 1.0, 0.1):\n    var =frame_with_durations_modified[\"trip_distance\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(99+i,var[int(len(var)*(float(99+i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","28fee485":"#removing further outliers based on the 99.9th percentile value\nframe_with_durations_modified=frame_with_durations[(frame_with_durations.trip_distance>0) & (frame_with_durations.trip_distance<23)]","36e38e81":"#box-plot after removal of outliers\nsns.boxplot(y=\"trip_distance\", data = frame_with_durations_modified)\nplt.show()","792c5c21":"# up to now I have removed the outliers based on trip durations, cab speeds, and trip distances\n# lets try if there are any outliers in based on the total_amount\n# box-plot showing outliers in fare\nsns.boxplot(y=\"total_amount\", data =frame_with_durations_modified)\nplt.show()","dfd0c266":"#calculating total fare amount values at each percntile 0,10,20,30,40,50,60,70,80,90,100 \nfor i in range(0,100,10):\n    var = frame_with_durations_modified[\"total_amount\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","d1e6e954":"#calculating total fare amount values at each percntile 90,91,92,93,94,95,96,97,98,99,100\nfor i in range(90,100):\n    var = frame_with_durations_modified[\"total_amount\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(i,var[int(len(var)*(float(i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","75a58c1d":"#calculating total fare amount values at each percntile 99.0,99.1,99.2,99.3,99.4,99.5,99.6,99.7,99.8,99.9,100\nfor i in np.arange(0.0, 1.0, 0.1):\n    var = frame_with_durations_modified[\"total_amount\"].values\n    var = np.sort(var,axis = None)\n    print(\"{} percentile value is {}\".format(99+i,var[int(len(var)*(float(99+i)\/100))]))\nprint(\"100 percentile value is \",var[-1])","9bfe9476":"#below plot shows us the fare values(sorted) to find a sharp increase to remove those values as outliers\n# plot the fare amount excluding last two values in sorted data\nplt.plot(var[:-2])\nplt.show()","44aca607":"# a very sharp increase in fare values can be seen \n# plotting last three total fare values, and we can observe there is share increase in the values\nplt.plot(var[-3:])\nplt.show()","283dc047":"#now looking at values not including the last two points we again find a drastic increase at around 1000 fare value\n# I plot last 50 values excluding last two values\nplt.plot(var[-50:-2])\nplt.show()","08c20ec7":"#removing all outliers based on our univariate analysis above\ndef remove_outliers(new_frame):\n\n    \n    a = new_frame.shape[0]\n    print (\"Number of pickup records = \",a)\n    temp_frame = new_frame[((new_frame.dropoff_longitude >= -74.15) & (new_frame.dropoff_longitude <= -73.7004) &\\\n                       (new_frame.dropoff_latitude >= 40.5774) & (new_frame.dropoff_latitude <= 40.9176)) & \\\n                       ((new_frame.pickup_longitude >= -74.15) & (new_frame.pickup_latitude >= 40.5774)& \\\n                       (new_frame.pickup_longitude <= -73.7004) & (new_frame.pickup_latitude <= 40.9176))]\n    b = temp_frame.shape[0]\n    print (\"Number of outlier coordinates lying outside NY boundaries:\",(a-b))\n\n    \n    temp_frame = new_frame[(new_frame.trip_times > 0) & (new_frame.trip_times < 720)]\n    c = temp_frame.shape[0]\n    print (\"Number of outliers from trip times analysis:\",(a-c))\n    \n    \n    temp_frame = new_frame[(new_frame.trip_distance > 0) & (new_frame.trip_distance < 23)]\n    d = temp_frame.shape[0]\n    print (\"Number of outliers from trip distance analysis:\",(a-d))\n    \n    temp_frame = new_frame[(new_frame.Speed <= 65) & (new_frame.Speed >= 0)]\n    e = temp_frame.shape[0]\n    print (\"Number of outliers from speed analysis:\",(a-e))\n    \n    temp_frame = new_frame[(new_frame.total_amount <1000) & (new_frame.total_amount >0)]\n    f = temp_frame.shape[0]\n    print (\"Number of outliers from fare analysis:\",(a-f))\n    \n    \n    new_frame = new_frame[((new_frame.dropoff_longitude >= -74.15) & (new_frame.dropoff_longitude <= -73.7004) &\\\n                       (new_frame.dropoff_latitude >= 40.5774) & (new_frame.dropoff_latitude <= 40.9176)) & \\\n                       ((new_frame.pickup_longitude >= -74.15) & (new_frame.pickup_latitude >= 40.5774)& \\\n                       (new_frame.pickup_longitude <= -73.7004) & (new_frame.pickup_latitude <= 40.9176))]\n    \n    new_frame = new_frame[(new_frame.trip_times > 0) & (new_frame.trip_times < 720)]\n    new_frame = new_frame[(new_frame.trip_distance > 0) & (new_frame.trip_distance < 23)]\n    new_frame = new_frame[(new_frame.Speed < 45.31) & (new_frame.Speed > 0)]\n    new_frame = new_frame[(new_frame.total_amount <1000) & (new_frame.total_amount >0)]\n    \n    print (\"Total outliers removed\",a - new_frame.shape[0])\n    print (\"---\")\n    return new_frame","97aa3645":"print (\"Removing outliers in the month of Jan-2015\")\nprint (\"----\")\nframe_with_durations_outliers_removed = remove_outliers(frame_with_durations)\nprint(\"fraction of data points that remain after removing outliers\", float(len(frame_with_durations_outliers_removed))\/len(frame_with_durations))","536ebe51":"#trying different cluster sizes to choose the right K in K-means\ncoords = frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']].values\nneighbours=[]\n\ndef find_min_distance(cluster_centers, cluster_len):\n    nice_points = 0\n    wrong_points = 0\n    less2 = []\n    more2 = []\n    min_dist=1000\n    for i in range(0, cluster_len):\n        nice_points = 0\n        wrong_points = 0\n        for j in range(0, cluster_len):\n            if j!=i:\n                distance = gpxpy.geo.haversine_distance(cluster_centers[i][0], cluster_centers[i][1],cluster_centers[j][0], cluster_centers[j][1])\n                min_dist = min(min_dist,distance\/(1.60934*1000))\n                if (distance\/(1.60934*1000)) <= 2:\n                    nice_points +=1\n                else:\n                    wrong_points += 1\n        less2.append(nice_points)\n        more2.append(wrong_points)\n    neighbours.append(less2)\n    print (\"On choosing a cluster size of \",cluster_len,\"\\nAvg. Number of Clusters within the vicinity (i.e. intercluster-distance < 2):\", np.ceil(sum(less2)\/len(less2)), \"\\nAvg. Number of Clusters outside the vicinity (i.e. intercluster-distance > 2):\", np.ceil(sum(more2)\/len(more2)),\"\\nMin inter-cluster distance = \",min_dist,\"\\n---\")\n\ndef find_clusters(increment):\n    kmeans = MiniBatchKMeans(n_clusters=increment, batch_size=10000,random_state=42).fit(coords)\n    frame_with_durations_outliers_removed['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']])\n    cluster_centers = kmeans.cluster_centers_\n    cluster_len = len(cluster_centers)\n    return cluster_centers, cluster_len\n\n# I need to choose number of clusters so that, there are more number of cluster regions \n# that are close to any cluster center\n# and make sure that the minimum inter cluster should not be very less\nfor increment in range(10, 100, 10):\n    cluster_centers, cluster_len = find_clusters(increment)\n    find_min_distance(cluster_centers, cluster_len)            ","d0f712b7":"# if check for the 50 clusters you can observe that there are two clusters with only 0.3 miles apart from each other\n# so I choose 40 clusters for solve the further problem\n\n# Getting 40 clusters using the kmeans \nkmeans = MiniBatchKMeans(n_clusters=40, batch_size=10000,random_state=0).fit(coords)\nframe_with_durations_outliers_removed['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']])","ff7b4599":"# Plotting the cluster centers on OSM\ncluster_centers = kmeans.cluster_centers_\ncluster_len = len(cluster_centers)\nmap_osm = folium.Map(location=[40.734695, -73.990372], tiles='Stamen Toner')\nfor i in range(cluster_len):\n    folium.Marker(list((cluster_centers[i][0],cluster_centers[i][1])), popup=(str(cluster_centers[i][0])+str(cluster_centers[i][1]))).add_to(map_osm)\nmap_osm","22d5cc26":"#Visualising the clusters on a map\ndef plot_clusters(frame):\n    city_long_border = (-74.03, -73.75)\n    city_lat_border = (40.63, 40.85)\n    fig, ax = plt.subplots(ncols=1, nrows=1)\n    ax.scatter(frame.pickup_longitude.values[:100000], frame.pickup_latitude.values[:100000], s=10, lw=0,\n               c=frame.pickup_cluster.values[:100000], cmap='tab20', alpha=0.2)\n    ax.set_xlim(city_long_border)\n    ax.set_ylim(city_lat_border)\n    ax.set_xlabel('Longitude')\n    ax.set_ylabel('Latitude')\n    plt.show()\n\nplot_clusters(frame_with_durations_outliers_removed)","04307374":"def add_pickup_bins(frame,month,year):\n    unix_pickup_times=[i for i in frame['pickup_times'].values]\n    unix_times = [[1420070400,1422748800,1425168000,1427846400,1430438400,1433116800],\\\n                    [1451606400,1454284800,1456790400,1459468800,1462060800,1464739200]]\n    \n    start_pickup_unix=unix_times[year-2015][month-1]\n    # (int((i-start_pickup_unix)\/600)+33) : our unix time is in gmt to we are converting it to est\n    tenminutewise_binned_unix_pickup_times=[(int((i-start_pickup_unix)\/600)+33) for i in unix_pickup_times]\n    frame['pickup_bins'] = np.array(tenminutewise_binned_unix_pickup_times)\n    return frame","ea4eecb8":"# clustering, making pickup bins and grouping by pickup cluster and pickup bins\nframe_with_durations_outliers_removed['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']])\njan_2015_frame = add_pickup_bins(frame_with_durations_outliers_removed,1,2015)\njan_2015_groupby = jan_2015_frame[['pickup_cluster','pickup_bins','trip_distance']].groupby(['pickup_cluster','pickup_bins']).count()","f9a31d07":"# I add two more columns 'pickup_cluster'(to which cluster it belogns to) \n# and 'pickup_bins' (to which 10min intravel the trip belongs to)\njan_2015_frame.head()","89064eb8":"# hear the trip_distance represents the number of pickups that are happend in that particular 10min intravel\n# this data frame has two indices\n# primary index: pickup_cluster (cluster number)\n# secondary index : pickup_bins (we devid whole months time into 10min intravels 24*31*60\/10 =4464bins)\njan_2015_groupby.head()","1dba19f6":"# upto now I cleaned data and prepared data for the month 2015,\n\n# now do the same operations for months Jan, Feb, March of 2016\n# 1. get the dataframe which inlcudes only required colums\n# 2. adding trip times, speed, unix time stamp of pickup_time\n# 4. remove the outliers based on trip_times, speed, trip_duration, total_amount\n# 5. add pickup_cluster to each data point\n# 6. add pickup_bin (index of 10min intravel to which that trip belongs to)\n# 7. group by data, based on 'pickup_cluster' and 'pickuo_bin'\n\n# Data Preparation for the months of Jan,Feb and March 2016\ndef datapreparation(month,kmeans,month_no,year_no):\n    \n    print (\"Return with trip times..\")\n\n    frame_with_durations = return_with_trip_times(month)\n    \n    print (\"Remove outliers..\")\n    frame_with_durations_outliers_removed = remove_outliers(frame_with_durations)\n    \n    print (\"Estimating clusters..\")\n    frame_with_durations_outliers_removed['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed[['pickup_latitude', 'pickup_longitude']])\n    #frame_with_durations_outliers_removed_2016['pickup_cluster'] = kmeans.predict(frame_with_durations_outliers_removed_2016[['pickup_latitude', 'pickup_longitude']])\n\n    print (\"Final groupbying..\")\n    final_updated_frame = add_pickup_bins(frame_with_durations_outliers_removed,month_no,year_no)\n    final_groupby_frame = final_updated_frame[['pickup_cluster','pickup_bins','trip_distance']].groupby(['pickup_cluster','pickup_bins']).count()\n    \n    return final_updated_frame,final_groupby_frame\n    \nmonth_jan_2016 = dd.read_csv('yellow_tripdata_2016-01.csv')\nmonth_feb_2016 = dd.read_csv('yellow_tripdata_2016-02.csv')\nmonth_mar_2016 = dd.read_csv('yellow_tripdata_2016-03.csv')\n\njan_2016_frame,jan_2016_groupby = datapreparation(month_jan_2016,kmeans,1,2016)\nfeb_2016_frame,feb_2016_groupby = datapreparation(month_feb_2016,kmeans,2,2016)\nmar_2016_frame,mar_2016_groupby = datapreparation(month_mar_2016,kmeans,3,2016)","28f29152":"# Gets the unique bins where pickup values are present for each each reigion\n\n# for each cluster region we will collect all the indices of 10min intravels in which the pickups are happened\n# I got an observation that there are some pickpbins that doesnt have any pickups\ndef return_unq_pickup_bins(frame):\n    values = []\n    for i in range(0,40):\n        new = frame[frame['pickup_cluster'] == i]\n        list_unq = list(set(new['pickup_bins']))\n        list_unq.sort()\n        values.append(list_unq)\n    return values","0925cfeb":"# for every month we get all indices of 10min intravels in which atleast one pickup got happened\n\n#jan\njan_2015_unique = return_unq_pickup_bins(jan_2015_frame)\njan_2016_unique = return_unq_pickup_bins(jan_2016_frame)\n\n#feb\nfeb_2016_unique = return_unq_pickup_bins(feb_2016_frame)\n\n#march\nmar_2016_unique = return_unq_pickup_bins(mar_2016_frame)","a95437e0":"# for each cluster number of 10min intravels with 0 pickups\nfor i in range(40):\n    print(\"for the \",i,\"th cluster number of 10min intavels with zero pickups: \",4464 - len(set(jan_2015_unique[i])))\n    print('-'*60)","029c6e5f":"# Fills a value of zero for every bin where no pickup data is present \n# the count_values: number pickps that are happened in each region for each 10min intravel\n# there wont be any value if there are no picksups.\n# values: number of unique bins\n\n# for every 10min intravel(pickup_bin) we will check it is there in our unique bin,\n# if it is there we will add the count_values[index] to smoothed data\n# if not we add 0 to the smoothed data\n# we finally return smoothed data\ndef fill_missing(count_values,values):\n    smoothed_regions=[]\n    ind=0\n    for r in range(0,40):\n        smoothed_bins=[]\n        for i in range(4464):\n            if i in values[r]:\n                smoothed_bins.append(count_values[ind])\n                ind+=1\n            else:\n                smoothed_bins.append(0)\n        smoothed_regions.extend(smoothed_bins)\n    return smoothed_regions","597b9192":"# Fills a value of zero for every bin where no pickup data is present \n# the count_values: number pickps that are happened in each region for each 10min intravel\n# there wont be any value if there are no picksups.\n# values: number of unique bins\n\n# for every 10min intravel(pickup_bin) we will check it is there in our unique bin,\n# if it is there we will add the count_values[index] to smoothed data\n# if not we add smoothed data (which is calculated based on the methods that are discussed in the above markdown cell)\n# we finally return smoothed data\ndef smoothing(count_values,values):\n    smoothed_regions=[] # stores list of final smoothed values of each reigion\n    ind=0\n    repeat=0 \n    smoothed_value=0\n    for r in range(0,40):\n        smoothed_bins=[] #stores the final smoothed values\n        repeat=0\n        for i in range(4464):\n            if repeat!=0: # prevents iteration for a value which is already visited\/resolved\n                repeat-=1\n                continue\n            if i in values[r]: #checks if the pickup-bin exists \n                smoothed_bins.append(count_values[ind]) # appends the value of the pickup bin if it exists\n            else:\n                if i!=0:\n                    right_hand_limit=0\n                    for j in range(i,4464):\n                        if  j not in values[r]: #searches for the left-limit or the pickup-bin value which has a pickup value\n                            continue\n                        else:\n                            right_hand_limit=j\n                            break\n                    if right_hand_limit==0:\n                    #Case 1: When we have the last\/last few values are found to be missing,hence we have no right-limit here\n                        smoothed_value=count_values[ind-1]*1.0\/((4463-i)+2)*1.0                               \n                        for j in range(i,4464):                              \n                            smoothed_bins.append(math.ceil(smoothed_value))\n                        smoothed_bins[i-1] = math.ceil(smoothed_value)\n                        repeat=(4463-i)\n                        ind-=1\n                    else:\n                    #Case 2: When we have the missing values between two known values\n                        smoothed_value=(count_values[ind-1]+count_values[ind])*1.0\/((right_hand_limit-i)+2)*1.0             \n                        for j in range(i,right_hand_limit+1):\n                            smoothed_bins.append(math.ceil(smoothed_value))\n                        smoothed_bins[i-1] = math.ceil(smoothed_value)\n                        repeat=(right_hand_limit-i)\n                else:\n                    #Case 3: When we have the first\/first few values are found to be missing,hence we have no left-limit here\n                    right_hand_limit=0\n                    for j in range(i,4464):\n                        if  j not in values[r]:\n                            continue\n                        else:\n                            right_hand_limit=j\n                            break\n                    smoothed_value=count_values[ind]*1.0\/((right_hand_limit-i)+1)*1.0\n                    for j in range(i,right_hand_limit+1):\n                            smoothed_bins.append(math.ceil(smoothed_value))\n                    repeat=(right_hand_limit-i)\n            ind+=1\n        smoothed_regions.extend(smoothed_bins)\n    return smoothed_regions\n","aa9ca0ec":"#Filling Missing values of Jan-2015 with 0\n# here in jan_2015_groupby dataframe the trip_distance represents the number of pickups that are happened\njan_2015_fill = fill_missing(jan_2015_groupby['trip_distance'].values,jan_2015_unique)\n\n#Smoothing Missing values of Jan-2015\njan_2015_smooth = smoothing(jan_2015_groupby['trip_distance'].values,jan_2015_unique)","866149e4":"# number of 10min indices for jan 2015= 24*31*60\/10 = 4464\n# number of 10min indices for jan 2016 = 24*31*60\/10 = 4464\n# number of 10min indices for feb 2016 = 24*29*60\/10 = 4176\n# number of 10min indices for march 2016 = 24*30*60\/10 = 4320\n# for each cluster we will have 4464 values, therefore 40*4464 = 178560 (length of the jan_2015_fill)\nprint(\"number of 10min intravels among all the clusters \",len(jan_2015_fill))","06202722":"# Smoothing vs Filling\n# sample plot that shows two variations of filling missing values\n# we have taken the number of pickups for cluster region 2\nplt.figure(figsize=(10,5))\nplt.plot(jan_2015_fill[4464:8920], label=\"zero filled values\")\nplt.plot(jan_2015_smooth[4464:8920], label=\"filled with avg values\")\nplt.legend()\nplt.show()","f8d89cf5":"# why I choose, these methods and which method is used for which data?\n\n# Ans: consider we have data of some month in 2015 jan 1st, 10 _ _ _ 20, i.e there are 10 pickups that are happened in 1st \n# 10st 10min intravel, 0 pickups happened in 2nd 10mins intravel, 0 pickups happened in 3rd 10min intravel \n# and 20 pickups happened in 4th 10min intravel.\n# in fill_missing method we replace these values like 10, 0, 0, 20\n# where as in smoothing method we replace these values as 6,6,6,6,6, if you can check the number of pickups \n# that are happened in the first 40min are same in both cases, but if you can observe that we looking at the future values \n# wheen you are using smoothing we are looking at the future number of pickups which might cause a data leakage.\n\n# so we use smoothing for jan 2015th data since it acts as our training data\n# and we use simple fill_misssing method for 2016th data.","b2590f63":"# Jan-2015 data is smoothed, Jan,Feb & March 2016 data missing values are filled with zero\njan_2015_smooth = smoothing(jan_2015_groupby['trip_distance'].values,jan_2015_unique)\njan_2016_smooth = fill_missing(jan_2016_groupby['trip_distance'].values,jan_2016_unique)\nfeb_2016_smooth = fill_missing(feb_2016_groupby['trip_distance'].values,feb_2016_unique)\nmar_2016_smooth = fill_missing(mar_2016_groupby['trip_distance'].values,mar_2016_unique)\n\n# Making list of all the values of pickup data in every bin for a period of 3 months and storing them region-wise \nregions_cum = []\n\n# a =[1,2,3]\n# b = [2,3,4]\n# a+b = [1, 2, 3, 2, 3, 4]\n\n# number of 10min indices for jan 2015= 24*31*60\/10 = 4464\n# number of 10min indices for jan 2016 = 24*31*60\/10 = 4464\n# number of 10min indices for feb 2016 = 24*29*60\/10 = 4176\n# number of 10min indices for march 2016 = 24*31*60\/10 = 4464\n# regions_cum: it will contain 40 lists, each list will contain 4464+4176+4464 values which represents the number of pickups \n# that are happened for three months in 2016 data\n\nfor i in range(0,40):\n    regions_cum.append(jan_2016_smooth[4464*i:4464*(i+1)]+feb_2016_smooth[4176*i:4176*(i+1)]+mar_2016_smooth[4464*i:4464*(i+1)])\n\n# print(len(regions_cum))\n# 40\n# print(len(regions_cum[0]))\n# 13104","d04390f5":"def uniqueish_color():\n    \"\"\"There're better ways to generate unique colors, but this isn't awful.\"\"\"\n    return plt.cm.gist_ncar(np.random.random())\nfirst_x = list(range(0,4464))\nsecond_x = list(range(4464,8640))\nthird_x = list(range(8640,13104))\nfor i in range(40):\n    plt.figure(figsize=(10,4))\n    plt.plot(first_x,regions_cum[i][:4464], color=uniqueish_color(), label='2016 Jan month data')\n    plt.plot(second_x,regions_cum[i][4464:8640], color=uniqueish_color(), label='2016 feb month data')\n    plt.plot(third_x,regions_cum[i][8640:], color=uniqueish_color(), label='2016 march month data')\n    plt.legend()\n    plt.show()","232ac3aa":"\nY    = np.fft.fft(np.array(jan_2016_smooth)[0:4460])\nfreq = np.fft.fftfreq(4460, 1)\nn = len(freq)\nplt.figure()\nplt.plot( freq[:int(n\/2)], np.abs(Y)[:int(n\/2)] )\nplt.xlabel(\"Frequency\")\nplt.ylabel(\"Amplitude\")\nplt.show()","a0bd498f":"#Preparing the Dataframe only with x(i) values as jan-2015 data and y(i) values as jan-2016\nratios_jan = pd.DataFrame()\nratios_jan['Given']=jan_2015_smooth\nratios_jan['Prediction']=jan_2016_smooth\nratios_jan['Ratios']=ratios_jan['Prediction']*1.0\/ratios_jan['Given']*1.0","dad819cd":"def MA_R_Predictions(ratios,month):\n    predicted_ratio=(ratios['Ratios'].values)[0]\n    error=[]\n    predicted_values=[]\n    window_size=3\n    predicted_ratio_values=[]\n    for i in range(0,4464*40):\n        if i%4464==0:\n            predicted_ratio_values.append(0)\n            predicted_values.append(0)\n            error.append(0)\n            continue\n        predicted_ratio_values.append(predicted_ratio)\n        predicted_values.append(int(((ratios['Given'].values)[i])*predicted_ratio))\n        error.append(abs((math.pow(int(((ratios['Given'].values)[i])*predicted_ratio)-(ratios['Prediction'].values)[i],1))))\n        if i+1>=window_size:\n            predicted_ratio=sum((ratios['Ratios'].values)[(i+1)-window_size:(i+1)])\/window_size\n        else:\n            predicted_ratio=sum((ratios['Ratios'].values)[0:(i+1)])\/(i+1)\n            \n    \n    ratios['MA_R_Predicted'] = predicted_values\n    ratios['MA_R_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","11b3fb8f":"def MA_P_Predictions(ratios,month):\n    predicted_value=(ratios['Prediction'].values)[0]\n    error=[]\n    predicted_values=[]\n    window_size=1\n    predicted_ratio_values=[]\n    for i in range(0,4464*40):\n        predicted_values.append(predicted_value)\n        error.append(abs((math.pow(predicted_value-(ratios['Prediction'].values)[i],1))))\n        if i+1>=window_size:\n            predicted_value=int(sum((ratios['Prediction'].values)[(i+1)-window_size:(i+1)])\/window_size)\n        else:\n            predicted_value=int(sum((ratios['Prediction'].values)[0:(i+1)])\/(i+1))\n            \n    ratios['MA_P_Predicted'] = predicted_values\n    ratios['MA_P_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","4b034bcf":"def WA_R_Predictions(ratios,month):\n    predicted_ratio=(ratios['Ratios'].values)[0]\n    alpha=0.5\n    error=[]\n    predicted_values=[]\n    window_size=5\n    predicted_ratio_values=[]\n    for i in range(0,4464*40):\n        if i%4464==0:\n            predicted_ratio_values.append(0)\n            predicted_values.append(0)\n            error.append(0)\n            continue\n        predicted_ratio_values.append(predicted_ratio)\n        predicted_values.append(int(((ratios['Given'].values)[i])*predicted_ratio))\n        error.append(abs((math.pow(int(((ratios['Given'].values)[i])*predicted_ratio)-(ratios['Prediction'].values)[i],1))))\n        if i+1>=window_size:\n            sum_values=0\n            sum_of_coeff=0\n            for j in range(window_size,0,-1):\n                sum_values += j*(ratios['Ratios'].values)[i-window_size+j]\n                sum_of_coeff+=j\n            predicted_ratio=sum_values\/sum_of_coeff\n        else:\n            sum_values=0\n            sum_of_coeff=0\n            for j in range(i+1,0,-1):\n                sum_values += j*(ratios['Ratios'].values)[j-1]\n                sum_of_coeff+=j\n            predicted_ratio=sum_values\/sum_of_coeff\n            \n    ratios['WA_R_Predicted'] = predicted_values\n    ratios['WA_R_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","5e63a979":"def WA_P_Predictions(ratios,month):\n    predicted_value=(ratios['Prediction'].values)[0]\n    error=[]\n    predicted_values=[]\n    window_size=2\n    for i in range(0,4464*40):\n        predicted_values.append(predicted_value)\n        error.append(abs((math.pow(predicted_value-(ratios['Prediction'].values)[i],1))))\n        if i+1>=window_size:\n            sum_values=0\n            sum_of_coeff=0\n            for j in range(window_size,0,-1):\n                sum_values += j*(ratios['Prediction'].values)[i-window_size+j]\n                sum_of_coeff+=j\n            predicted_value=int(sum_values\/sum_of_coeff)\n\n        else:\n            sum_values=0\n            sum_of_coeff=0\n            for j in range(i+1,0,-1):\n                sum_values += j*(ratios['Prediction'].values)[j-1]\n                sum_of_coeff+=j\n            predicted_value=int(sum_values\/sum_of_coeff)\n    \n    ratios['WA_P_Predicted'] = predicted_values\n    ratios['WA_P_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","5d718682":"def EA_R1_Predictions(ratios,month):\n    predicted_ratio=(ratios['Ratios'].values)[0]\n    alpha=0.6\n    error=[]\n    predicted_values=[]\n    predicted_ratio_values=[]\n    for i in range(0,4464*40):\n        if i%4464==0:\n            predicted_ratio_values.append(0)\n            predicted_values.append(0)\n            error.append(0)\n            continue\n        predicted_ratio_values.append(predicted_ratio)\n        predicted_values.append(int(((ratios['Given'].values)[i])*predicted_ratio))\n        error.append(abs((math.pow(int(((ratios['Given'].values)[i])*predicted_ratio)-(ratios['Prediction'].values)[i],1))))\n        predicted_ratio = (alpha*predicted_ratio) + (1-alpha)*((ratios['Ratios'].values)[i])\n    \n    ratios['EA_R1_Predicted'] = predicted_values\n    ratios['EA_R1_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","3e9e872c":"def EA_P1_Predictions(ratios,month):\n    predicted_value= (ratios['Prediction'].values)[0]\n    alpha=0.3\n    error=[]\n    predicted_values=[]\n    for i in range(0,4464*40):\n        if i%4464==0:\n            predicted_values.append(0)\n            error.append(0)\n            continue\n        predicted_values.append(predicted_value)\n        error.append(abs((math.pow(predicted_value-(ratios['Prediction'].values)[i],1))))\n        predicted_value =int((alpha*predicted_value) + (1-alpha)*((ratios['Prediction'].values)[i]))\n    \n    ratios['EA_P1_Predicted'] = predicted_values\n    ratios['EA_P1_Error'] = error\n    mape_err = (sum(error)\/len(error))\/(sum(ratios['Prediction'].values)\/len(ratios['Prediction'].values))\n    mse_err = sum([e**2 for e in error])\/len(error)\n    return ratios,mape_err,mse_err","0fe8b5ef":"mean_err=[0]*10\nmedian_err=[0]*10\nratios_jan,mean_err[0],median_err[0]=MA_R_Predictions(ratios_jan,'jan')\nratios_jan,mean_err[1],median_err[1]=MA_P_Predictions(ratios_jan,'jan')\nratios_jan,mean_err[2],median_err[2]=WA_R_Predictions(ratios_jan,'jan')\nratios_jan,mean_err[3],median_err[3]=WA_P_Predictions(ratios_jan,'jan')\nratios_jan,mean_err[4],median_err[4]=EA_R1_Predictions(ratios_jan,'jan')\nratios_jan,mean_err[5],median_err[5]=EA_P1_Predictions(ratios_jan,'jan')","4e18f9a1":"print (\"Error Metric Matrix (Forecasting Methods) - MAPE & MSE\")\nprint (\"--------------------------------------------------------------------------------------------------------\")\nprint (\"Moving Averages (Ratios) -                             MAPE: \",mean_err[0],\"      MSE: \",median_err[0])\nprint (\"Moving Averages (2016 Values) -                        MAPE: \",mean_err[1],\"       MSE: \",median_err[1])\nprint (\"--------------------------------------------------------------------------------------------------------\")\nprint (\"Weighted Moving Averages (Ratios) -                    MAPE: \",mean_err[2],\"      MSE: \",median_err[2])\nprint (\"Weighted Moving Averages (2016 Values) -               MAPE: \",mean_err[3],\"      MSE: \",median_err[3])\nprint (\"--------------------------------------------------------------------------------------------------------\")\nprint (\"Exponential Moving Averages (Ratios) -              MAPE: \",mean_err[4],\"      MSE: \",median_err[4])\nprint (\"Exponential Moving Averages (2016 Values) -         MAPE: \",mean_err[5],\"      MSE: \",median_err[5])","6a4da661":"# Preparing data to be split into train and test, The below prepares data in cumulative form which will be later split into test and train\n# number of 10min indices for jan 2015= 24*31*60\/10 = 4464\n# number of 10min indices for jan 2016 = 24*31*60\/10 = 4464\n# number of 10min indices for feb 2016 = 24*29*60\/10 = 4176\n# number of 10min indices for march 2016 = 24*31*60\/10 = 4464\n# regions_cum: it will contain 40 lists, each list will contain 4464+4176+4464 values which represents the number of pickups \n# that are happened for three months in 2016 data\n\n# print(len(regions_cum))\n# 40\n# print(len(regions_cum[0]))\n# 12960\n\n# we take number of pickups that are happened in last 5 10min intravels\nnumber_of_time_stamps = 5\n\n# output varaible\n# it is list of lists\n# it will contain number of pickups 13099 for each cluster\noutput = []\n\n\n# tsne_lat will contain 13104-5=13099 times lattitude of cluster center for every cluster\n# Ex: [[cent_lat 13099times],[cent_lat 13099times], [cent_lat 13099times].... 40 lists]\n# it is list of lists\ntsne_lat = []\n\n\n# tsne_lon will contain 13104-5=13099 times logitude of cluster center for every cluster\n# Ex: [[cent_long 13099times],[cent_long 13099times], [cent_long 13099times].... 40 lists]\n# it is list of lists\ntsne_lon = []\n\n# we will code each day \n# sunday = 0, monday=1, tue = 2, wed=3, thur=4, fri=5,sat=6\n# for every cluster we will be adding 13099 values, each value represent to which day of the week that pickup bin belongs to\n# it is list of lists\ntsne_weekday = []\n\n# its an numbpy array, of shape (523960, 5)\n# each row corresponds to an entry in out data\n# for the first row we will have [f0,f1,f2,f3,f4] fi=number of pickups happened in i+1th 10min intravel(bin)\n# the second row will have [f1,f2,f3,f4,f5]\n# the third row will have [f2,f3,f4,f5,f6]\n# and so on...\ntsne_feature = []\n\n\ntsne_feature = [0]*number_of_time_stamps\nfor i in range(0,40):\n    tsne_lat.append([kmeans.cluster_centers_[i][0]]*13099)\n    tsne_lon.append([kmeans.cluster_centers_[i][1]]*13099)\n    # jan 1st 2016 is thursday, so we start our day from 4: \"(int(k\/144))%7+4\"\n    # our prediction start from 5th 10min intravel since we need to have number of pickups that are happened in last 5 pickup bins\n    tsne_weekday.append([int(((int(k\/144))%7+4)%7) for k in range(5,4464+4176+4464)])\n    # regions_cum is a list of lists [[x1,x2,x3..x13104], [x1,x2,x3..x13104], [x1,x2,x3..x13104], [x1,x2,x3..x13104], [x1,x2,x3..x13104], .. 40 lsits]\n    tsne_feature = np.vstack((tsne_feature, [regions_cum[i][r:r+number_of_time_stamps] for r in range(0,len(regions_cum[i])-number_of_time_stamps)]))\n    output.append(regions_cum[i][5:])\ntsne_feature = tsne_feature[1:]","c6bb4ef8":"len(tsne_lat[0])*len(tsne_lat) == tsne_feature.shape[0] == len(tsne_weekday)*len(tsne_weekday[0]) == 40*13099 == len(output)*len(output[0])","26cacf9a":"# Getting the predictions of exponential moving averages to be used as a feature in cumulative form\n\n# upto now we computed 8 features for every data point that starts from 50th min of the day\n# 1. cluster center lattitude\n# 2. cluster center longitude\n# 3. day of the week \n# 4. f_t_1: number of pickups that are happened previous t-1th 10min intravel\n# 5. f_t_2: number of pickups that are happened previous t-2th 10min intravel\n# 6. f_t_3: number of pickups that are happened previous t-3th 10min intravel\n# 7. f_t_4: number of pickups that are happened previous t-4th 10min intravel\n# 8. f_t_5: number of pickups that are happened previous t-5th 10min intravel\n\n# from the baseline models we said the exponential weighted moving avarage gives us the best error\n# we will try to add the same exponential weighted moving avarage at t as a feature to our data\n# exponential weighted moving avarage => p'(t) = alpha*p'(t-1) + (1-alpha)*P(t-1) \nalpha=0.3\n\n# it is a temporary array that store exponential weighted moving avarage for each 10min intravel, \n# for each cluster it will get reset\n# for every cluster it contains 13104 values\npredicted_values=[]\n\n# it is similar like tsne_lat\n# it is list of lists\n# predict_list is a list of lists [[x5,x6,x7..x13104], [x5,x6,x7..x13104], [x5,x6,x7..x13104], [x5,x6,x7..x13104], [x5,x6,x7..x13104], .. 40 lsits]\npredict_list = []\ntsne_flat_exp_avg = []\nfor r in range(0,40):\n    for i in range(0,13104):\n        if i==0:\n            predicted_value= regions_cum[r][0]\n            predicted_values.append(0)\n            continue\n        predicted_values.append(predicted_value)\n        predicted_value =int((alpha*predicted_value) + (1-alpha)*(regions_cum[r][i]))\n    predict_list.append(predicted_values[5:])\n    predicted_values=[]","133e7258":"# train, test split : 70% 30% split\n# Before we start predictions using the tree based regression models we take 3 months of 2016 pickup data \n# and split it such that for every region we have 70% data in train and 30% in test,\n# ordered date-wise for every region\nprint(\"size of train data :\", int(13099*0.7))\nprint(\"size of test data :\", int(13099*0.3))","7df9a255":"# extracting first 9169 timestamp values i.e 70% of 13099 (total timestamps) for our training data\ntrain_features =  [tsne_feature[i*13099:(13099*i+9169)] for i in range(0,40)]\n# temp = [0]*(12955 - 9068)\ntest_features = [tsne_feature[(13099*(i))+9169:13099*(i+1)] for i in range(0,40)]","63e7c5b0":"print(\"Number of data clusters\",len(train_features), \"Number of data points in trian data\", len(train_features[0]), \"Each data point contains\", len(train_features[0][0]),\"features\")\nprint(\"Number of data clusters\",len(train_features), \"Number of data points in test data\", len(test_features[0]), \"Each data point contains\", len(test_features[0][0]),\"features\")","2f6ba6dd":"# extracting first 9169 timestamp values i.e 70% of 13099 (total timestamps) for our training data\ntsne_train_flat_lat = [i[:9169] for i in tsne_lat]\ntsne_train_flat_lon = [i[:9169] for i in tsne_lon]\ntsne_train_flat_weekday = [i[:9169] for i in tsne_weekday]\ntsne_train_flat_output = [i[:9169] for i in output]\ntsne_train_flat_exp_avg = [i[:9169] for i in predict_list]","a56a562e":"# extracting the rest of the timestamp values i.e 30% of 12956 (total timestamps) for our test data\ntsne_test_flat_lat = [i[9169:] for i in tsne_lat]\ntsne_test_flat_lon = [i[9169:] for i in tsne_lon]\ntsne_test_flat_weekday = [i[9169:] for i in tsne_weekday]\ntsne_test_flat_output = [i[9169:] for i in output]\ntsne_test_flat_exp_avg = [i[9169:] for i in predict_list]","423e24db":"# the above contains values in the form of list of lists (i.e. list of values of each region), here we make all of them in one list\ntrain_new_features = []\nfor i in range(0,40):\n    train_new_features.extend(train_features[i])\ntest_new_features = []\nfor i in range(0,40):\n    test_new_features.extend(test_features[i])","d8440469":"# converting lists of lists into sinle list i.e flatten\n# a  = [[1,2,3,4],[4,6,7,8]]\n# print(sum(a,[]))\n# [1, 2, 3, 4, 4, 6, 7, 8]\n\ntsne_train_lat = sum(tsne_train_flat_lat, [])\ntsne_train_lon = sum(tsne_train_flat_lon, [])\ntsne_train_weekday = sum(tsne_train_flat_weekday, [])\ntsne_train_output = sum(tsne_train_flat_output, [])\ntsne_train_exp_avg = sum(tsne_train_flat_exp_avg,[])","ad5e1b38":"# converting lists of lists into sinle list i.e flatten\n# a  = [[1,2,3,4],[4,6,7,8]]\n# print(sum(a,[]))\n# [1, 2, 3, 4, 4, 6, 7, 8]\n\ntsne_test_lat = sum(tsne_test_flat_lat, [])\ntsne_test_lon = sum(tsne_test_flat_lon, [])\ntsne_test_weekday = sum(tsne_test_flat_weekday, [])\ntsne_test_output = sum(tsne_test_flat_output, [])\ntsne_test_exp_avg = sum(tsne_test_flat_exp_avg,[])","82adb839":"# Preparing the data frame for our train data\ncolumns = ['ft_5','ft_4','ft_3','ft_2','ft_1']\ndf_train = pd.DataFrame(data=train_new_features, columns=columns) \ndf_train['lat'] = tsne_train_lat\ndf_train['lon'] = tsne_train_lon\ndf_train['weekday'] = tsne_train_weekday\ndf_train['exp_avg'] = tsne_train_exp_avg\n\nprint(df_train.shape)","85eaf1b1":"# Preparing the data frame for our train data\ndf_test = pd.DataFrame(data=test_new_features, columns=columns) \ndf_test['lat'] = tsne_test_lat\ndf_test['lon'] = tsne_test_lon\ndf_test['weekday'] = tsne_test_weekday\ndf_test['exp_avg'] = tsne_test_exp_avg\nprint(df_test.shape)","71a15033":"df_test.head()","a72b87b8":"from sklearn.linear_model import LinearRegression\nlr_reg=LinearRegression().fit(df_train, tsne_train_output)\n\ny_pred = lr_reg.predict(df_test)\nlr_test_predictions = [round(value) for value in y_pred]\ny_pred = lr_reg.predict(df_train)\nlr_train_predictions = [round(value) for value in y_pred]","f8e215d6":"regr1 = RandomForestRegressor(max_features='sqrt',min_samples_leaf=4,min_samples_split=3,n_estimators=40, n_jobs=-1)\nregr1.fit(df_train, tsne_train_output)","51fa216f":"# Predicting on test data using our trained random forest model \n\n# the models regr1 is already hyper parameter tuned\n# the parameters that we got above are found using grid search\n\ny_pred = regr1.predict(df_test)\nrndf_test_predictions = [round(value) for value in y_pred]\ny_pred = regr1.predict(df_train)\nrndf_train_predictions = [round(value) for value in y_pred]","20227603":"#feature importances based on analysis using random forest\nprint (df_train.columns)\nprint (regr1.feature_importances_)","76b96526":"x_model = xgb.XGBRegressor(\n learning_rate =0.1,\n n_estimators=1000,\n max_depth=3,\n min_child_weight=3,\n gamma=0,\n subsample=0.8,\n reg_alpha=200, reg_lambda=200,\n colsample_bytree=0.8,nthread=4)\nx_model.fit(df_train, tsne_train_output)","9dc9bd00":"#predicting with our trained Xg-Boost regressor\n# the models x_model is already hyper parameter tuned\n# the parameters that we got above are found using grid search\n\ny_pred = x_model.predict(df_test)\nxgb_test_predictions = [round(value) for value in y_pred]\ny_pred = x_model.predict(df_train)\nxgb_train_predictions = [round(value) for value in y_pred]","2b766ab2":"#feature importances\nx_model.booster().get_score(importance_type='weight')","2b3ba466":"train_mape=[]\ntest_mape=[]\n\ntrain_mape.append((mean_absolute_error(tsne_train_output,df_train['ft_1'].values))\/(sum(tsne_train_output)\/len(tsne_train_output)))\ntrain_mape.append((mean_absolute_error(tsne_train_output,df_train['exp_avg'].values))\/(sum(tsne_train_output)\/len(tsne_train_output)))\ntrain_mape.append((mean_absolute_error(tsne_train_output,rndf_train_predictions))\/(sum(tsne_train_output)\/len(tsne_train_output)))\ntrain_mape.append((mean_absolute_error(tsne_train_output, xgb_train_predictions))\/(sum(tsne_train_output)\/len(tsne_train_output)))\ntrain_mape.append((mean_absolute_error(tsne_train_output, lr_train_predictions))\/(sum(tsne_train_output)\/len(tsne_train_output)))\n\ntest_mape.append((mean_absolute_error(tsne_test_output, df_test['ft_1'].values))\/(sum(tsne_test_output)\/len(tsne_test_output)))\ntest_mape.append((mean_absolute_error(tsne_test_output, df_test['exp_avg'].values))\/(sum(tsne_test_output)\/len(tsne_test_output)))\ntest_mape.append((mean_absolute_error(tsne_test_output, rndf_test_predictions))\/(sum(tsne_test_output)\/len(tsne_test_output)))\ntest_mape.append((mean_absolute_error(tsne_test_output, xgb_test_predictions))\/(sum(tsne_test_output)\/len(tsne_test_output)))\ntest_mape.append((mean_absolute_error(tsne_test_output, lr_test_predictions))\/(sum(tsne_test_output)\/len(tsne_test_output)))","21acbb06":"print (\"Error Metric Matrix (Tree Based Regression Methods) -  MAPE\")\nprint (\"--------------------------------------------------------------------------------------------------------\")\nprint (\"Baseline Model -                             Train: \",train_mape[0],\"      Test: \",test_mape[0])\nprint (\"Exponential Averages Forecasting -           Train: \",train_mape[1],\"      Test: \",test_mape[1])\nprint (\"Linear Regression -                         Train: \",train_mape[3],\"      Test: \",test_mape[3])\nprint (\"Random Forest Regression -                   Train: \",train_mape[2],\"     Test: \",test_mape[2])","69e6398a":"print (\"Error Metric Matrix (Tree Based Regression Methods) -  MAPE\")\nprint (\"--------------------------------------------------------------------------------------------------------\")\nprint (\"Baseline Model -                             Train: \",train_mape[0],\"      Test: \",test_mape[0])\nprint (\"Exponential Averages Forecasting -           Train: \",train_mape[1],\"      Test: \",test_mape[1])\nprint (\"Linear Regression -                         Train: \",train_mape[4],\"      Test: \",test_mape[4])\nprint (\"Random Forest Regression -                   Train: \",train_mape[2],\"     Test: \",test_mape[2])\nprint (\"XgBoost Regression -                         Train: \",train_mape[3],\"      Test: \",test_mape[3])\nprint (\"--------------------------------------------------------------------------------------------------------\")","36943979":"It is inferred from the source https:\/\/www.flickr.com\/places\/info\/2459115 that New York is bounded by the location cordinates(lat,long) - (40.5774, -74.15) & (40.9176,-73.7004) so hence any cordinates not within these cordinates are not considered by us as we are only concerned with dropoffs which are within New York.","78dcefbc":"### Using Linear Regression","e0ad6076":"<b>Observation:-<\/b> As you can see above that there are some points just outside the boundary but there are a few that are in either South america, Mexico or Canada","8b20bf9d":"## Data Cleaning\n\nIn this section I will be doing univariate analysis and removing outlier\/illegitimate values which may be caused due to some error","1a49fd42":"### Simple Moving Averages\nThe First Model used is the Moving Averages Model which uses the previous n values in order to predict the next value <br> ","34ff3450":"### Train-Test Split\nBefore we start predictions using the tree based regression models we take 3 months of 2016 pickup data and split it such that for every region we have 70% data in train and 30% in test, ordered date-wise for every region","86fbbb27":"For the above the Hyperparameter is the window-size (n) which is tuned manually and it is found that the window-size of 1 is optimal for getting the best results using Moving Averages using previous 2016 values therefore we get $\\begin{align}P_{t} = P_{t-1} \\end{align}$","eb046d39":"## Modelling: Baseline Models\n\nNow we get into modelling in order to forecast the pickup densities for the months of Jan, Feb and March of 2016 for which we are using multiple models with two variations \n1. Using Ratios of the 2016 data to the 2015 data i.e $\\begin{align} R_{t} = P^{2016}_{t} \/ P^{2015}_{t} \\end{align}$\n2. Using Previous known values of the 2016 data itself to predict the future values","09fba84b":"### Calculating the error metric values for various models","12d08fcc":"$\\begin{align}R^{'}_{t} = \\alpha*R_{t-1} + (1-\\alpha)*R^{'}_{t-1}  \\end{align}$","a43425a8":"## Remove all outliers\/erronous points.","da4395ef":"### Error Metric Matrix","186c3db4":"<b>Plese Note:-<\/b> The above comparisons are made using Jan 2015 and Jan 2016 only","66886a85":"there are two ways to fill up these values\n<ul>\n<li> Fill the missing value with 0's<\/li>\n<li> Fill the missing values with the avg values\n<ul>\n<li> Case 1:(values missing at the start)  <br>Ex1: \\_ \\_ \\_ x =>ceil(x\/4), ceil(x\/4), ceil(x\/4), ceil(x\/4) <br> Ex2: \\_ \\_ x => ceil(x\/3), ceil(x\/3), ceil(x\/3) <\/li>\n<li> Case 2:(values missing in middle) <br>Ex1: x \\_ \\_ y => ceil((x+y)\/4), ceil((x+y)\/4), ceil((x+y)\/4), ceil((x+y)\/4) <br> Ex2: x \\_ \\_ \\_ y => ceil((x+y)\/5), ceil((x+y)\/5), ceil((x+y)\/5), ceil((x+y)\/5), ceil((x+y)\/5) <\/li>\n<li> Case 3:(values missing at the end)  <br>Ex1: x \\_ \\_ \\_  => ceil(x\/4), ceil(x\/4), ceil(x\/4), ceil(x\/4) <br> Ex2: x \\_  => ceil(x\/2), ceil(x\/2) <\/li>\n<\/ul>\n<\/li>\n<\/ul>","acf61178":"For the above the Hyperparameter is the window-size (n) which is tuned manually and it is found that the window-size of 3 is optimal for getting the best results using Moving Averages using previous Ratio values therefore we get $\\begin{align}R_{t} = ( R_{t-1} + R_{t-2} + R_{t-3})\/3 \\end{align}$","3cb968a7":"<p style=\"font-size:18px\">According to NYC Taxi &amp; Limousine Commision Regulations <b style= \"color:blue\">the maximum allowed trip duration in a 24 hour interval is 12 hours.<\/b> <\/p>","935625c7":"It is inferred from the source https:\/\/www.flickr.com\/places\/info\/2459115 that New York is bounded by the location cordinates(lat,long) - (40.5774, -74.15) & (40.9176,-73.7004) so hence any cordinates not within these cordinates are not considered by us as we are only concerned with pickups which originate within New York.","d486d888":"### 3. Trip Durations:","e8d6ae39":"### 1. Pickup Latitude and Pickup Longitude","dbbc2d0f":"## Time series and Fourier Transforms","f62d5124":"## Time-binning","9963b6d4":"For the above the Hyperparameter is the window-size (n) which is tuned manually and it is found that the window-size of 5 is optimal for getting the best results using Weighted Moving Averages using previous Ratio values therefore we get $\\begin{align} R_{t} = ( 5*R_{t-1} + 4*R_{t-2} + 3*R_{t-3} + 2*R_{t-4} + R_{t-5} )\/15 \\end{align}$","cd3c4737":"# Data Information","a9070497":"### Exponential  Weighted Moving Averages\n https:\/\/en.wikipedia.org\/wiki\/Moving_average#Exponential_moving_average\nThrough weighted averaged we have satisfied the analogy of giving higher weights to the latest value and decreasing weights to the subsequent ones but we still do not know which is the correct weighting scheme as there are infinetly many possibilities in which we can assign weights in a non-increasing order and tune the the hyperparameter window-size. To simplify this process we use Exponential Moving Averages which is a more logical way towards assigning weights and at the same time also using an optimal window-size.\n\nIn exponential moving averages we use a single hyperparameter alpha $\\begin{align}(\\alpha)\\end{align}$ which is a value between 0 & 1 and based on the value of the hyperparameter alpha the weights and the window sizes are configured.<br>\nFor eg. If $\\begin{align}\\alpha=0.9\\end{align}$ then the number of days on which the value of the current iteration is based is~$\\begin{align}1\/(1-\\alpha)=10\\end{align}$ i.e. we consider values 10 days prior before we predict the value for the current iteration. Also the weights are assigned using $\\begin{align}2\/(N+1)=0.18\\end{align}$ ,where N = number of prior values being considered, hence from this it is implied that the first or latest value is assigned a weight of 0.18 which keeps exponentially decreasing for the subsequent values.","a519c0a0":"## Regression Models","96fdbb0d":"# Data Collection\nI have collected all yellow taxi trips data from jan-2015 to dec-2016(Will be using only 2015 data)\n<table>\n<tr>\n<th> file name <\/th>\n<th> file name size<\/th>\n<th> number of records <\/th>\n<th> number of features <\/th>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2016-01 <\/td>\n<td> 1. 59G <\/td>\n<td> 10906858 <\/td>\n<td> 19 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-02 <\/td>\n<td> 1. 66G <\/td>\n<td> 11382049 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2016-03 <\/td>\n<td> 1. 78G <\/td>\n<td> 12210952 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2016-04 <\/td>\n<td> 1. 74G <\/td>\n<td> 11934338 <\/td>\n<td> 19 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-05 <\/td>\n<td> 1. 73G <\/td>\n<td> 11836853 <\/td>\n<td> 19 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-06 <\/td>\n<td> 1. 62G <\/td>\n<td> 11135470 <\/td>\n<td> 19 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-07 <\/td>\n<td> 884Mb <\/td>\n<td> 10294080 <\/td>\n<td> 17 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-08 <\/td>\n<td> 854Mb <\/td>\n<td> 9942263 <\/td>\n<td> 17 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-09 <\/td>\n<td> 870Mb <\/td>\n<td> 10116018 <\/td>\n<td> 17 <\/td>\n<\/tr>\n\n<tr>\n<td> yellow_tripdata_2016-10 <\/td>\n<td> 933Mb <\/td>\n<td> 10854626 <\/td>\n<td> 17 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2016-11 <\/td>\n<td> 868Mb <\/td>\n<td> 10102128 <\/td>\n<td> 17 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2016-12 <\/td>\n<td> 897Mb <\/td>\n<td> 10449408 <\/td>\n<td> 17 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-01 <\/td>\n<td> 1.84Gb <\/td>\n<td> 12748986 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-02 <\/td>\n<td> 1.81Gb <\/td>\n<td> 12450521 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-03 <\/td>\n<td> 1.94Gb <\/td>\n<td> 13351609 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-04 <\/td>\n<td> 1.90Gb <\/td>\n<td> 13071789 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-05 <\/td>\n<td> 1.91Gb <\/td>\n<td> 13158262 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-06 <\/td>\n<td> 1.79Gb <\/td>\n<td> 12324935 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-07 <\/td>\n<td> 1.68Gb <\/td>\n<td> 11562783 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-08 <\/td>\n<td> 1.62Gb <\/td>\n<td> 11130304 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-09 <\/td>\n<td> 1.63Gb <\/td>\n<td> 11225063 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-10 <\/td>\n<td> 1.79Gb <\/td>\n<td> 12315488 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-11 <\/td>\n<td> 1.65Gb <\/td>\n<td> 11312676 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<tr>\n<td> yellow_tripdata_2015-12 <\/td>\n<td> 1.67Gb <\/td>\n<td> 11460573 <\/td>\n<td> 19 <\/td>\n<\/tr>\n<\/table>","952ee5de":"# Data-preperation\n## Clustering\/Segmentation","2f3e9f98":"# ML Problem Formulation\n<p><b> Time-series forecasting and Regression<\/b><\/p>\n<br>\n-<i> To find number of pickups, given location cordinates(latitude and longitude) and time, in the query reigion and surrounding regions.<\/i>\n<p> \nTo solve the above we would be using data collected in Jan - Mar 2015 to predict the pickups in Jan - Mar 2016.\n<\/p>","ebf9929c":"### Using XgBoost Regressor","95b35de2":"Weighted Moving Averages using Previous 2016 Values - $\\begin{align}P_{t} = ( N*P_{t-1} + (N-1)*P_{t-2} + (N-2)*P_{t-3} .... 1*P_{t-n} )\/(N*(N+1)\/2) \\end{align}$","93eafc1b":"# Taxi demand prediction in New York City\n","6b296cb5":"For the above the Hyperparameter is the window-size (n) which is tuned manually and it is found that the window-size of 2 is optimal for getting the best results using Weighted Moving Averages using previous 2016 values therefore we get $\\begin{align} P_{t} = ( 2*P_{t-1} + P_{t-2} )\/3 \\end{align}$","cb2a8cb7":"### 5. Total Fare","210400f3":"### Using Random Forest Regressor","84094619":"From the above matrix it is inferred that the best forecasting model for our prediction would be:-\n$\\begin{align}P^{'}_{t} = \\alpha*P_{t-1} + (1-\\alpha)*P^{'}_{t-1}  \\end{align}$ i.e Exponential Moving Averages using 2016 Values","d8b05542":"### 4. Speed","6e1f1dff":"Weighted Moving Averages using Ratio Values - $\\begin{align}R_{t} = ( N*R_{t-1} + (N-1)*R_{t-2} + (N-2)*R_{t-3} .... 1*R_{t-n} )\/(N*(N+1)\/2) \\end{align}$","46ecfefc":"# Performance metrics\n1. Mean Absolute percentage error.\n2. Mean Squared error.","37950260":"## Information on taxis:\n\n<h5> Yellow Taxi: Yellow Medallion Taxicabs<\/h5>\n<p> These are the famous NYC yellow taxis that provide transportation exclusively through street-hails. The number of taxicabs is limited by a finite number of medallions issued by the TLC. You access this mode of transportation by standing in the street and hailing an available taxi with your hand. The pickups are not pre-arranged.<\/p>\n\n<h5> For Hire Vehicles (FHVs) <\/h5>\n<p> FHV transportation is accessed by a pre-arrangement with a dispatcher or limo company. These FHVs are not permitted to pick up passengers via street hails, as those rides are not considered pre-arranged. <\/p>\n\n<h5> Green Taxi: Street Hail Livery (SHL) <\/h5>\n<p>  The SHL program will allow livery vehicle owners to license and outfit their vehicles with green borough taxi branding, meters, credit card machines, and ultimately the right to accept street hails in addition to pre-arranged rides. <\/p>\n\n<h5>Footnote:<\/h5>\nIn the given notebook we are considering only the yellow taxis for the time period between Jan - Mar 2015 & Jan - Mar 2016","702faed5":"### Plotting the cluster centers:","c196f2a5":"<b style='font-size:16px'>The avg speed in Newyork speed is 12.45miles\/hr, so a cab driver can travel <font color='blue'> 2 miles per 10min on avg.<\/font> <\/b>","a68e35af":"### Weighted Moving Averages\nThe Moving Avergaes Model used gave equal importance to all the values in the window used, but we know intuitively that the future is more likely to be similar to the latest values and less similar to the older values. Weighted Averages converts this analogy into a mathematical relationship giving the highest weight while computing the averages to the latest previous value and decreasing weights to the subsequent older ones<br>","18d4af7a":"$\\begin{align}P^{'}_{t} = \\alpha*P_{t-1} + (1-\\alpha)*P^{'}_{t-1}  \\end{align}$","877130ce":"### 4. Trip Distance","2221cdad":"## Comparison between baseline models\nI have chosen our error metric for comparison between models as <b>MAPE (Mean Absolute Percentage Error)<\/b> so that we can know that on an average how good is our model with predictions and <b>MSE (Mean Squared Error)<\/b> is also used so that we have a clearer understanding as to how well our forecasting model performs with outliers so that we make sure that there is not much of a error margin between our prediction and the actual value","512d36da":"### Plotting the clusters:","eb19008e":"### Inference:\n- The main objective was to find a optimal min. distance(Which roughly estimates to the radius of a cluster) between the clusters which we got was 40","59b775e5":"<b>Observation:-<\/b> As even the 99.9th percentile value doesnt look like an outlier,as there is not much difference between the 99.8th percentile and 99.9th percentile, we move on to do graphical analyis","34e41d80":"<b>Observation:-<\/b> The observations here are similar to those obtained while analysing pickup latitude and longitude","50b9d40d":"### 2. Dropoff Latitude & Dropoff Longitude","145db3ed":"<p>\nGe the data from : http:\/\/www.nyc.gov\/html\/tlc\/html\/about\/trip_record_data.shtml (2016 data)\nThe data used in the attached datasets were collected and provided to the NYC Taxi and Limousine Commission (TLC) \n<\/p>","1e28affd":"## Smoothing","7f1c31b8":"## Features in the dataset:\n<table border=\"1\">\n\t<tr>\n\t\t<th>Field Name<\/th>\n\t\t<th>Description<\/th>\n\t<\/tr>\n\t<tr>\n\t\t<td>VendorID<\/td>\n\t\t<td>\n\t\tA code indicating the TPEP provider that provided the record.\n\t\t<ol>\n\t\t\t<li>Creative Mobile Technologies<\/li>\n\t\t\t<li>VeriFone Inc.<\/li>\n\t\t<\/ol>\n\t\t<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>tpep_pickup_datetime<\/td>\n\t\t<td>The date and time when the meter was engaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>tpep_dropoff_datetime<\/td>\n\t\t<td>The date and time when the meter was disengaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Passenger_count<\/td>\n\t\t<td>The number of passengers in the vehicle. This is a driver-entered value.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Trip_distance<\/td>\n\t\t<td>The elapsed trip distance in miles reported by the taximeter.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Pickup_longitude<\/td>\n\t\t<td>Longitude where the meter was engaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Pickup_latitude<\/td>\n\t\t<td>Latitude where the meter was engaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>RateCodeID<\/td>\n\t\t<td>The final rate code in effect at the end of the trip.\n\t\t<ol>\n\t\t\t<li> Standard rate <\/li>\n\t\t\t<li> JFK <\/li>\n\t\t\t<li> Newark <\/li>\n\t\t\t<li> Nassau or Westchester<\/li>\n\t\t\t<li> Negotiated fare <\/li>\n\t\t\t<li> Group ride<\/li>\n\t\t<\/ol>\n\t\t<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Store_and_fwd_flag<\/td>\n\t\t<td>This flag indicates whether the trip record was held in vehicle memory before sending to the vendor,<br\\> aka \u201cstore and forward,\u201d because the vehicle did not have a connection to the server.\n\t\t<br\\>Y= store and forward trip\n\t\t<br\\>N= not a store and forward trip\n\t\t<\/td>\n\t<\/tr>\n\n\t<tr>\n\t\t<td>Dropoff_longitude<\/td>\n\t\t<td>Longitude where the meter was disengaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Dropoff_ latitude<\/td>\n\t\t<td>Latitude where the meter was disengaged.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Payment_type<\/td>\n\t\t<td>A numeric code signifying how the passenger paid for the trip.\n\t\t<ol>\n\t\t\t<li> Credit card <\/li>\n\t\t\t<li> Cash <\/li>\n\t\t\t<li> No charge <\/li>\n\t\t\t<li> Dispute<\/li>\n\t\t\t<li> Unknown <\/li>\n\t\t\t<li> Voided trip<\/li>\n\t\t<\/ol>\n\t\t<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Fare_amount<\/td>\n\t\t<td>The time-and-distance fare calculated by the meter.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Extra<\/td>\n\t\t<td>Miscellaneous extras and surcharges. Currently, this only includes. the $0.50 and $1 rush hour and overnight charges.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>MTA_tax<\/td>\n\t\t<td>0.50 MTA tax that is automatically triggered based on the metered rate in use.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Improvement_surcharge<\/td>\n\t\t<td>0.30 improvement surcharge assessed trips at the flag drop. the improvement surcharge began being levied in 2015.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Tip_amount<\/td>\n\t\t<td>Tip amount \u2013 This field is automatically populated for credit card tips.Cash tips are not included.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Tolls_amount<\/td>\n\t\t<td>Total amount of all tolls paid in trip.<\/td>\n\t<\/tr>\n\t<tr>\n\t\t<td>Total_amount<\/td>\n\t\t<td>The total amount charged to passengers. Does not include cash tips.<\/td>\n\t<\/tr>\n<\/table>","1315c279":"Next we use the Moving averages of the 2016  values itself to predict the future value using $\\begin{align}P_{t} = ( P_{t-1} + P_{t-2} + P_{t-3} .... P_{t-n} )\/n \\end{align}$","048101fa":"Using Ratio Values - $\\begin{align}R_{t} = ( R_{t-1} + R_{t-2} + R_{t-3} .... R_{t-n} )\/n \\end{align}$"}}