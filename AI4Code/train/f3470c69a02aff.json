{"cell_type":{"f4467fc0":"code","7d838ccf":"code","81a5dbb4":"code","137e3509":"code","240a6811":"code","0c52a4cb":"code","f0de9d4f":"code","31aca20a":"code","0ac84de9":"code","a14246b8":"code","1bb36e02":"code","84b106e6":"code","fa07b45b":"code","2234b035":"code","6e6be66e":"code","6767fbfe":"code","41cff0e6":"code","9a5d60cd":"code","4ca89feb":"code","b7e5c7f2":"code","9c2f9485":"code","dbe467f6":"code","bbe5d0fe":"code","308e6941":"code","7cb1a14e":"code","67cdb67e":"code","c13045c0":"code","e8397d3a":"code","6943ced9":"code","920b12a6":"code","800f83ae":"code","a350142f":"code","fcfd5275":"code","d15ecea2":"markdown","89e20056":"markdown","e1b6d03e":"markdown","bfb6684b":"markdown","ff704f04":"markdown","3e21cbdd":"markdown","befc83b5":"markdown","b8f93bba":"markdown","0c279ebb":"markdown","4f9e5394":"markdown","24c831a5":"markdown","65d390dd":"markdown","13942e39":"markdown","5f0b13c7":"markdown","843ca2ac":"markdown","fc431067":"markdown","4315a0f9":"markdown","4377041f":"markdown","f5db7142":"markdown","2c7a392e":"markdown","665ee658":"markdown","4f2e45ce":"markdown","364e5066":"markdown","7dd00039":"markdown","49f23e23":"markdown","cf0caf40":"markdown","8f941d59":"markdown","439a58bb":"markdown"},"source":{"f4467fc0":"import numpy as np\nfrom matplotlib import pyplot","7d838ccf":"u = np.array([1,2])\nu.shape","81a5dbb4":"np.random.seed(42)\nM = np.random.randint(1,5,(2,2))\nM","137e3509":"v = M @ u\nu, v","240a6811":"pyplot.annotate(\"vector u is transformed to v by linear map M\", [2, 9])\n\npyplot.annotate(\"u\", u+0.5)\npyplot.arrow(0, 0, *u, head_width=0.5, head_length=0.5)\n\npyplot.annotate(\"v\", v+0.5)\npyplot.arrow(0, 0, *v, head_width=0.5, head_length=0.5)\n\npyplot.xlim(0, 12)\npyplot.ylim(0, 10)\npyplot.show()","0c52a4cb":"import math\n\ncentre = (2,2)\nPI = math.pi\nn = 10\nr = 1\n\n# circum_vectors are the vector points at the circumference of this unit circle.\ncircum_vectors = [np.array((centre[0] + math.cos(2*PI\/n*x)*r, centre[1] + math.sin(2*PI\/n*x)*r)) for x in range(0,n)]\n\n# Now, we will transform these circum_vectors using M.\ntransformed_vectors = []\nfor v in circum_vectors:\n    transformed_vectors.append(M @ v)\n\n\n# Now, let's visualize how this mapping change the shape of circle.\npyplot.annotate(\"circle\", [1,4])\npyplot.scatter([p[0] for p in circum_vectors], [p[1] for p in circum_vectors])\n\npyplot.annotate(\"transformed ellipse\", [15, 12])\npyplot.scatter([p[0] for p in transformed_vectors], [p[1] for p in transformed_vectors])\n\n\npyplot.annotate(\"circle is transformed to an ellipse by linear map M\", [2, 14])\npyplot.xlim(0, 24)\npyplot.ylim(0, 15)\npyplot.show()","f0de9d4f":"# Let's apply SVD to the linear map M we used earlier.\nU, S, V_T = np.linalg.svd(M)\nU, S , V_T","31aca20a":"# first rotating using V_T\nVT_transformed = []\nfor v in circum_vectors:\n    VT_transformed.append(V_T @ v)\n\n# then scaling using S\nS_transformed = []\nfor v in VT_transformed:\n    S_transformed.append(S * v)\n    \n# then again rotating using U\nU_transformed = []\nfor v in S_transformed:\n    U_transformed.append(U @ v)","0ac84de9":"# Now, let's plot these transformations individually.\n\nfig = pyplot.figure(1, (12, 4))\n\n\nax1 = pyplot.subplot(1,3,1)\nax1.annotate(\"first rotated by V_T\", [-8, 5])\nax1.scatter([p[0] for p in VT_transformed], [p[1] for p in VT_transformed])\nax1.set_xlim(-10, 10)\nax1.set_ylim(-10, 10)\n\nax2 = pyplot.subplot(1,3,2)\nax2.annotate(\"then scaled by S\", [-18, 5])\nax2.scatter([p[0] for p in S_transformed], [p[1] for p in S_transformed], c=\"g\")\nax2.set_xlim(-22, -2)\nax2.set_ylim(-10, 10)\n\nax3 = pyplot.subplot(1,3,3)\nax3.annotate(\"then again rotated by U\", [10, 13])\nax3.scatter([p[0] for p in U_transformed], [p[1] for p in U_transformed], c=\"orange\")\nax3.set_xlim(5, 25)\nax3.set_ylim(-5, 15)\n\n\npyplot.tight_layout()\npyplot.show()","a14246b8":"np.random.seed(42)\n\nIMG = np.random.randint(0,2,(7,7))\nIMG","1bb36e02":"np.linalg.matrix_rank(IMG)","84b106e6":"def plot_img(img):\n    pyplot.imshow(img, cmap=\"gray\")\n    pyplot.xticks([])\n    pyplot.yticks([])\n    pyplot.show()\n    \n    \nplot_img(IMG)","fa07b45b":"# Now, we will decompose this image using SVD.\nU, S, V_T = np.linalg.svd(IMG)\n\nU.shape, S.shape, V_T.shape","2234b035":"with np.printoptions(precision=1):\n    print(\"U: \\n\", U, \"\\n\")\n    print(\"V_T: \\n\", V_T)","6e6be66e":"print(\"S: \", np.around(S, decimals=4))","6767fbfe":"rank_1_images = []\n\nfig = pyplot.figure(1, (16,8))\n\nfor idx,(u,s,v_t) in enumerate(zip(U.T, S, V_T)):\n    ax = pyplot.subplot(1,7,idx+1)\n    rank_1_img = s * np.outer(u, v_t)\n    rank_1_images.append(rank_1_img)\n    ax.imshow(rank_1_img, cmap=\"gray\")\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_title(f\"u{idx+1}*s{idx+1}*vt{idx+1}\")\n    pyplot.tight_layout()","41cff0e6":"IMG_rank1 = S[0] * np.outer(U[:, 0], V_T[0, :])\n\nwith np.printoptions(precision=2):\n    print(\"IMG_rank1: \\n\", IMG_rank1)","9a5d60cd":"plot_img(IMG_rank1)","4ca89feb":"IMG_rank2 = S[0] * np.outer(U[:, 0], V_T[0, :]) + \\\n            S[1] * np.outer(U[:, 1], V_T[1, :])\n\nwith np.printoptions(precision=2):\n    print(\"IMG_rank2: \\n\", IMG_rank2)","b7e5c7f2":"plot_img(IMG_rank2)","9c2f9485":"fig = pyplot.figure(1, (16,8))\n\nfor i in range(1,len(S)+1):\n    best_rank_i_approx = np.zeros_like(IMG, dtype=\"float64\")\n    for j in range(i):\n        best_rank_i_approx += rank_1_images[j]\n        \n    ax = pyplot.subplot(1,7,i)\n    ax.imshow(best_rank_i_approx, cmap=\"gray\")\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_title(f\"best_rank_{i}_approx\")\n    pyplot.tight_layout()","dbe467f6":"# these spaces are in units\n\noriginal_space = 7*7\nprint(\"original space: \", original_space)\n\nbest_rank_3_space = 3*(7+7) + 3\nprint(\"best_rank_3_space: \", best_rank_3_space)\n\nspace_saved = 1 - best_rank_3_space \/ original_space\nprint(f\"space saved: {space_saved * 100} %\")","bbe5d0fe":"import cv2\nimport requests\n\nIMG_URL = \"https:\/\/images.theconversation.com\/files\/350865\/original\/file-20200803-24-50u91u.jpg?ixlib=rb-1.1.0&rect=37%2C29%2C4955%2C3293&q=45&auto=format&w=926&fit=clip\"\n\nimg_data = requests.get(IMG_URL).content\nwith open('image.jpg', 'wb') as handler:\n    handler.write(img_data)\n    \n\nimage = cv2.imread(\"image.jpg\")\nprint(image.shape)\n\nplot_img(image)","308e6941":"IMG_CAT = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n# This image is very large in resolution so I am resizing it to smaller size.\nIMG_CAT = cv2.resize(IMG_CAT, (400, 300))\nprint(IMG_CAT.shape)\n\nplot_img(IMG_CAT)","7cb1a14e":"np.linalg.matrix_rank(IMG_CAT)","67cdb67e":"# Rank of the image is 300 (which is a lot). Let's decompose it.\n\nU, S, V_T = np.linalg.svd(IMG_CAT)\nU.shape, S.shape, V_T.shape","c13045c0":"rank_i_images = []\n\nfig = pyplot.figure(1, (16,4))\n\nfor idx,(u,s,v_t) in enumerate(zip(U.T, S, V_T)):\n    if idx >= 14:\n        break\n    ax = pyplot.subplot(2,7,idx+1)\n    rank_i_img = s * np.outer(u, v_t)\n    rank_i_images.append(rank_i_img)\n    ax.imshow(rank_i_img, cmap=\"gray\")\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_title(f\"u{idx+1}*s{idx+1}*vt{idx+1}\")\n\npyplot.tight_layout()","e8397d3a":"def svd(img, full_matrices=False):\n    U, S, VT = np.linalg.svd(img, full_matrices=full_matrices)\n    return (U, np.diag(S), VT)\n\n\ndef perc_storage(rank, n_rows, n_cols):\n    original_space = n_rows*n_cols\n    compressed_space = n_rows*rank + rank + n_cols*rank\n    return compressed_space \/ original_space * 100\n\n\ndef perc_energy(S, r):\n    return (np.trace(S[:r]) \/ np.trace(S)) * 100","6943ced9":"def get_optimal_rank_by_energy(S, max_energy):\n    max_rank_ = S.shape[0]\n    opt_rank_ = 1\n    \n    while opt_rank_ <= max_rank_:\n        energy = perc_energy(S, opt_rank_)\n        if energy < max_energy:\n            opt_rank_ += 1\n            continue\n        elif energy > max_energy:\n            return opt_rank_ - 1\n        else:\n            return opt_rank_\n    \n\ndef get_optimal_rank_by_storage(S, max_storage):\n    max_rank_ = S.shape[0]\n    opt_rank_ = 1\n    \n    while opt_rank_ <= max_rank_:\n        storage = perc_storage(opt_rank_, *S.shape)\n        if storage < max_storage:\n            opt_rank_ += 1\n            continue\n        if storage > max_storage:\n            return opt_rank_ - 1\n        else:\n            return opt_rank_","920b12a6":"%%time\nU, S_mat, V_T = svd(IMG_CAT)\n\nprint(f'U: {U.shape},   S: {S_mat.shape},   VT: {V_T.shape}')\nprint('\\n')","800f83ae":"%%time\n\nMAX_ENERGY=85 # in percentage\nMAX_STORAGE=30 # in percentage\n\n# We will find the optimal rank using above defined functions.\n\nopt_rank_by_energy = get_optimal_rank_by_energy(S_mat, MAX_ENERGY)\nopt_rank_by_storage = get_optimal_rank_by_storage(S_mat, MAX_STORAGE)\n\nprint(f'optimum rank for {MAX_ENERGY}% energy is {opt_rank_by_energy}')\nprint(f'optimum rank for {MAX_STORAGE}% storage is {opt_rank_by_storage}')\n\nprint(\"\\n\")","a350142f":"%%time\n\nn_rows, n_cols = IMG_CAT.shape\nRANKS = [5, 25, 50, 100, 200]\n\nfig = pyplot.figure(0, (16, 10))\n\nfor idx, r in enumerate(RANKS):\n    X_r = U[:, :r] @ S_mat[:r, :r] @ V_T[:r, :]\n\n    ax = pyplot.subplot(2,3, idx+1)\n    ax.imshow(X_r, cmap='gray')\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    ax.set_title(f'''rank {r}\\nspace required: {round(perc_storage(r, n_rows, n_cols), 2)}%\n    information stored: {round(perc_energy(S_mat, r), 2)}''')\n        \nax = pyplot.subplot(2, 3, idx+2)\nax.imshow(IMG_CAT, cmap='gray')\nax.set_title('original image')\nax.set_xticks([])\nax.set_yticks([])\n\npyplot.tight_layout()","fcfd5275":"fig = pyplot.figure(0, (14, 4))\n\nax1 = pyplot.subplot(1, 3, 1)\nax1.semilogy(np.diag(S))\nax1.set_xlabel('rank')\nax1.set_ylabel('log sigma')\nax1.set_title('rank   v\/s   log_sigma')\n\nax2 = pyplot.subplot(1, 3, 2)\nax2.plot(np.cumsum(np.diag(S) \/ np.sum(np.diag(S))))\nax2.set_xlabel('rank')\nax2.set_ylabel('cumsum sigma')\nax2.set_title('rank   v\/s   information_store')\n\n\nperc_strg = []\nx_ticks = []\nrank = np.linalg.matrix_rank(IMG_CAT)\nfor r in np.linspace(1, rank, 10):\n    x_ticks.append(r)    \n    perc_strg.append(perc_storage(r, n_rows, n_cols))\n\n\nax3 = pyplot.subplot(1, 3, 3)\nax3.plot(x_ticks, perc_strg)\nax3.set_xlabel('rank')\nax3.set_ylabel('% storage_required')\nax3.set_title('rank   v\/s   percentage_storage_required')\n\npyplot.tight_layout()","d15ecea2":"**So, V_T rotated the original circle, then S scaled this rotated circle and finally U again rotate this scaled circle. All are done sequentially.**\n\nSo, we can see that indeed the end result is exactly the same. Note, these images are on different scale(see x ticks), this is done because if we plot all of them on same scale then circle will look very tiny.","89e20056":"We will use these rank 1 images to construct the image close to original image. We do this by cumulative sum of rank 1 images. Also by doing this we increase the rank of the matrix and hence information stored i.e., the constructed image will resemble more close to the original image as we cumulate more and more rank 1 images.\n\n**Note:** At any step that approximated image is the best possible approximation of that rank for that image.","e1b6d03e":"#### Best higher rank approximation\n\nSimilarly, **the best rank i image is the sum of rank (i-1) image and outer product of ui with vi scaled by si**.\n\nWe will **construct best rank i image by cumulating all rank 1 images corresponding to singular values from 1 to i**.\n\n![CodeCogsEqn%284%29.gif](attachment:CodeCogsEqn%284%29.gif)","bfb6684b":"Below are all **rank 1 images.** These are constructed by taking the outer product of columns of U and rows of V_T and then multiplying\/scaling by corresponding sigma value in S.","ff704f04":"Now, we will transform random vector u using linear map M, this will give us transformed vector u which we call as v.","3e21cbdd":"*We can see that rank 50 is a very good approximation, as it contains 75% information content keeping the storage requirement below 30%. So, we get 75% information by reducing 71% space, which is a lot saving keeping the image content very enriched.\n*\n\nMany of us will stop at rank 50 approximation, some of us may go till rank 75 approximation and those you wants more clear image may go till rank 100. But the idea is there is always a trade between **information retained** and **space required**. It depends on your needs, if you want more quality image then you may go to higher rank approximations providing more image space but if space is limited to you then you will stop at initial ranks retaining maximum information in given space limits.\n\n**Below is the plot showing the trade-off of rank with different attributes.**","befc83b5":"# Compressing images using Linear Algebra\n\nWe all have studied some degree of linear algebra in our high school and some of us even studied it rigorously in our graduation. But linear algebra is more power-full then we all thought. It comprises of algorithms\/methods which helps a lot in the real world specially in the study and manipulation of images. Images are one of the highly used medium of communication in today's digital and social world.\n\nWe all share thousands of images, memes etc. to our known ones. But when it comes to sharing large image files we need to compress it such that the size of image got reduced significantly keeping the image quality and content as good as possible. Images are represented as 3 dimensional(2 for height and width and 1 for channel) array\/matrix of pixels, and we all know whenever matrix is coined linear algebra appears automatically.\n\nThis story is divided into following parts -\n* Linear algebra refresher\u00a0\n* visualize what a matrix do to a vector\n* visualize what a matrix do to a shape\n* matrix factorization and SVD\n* Compressing small dummy image using SVD\n* Compressing big real image using SVD","b8f93bba":"### Visualize what a matrix do to a\u00a0shape\n\nWe now visualize what a matrix\/linear map do to a shape in euclidean space(R2 in this case).\n\nWe will take a unit circle centered at (2,2) and then apply linear map M to it and visualize how it got transformed.","0c279ebb":"## Image compression using SVD\n\nNow we will use this extremely powerful tool to compress images. We will see that how **the outer product of u and v corresponding to few topmost singular values can approximate the original image really well while reducing the image size significantly**.\n\n### Compressing dummy image\n\nIn this section we will take a very small 7x7 dummy image. We first apply SVD to it, then see all the rank 1 images corresponding to all singular values. Then we will **construct best rank i image by cumulating all rank 1 images corresponding to singular values from 1 to i**.\n\n![svd4.png](attachment:svd4.png)","4f9e5394":"So, we see that the linear map M do both scaling and rotation when applied to u.\n\nIf M would have done only scaling to u then u would be called as **eigen vector** of linear map M and the amount by which M scales u is called **eigen value** corresponding to that eigen vector. Also, if M would have done only rotation to u then M is called as **rotation matrix** or **rotational mapping**.\n\n**So, a linear map\/matrix either scales or rotates or does both to a vector in euclidean space.**","24c831a5":"### Visualize what a matrix do to a\u00a0vector\nWe will first create a random vector and random linear map.","65d390dd":"We can see as we add more and more rank 1 images the approximated image get more and more close to original image and finally we get the original image.\n\n**If the rank of image is r then adding all r rank 1 images gives us the same original image.**\n\nBut we won't go till rank r after all it will give us no benefit and even require more space. So we stop earlier, in this case most of us will stop at **best rank 4 or 5 approximation**, because it gives an image close enough to the original image so that we get an good idea of what the image is. Also in this case all of us will stop at **best rank 6 approximation**, because rank_7 is same as rank_6. This is because, as the image is rank 6, the last singular value is 0, so it will not add anything to the image.\n\nLet's see how much space we saved by using best rank 3 image.","13942e39":"So, even in the case of extremely tiny 7x7 image we saved around 8% space with a rank 3 approximation. Although this saving is not a lot as we are also compromising with the image quality, but in case of real life bigger images we save a lot space keeping the image quality almost same.","5f0b13c7":"### Transforming using\u00a0SVD\nNow, we will transform above unit circle centered at (2,2) using these decomposed transformations in sequential manner and will see that indeed the end result is same as before.\n\n**Whether apply M directly or first apply V_T then S and then U, will always gives the same result**. See below image,\n\n![svd1.png](attachment:svd1.png)","843ca2ac":"![svd3.jpg](attachment:svd3.jpg)\n\n![svd2.png](attachment:svd2.png)","fc431067":"So, we can see that this circle is transformed into an ellipse. This is because each vector point is scaled and rotated which result in this transformed ellipse. *Every point on the circle has an one-to-one mapping with points on the ellipse as the mapping is linear.*","4315a0f9":"## Linear Algebra refresher\n\nThe two core element of linear algebra are **vector** and **matrix**. Vector represents a point in euclidean space whereas matrix is a linear mapping which maps vectors from one space to other (both the spaces could be of same or different dimensions). Here I coined the term **linear mapping**, it means *the mapping from one vector space to another respects the underlying (linear) structure of each vector space i.e., it preserves the linearity*, (vector space is just an abstract representation). Mathematically, we write as\n\n\n\nHere, L is the linear map also known as linear transformation.\n\nThis is all mathematical jargon, but what it really do geometrically? So, *if there is a vector in euclidean space then it will either scale it, or rotate it, or do both sequentially*. Let's visualize what a matrix(linear mapping) do to a vector in euclidean space(R2 in this case).","4377041f":"Below are some rank 1 images corresponding to the top singular values.","f5db7142":"**Rank of a matrix is defined as the number of independent rows\/columns in that matrix. It is always less then the minimum of number of rows and columns in that matrix.**","2c7a392e":"#### Best rank 1 approximation\n\n![CodeCogsEqn%282%29.gif](attachment:CodeCogsEqn%282%29.gif)\n\nThe best rank 1 image is nothing but just the outer product of u1 with v1 and scaled by s1.","665ee658":"**get_optimal_rank_by_energy:** Gives the lowest rank for the given amount of energy.\n\n**get_optimal_rank_by_storage:** Gives the lowest rank for the given amount of storage.\n\nLet's decompose the image using SVD.","4f2e45ce":"So we get the optimal rank for 85% energy and 30% storage.\n\nNow let's visualize compressed images of different ranks and compare them with original image.","364e5066":"Clearly we are not able to guess anything from these rank 1 images but magic will happen when we start cumulating them.\n\nWe would require some helper functions.","7dd00039":"**If you like this notebook then do up-vote and also share with others.**\n\n[Here](https:\/\/medium.com\/@greatsharma04\/compressing-images-using-linear-algebra-bdac64c5e7ef) is the medium version of this notebook, have a read.\n\nAlso, have a read of my other notebooks which includes variety of topics including,\n* [statistical analysis in python](https:\/\/www.kaggle.com\/gauravsharma99\/statistical-analysis-on-mpg-data)\n* [multi-collinearity in linear-regression](https:\/\/www.kaggle.com\/gauravsharma99\/effect-of-multicollinearity-on-linear-regression)\n* [facial emotion recognition using keras](https:\/\/www.kaggle.com\/gauravsharma99\/facial-emotion-recognition)\n\nand [many more](https:\/\/www.kaggle.com\/gauravsharma99\/notebooks).\n\nThankyou once again for reading my kernels my friends :)","49f23e23":"### Matrix factorization and\u00a0SVD\n\nMatrix factorization is the most power-full tool in linear algebra, it is used extensively not just in mathematics but also in the field of data science and machine learning. Recommender systems uses matrix factorization heavily. The *idea is to factorize an unknown matrix into pieces whose properties are known to us or who are easy to manipulate.* There are many matrix factorization available but the most popular and fundamental is Singular value decomposition (SVD). *Any matrix no matter of what shape can be decomposed into three matrices using SVD.*\n\nWe can decompose any linear transformation M into 3 transformations. These are -\n* first rotating using V_T (right singular vectors)\n* then scaling using S (singular values)\n* then again rotating using U (left singular vectors)\n\nHere V_T, S, U are decomposed matrices of M. *So, any linear map can be decomposed into these three fundamental transformations, and this decomposition is called* **Singular value decomposition (SVD)**.","cf0caf40":"### Compressing real image\n\nFor simplicity I am taking only gray-scale image. But the method can be easily mapped to colored images as well.","8f941d59":"#### Best rank 2 approximation\n\n![CodeCogsEqn%283%29.gif](attachment:CodeCogsEqn%283%29.gif)\n\nThe best rank 2 image is the sum of rank 1 image and outer product of u2 with v2 and scaled by s2.","439a58bb":"As the SVD from numpy linalg package throws S not as a matrix but as array of values, so I defined a function which throws S as a diagonal matrix.\n\n**perc_storage:** Returns the percentage of storage taken by the compressed image.\n\n**perc_energy:** Returns the percentage of energy(sum of sigmas) taken by the compressed image.\n\nAs we need to decide the rank of image upto which we want to compress, but this can't be done manually as this vary image to image. So, we will use the below functions for that, which returns optimal rank for given energy and storage."}}