{"cell_type":{"5e8e0102":"code","d2eeb81e":"code","c8a13ee3":"code","699b4fb9":"code","c3fe868c":"code","bf3bdd41":"code","93daecac":"code","d1ab3c31":"code","64efc677":"code","455394df":"markdown","750f8465":"markdown","78fe9ccb":"markdown","61aeaae6":"markdown"},"source":{"5e8e0102":"#imports\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n%matplotlib inline \n\nfrom datetime import datetime","d2eeb81e":"# loading just 100k datapoints for illustration\ndf1 = pd.read_csv('..\/input\/train.csv', nrows = 100_000, parse_dates = ['pickup_datetime']).drop(columns = 'key')","c8a13ee3":"# fairly standard cleanup\ndef clean(df):\n    # dropping rides outside test area\n    df=df[(-74.27 <= df['pickup_longitude']) & (df['pickup_longitude'] <= -72.95)]\n    df=df[(-74.27 <= df['dropoff_longitude']) & (df['dropoff_longitude'] <= -72.95)]\n    df=df[(40.56 <= df['pickup_latitude']) & (df['pickup_latitude'] <= 41.71)]\n    df=df[(40.56 <= df['dropoff_latitude']) & (df['dropoff_latitude'] <= 41.71)]\n    # Remove passenger count outliers\n    df = df[(df['passenger_count'] > 0) & (df['passenger_count'] < 6)]\n    # Remove possible fare outliers\n    df=df[(2.5 <= df['fare_amount']) & (df['fare_amount'] <= 250)]\n\n    return df","699b4fb9":"# distances \ndef distance (x1,y1,x2,y2):# x=longitude, y=latitude, 1=start, 2=finish\n    return  np.sqrt(((x2-x1)* 50)** 2 + ((y2-y1)*69.172)**2)\n\n# EXCERCISE IN DISTANCE ALONG MANHATTAN GRID ALIGNED AT 29 DEGREE ANGLE\n# Manhattan grid is tilted at 29 degrees angle (https:\/\/trefethen.net\/2013\/09\/29\/manhattan-is-tilted-at-a-29-degree-angle\/)\n# sin (29) ~ 0.4848096, cos (29) ~ 0,8746197\n# 1 degree of latitude  = 69.172 miles, 1 degree of longitude = 50 miles\ndef distance29(x1,y1,x2,y2):# x=longitude, y=latitude, 1=start, 2=finish\n    dist_avenue = (x2-x1) * 0.4848096 * 50 + (y2-y1) * 0.8746197 * 69.172\n    dist_street = (x2-x1) * 0.8746197 * 50 - (y2-y1) * 0.4848096 * 69.172\n    return np.abs(dist_avenue) + np.abs(dist_street)\n# It has about same correlation to fare_amount but is helpful in improving predictions\n\ndef add_location_factors(df):\n    df['distance'] = distance(df['pickup_latitude'], df['pickup_longitude'],df['dropoff_latitude'], df['dropoff_longitude'])\n    #df['distance29'] = np.vectorize(distance29)(df['pickup_latitude'], df['pickup_longitude'],df['dropoff_latitude'], df['dropoff_longitude'])\n    #df['distance29'] = distance29(df['pickup_latitude'], df['pickup_longitude'],df['dropoff_latitude'], df['dropoff_longitude'])\n    #df['zero'] = df['distance'].apply(lambda x: x < 0.01 )\n    return (df)","c3fe868c":"import matplotlib.path as mpltPath\nmanhattan_path = mpltPath.Path([[40.698,-74.019 ],[40.757,-74.014 ],[ 40.881745, -73.934875 ],[ 40.872186, -73.909654 ],\\\n                     [40.834051, -73.934120],[ 40.809238, -73.933307 ],[40.798337, -73.927591],[ 40.773668, -73.941674 ],\\\n                    [40.741346, -73.966607],[40.707832, -73.974694]])\n\ndef is_within(x,y,path):  #(latitude, longitude)\n    return path.contains_point([x,y])\n# inspired by https:\/\/stackoverflow.com\/questions\/36399381\/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python \n\ndef manhattanize (df):\n    df ['manh_pu'] = np.vectorize(is_within)(df['pickup_latitude'],df['pickup_longitude'],manhattan_path)\n    df ['manh_do'] = np.vectorize(is_within)(df['dropoff_latitude'],df['dropoff_longitude'],manhattan_path)\n    df ['manh'] = df ['manh_pu'] & df ['manh_do'] \n    return df","bf3bdd41":"df1 = clean(df1)\ndf1 = add_location_factors(df1)\ndf1 = manhattanize(df1)","93daecac":"print ('{:.3}% of the sample rides are wholly within Manhattan'.format(df1[df1.manh].shape[0] \/ df1.shape[0] * 100))\ndf1.head(40)\n# big majority of the rides are within Manhattan.","d1ab3c31":"# this function will also be used with the test set below\ndef select_within_boundingbox(df, BB):\n    return (df.pickup_longitude >= BB[0]) & (df.pickup_longitude <= BB[1]) & \\\n           (df.pickup_latitude >= BB[2]) & (df.pickup_latitude <= BB[3]) & \\\n           (df.dropoff_longitude >= BB[0]) & (df.dropoff_longitude <= BB[1]) & \\\n           (df.dropoff_latitude >= BB[2]) & (df.dropoff_latitude <= BB[3])\n            \n# load extra image to zoom in on NYC\nBB_zoom = (-74.3, -73.7, 40.5, 40.9)\nnyc_map_zoom = plt.imread('https:\/\/aiblog.nl\/download\/nyc_-74.3_-73.7_40.5_40.9.png')","64efc677":"# this function will be used more often to plot data on the NYC map\npu_w = df1[df1['manh_pu'] == True].sample(1000)\npu_o = df1[df1['manh_pu'] == False].sample(2000)\ns=10\nalpha=0.2\nBB = BB_zoom\nfig, axs = plt.subplots(1, 2, figsize=(16,10))\naxs[0].scatter(pu_w.pickup_longitude, pu_w.pickup_latitude, zorder=1, alpha=alpha, c='r', s=s)\naxs[0].scatter(pu_o.pickup_longitude, pu_o.pickup_latitude, zorder=1, alpha=alpha, c='b', s=s)\naxs[0].set_xlim((BB[0], BB[1]))\naxs[0].set_ylim((BB[2], BB[3]))\naxs[0].set_title('Pickup locations inside \/ outside Manhattan')\naxs[0].imshow(nyc_map_zoom, zorder=0, extent=BB)\n\ndo_w = df1[df1['manh_do'] == True].sample(1000)\ndo_o = df1[df1['manh_do'] == False].sample(2000)\n\naxs[1].scatter(do_w.dropoff_longitude, do_w.dropoff_latitude, zorder=1, alpha=alpha, c='r', s=s)\naxs[1].scatter(do_o.dropoff_longitude, do_o.dropoff_latitude, zorder=1, alpha=alpha, c='g', s=s)\naxs[1].set_xlim((BB[0], BB[1]))\naxs[1].set_ylim((BB[2], BB[3]))\naxs[1].set_title('Dropoff locations inside \/ outside Manhattan')\naxs[1].imshow(nyc_map_zoom, zorder=0, extent=BB)","455394df":"### Adding function to define  Manhattan location.\nManhattan locationis defined as a polygon with 10 points which I picked manually. A more precise outline is not needed since boundaries are along water bodies.","750f8465":"This notebook illustrates adding attributes based on datapoint location within specific geographic boundaries. While some notebook use simple distance from the center of an area, there is a simple way to attiribute a datapoint to a specific geogprahical territitory using *__matplotlib.path.contains_point()__* function.\n\nThe notebook borrows heavily from rich and detailed notebook by Albert van Breemen https:\/\/www.kaggle.com\/breemen\/nyc-taxi-fare-data-exploration (with many thanks for the inspiration) and a few others.","78fe9ccb":"### Mapping rides within and outside Manhattan","61aeaae6":"A more advanced technic would be to use *geojson* files that contain boundaries of multiple geographic areas."}}