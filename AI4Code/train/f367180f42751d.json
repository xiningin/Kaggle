{"cell_type":{"091e9c8a":"code","7f1b7951":"code","5f047aec":"code","f5cd4cab":"code","6ec9da05":"code","723c4319":"code","6c10f311":"code","54b5d399":"code","b5b9bacd":"code","5c23eaf2":"code","6821fdb9":"code","bdecdf8b":"code","15046475":"code","cafa6a01":"code","03b74361":"code","f3f29e35":"code","0d2768f9":"code","dcb90e0d":"code","b1e9a70b":"code","d5f79112":"code","4c6e065b":"code","c45231d1":"code","58d5d56d":"code","decf8de1":"code","ce89e551":"code","facad15c":"code","0b77a4a2":"code","6c957559":"code","8f77d101":"code","07eb5761":"code","1d6d638d":"code","0547c0f2":"markdown","7c9516fa":"markdown","ed0e6aa0":"markdown","5e04f372":"markdown","c9f67636":"markdown","9a1e4bb8":"markdown","889d4d79":"markdown","3d6e96f2":"markdown","cf77ef92":"markdown","8ae53de2":"markdown","147be403":"markdown","18a4b312":"markdown","790c1510":"markdown","234344d9":"markdown","df74505d":"markdown","79c9bae5":"markdown"},"source":{"091e9c8a":"# Libraries\nimport numpy as np\nimport pandas as pd\npd.set_option('max_columns', None)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\n\nimport datetime\nimport lightgbm as lgb\nfrom scipy import stats\nfrom sklearn.model_selection import train_test_split, StratifiedKFold, KFold, cross_val_score, GridSearchCV, RepeatedStratifiedKFold\nfrom sklearn.preprocessing import StandardScaler\nimport os\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls\nimport xgboost as xgb\nimport lightgbm as lgb\nfrom sklearn import model_selection\nfrom sklearn.metrics import accuracy_score, roc_auc_score\nfrom sklearn import metrics\nimport json\nimport ast\nimport time\nfrom sklearn import linear_model\nimport eli5\nfrom eli5.sklearn import PermutationImportance\nimport shap\nfrom tqdm import tqdm_notebook\nfrom mlxtend.feature_selection import SequentialFeatureSelector as SFS\nfrom mlxtend.plotting import plot_sequential_feature_selection as plot_sfs\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.feature_selection import GenericUnivariateSelect, SelectPercentile, SelectKBest, f_classif, mutual_info_classif, RFE\nimport statsmodels.api as sm\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom catboost import CatBoostClassifier","7f1b7951":"train = pd.read_csv('..\/input\/train.csv')\ntest = pd.read_csv('..\/input\/test.csv')\ntrain.shape, test.shape","5f047aec":"train.head()","f5cd4cab":"train[train.columns[2:]].std().plot('hist');\nplt.title('Distribution of stds of all columns');","6ec9da05":"train[train.columns[2:]].mean().plot('hist');\nplt.title('Distribution of means of all columns');","723c4319":"train.head()","6c10f311":"# we have no missing values\ntrain.isnull().any().any()","54b5d399":"print('Distributions of first 28 columns')\nplt.figure(figsize=(26, 24))\nfor i, col in enumerate(list(train.columns)[2:30]):\n    plt.subplot(7, 4, i + 1)\n    plt.hist(train[col])\n    plt.title(col)","b5b9bacd":"train['target'].value_counts(normalize=True)","5c23eaf2":"corrs = train.corr().abs().unstack().sort_values(kind=\"quicksort\").reset_index()\ncorrs = corrs[corrs['level_0'] != corrs['level_1']]\ncorrs.tail(30)","6821fdb9":"corrs.head()","bdecdf8b":"X = train.drop(['ID_code', 'target'], axis=1)\ny = train['target']\nX_test = test.drop(['ID_code'], axis=1)\nn_fold = 4\nfolds = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=42)\nrepeated_folds = RepeatedStratifiedKFold(n_splits=10, n_repeats=20, random_state=42)\n\n# scaler = StandardScaler()\n# X_train = scaler.fit_transform(X_train)\n# X_test = scaler.transform(X_test)","15046475":"def train_model(X, X_test, y, params, folds, model_type='lgb', plot_feature_importance=False, averaging='usual', model=None):\n    oof = np.zeros(len(X))\n    prediction = np.zeros(len(X_test))\n    scores = []\n    feature_importance = pd.DataFrame()\n    for fold_n, (train_index, valid_index) in enumerate(folds.split(X, y)):\n        print('Fold', fold_n, 'started at', time.ctime())\n        X_train, X_valid = X.loc[train_index], X.loc[valid_index]\n        y_train, y_valid = y[train_index], y[valid_index]\n        \n        if model_type == 'lgb':\n            train_data = lgb.Dataset(X_train, label=y_train)\n            valid_data = lgb.Dataset(X_valid, label=y_valid)\n            \n            model = lgb.train(params,\n                    train_data,\n                    num_boost_round=20000,\n                    valid_sets = [train_data, valid_data],\n                    verbose_eval=1000,\n                    early_stopping_rounds = 200)\n            \n            y_pred_valid = model.predict(X_valid)\n            y_pred = model.predict(X_test, num_iteration=model.best_iteration)\n            \n        if model_type == 'xgb':\n            train_data = xgb.DMatrix(data=X_train, label=y_train, feature_names=X_train.columns)\n            valid_data = xgb.DMatrix(data=X_valid, label=y_valid, feature_names=X_train.columns)\n\n            watchlist = [(train_data, 'train'), (valid_data, 'valid_data')]\n            model = xgb.train(dtrain=train_data, num_boost_round=20000, evals=watchlist, early_stopping_rounds=200, verbose_eval=500, params=params)\n            y_pred_valid = model.predict(xgb.DMatrix(X_valid, feature_names=X_train.columns), ntree_limit=model.best_ntree_limit)\n            y_pred = model.predict(xgb.DMatrix(X_test, feature_names=X_train.columns), ntree_limit=model.best_ntree_limit)\n        \n        if model_type == 'sklearn':\n            model = model\n            model.fit(X_train, y_train)\n            y_pred_valid = model.predict_proba(X_valid).reshape(-1,)\n            score = roc_auc_score(y_valid, y_pred_valid)\n            # print(f'Fold {fold_n}. AUC: {score:.4f}.')\n            # print('')\n            \n            y_pred = model.predict_proba(X_test)[:, 1]\n            \n        if model_type == 'glm':\n            model = sm.GLM(y_train, X_train, family=sm.families.Binomial())\n            model_results = model.fit()\n            model_results.predict(X_test)\n            y_pred_valid = model_results.predict(X_valid).reshape(-1,)\n            score = roc_auc_score(y_valid, y_pred_valid)\n            \n            y_pred = model_results.predict(X_test)\n            \n        if model_type == 'cat':\n            model = CatBoostClassifier(iterations=20000, learning_rate=0.05, loss_function='Logloss',  eval_metric='AUC', **params)\n            model.fit(X_train, y_train, eval_set=(X_valid, y_valid), cat_features=[], use_best_model=True, verbose=False)\n\n            y_pred_valid = model.predict_proba(X_valid)[:, 1]\n            y_pred = model.predict_proba(X_test)[:, 1]\n            \n        oof[valid_index] = y_pred_valid.reshape(-1,)\n        scores.append(roc_auc_score(y_valid, y_pred_valid))\n\n        if averaging == 'usual':\n            prediction += y_pred\n        elif averaging == 'rank':\n            prediction += pd.Series(y_pred).rank().values  \n        \n        if model_type == 'lgb':\n            # feature importance\n            fold_importance = pd.DataFrame()\n            fold_importance[\"feature\"] = X.columns\n            fold_importance[\"importance\"] = model.feature_importance()\n            fold_importance[\"fold\"] = fold_n + 1\n            feature_importance = pd.concat([feature_importance, fold_importance], axis=0)\n\n    prediction \/= n_fold\n    \n    print('CV mean score: {0:.4f}, std: {1:.4f}.'.format(np.mean(scores), np.std(scores)))\n    \n    if model_type == 'lgb':\n        feature_importance[\"importance\"] \/= n_fold\n        if plot_feature_importance:\n            cols = feature_importance[[\"feature\", \"importance\"]].groupby(\"feature\").mean().sort_values(\n                by=\"importance\", ascending=False)[:50].index\n\n            best_features = feature_importance.loc[feature_importance.feature.isin(cols)]\n\n            plt.figure(figsize=(16, 12));\n            sns.barplot(x=\"importance\", y=\"feature\", data=best_features.sort_values(by=\"importance\", ascending=False));\n            plt.title('LGB Features (avg over folds)');\n        \n            return oof, prediction, feature_importance\n        return oof, prediction, scores\n    \n    else:\n        return oof, prediction, scores","cafa6a01":"# %%time\n# model = linear_model.LogisticRegression(class_weight='balanced', penalty='l2', C=0.1)\n# oof_lr, prediction_lr, scores = train_model(X, X_test, y, params=None, folds=folds, model_type='sklearn', model=model)","03b74361":"params = {'num_leaves': 128,\n         'min_data_in_leaf': 42,\n         'objective': 'binary',\n         'max_depth': 16,\n         'learning_rate': 0.0123,\n         'boosting': 'gbdt',\n         'bagging_freq': 5,\n         'feature_fraction': 0.8201,\n         'bagging_seed': 11,\n         'reg_alpha': 1.728910519108444,\n         'reg_lambda': 4.9847051755586085,\n         'random_state': 42,\n         'metric': 'auc',\n         'verbosity': -1,\n         'subsample': 0.81,\n         'min_gain_to_split': 0.01077313523861969,\n         'min_child_weight': 19.428902804238373,\n         'num_threads': 4}\n# oof_lgb, prediction_lgb, scores = train_model(X, X_test, y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)","f3f29e35":"# sub = pd.read_csv('..\/input\/sample_submission.csv')\n# sub['target'] = prediction_lgb\n# sub.to_csv('lgb.csv', index=False)","0d2768f9":"model = lgb.LGBMClassifier(**params, n_estimators = 20000, n_jobs = -1)\nX_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, stratify=y)\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_valid, y_valid)], verbose=1000, early_stopping_rounds=200)","dcb90e0d":"eli5.show_weights(model, targets=[0, 1], feature_names=list(X_train.columns), top=40, feature_filter=lambda x: x != '<BIAS>')","b1e9a70b":"top_features = [i for i in eli5.formatters.as_dataframe.explain_weights_df(model).feature if 'BIAS' not in i][:100]\nX1 = X[top_features]\nX_train, X_valid, y_train, y_valid = train_test_split(X1, y, test_size=0.2, stratify=y)\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_valid, y_valid)], verbose=1000, early_stopping_rounds=200)","d5f79112":"def calculate_metrics(model, X_train: pd.DataFrame() = None, y_train: pd.DataFrame() = None, X_valid: pd.DataFrame() = None,\n                      y_valid: pd.DataFrame() = None, columns: list = []) -> pd.DataFrame():\n    columns = columns if len(columns) > 0 else list(X_train.columns)\n    train_pred = model.predict_proba(X_train[columns])\n    valid_pred = model.predict_proba(X_valid[columns])\n    f1 = 0\n    best_t = 0\n    for t in np.arange(0.1, 1, 0.05):\n        valid_pr = (valid_pred[:, 1] > t).astype(int)\n        valid_f1 = metrics.f1_score(y_valid, valid_pr)\n        if valid_f1 > f1:\n            f1 = valid_f1\n            best_t = t\n\n    t = best_t\n    train_pr = (train_pred[:, 1] > t).astype(int)\n    valid_pr = (valid_pred[:, 1] > t).astype(int)\n    train_f1 = metrics.f1_score(y_train, train_pr)\n    valid_f1 = metrics.f1_score(y_valid, valid_pr)\n    score_df = []\n    print(f'Best threshold: {t:.2f}. Train f1: {train_f1:.4f}. Valid f1: {valid_f1:.4f}.')\n    score_df.append(['F1', np.round(train_f1, 4), np.round(valid_f1, 4)])\n    train_r = metrics.recall_score(y_train, train_pr)\n    valid_r = metrics.recall_score(y_valid, valid_pr)\n\n    score_df.append(['Recall', np.round(train_r, 4), np.round(valid_r, 4)])\n    train_p = metrics.precision_score(y_train, train_pr)\n    valid_p = metrics.precision_score(y_valid, valid_pr)\n\n    score_df.append(['Precision', np.round(train_p, 4), np.round(valid_p, 4)])\n    train_roc = metrics.roc_auc_score(y_train, train_pred[:, 1])\n    valid_roc = metrics.roc_auc_score(y_valid, valid_pred[:, 1])\n\n    score_df.append(['ROCAUC', np.round(train_roc, 4), np.round(valid_roc, 4)])\n    train_apc = metrics.average_precision_score(y_train, train_pred[:, 1])\n    valid_apc = metrics.average_precision_score(y_valid, valid_pred[:, 1])\n\n    score_df.append(['APC', np.round(train_apc, 4), np.round(valid_apc, 4)])\n    print(metrics.confusion_matrix(y_valid, valid_pr))\n    score_df = pd.DataFrame(score_df, columns=['Metric', 'Train', 'Valid'])\n    print(score_df)\n\n    return score_df, t","4c6e065b":"_ = calculate_metrics(model, X_train, y_train, X_valid, y_valid)","c45231d1":"# X = train.drop(['ID_code', 'target'], axis=1)\n# X_test = test.drop(['ID_code'], axis=1)\n\n# columns = top_features = [i for i in eli5.formatters.as_dataframe.explain_weights_df(model).feature if 'BIAS' not in i][:20]\n# for col1 in tqdm_notebook(columns):\n#     for col2 in columns:\n#         X[col1 + '_' + col2] = X[col1] * X[col2]   \n#         X_test[col1 + '_' + col2] = X_test[col1] * X_test[col2]","58d5d56d":"# oof_lgb, prediction_lgb_inter, scores = train_model(X, X_test, y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)","decf8de1":"# sub = pd.read_csv('..\/input\/sample_submission.csv')\n# sub['target'] = prediction_lgb_inter\n# sub.to_csv('lgb_inter.csv', index=False)","ce89e551":"# X = train.drop(['ID_code', 'target'], axis=1)\n# X_test = test.drop(['ID_code'], axis=1)\n# scaler = StandardScaler()\n# X_train[X_train.columns] = scaler.fit_transform(X_train[X_train.columns])\n# X_test[X_train.columns] = scaler.transform(X_test[X_train.columns])\n# oof_lgb, prediction_lgb_scaled, scores = train_model(X, X_test, y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)\n# sub = pd.read_csv('..\/input\/sample_submission.csv')\n# sub['target'] = prediction_lgb_scaled\n# sub.to_csv('lgb_scaled.csv', index=False)","facad15c":"# X = train.drop(['ID_code', 'target'], axis=1)\n# X_test = test.drop(['ID_code'], axis=1)\n\n# X['std'] = X.std(1)\n# X_test['std'] = X_test.std(1)\n\n# X['mean'] = X.mean(1)\n# X_test['mean'] = X_test.mean(1)\n# oof_lgb, prediction_lgb_stats, scores = train_model(X, X_test, y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)\n# sub = pd.read_csv('..\/input\/sample_submission.csv')\n# sub['target'] = prediction_lgb_stats\n# sub.to_csv('lgb_stats.csv', index=False)","0b77a4a2":"%%time\nX = train.drop(['ID_code', 'target'], axis=1)\nX_test = test.drop(['ID_code'], axis=1)\nneigh = NearestNeighbors(3, n_jobs=-1)\nneigh.fit(X)\n\ndists, _ = neigh.kneighbors(X, n_neighbors=3)\nmean_dist = dists.mean(axis=1)\nmax_dist = dists.max(axis=1)\nmin_dist = dists.min(axis=1)\n\nX['mean_dist'] = mean_dist\nX['max_dist'] = max_dist\nX['min_dist'] = min_dist\n\ntest_dists, _ = neigh.kneighbors(X_test, n_neighbors=3)\n\ntest_mean_dist = test_dists.mean(axis=1)\ntest_max_dist = test_dists.max(axis=1)\ntest_min_dist = test_dists.min(axis=1)\n\nX_test['mean_dist'] = test_mean_dist\nX_test['max_dist'] = test_max_dist\nX_test['min_dist'] = test_min_dist\n\noof_lgb, prediction_lgb_dist, scores = train_model(X, X_test, y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)\nsub = pd.read_csv('..\/input\/sample_submission.csv')\nsub['target'] = prediction_lgb_dist\nsub.to_csv('lgb_dist.csv', index=False)","6c957559":"# xgb_params = {'eta': 0.05, 'max_depth': 3, 'subsample': 0.9, 'colsample_bytree': 0.9, \n#           'objective': 'binary:logistic', 'eval_metric': 'auc', 'silent': True, 'nthread': 4}\n# oof_xgb, prediction_xgb, scores = train_model(X, X_test, y, params=xgb_params, folds=folds, model_type='xgb')","8f77d101":"# cat_params = {'depth': 13,\n#               'l2_leaf_reg': 10,\n#               'bootstrap_type': 'Bernoulli',\n#               #'metric_period': 500,\n#               'od_type': 'Iter',\n#               'od_wait': 50,\n#               'random_seed': 11,\n#               'allow_writing_files': False}\n# oof_cat, prediction_cat, _ = train_model(X, X_test, y, params=cat_params, folds=folds, model_type='cat')","07eb5761":"# sub['target'] = (prediction_lgb + prediction_xgb) \/ 2\n# sub.to_csv('blend1.csv', index=False)\n# sub['target'] = (prediction_lgb + prediction_xgb + prediction_cat) \/ 3\n# sub.to_csv('blend2.csv', index=False)","1d6d638d":"# oof_lgb, prediction_lgb, scores = train_model(np.round(X, 3), np.round(X_test, 3), y, params=params, folds=folds, model_type='lgb', plot_feature_importance=True)\n# sub = pd.read_csv('..\/input\/sample_submission.csv')\n# sub['target'] = prediction_lgb\n# sub.to_csv('lgb_rounded_3.csv', index=False)","0547c0f2":"Let's have a look at correlations now!","7c9516fa":"### Scaling\n\n! **Notice** scaling severely decreases score","ed0e6aa0":"We can see that all features have a low correlation with target. So we have no highly correlated features which we could drop, on the other hand we could drop some columns with have little correlation with the target.","5e04f372":"### Feature interaction\n\nDidn't improve score","c9f67636":"## ELI5","9a1e4bb8":"### NN features\n\nTakes several hours.","889d4d79":"### Statistics","3d6e96f2":"ELI5 didn't help up to eliminate features, but let's at least try to take top-100 and see how it helps.","cf77ef92":"From this overview we can see the following things:\n* target is binary and has disbalance: 10% of samples belong to 1 class;\n* values in columns are more or less similar;\n* columns have high std (up to 20)\n* columns have a high range of means;","8ae53de2":"### Rounding data","147be403":"## Data exploration","18a4b312":"## Basic modelling","790c1510":"## Blend","234344d9":"# General information\n\nIn Santander Customer Transaction Prediction competition we have a binary classification task. Train and test data have 200k samples each and we have 200 anonimyzed numerical columns. It would be interesting to try good models without overfitting and knowing the meaning of the features.\nIn fact this competition seems to be similar to another current competition: don't overfit II, so I'll use a lot of ideas from my [kernel](https:\/\/www.kaggle.com\/artgor\/how-to-not-overfit).\n\nIn this kernel I'll write the following things:\n\n* EDA on the features and trying to get some insights;\n* Using permutation importance to select most impactful features;\n* Comparing various models: linear models, tree based models and others;\n* Trying various approaches to feature selection including taking top features from eli5;\n* Hyperparameter optimization for models;\n* Feature generation;\n* Other things;\n\n![](https:\/\/i.imgur.com\/e5vPHpJ.png)\n\n*Work still in progress*","df74505d":"Training with these features gives the same score on LB: 0.899","79c9bae5":"## Feature generation"}}