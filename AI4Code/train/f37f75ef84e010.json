{"cell_type":{"92f906e1":"code","12567d95":"code","4b71687e":"code","8f555497":"code","d7139153":"code","90f54d79":"code","5000646a":"code","12bd6026":"code","b829fc51":"code","38f007db":"code","82c4896d":"code","d2c9f1b6":"code","443c1229":"code","7db53cf3":"code","3121a592":"code","c117f52a":"code","14e38071":"code","a2d55fcd":"code","646db338":"code","e5565102":"markdown","734e5549":"markdown","b3fb2134":"markdown","10285871":"markdown","85bf4026":"markdown","a08b0b63":"markdown","6171542a":"markdown","10b03c6b":"markdown","b8d293a2":"markdown","5dc9428d":"markdown","09eebb32":"markdown"},"source":{"92f906e1":"#Importing libraries\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n# Input data files are available in the \"..\/input\/\" directory.\nimport os\nimport matplotlib.pyplot as plt#visualization\nfrom PIL import  Image\n%matplotlib inline\nimport pandas as pd\nimport seaborn as sns#visualization\nimport itertools\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nimport io\nimport plotly.offline as py#visualization\npy.init_notebook_mode(connected=True)#visualization\nimport plotly.graph_objs as go#visualization\nimport plotly.tools as tls#visualization\nimport plotly.figure_factory as ff#visualization","12567d95":"telcom = pd.read_csv(r\"..\/input\/WA_Fn-UseC_-Telco-Customer-Churn.csv\")\n#first few rows\ntelcom.head()","4b71687e":"print (\"Rows     : \" ,telcom.shape[0])\nprint (\"Columns  : \" ,telcom.shape[1])\nprint (\"\\nFeatures : \\n\" ,telcom.columns.tolist())\nprint (\"\\nMissing values :  \", telcom.isnull().sum().values.sum())\nprint (\"\\nUnique values :  \\n\",telcom.nunique())","8f555497":"#Replacing spaces with null values in total charges column\ntelcom['TotalCharges'] = telcom[\"TotalCharges\"].replace(\" \",np.nan)\n\n#Dropping null values from total charges column which contain .15% missing data \ntelcom = telcom[telcom[\"TotalCharges\"].notnull()]\ntelcom = telcom.reset_index()[telcom.columns]\n\n\n\n#convert to float type\ntelcom[\"TotalCharges\"] = telcom[\"TotalCharges\"].astype(float)\n\n#replace 'No internet service' to No for the following columns\nreplace_cols = [ 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',\n                'TechSupport','StreamingTV', 'StreamingMovies']\nfor i in replace_cols : \n    telcom[i]  = telcom[i].replace({'No internet service' : 'No'})\n    \n#replace values\ntelcom[\"SeniorCitizen\"] = telcom[\"SeniorCitizen\"].replace({1:\"Yes\",0:\"No\"})\n\n#Tenure to categorical column\ndef tenure_lab(telcom) :\n    \n    if telcom[\"tenure\"] <= 12 :\n        return \"Tenure_0-12\"\n    elif (telcom[\"tenure\"] > 12) & (telcom[\"tenure\"] <= 24 ):\n        return \"Tenure_12-24\"\n    elif (telcom[\"tenure\"] > 24) & (telcom[\"tenure\"] <= 48) :\n        return \"Tenure_24-48\"\n    elif (telcom[\"tenure\"] > 48) & (telcom[\"tenure\"] <= 60) :\n        return \"Tenure_48-60\"\n    elif telcom[\"tenure\"] > 60 :\n        return \"Tenure_gt_60\"\ntelcom[\"tenure_group\"] = telcom.apply(lambda telcom:tenure_lab(telcom),\n                                      axis = 1)\n\n#Separating churn and non churn customers\nchurn     = telcom[telcom[\"Churn\"] == \"Yes\"]\nnot_churn = telcom[telcom[\"Churn\"] == \"No\"]\n\n#Separating catagorical and numerical columns\nId_col     = ['customerID']\ntarget_col = [\"Churn\"]\ncat_cols   = telcom.nunique()[telcom.nunique() < 6].keys().tolist()\ncat_cols   = [x for x in cat_cols if x not in target_col]\nnum_cols   = [x for x in telcom.columns if x not in cat_cols + target_col + Id_col]\n\n","d7139153":"ax = sns.boxplot(x=telcom[\"TotalCharges\"])","90f54d79":"ax2 = sns.boxplot(x=telcom[\"MonthlyCharges\"])","5000646a":"# Distribution target variable\n#labels\n\nlab = telcom[\"Churn\"].value_counts().keys().tolist()\n#values\nval = telcom[\"Churn\"].value_counts().values.tolist()\n\ntrace = go.Pie(labels = lab ,\n               values = val ,\n               marker = dict(colors =  [ 'royalblue' ,'lime'],\n                             line = dict(color = \"white\",\n                                         width =  1.3)\n                            ),\n               rotation = 90,\n               hoverinfo = \"label+value+text\",\n               hole = .5\n              )\nlayout = go.Layout(dict(title = \"Distribution of Churn varibale \",\n                        plot_bgcolor  = \"rgb(243,243,243)\",\n                        paper_bgcolor = \"rgb(243,243,243)\",\n                       )\n                  )\n\ndata = [trace]\nfig = go.Figure(data = data,layout = layout)\npy.iplot(fig)","12bd6026":"from sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import StandardScaler\n\n#customer id col\nId_col     = ['customerID']\n#Target columns\ntarget_col = [\"Churn\"]\n#categorical columns\ncat_cols   = telcom.nunique()[telcom.nunique() < 6].keys().tolist()\ncat_cols   = [x for x in cat_cols if x not in target_col]\n#numerical columns\nnum_cols   = [x for x in telcom.columns if x not in cat_cols + target_col + Id_col]\n#Binary columns with 2 values\nbin_cols   = telcom.nunique()[telcom.nunique() == 2].keys().tolist()\n#Columns more than 2 values\nmulti_cols = [i for i in cat_cols if i not in bin_cols]\n\n#Label encoding Binary columns\nle = LabelEncoder()\nfor i in bin_cols :\n    telcom[i] = le.fit_transform(telcom[i])\n    \n#Duplicating columns for multi value columns\ntelcom = pd.get_dummies(data = telcom,columns = multi_cols )\n\n#Scaling Numerical columns\nstd = StandardScaler()\nscaled = std.fit_transform(telcom[num_cols])\nscaled = pd.DataFrame(scaled,columns=num_cols)\n\n#dropping original values merging scaled values for numerical columns\ndf_telcom_og = telcom.copy()\ntelcom = telcom.drop(columns = num_cols,axis = 1)\ntelcom = telcom.merge(scaled,left_index=True,right_index=True,how = \"left\")","b829fc51":"summary = (df_telcom_og[[i for i in df_telcom_og.columns if i not in Id_col]].\n           describe().transpose().reset_index())\n\nsummary = summary.rename(columns = {\"index\" : \"feature\"})\nsummary = np.around(summary,3)\n\nval_lst = [summary['feature'], summary['count'],\n           summary['mean'],summary['std'],\n           summary['min'], summary['25%'],\n           summary['50%'], summary['75%'], summary['max']]\n\ntrace  = go.Table(header = dict(values = summary.columns.tolist(),\n                                line = dict(color = ['#506784']),\n                                fill = dict(color = ['#119DFF']),\n                               ),\n                  cells  = dict(values = val_lst,\n                                line = dict(color = ['#506784']),\n                                fill = dict(color = [\"lightgrey\",'#F5F8FF'])\n                               ),\n                  columnwidth = [200,60,100,100,60,60,80,80,80])\nlayout = go.Layout(dict(title = \"Variable Summary\"))\nfigure = go.Figure(data=[trace],layout=layout)\npy.iplot(figure)","38f007db":"from sklearn.model_selection import train_test_split\n\ntrain,test = train_test_split(telcom,test_size = .25 ,random_state = 111)","82c4896d":"from imblearn.over_sampling import SMOTE\n\ncols    = [i for i in telcom.columns if i not in Id_col+target_col]\n\nsmote_X = telcom[cols]\nsmote_Y = telcom[target_col]\n\n#Split train and test data\nsmote_train_X,smote_test_X,smote_train_Y,smote_test_Y = train_test_split(smote_X,smote_Y,\n                                                                         test_size = .25 ,\n                                                                         random_state = 111)\n\n#oversampling minority class using smote\nos = SMOTE(random_state = 0,  k_neighbors=5)\nos_smote_X,os_smote_Y = os.fit_sample(smote_train_X,smote_train_Y)\nos_smote_X = pd.DataFrame(data = os_smote_X,columns=cols)\nos_smote_Y = pd.DataFrame(data = os_smote_Y,columns=target_col)\n###","d2c9f1b6":"#labels\nlab = os_smote_Y[\"Churn\"].value_counts().keys().tolist()\n#values\nval = os_smote_Y[\"Churn\"].value_counts().values.tolist()\n\ntrace = go.Pie(labels = lab ,\n               values = val ,\n               marker = dict(colors =  [ 'royalblue' ,'lime'],\n                             line = dict(color = \"white\",\n                                         width =  1.3)\n                            ),\n               rotation = 90,\n               hoverinfo = \"label+value+text\",\n               hole = .5\n              )\nlayout = go.Layout(dict(title = \"Distribution of Churn varibale after oversampling\",\n                        plot_bgcolor  = \"rgb(243,243,243)\",\n                        paper_bgcolor = \"rgb(243,243,243)\",\n                       )\n                  )\n\ndata = [trace]\nfig = go.Figure(data = data,layout = layout)\npy.iplot(fig)","443c1229":"from sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree import export_graphviz\nfrom sklearn import tree\nfrom graphviz import Source\nfrom IPython.display import SVG,display\n\n#Liste dataframe header \ncolumns=list(os_smote_X.columns.values)\n#model\n\ndt_classifier = DecisionTreeClassifier(max_depth = 3,\n                                           splitter  = \"best\",\n                                           criterion = \"gini\",\n                                          )\ndt_classifier.fit(os_smote_X,os_smote_Y)\n    \n#plot decision tree\ngraph = Source(tree.export_graphviz(dt_classifier,out_file=None,\n                                        rounded=True,proportion = False,\n                                        feature_names = columns, \n                                        precision  = 2,\n                                        class_names=[\"Not churn\",\"Churn\"],\n                                        filled = True                         \n                                       ))\ndisplay(graph)\n","7db53cf3":"from sklearn.metrics import roc_auc_score,roc_curve,scorer\n\ndt_classifier.fit(os_smote_X,os_smote_Y)\npredictions   = dt_classifier.predict(smote_test_X)\nprobabilities = dt_classifier.predict_proba(smote_test_X)\n\n\nmodel_roc_auc = roc_auc_score(smote_test_Y,predictions) \nprint (\"Area under curve : \",model_roc_auc,\"\\n\")\nfpr,tpr,thresholds = roc_curve(smote_test_Y,probabilities[:,1])\n\n#plot roc curve\ntrace2 = go.Scatter(x = fpr,y = tpr,\n                        name = \"Roc : \" + str(model_roc_auc),\n                        line = dict(color = ('rgb(22, 96, 167)'),width = 2))\ntrace3 = go.Scatter(x = [0,1],y=[0,1],\n                        line = dict(color = ('rgb(205, 12, 24)'),width = 2,\n                        dash = 'dot'))\n\n\n\n#subplots\nfig = tls.make_subplots(rows=2, cols=2, specs=[[{}, {}], [{'colspan': 2}, None]],\n                            subplot_titles=('',\n                                            'Receiver operating characteristic',\n                                            ''))\n    \n   \nfig.append_trace(trace2,1,2)\nfig.append_trace(trace3,1,2)\n\npy.iplot(fig)","3121a592":"from sklearn.linear_model import LogisticRegression\nlogit  = LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,\n          intercept_scaling=1, max_iter=100, multi_class='ovr', n_jobs=1,\n          penalty='l2', random_state=None, solver='liblinear', tol=0.0001,\n          verbose=0, warm_start=False)","c117f52a":"logit.fit(os_smote_X,os_smote_Y)\npredictions   = logit.predict(smote_test_X)\nprobabilities = logit.predict_proba(smote_test_X)\n\n\nmodel_roc_auc = roc_auc_score(smote_test_Y,predictions) \nprint (\"Area under curve : \",model_roc_auc,\"\\n\")\nfpr,tpr,thresholds = roc_curve(smote_test_Y,probabilities[:,1])\n\n#plot roc curve\ntrace2 = go.Scatter(x = fpr,y = tpr,\n                        name = \"Roc : \" + str(model_roc_auc),\n                        line = dict(color = ('rgb(22, 96, 167)'),width = 2))\ntrace3 = go.Scatter(x = [0,1],y=[0,1],\n                        line = dict(color = ('rgb(205, 12, 24)'),width = 2,\n                        dash = 'dot'))\n\n\n\n#subplots\nfig = tls.make_subplots(rows=2, cols=2, specs=[[{}, {}], [{'colspan': 2}, None]],\n                            subplot_titles=('',\n                                            'Receiver operating characteristic',\n                                            ''))\n    \n   \nfig.append_trace(trace2,1,2)\nfig.append_trace(trace3,1,2)\n\npy.iplot(fig)","14e38071":"import keras\nfrom keras.layers import Dense\nfrom keras.models import Sequential\nfrom IPython.display import SVG\nfrom keras.optimizers import Adam\nfrom keras import regularizers\nfrom keras.utils.vis_utils import model_to_dot\nfrom keras import losses\n#import pydot\nfrom keras.utils.vis_utils import plot_model\n\n\n#convertir la dataframe en une matrice\nos_smote_X_matrix = os_smote_X.as_matrix()\nos_smote_Y_matrix =os_smote_Y.as_matrix()\n#os_smote_X_matrix.shape[1]","a2d55fcd":"\nn_cols=os_smote_X_matrix.shape[1]\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(n_cols,), activation='relu'))\nmodel.add(Dense(16, activation='relu'))\nmodel.add(Dense(8, activation='relu'))\nmodel.add(Dense(4, activation='relu'))\nmodel.add(Dense(1, activation='sigmoid'))\n\nmodel.compile(loss='binary_crossentropy', optimizer='adam')\nmodel.summary()\n\n#plot the a graphe\nSVG(model_to_dot(model).create(prog='dot', format='svg'))","646db338":"from sklearn.metrics import roc_auc_score,roc_curve,scorer\n\n\nmodel.fit(os_smote_X_matrix, os_smote_Y_matrix, epochs=20)\npredictions   = model.predict(smote_test_X)\nprobabilities = model.predict_proba(smote_test_X)\n\nmodel_roc_auc = roc_auc_score(smote_test_Y,predictions) \nprint (\"Area under curve : \",model_roc_auc,\"\\n\")\nfpr,tpr,thresholds = roc_curve(smote_test_Y,probabilities)\n\n\n#plot roc curve\ntrace2 = go.Scatter(x = fpr,y = tpr,\n                        name = \"Roc : \" + str(model_roc_auc),\n                        line = dict(color = ('rgb(22, 96, 167)'),width = 2))\ntrace3 = go.Scatter(x = [0,1],y=[0,1],\n                        line = dict(color = ('rgb(205, 12, 24)'),width = 2,\n                        dash = 'dot'))\n\n\n#subplots\nfig = tls.make_subplots(rows=2, cols=2, specs=[[{}, {}], [{'colspan': 2}, None]],\n                            subplot_titles=('',\n                                            'Receiver operating characteristic',\n                                            ''))\n    \n   \nfig.append_trace(trace2,1,2)\nfig.append_trace(trace3,1,2)\n\npy.iplot(fig)","e5565102":"<h1 style=\"color:blue\"> 4:  data preprocessing  <\/h1>  ","734e5549":"<h2 style=\"color:blue\"> 5.4 Logistic Regression Model  <\/h2>  ","b3fb2134":"<h2 style=\"color:blue\"> 5.2 Synthetic Minority Oversampling TEchnique (SMOTE)  <\/h2>  ","10285871":"<h2 style=\"color:blue\"> 2.1: Deal with outliers  <\/h1> ","85bf4026":"<h1 style=\"color:blue\">1: Load the Telco Customer Churn data set<\/h1>","a08b0b63":"<h1 style=\"color:blue\"> 2: Cleaning data <\/h1> \n<h2 style=\"color:blue\"> 2.1: Deal with missing data  <\/h1> ","6171542a":"<h1 style=\"color:blue\"> 5: Model Building  <\/h1>  \n<h2 style=\"color:blue\"> 5.1 training & test sets  <\/h2>  ","10b03c6b":"<h2 style=\"color:blue\">3: Distribution target variable:  Churn  <\/h1>  ","b8d293a2":" <h4 style=\"color:blue\" >1.1 Some statistic about the data set<\/h1>","5dc9428d":"<h2 style=\"color:blue\"> 5.3 Decision Tree Model  <\/h2>  ","09eebb32":"<h2 style=\"color:blue\"> 5.5 Deep Learning Model  <\/h2>  "}}