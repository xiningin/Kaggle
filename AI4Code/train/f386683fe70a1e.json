{"cell_type":{"df29e493":"code","8296f90e":"code","ca34b794":"code","550a784b":"code","3f678651":"code","4f413cb1":"code","827a03da":"code","c27c55af":"code","2febf836":"code","18738ae9":"code","4ce2fb67":"code","cd649199":"code","becef00d":"code","b0b5ead0":"code","7dc300fb":"markdown","b3991dc0":"markdown","26a8d6ba":"markdown","c91dd9fe":"markdown","b7086922":"markdown","f411f7a9":"markdown","f2b5d6cc":"markdown","add3b110":"markdown","0a35a5ee":"markdown","dc843768":"markdown","11be4b36":"markdown","1f7976ef":"markdown"},"source":{"df29e493":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nfrom scipy import stats\nimport warnings\nwarnings.filterwarnings('ignore')\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\ndf = pd.read_csv('\/kaggle\/input\/avocado-prices\/avocado.csv')\ndf.head()","8296f90e":"df.info()","ca34b794":"# bootstrap\n\ndef get_bootstrap(\n    data_column_1, \n    data_column_2,\n    color,\n    boot_it = 1000, \n    statistic = np.mean, \n    bootstrap_conf_level = 0.95\n):\n    boot_len = max([len(data_column_1), len(data_column_2)])\n    boot_data = []\n    for i in (range(boot_it)): \n        samples_1 = data_column_1.sample(\n            boot_len, \n            replace = True \n        ).values\n        \n        samples_2 = data_column_2.sample(\n            boot_len, \n            replace = True\n        ).values\n        \n        boot_data.append(statistic(samples_1-samples_2)) \n        \n    pd_boot_data = pd.DataFrame(boot_data)\n        \n    left_quant = (1 - bootstrap_conf_level)\/2\n    right_quant = 1 - (1 - bootstrap_conf_level) \/ 2\n    ci = pd_boot_data.quantile([left_quant, right_quant])\n        \n    p_1 = stats.norm.cdf(\n        x = 0, \n        loc = np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_2 = stats.norm.cdf(\n        x = 0, \n        loc = -np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_value = min(p_1, p_2) * 2\n        \n    plt.figure(figsize = (13, 6))\n    plt.hist(pd_boot_data[0], bins = 50, color = color)\n    plt.vlines(ci,ymin=0,ymax=50,linestyle='--', color = 'black', lw = 2)\n    plt.tick_params(direction='out', length=8, width=4, colors='black', grid_color='black', labelsize = 16)\n    plt.xlabel('boot_data', fontsize = 20, fontweight = 'bold')\n    plt.ylabel('frequency', fontsize = 20, fontweight = 'bold')\n    plt.title(\"Histogram of boot_data\", color= 'black', fontsize = 24, fontweight = 'bold', x = 0.2, y = 1.1)\n    sns.despine()\n    plt.show()\n       \n    return {\"boot_data\": boot_data, \n            \"ci\": ci, \n            \"p_value\": p_value}\n\n# hist + test Shapiro\ndef normal (data, name, color):\n    x = data.sample(1000, random_state = 17)\n    a = 0.05\n    stat, p = stats.shapiro(x)\n    plt.figure(figsize = (13, 6))\n    sns.distplot(data, color = color, kde_kws = dict(lw = 3), hist_kws = dict(edgecolor = 'black'))\n    sns.despine()\n    plt.xlabel('')\n    plt.ylabel('')\n    plt.tick_params(direction='out', length=8, width=4, colors='black', grid_color='black', labelsize = 16)\n    plt.title(f'Ditribution of {name}', color = 'black', fontsize = 24, fontweight = 'bold', x = 0.05, y = 1.1)\n    plt.show()\n    if p > 0.05:\n        print(f'{p} > 0.05, no reject HO (distribution is normal)')\n    else:\n        print(f'{p} < 0.05, reject HO (distribution is not normal)')\n        \n# barplot\ndef barplot(data_x, data_y, x_label, y_label,  x_ticks, title, color):\n    fig = plt.figure(figsize = (13, 6))\n    ax = fig.add_axes([0, 0, 1, 1])\n    ax.bar(x = data_x, height = data_y, color = color, width = 0.4)\n    sns.despine()\n    for p in ax.patches:\n        width = p.get_width()\n        height = p.get_height()\n        x, y = p.get_xy() \n        ax.annotate('{:.0f}'.format(height), (x + width\/2, y + height*1.02), ha='center', fontsize=16, color='black')\n    ax.set_xlabel(x_label, color = 'black', fontsize = 20, fontweight = 'bold')\n    ax.set_ylabel(y_label, color = 'black', fontsize = 20, fontweight = 'bold')\n    ax.set_xticks(x_ticks)\n    ax.tick_params(direction='out', length=8, width=4, colors='black', grid_color='black', labelsize = 16)\n    plt.title(title, color= 'black', fontsize = 24, fontweight = 'bold', x = 0.2, y = 1.1)\n    plt.show()","550a784b":"group_by_type = df \\\n    .groupby('type', as_index = False) \\\n    .agg({'Unnamed: 0' : 'count'}) \\\n    .rename(columns = {'Unnamed: 0' : 'count'})\ngroup_by_type\nbarplot(data_x = group_by_type['type'], \n        data_y = group_by_type['count'], \n        x_label = 'avocado type', \n        y_label = 'count',  \n        x_ticks = group_by_type['type'], \n        title = 'Number of avocoda by type', \n        color = '#006400')","3f678651":"normal(data = df['AveragePrice'],\n       name = 'AveragePrice',\n       color = '#006400')","4f413cb1":"normal(data = df[df['type'] == 'conventional']['AveragePrice'],\n       name = 'AveragePrice (conventional)',\n       color = '#006400')","827a03da":"normal(data = df[df['type'] == 'organic']['AveragePrice'],\n       name = 'AveragePrice (organic)',\n       color = '#006400')","c27c55af":"a = 0.05\nstatistics, p = stats.ttest_ind(np.log(df[df['type'] == 'conventional']['AveragePrice']), np.log(df[df['type'] == 'organic']['AveragePrice']), equal_var = False)\nif p > a:\n    print(f'{p} > {a}, no reject HO (Same distribution)')\nelse:\n    print(f'{p} < {a}, reject HO (Different distribution)')","2febf836":"statistics, p = stats.mannwhitneyu(df[df['type'] == 'conventional']['AveragePrice'], df[df['type'] == 'organic']['AveragePrice'])\nif p > a:\n    print(f'{p} > {a}, no reject HO (Same distribution)')\nelse:\n    print(f'{p} < {a}, reject HO (Different distribution)')","18738ae9":"mean = get_bootstrap(\n    data_column_1 = df[df['type'] == 'conventional']['AveragePrice'], \n    data_column_2 = df[df['type'] == 'organic']['AveragePrice'], \n    color = '#006400',\n    boot_it = 1000, \n    statistic = np.mean, \n    bootstrap_conf_level = 0.95 \n)\nif mean['p_value'] > a:\n    print(f\"{mean['p_value']} > {a}, no reject HO (Same value)\")\nelse:\n    print(f\"{mean['p_value']} < {a}, reject HO (Different value)\")","4ce2fb67":"median = get_bootstrap(\n    data_column_1 = df[df['type'] == 'conventional']['AveragePrice'], \n    data_column_2 = df[df['type'] == 'organic']['AveragePrice'], \n    boot_it = 1000, \n    color = '#006400',\n    statistic = np.median, \n    bootstrap_conf_level = 0.95 \n)\nif median['p_value'] > a:\n    print(f\"{median['p_value']} > {a}, no reject HO (Same value)\")\nelse:\n    print(f\"{median['p_value']} < {a}, reject HO (Different value)\")","cd649199":"def get_bootstrap(\n    data_column_1, \n    data_column_2,\n    color,\n    statistic,\n    quantile,\n    boot_it = 1000,  \n    bootstrap_conf_level = 0.95\n):\n    boot_len = max([len(data_column_1), len(data_column_2)])\n    boot_data = []\n    for i in (range(boot_it)): \n        samples_1 = data_column_1.sample(\n            boot_len, \n            replace = True \n        ).values\n        \n        samples_2 = data_column_2.sample(\n            boot_len, \n            replace = True\n        ).values\n        \n        boot_data.append(statistic(samples_1-samples_2, quantile)) \n        \n    pd_boot_data = pd.DataFrame(boot_data)\n        \n    left_quant = (1 - bootstrap_conf_level)\/2\n    right_quant = 1 - (1 - bootstrap_conf_level) \/ 2\n    ci = pd_boot_data.quantile([left_quant, right_quant])\n        \n    p_1 = stats.norm.cdf(\n        x = 0, \n        loc = np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_2 = stats.norm.cdf(\n        x = 0, \n        loc = -np.mean(boot_data), \n        scale = np.std(boot_data)\n    )\n    p_value = min(p_1, p_2) * 2\n    return (ci)","becef00d":"percentiles = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\nlow = []\nhigh = []\nfor i in percentiles:\n    percentile = get_bootstrap(\n    data_column_1 = df[df['type'] == 'conventional']['AveragePrice'], \n    data_column_2 = df[df['type'] == 'organic']['AveragePrice'], \n    boot_it = 1000, \n    color = '#006400',\n    statistic = np.quantile, \n    quantile = i,\n    bootstrap_conf_level = 0.95 \n)\n    low.append(percentile.values[0][0])\n    high.append(percentile.values[1][0])","b0b5ead0":"plt.figure(figsize = (13, 6))\nplt.vlines(x = percentiles, ymin = low, ymax = high, lw = 3, color = '#006400')\nplt.hlines(y = 0, xmin = 0, xmax = 1, lw = 2, color = 'black')\nplt.xlabel('deciles', color = 'black', fontsize = 20, fontweight = 'bold')\nplt.ylabel('confidence intervals', color = 'black', fontsize = 20, fontweight = 'bold')\nplt.title('Confidence intervals by deciles', color = 'black', fontsize = 24, fontweight = 'bold', x = 0.2, y = 1.1)\nplt.tick_params(direction='out', length=8, width=4, colors='black', grid_color='black', labelsize = 16)\nsns.despine()","7dc300fb":"## How can we interpret the result?\n\n* Confidence interval - if it crosses 0, then we cannot reject H0;\n* p-value - if p > 0, then we cannot reject H0.","b3991dc0":"![https:\/\/storage.yandexcloud.net\/klms-public\/production\/learning-content\/11\/79\/621\/1799\/8302\/image.png](https:\/\/storage.yandexcloud.net\/klms-public\/production\/learning-content\/11\/79\/621\/1799\/8302\/image.png)","26a8d6ba":"## Source of function get_bootstrap - [KARPOV.COURSES](https:\/\/karpov.courses\/)","c91dd9fe":"## Both tests showed that there is a statistically significant difference between the types.\n\n## Let's apply bootstrap (mean and median).","b7086922":"## We have balanced groups. \n\n## Let's check distribution of average price.","f411f7a9":"## From chart we can see that no one confidence interval across 0, therefore, we have a statistical significance on each decile.","f2b5d6cc":"## Target - AveragePrice, groups - conventional and organic avocado.\n\n## I will add functions, which help me.\n\n## Let's analyze target and group.","add3b110":"## All tests reject H0. Another advantage of bootstrap is that we can find exactly where there are statistically significant differences. We can do this with percentiles. But need to modify the get_bootstrap function.","0a35a5ee":"## Now let's check non parametric test - Mann Whitney:","dc843768":"## Before apply botstrap I want to check classic - t-test and Mann Whitney. \n\n## To perform the t-test, the following criteria must be met:\n\n* Normal distribution;\n* homogeneity of variances.\n\n## What we can do in our situation? I suggest using the logarithm (1st problem) and parametre equal_var = False in scipy.stats.ttest_ind (2nd problem). ","11be4b36":"## In this notebook I want to apply bootstrap.\n## How bootstrap works:","1f7976ef":"## Shapori test reject H0 (H0 - distribution is normal). And from chart we can see not strong right skewed and some outliers. \n\n## And I want to see distribution average price by types."}}