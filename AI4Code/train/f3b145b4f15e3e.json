{"cell_type":{"01d53287":"code","9517787e":"code","baf75e1a":"code","d764ba6c":"code","5e3dcfcf":"code","f1e9889b":"code","308f7552":"code","255580b2":"code","fa9fb781":"code","547895a8":"code","5d890128":"code","0c7d2227":"code","ce77326f":"code","9d290e80":"code","5856a964":"code","e80b3316":"code","85b39d42":"code","aeae6b8b":"code","32c05f3c":"code","47f7898b":"code","1edab4d1":"code","bcf7d3e9":"code","8ee89879":"code","913b01ac":"code","7c20eca8":"code","2617c9b8":"code","95e29717":"code","bdfed189":"code","4e36cc29":"code","8b9deb7b":"code","9a040d73":"code","63f327cf":"code","824a999e":"markdown","768305d6":"markdown","b30d62ab":"markdown","b19ba6bb":"markdown"},"source":{"01d53287":"import numpy as np\nimport pandas as pd\nimport pydicom\nimport os\nimport cv2\nfrom pydicom.pixel_data_handlers.util import apply_voi_lut\nfrom PIL import Image\nfrom skimage import exposure\nfrom tqdm.auto import tqdm","9517787e":"def read_xray(path, voi_lut = True, fix_monochrome = True):\n    dicom = pydicom.read_file(path)\n    \n    # VOI LUT (if available by DICOM device) is used to transform raw DICOM data to \"human-friendly\" view\n    if voi_lut:\n        data = apply_voi_lut(dicom.pixel_array, dicom)\n    else:\n        data = dicom.pixel_array\n               \n    # depending on this value, X-ray may look inverted - fix that:\n    if fix_monochrome and dicom.PhotometricInterpretation == \"MONOCHROME1\":\n        data = np.amax(data) - data\n    \n    data = data - np.min(data)\n\n    # added\n    data = data \/ np.max(data)\n    data = (data * 255).astype(np.uint8)\n        \n    return data","baf75e1a":"def resize(img, size, padColor=0):\n\n    h, w = img.shape[:2]\n    sh, sw = size\n\n    # interpolation method\n    if h > sh or w > sw: # shrinking image\n        interp = cv2.INTER_AREA\n    else: # stretching image\n        interp = cv2.INTER_CUBIC\n\n    # aspect ratio of image\n    aspect = w\/h  # if on Python 2, you might need to cast as a float: float(w)\/h\n\n    # compute scaling and pad sizing\n    if aspect > 1: # horizontal image\n        new_w = sw\n        new_h = np.round(new_w\/aspect).astype(int)\n        pad_vert = (sh-new_h)\/2\n        pad_top, pad_bot = np.floor(pad_vert).astype(int), np.ceil(pad_vert).astype(int)\n        pad_left, pad_right = 0, 0\n    elif aspect < 1: # vertical image\n        new_h = sh\n        new_w = np.round(new_h*aspect).astype(int)\n        pad_horz = (sw-new_w)\/2\n        pad_left, pad_right = np.floor(pad_horz).astype(int), np.ceil(pad_horz).astype(int)\n        pad_top, pad_bot = 0, 0\n    else: # square image\n        new_h, new_w = sh, sw\n        pad_left, pad_right, pad_top, pad_bot = 0, 0, 0, 0\n\n    # set pad color\n    if len(img.shape) is 3 and not isinstance(padColor, (list, tuple, np.ndarray)): # color image but only one color provided\n        padColor = [padColor]*3\n\n    # scale and pad\n    scaled_img = cv2.resize(img, (new_w, new_h), interpolation=interp)\n    # keep aspect ratio (no padding)\n    # scaled_img = cv2.copyMakeBorder(scaled_img, pad_top, pad_bot, pad_left, pad_right, borderType=cv2.BORDER_CONSTANT, value=padColor)\n\n    return scaled_img","d764ba6c":"# test 1 img\nimage_id = []\norig_height = []\norig_width = []\nre_height = []\nre_width = []\n\nfor split in ['train']:\n    load_dir = f'..\/input\/vinbigdata-chest-xray-abnormalities-detection\/{split}\/'\n    save_dir = f'\/kaggle\/working\/{split}\/'\n    \n    os.makedirs(save_dir, exist_ok=True)\n\n    for file in tqdm(os.listdir(load_dir)):\n        xray = read_xray(load_dir + file)\n        im = resize(xray, (608,608))  # yolov4 default 608\n        im = exposure.equalize_hist(im) # histogram normalization\n        im = exposure.equalize_adapthist(im\/np.max(im)) #clahe\n        cv2.imwrite(save_dir + file.replace('dicom', 'jpg'), im*255)\n        \n        # shape[0] = height, 1 = width\n        if split == 'train':\n            image_id.append(file.replace('.dicom', ''))\n            re_height.append(im.shape[0])\n            re_width.append(im.shape[1])\n            orig_height.append(xray.shape[0])\n            orig_width.append(xray.shape[1])\n            \n            break\n    break","5e3dcfcf":"!ls \/kaggle\/working\/train\/","f1e9889b":"df_resized = pd.DataFrame.from_dict({\n    'image_id': image_id, \n    're_height': re_height, \n    're_width': re_width,\n    'orig_height': orig_height,\n    'orig_width': orig_width\n})\ndf_resized","308f7552":"# resize\nimage_id = []\norig_height = []\norig_width = []\nre_height = []\nre_width = []\n\nfor split in ['train', 'test']:\n    load_dir = f'..\/input\/vinbigdata-chest-xray-abnormalities-detection\/{split}\/'\n    save_dir = f'\/kaggle\/tmp\/{split}\/'\n#     save_dir = f'\/kaggle\/working\/{split}\/'\n\n\n    os.makedirs(save_dir, exist_ok=True)\n\n    for file in tqdm(os.listdir(load_dir)):\n        xray = read_xray(load_dir + file)\n        im = resize(xray, (608,608))  # yolov4 default 608\n        im = exposure.equalize_hist(im) # histogram normalization\n        im = exposure.equalize_adapthist(im\/np.max(im)) #clahe\n        cv2.imwrite(save_dir + file.replace('dicom', 'jpg'), im*255)\n        \n        # shape[0] = height, 1 = width\n        if split == 'train':\n            image_id.append(file.replace('.dicom', ''))\n            re_height.append(im.shape[0])\n            re_width.append(im.shape[1])\n            orig_height.append(xray.shape[0])\n            orig_width.append(xray.shape[1])","255580b2":"df_resized = pd.DataFrame.from_dict({\n    'image_id': image_id, \n    're_height': re_height, \n    're_width': re_width,\n    'orig_height': orig_height,\n    'orig_width': orig_width\n})\n","fa9fb781":"%cd \/kaggle\/tmp\/\n!ls","547895a8":"%cd \/kaggle\/tmp\/train\/\ndir = f'\/kaggle\/tmp\/train\/'\n\nfor file in os.listdir(dir):\n    im_id = file[:-4]\n    print(file)\n    break\nim_id","5d890128":"# shape[0] = height, 1 = width\n# resize\nimage_id = []\n# orig_height = []\n# orig_width = []\nre_height = []\nre_width = []\n\ndir = f'\/kaggle\/tmp\/train\/'\nfor file in tqdm(os.listdir(dir)):\n    im_id = file[:-4]\n    im =  cv2.imread(file)\n\n    image_id.append(im_id)\n    re_height.append(im.shape[0])\n    re_width.append(im.shape[1])","0c7d2227":"df_resized = pd.DataFrame.from_dict({\n    'image_id': image_id, \n    're_height': re_height, \n    're_width': re_width\n})","ce77326f":"%cd \/kaggle\/working\/","9d290e80":"import numpy as np\nimport pandas as pd\n\nimport pydicom\nimport glob\n\ndf = pd.read_csv(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train.csv\")\n\ndf.head()","5856a964":"dicom_metadata = [pydicom.filereader.dcmread(f\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train\/{image_id}.dicom\", stop_before_pixels=True) for image_id in df['image_id']]","e80b3316":"df['orig_width'] = [i.Columns for i in dicom_metadata]\ndf['orig_height'] = [i.Rows for i in dicom_metadata]","85b39d42":"df = df[df.class_id!=14].reset_index(drop = True)\n\nprint(\"We have {} unique images with boxes.\".format(len(df.image_id.unique())))\nunique_img_ids = df.image_id.unique()","aeae6b8b":"df = df.merge(df_resized, how='left', on='image_id')","32c05f3c":"df.head().T","47f7898b":"# # resized reindex\n# df['x'] = df.apply(lambda row: row.x_min*(row.re_width\/row.orig_width), axis =1)\n# df['y'] = df.apply(lambda row: row.y_min*(row.re_height\/row.orig_height), axis =1)\n\n# df['x_re_max'] = df.apply(lambda row: row.x_max*(row.re_width\/row.orig_width), axis =1)\n# df['y_re_max'] = df.apply(lambda row: row.y_max*(row.re_height\/row.orig_height), axis =1)","1edab4d1":"# # resized reindex\n# df['x_re_min'] = df.apply(lambda row: row.x_min*(row.re_width_x\/row.orig_width), axis =1)\n# df['y_re_min'] = df.apply(lambda row: row.y_min*(row.re_height_x\/row.orig_height), axis =1)\n\n# df['x_re_max'] = df.apply(lambda row: row.x_max*(row.re_width_x\/row.orig_width), axis =1)\n# df['y_re_max'] = df.apply(lambda row: row.y_max*(row.re_height_x\/row.orig_height), axis =1)","bcf7d3e9":"# yolov4 format\ndf['x_mid'] = df.apply(lambda row: (row.x_min+row.x_max)\/2, axis =1)\ndf['y_mid'] = df.apply(lambda row: (row.y_re_max+row.y_re_min)\/2, axis =1)\n\n# df['w'] = df.apply(lambda row: (row.x_re_max-row.x_re_min), axis =1)\n# df['h'] = df.apply(lambda row: (row.y_re_max-row.y_re_min), axis =1)\n\n# df['area'] = df['w']*df['h']\ndf.head()","8ee89879":"df['yolo_box'] = df[['x_mid', 'y_mid', 'w', 'h']].values.tolist()\n\nprint(\"We have {} unique images with boxes.\".format(len(df.image_id.unique())))\nunique_img_ids = df.image_id.unique()","913b01ac":"%cd \/kaggle\/tmp\/","7c20eca8":"folder_location = \"\/kaggle\/tmp\/train\/\"\n\nfor img_id in tqdm(unique_img_ids): # loop through all unique image ids. Remove the slice to do all images\n    filt_df = df.query(\"image_id == @img_id\") # filter the df to a specific id\n    #all_boxes = filt_df.yolo_box.values\n    file_name = \"{}\/{}.txt\".format(folder_location,img_id) # specify the name of the folder and get a file name\n\n    with open(file_name, 'w+') as file: # append lines to file\n        for i in filt_df.iterrows():\n            s = f\"{i[1].class_id} %s %s %s %s \\n\" # The first number is the class name\n            new_line = (s % tuple(i[1].yolo_box))\n            file.write(new_line)","2617c9b8":"!ls \/kaggle\/tmp\/train\/","95e29717":"# Create labels for training images that do not have bounding boxes\n# If you wish to train on only images with a finding, remove this code cell\nall_imgs = glob.glob(\"..\/input\/vinbigdata-chest-xray-abnormalities-detection\/train\/*.dicom\")\nall_imgs = [i.split(\"\/\")[-1].replace(\".dicom\", \"\") for i in all_imgs]\npositive_imgs = df.image_id.unique()\n\nnegative_images = set(all_imgs) - set(positive_imgs)\nprint('All images:', len(all_imgs), 'Positive images:', len(positive_imgs))\n\nfor i in tqdm(list(negative_images)):\n    file_name = \"{}\/{}.txt\".format(folder_location, i)\n    #print(file_name)\n    with open(file_name, 'w') as fp:\n        pass","bdfed189":"%%capture\n\n# zip to make files easier to download\n\n!zip -r yolo_labels.zip \/kaggle\/tmp\/","4e36cc29":"!mv \/kaggle\/tmp\/yolo_labels.zip \/kaggle\/working\/","8b9deb7b":"# resize\nimage_id = []\norig_height = []\norig_width = []\nre_height = []\nre_width = []\n\n#test\nload_dir = f'..\/input\/vinbigdata-chest-xray-abnormalities-detection\/test\/'\nsave_dir = f'\/kaggle\/working\/test\/'\n#     save_dir = f'\/kaggle\/working\/{split}\/'\n\n\nos.makedirs(save_dir, exist_ok=True)\n\nfor file in tqdm(os.listdir(load_dir)):\n    xray = read_xray(load_dir + file)\n    im = resize(xray, (608,608))  # yolov4 default 608\n    im = exposure.equalize_hist(im) # histogram normalization\n    im = exposure.equalize_adapthist(im\/np.max(im)) #clahe\n    cv2.imwrite(save_dir + file.replace('dicom', 'jpg'), im*255)","9a040d73":"%%capture\n\n# zip to make files easier to download\n\n!zip -r yolo_test.zip \/kaggle\/working\/test","63f327cf":"!ls","824a999e":"---\nDownsize https:\/\/www.kaggle.com\/xhlulu\/vinbigdata-process-and-resize-to-jpg\n\nto 608px and normalize+CLIHE images","768305d6":"---\nclean up","b30d62ab":"---\nclean up","b19ba6bb":"---\nCreate yolov4 txt files\n\nhttps:\/\/www.kaggle.com\/jackpodkim\/vbd-convert-labels-to-yolo-yolov4\/edit"}}