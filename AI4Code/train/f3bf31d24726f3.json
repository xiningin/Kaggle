{"cell_type":{"2ad371b5":"code","2cfb54c1":"code","ac96248a":"code","25493a79":"code","da8a2b93":"code","9fb8a2d7":"code","8e39f0e6":"code","b4947e98":"code","118d74da":"code","59574a90":"code","d31ca06a":"code","d53cf9fa":"code","f8a77238":"code","a68d1424":"code","5713c198":"code","2ae07bc4":"code","fcdf1c18":"code","2eee2936":"code","7b78dc98":"code","43f8ab12":"code","d606fba1":"code","77fd82c2":"code","68dab598":"code","1ec635fc":"code","5bd4a98d":"code","b949a22e":"code","6f541fc1":"code","2e0562ae":"code","31c84726":"code","e13c63c8":"markdown","32e69b12":"markdown","e4214973":"markdown"},"source":{"2ad371b5":"#It is a good practice to import all the modules required for training the model.\nimport torch\nimport torchvision\nimport torch.nn as nn\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F\nfrom torchvision.datasets.utils import download_url\nfrom torch.utils.data import DataLoader, TensorDataset, random_split","2cfb54c1":"DATASET_URL = \"https:\/\/archive.ics.uci.edu\/ml\/machine-learning-databases\/00242\/ENB2012_data.xlsx\" #The url of the dataset is given here\nDATA_FILENAME = \"Energyefficiency.csv\" #the name of the saved downloaded file.\ndownload_url(DATASET_URL, root='.',filename=DATA_FILENAME) #Don't forget to add the directory(any name where the downloaded file is saved) at the root parameter.","ac96248a":"# To read the data from the excel file(.xlsx means excel),we use pandas dataframe where dataframe is like row by column which can be visualized below.\ndataframe = pd.read_excel(DATA_FILENAME) \ndataframe.head(5) #It is used to get the first 5 rows of the dataframe.","25493a79":"num_rows = len(dataframe)\nprint(num_rows)","da8a2b93":"num_cols = sum(1 for i in dataframe.columns)\nprint(num_cols)","9fb8a2d7":"input_cols = [i for i in dataframe.columns if(i!='Y1' and i!='Y2')] #the column titles of the input variables\nprint(len(input_cols))","8e39f0e6":"output_cols = ['Y1','Y2'] #the column titles of output\/target variable(s)\nprint(len(output_cols))","b4947e98":"# Visualizing the distribution of target values in a graph.\nplt.plot(dataframe['Y1'],'r')\nplt.plot(dataframe['Y2'],'b')\nplt.legend(['heating load','cooling load'])\nplt.show()","118d74da":"import numpy as np\ndef dataframe_to_arrays(dataframe):\n    # Make a copy of the original dataframe as we may need the original one if anything goes wrong which is a good practice.\n    dataframe1 = dataframe.copy(deep=True)\n    # Extract input & outupts as numpy arrays of datatype float32 as the model expects the data to be float instead of double.\n    inputs_array = dataframe1[input_cols].to_numpy().astype(np.float32)\n    targets_array = dataframe1[output_cols].to_numpy().astype(np.float32)\n    return inputs_array, targets_array","59574a90":"inputs_array, targets_array = dataframe_to_arrays(dataframe)\ninputs_array, targets_array","d31ca06a":"# We should convert the numpy arrays into tensor as the model expects tensors.\ninputs = torch.from_numpy(inputs_array)\ntargets = torch.from_numpy(targets_array)","d53cf9fa":"#let's confirm that the datatype is float\ninputs.dtype, targets.dtype","f8a77238":"# Let's now create the dataset with inputs and targets combined to create batches at next step\ndataset = TensorDataset(inputs, targets)","a68d1424":"# It is necessary to split the data into train and validation in order to evaluate the model on untouched data while training the model.\ntorch.manual_seed(16)#this will make the random same everytime we run this notebook which will help us evaluate a particular value as we do below .\nval_percent = 0.1 # between 0.1 and 0.2 is good.\nval_size = int(num_rows * val_percent)\ntrain_size = num_rows - val_size\n\n\ntrain_ds, val_ds = random_split(dataset,[train_size,val_size]) # Use the random_split function to split dataset into 2 parts of the desired length.","5713c198":"#Usually we take batch_size as a power of 2(i.e,16,32,64,...) as it improves the speed of the traing convergence(i.e,loss is reduced to minimum soon)\nbatch_size = 128","2ae07bc4":"train_loader = DataLoader(train_ds, batch_size, shuffle=True, num_workers=4, pin_memory=True) #pin_memory enables the data to be loaded into pinmemory which speedups the GPU loading action.\nval_loader = DataLoader(val_ds, batch_size*2, num_workers=4, pin_memory=True) # num_works are used when the dataset is large to make the loading fat as it is done parallely by 4 systems.","fcdf1c18":"#Let's have a look at the first batch.\nfor xb, yb in train_loader:\n    print(\"inputs:\", xb)\n    print(\"targets:\", yb)\n    break","2eee2936":"input_size = len(input_cols)\noutput_size = len(output_cols)","7b78dc98":"class EfficiencyModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        #input layer\n        self.linear1=nn.Linear(input_size,128)  # we have to pass the number of inputs(number of input columns) and the number of hidden units\n        #hidden layers\n        self.linear2=nn.Linear(128,64) #previous layer hidden units count and the current layer's hidden units count\n        self.linear3=nn.Linear(64,32) # make sure that the previous layer hidden units count and the current layer's hidden units count are equal.\n        self.linear4=nn.Linear(32,16)\n        self.linear5=nn.Linear(16,8) #it is not mandatory to reduce the hidden units as we go below the layers. Try for different combinations and get the best one for your problem.\n        #output layer\n        self.linear6=nn.Linear(8,output_size) # here we need to pass previous layers hidden units count and number of outputs(number of output columns) as we mentioned above.\n        \n    def forward(self, xb):\n        # Flatten images into vectors\n        out = xb.view(xb.size(0), -1) #As the model expects the features to flattened(i.e, all the features are stacked vertically),view()will do this for us where -1 makes the model to rest features as 2nd dimension.\n        # Apply layers & activation functions\n        out= self.linear1(out) #It is an inbuilt-method for linear regression i.e  z= w*x +b where w is the weight and b is the bias\n        out=F.relu(out)  #As we can know from the previous post that linear relation can't make a good prediction , now we are using a non-linear activation function called rectified linear units (Relu)\n        out= self.linear2(out)\n        out=F.relu(out)\n        out= self.linear3(out)\n        out=F.relu(out)\n        out= self.linear4(out)     # you can even use different variables(i.e instead of out) but don't forget to pass it to the next layer\n        out=F.relu(out)\n        out= self.linear5(out)\n        out=F.relu(out)\n        out=self.linear6(out)  # here we used 6 layers including 4 hidden layers.\n        return out\n    def training_step(self, batch):\n        inputs, targets = batch \n        # Generate predictions\n        out = self(inputs)  #which returns the predicted values      \n        # Calcuate loss\n        loss = F.l1_loss(out,targets) #L1 loss(i.e ((1\/num_rows)*(predicted-target)^2)^1\/2) which is used to calculate the loss. Although there are lot loss functions, l1_loss will be more suitable for linear reg.\n        return loss\n    \n    def validation_step(self, batch):\n        inputs, targets = batch\n        # Generate predictions\n        out = self(inputs)\n        # Calculate loss\n        loss = F.l1_loss(out,targets)                           # l1_loss is calculated for validation set   \n        return {'val_loss': loss.detach()}  \n        #detach() is used to remove this from computational graph as it may confuse the backprop since it is the loss of validation set to clear the memory whic will make training fast.\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combining losses for all the batches to compute a single loss value\n        return {'val_loss': epoch_loss.item()}\n    \n    def epoch_end(self, epoch, result, num_epochs):\n        # Print result every 20th epoch where epoch represents a complete traversal through the training examples.\n        if (epoch+1) % 2 == 0 or epoch == num_epochs-1:\n            print(\"Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}\".format(epoch+1, result['loss'],result['val_loss']))","43f8ab12":"torch.cuda.is_available() #This gives whether the gpu is available or not in form of boolean(true or false)\ndef get_default_device():\n    \"\"\"To pick GPU if available, else CPU so that the program won't crash if gpu not available\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')\ndevice=get_default_device() #and hence the device available will stored as device\nprint(device)\ndef to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device as everything should be present in the respective device \"\"\"\n    if isinstance(data, (list,tuple)): # isinstance() checks whether the input is of the desired type like it is list or tuple and will go next only if the condition is passed.\n        return [to_device(x, device) for x in data] #each batch is moved one by one\n    return data.to(device, non_blocking=True) #thus the data is moved according to the device selected\n\nclass DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device .Don't worry if you dont't get it,just do as instructed\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)\n#The above class will perform the functions when the instance is called.","d606fba1":"#Let's now create the instances for the both train and validation data.\ntrain_loader = DeviceDataLoader(train_loader, device)\nval_loader = DeviceDataLoader(val_loader, device)","77fd82c2":"model = to_device(EfficiencyModel(),device) #Initializing the model and also moving the model to the device ","68dab598":"#once the model is initialized ,all the w's(weights) and b's(biases) are initialized at random which are then updated by calculating the derivative of the loss fuction with respect to both w and b respectively.\n#This is how the model is made to learn the relations between inputs and targets.\nlist(model.parameters()) ","1ec635fc":"def evaluate(model, val_loader):\n    #To evaluate the validation set\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    history = []\n    optimizer = opt_func(model.parameters(), lr) #optimizer which is used update the parameters. Stochastic Gradient Descent is mostly used for linear reg. problems.\n    for epoch in range(epochs):\n        # Training Phase \n        losses=[]\n        for batch in train_loader:\n            loss = model.training_step(batch)\n            losses.append(loss) #the training losses are stored for every batch for future visualizations.\n            loss.backward() # Backpropagation(i.e, derivative(slope) calculation) is made by the model.\n            optimizer.step() #It updates the weights and biases with the derivatives and learning rate(i.e, w=w-lr*dw)\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        result['loss']= torch.stack(losses).mean()  #The mean of training losses is stored for each epoch.\n        model.epoch_end(epoch, result, epochs)\n        history.append(result) #appending the results for visualization purposes.\n    return history","5bd4a98d":"result = evaluate(model,val_loader) # Use the the evaluate function to evaluate the model.\nprint(result)","b949a22e":"epochs = 160 #number of epochs to run the model.\nlr = 0.5e-3  #learning rate\nmodel = to_device(EfficiencyModel(),device)\nhistory = fit(epochs, lr, model, train_loader, val_loader)","6f541fc1":"val_loss = evaluate(model,val_loader)\nprint(val_loss)\n#Let's visualize the validation loss for the epochs\nplt.plot([i['loss'] for i in history],'r')\nplt.plot([i['val_loss'] for i in history],'b')\nplt.xlabel(\"epochs\")\nplt.ylabel(\"losses\")\nplt.legend(['loss','val_loss'])\nplt.show()","2e0562ae":"def predict_single(input, target, model):\n    predictions = model(input.unsqueeze(0))     \n    prediction = predictions[0].detach() #detach() is done to remove it from the computational graphs i.e, its dervatives are no longer calculated.\n    print(\"Input:\", input)\n    print(\"Target:\", target)\n    print(\"Prediction:\", prediction)","31c84726":"#Let's check the predictions of the model by passing a value from the validation set(you can also try by passing a tensor of your wish as torch.tensor([...]))\nprint(val_ds[4])\nval=DeviceDataLoader(val_ds[4],device) #we have to move the data to the available device to avoid errors.\ninput, target = val\npredict_single(input, target, model)","e13c63c8":"## Step 3: Create a Linear Regression Model\n\nOur model itself is a fairly straightforward linear regression (we'll build more complex models in the next assignment). \n","32e69b12":"## Step 4: Train the model to fit the data\n\nTo train our model, we'll use the same `fit` function explained in the lecture. That's the benefit of defining a generic training loop - you can use it for any problem.","e4214973":"## Step 2: Prepare the dataset for training\n\nWe need to convert the data from the Pandas dataframe into a PyTorch tensors for training. To do this, the first step is to convert it numpy arrays. If you've filled out `input_cols`, `categorial_cols` and `output_cols` correctly, this following function will perform the conversion to numpy arrays."}}