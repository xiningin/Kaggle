{"cell_type":{"a4a7638d":"code","10249587":"markdown"},"source":{"a4a7638d":"## This program uses the bisection method \n## to find the root of f(x) = exp(x)*ln(x)-x*x = 0\n\n# math functions and constants\nimport math \n\n# solution tolerance\ntolerance = 1.0e-6\n\n# function definition\ndef f(x):\n    f = math.exp(x)*math.log(x) - x*x\n    return f\n\n# Get the initial guesses\na = 1\nb = 5\n\n# Set the counter\ncnt = 0\n\n# initial value of dx\ndx = abs(b-a)\n\nif f(a)*f(b) > 0:\n    # Both f(a) and f(b) are the same sign\n    print(\"No root found\")   \nelse:   \n    # Repeat until dx < tolerance\n    while dx > tolerance:\n        \n        x = (a+b) \/ 2.0\n        cnt = cnt +1\n        \n        # root is in left half\n        if f(a)*f(x) < 0:\n            b = x\n            print(cnt , \"  [ \", a , \" , \" , x , \" ]\")\n        # root is in right half\n        else:\n            a = x\n            print(cnt , \"  [ \", x , \" , \" , b , \" ]\")\n        # update uncertainty in root location\n        dx = abs(b-a)  \n        \n    print(\"\\n\\nFound f(x) = 0 at x = \", x , \" with tolerance = \" , tolerance)","10249587":"## Bisection Method\nThe simplest **root finding algorithm** is the bisection method. The algorithm applies to any **continuous** function **f(x)** on an interval **[a,b]**  where the value of the function **f(x)** changes sign from **a** to **b** .\n\n## Algorithm\nThe bisection method procedure is:\n\n**(1)** Choose a starting interval **[a\u2080 , b\u2080]** such that :\n$$ f(a_{0}) \\times f(b_{0})<0 $$\n**(2)** Compute **f(m\u2080)** where :\n$$ m_{0}=\\frac{a_{0}+b_{0}}{2} $$\n**(3)** Determine the next subinterval **[a\u2081 , b\u2081]** :\n* If **f(a\u2080)f(m\u2080)<0**, then let **[a\u2081 , b\u2081]** be the next interval with **a\u2081=a\u2080** and **b\u2081=m\u2080** .\n* If **f(b\u2080)f(m\u2080)<0**, then let **[a\u2081 , b\u2081]** be the next interval with **a\u2081=m\u2080** and **b\u2081=b\u2080** .\n\n**(4)** Repeat (2) and (3) until the interval **[a<sub>N<\/sub> , b<sub>N<\/sub>]** reaches some predetermined length.\n\n**(5)** Return the midpoint value:\n$$ m_{N}=\\frac{a_{N}+b_{N}}{2} $$\n\nA solution of the equation **f(x)=0** in the interval **[a,b]** is guaranteed by the Intermediate Value Theorem provided **f(x)** is continuous on **[a,b]** and **f(a)f(b)<0** . In other words, the function changes sign over the interval and therefore must equal 0 at some point in the interval **[a,b]**.\n\n## Absolute Error\nThe bisection method does not (in general) produce an exact solution of an equation **f(x)=0**. However, we can give an estimate of the absolute error in the approxiation.\n\n**Theorem.** Let **f(x)** be a continuous function on **[a , b]** such that **f(a)f(b)<0** . After **N** iterations of the biection method, let **x<sub>N<\/sub>** be the midpoint in the **Nth** subinterval **[a<sub>N<\/sub> , b<sub>N<\/sub>]**\n\n$$ x_{N}=\\frac{a_{N}+b_{N}}{2} $$\n\nThere exists an exact solution **x<sub>true<\/sub>** of the equation **f(x)** in the subinterval **[a<sub>N<\/sub> , b<sub>N<\/sub>]** and the absolute error is:\n\n$$ \\left | x_{true} - x_{N} \\right |\\leqslant \\frac{b-a}{2^{N+1}} $$\n\nNote that we can rearrange the error bound to see the **minimum number of iterations** required to guarantee absolute error less than a prescribed **\u03b5**:\n\n$$\n\\begin{matrix}\n\\frac{b-a}{2^{N+1}}< \\varepsilon \\\\\n\\\\\n\\frac{b-a}{\\varepsilon}< 2^{N+1}  \\\\\n\\\\\nln(\\frac{b-a}{\\varepsilon})< (N+1)ln(2))\\\\\n\\\\\n\\frac{ln(\\frac{b-a}{\\varepsilon})}{ln(2)}-1< N\n\\end{matrix}\n$$\n\n## Example\n![alt text](https:\/\/yaser-rahmati.gitbook.io\/~\/files\/v0\/b\/gitbook-x-prod.appspot.com\/o\/spaces%2F-M2g31CUvdCruJm660Ot%2Fuploads%2F2DcKOnONfeSsSsnk9CF9%2F954.png?alt=media&token=1a163103-41cf-4dd0-87a6-22b2e696940d \"Bisection Method\")\n\n## Implementation"}}