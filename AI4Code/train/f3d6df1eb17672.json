{"cell_type":{"3a228ff8":"code","ba2a248c":"code","f9783499":"code","b39c0c68":"code","b0ca584f":"code","13461488":"code","e6b8fd0b":"code","8433543e":"code","81a97b76":"code","11b6b9ba":"code","1da6a16e":"code","6aafb5f5":"markdown","d1fdcd97":"markdown","1fcba472":"markdown","26ccae85":"markdown","98805036":"markdown"},"source":{"3a228ff8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","ba2a248c":"import numpy as np\nimport pandas as pd\nfrom tensorflow.python.keras.applications.resnet50 import preprocess_input\nfrom tensorflow.python.keras.preprocessing.image import load_img, img_to_array\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.python import keras\nfrom tensorflow.python.keras.models import Sequential\nfrom tensorflow.python.keras.layers import Dense, Flatten, Conv2D, Dropout","f9783499":"train_img_dir = \"..\/input\/train\/train\/\"\ntrain_img_pathes = [train_img_dir + fpath for fpath in sorted(os.listdir(train_img_dir))]\n\ndf = pd.read_csv(\"..\/input\/train.csv\")\n\ntrain_img_pathes[:5]","b39c0c68":"# Check corresponding between labels and imgs\nlst = sorted(os.listdir(train_img_dir))\nerr = False\n\nfor i, idx in enumerate(df[\"id\"]):\n    if idx != lst[i]:\n        print(\"mismatch after %d iterations\" % i)\n        err = True\n        break\n\nif not err:\n    print(\"1:1 corresponding between train_img_pathes and df labels\")","b0ca584f":"img_size = 32\n\n\ndef read_and_prep_images(img_paths, img_height=img_size, img_width=img_size):\n    # to avoid OSError tooManyOpenedFiles I used batch loading\n    img_load_batch_size = 900\n    output = None\n    \n    for i in range(0, len(img_paths), img_load_batch_size):\n        print(\"process batch %d\" % i)\n        tmp_imgs =  [load_img(img_path, target_size=(img_height, img_width)) \n                     for img_path \n                     in img_paths[i:i+img_load_batch_size]]\n        tmp_img_array = np.array([img_to_array(img) for img in tmp_imgs])\n        \n        if type(output) != np.ndarray:\n            output = preprocess_input(tmp_img_array)\n        else:\n            output = np.vstack((output, preprocess_input(tmp_img_array)))\n        \n    return(output)\n\n\ntrain_imgs = read_and_prep_images(train_img_pathes)\n","13461488":"num_classes = 2\nout_y = keras.utils.to_categorical(df[\"has_cactus\"], num_classes)\n\nnp.shape(train_imgs[0])\n\nmodel = Sequential()","e6b8fd0b":"model.add(Conv2D(filters=50, kernel_size=(3, 3), input_shape=(32, 32, 3), activation=\"relu\"))\nmodel.add(Dropout(0.5))\nmodel.add(Conv2D(30, kernel_size=(3, 3), activation=\"relu\"))\nmodel.add(Dropout(0.5))\nmodel.add(Flatten())\nmodel.add(Dense(54, activation=\"relu\"))\nmodel.add(Dense(num_classes, activation=\"softmax\"))\n\n\nmodel.compile(loss=keras.losses.categorical_crossentropy,\n              optimizer=\"adam\",\n              metrics=[\"accuracy\"])\n","8433543e":"model.fit(train_imgs, out_y,\n          batch_size=int(17500*0.8\/100),\n          epochs=4,\n          validation_split = 0.2)","81a97b76":"test_img_dir = \"..\/input\/test\/test\/\"\ntest_img_pathes = [test_img_dir + fpath for fpath in sorted(os.listdir(test_img_dir))]\ntest_imgs = read_and_prep_images(test_img_pathes)\n\ntest_img_pathes[:5]","11b6b9ba":"prediction = model.predict_proba(test_imgs)[:, 1]\nanswer = pd.DataFrame(columns=(\"id\", \"has_cactus\"))\n\ngetFilename = lambda s: s.split(\"\/\")[-1]\nfor i in range(len(test_img_pathes)):\n    #print(getFilename(test_img_pathes[i]), prediction[i])\n    answer.loc[i] = (getFilename(test_img_pathes[i]), prediction[i])\n\nanswer.head()","1da6a16e":"answer.to_csv(\"submission.csv\", index=False)","6aafb5f5":"Fit model","d1fdcd97":"Prepare model\n","1fcba472":"Make predictions and write them to file","26ccae85":"Load train imgs data and labels\n","98805036":"Now ready to classify test images"}}