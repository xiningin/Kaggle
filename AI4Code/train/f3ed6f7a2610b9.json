{"cell_type":{"ba9e2dd4":"code","9cea16ea":"code","03b477e3":"code","e966b64e":"code","404aa770":"code","e8d97eb4":"code","81ccdfcc":"code","56c42f3b":"code","7fdd0b17":"code","791fe5b7":"code","1e031b60":"code","8e4b3f6a":"code","a7d3cc21":"code","e2026189":"code","4e326330":"code","a00ebf56":"code","140a9821":"code","3fe58024":"code","bb97d81d":"code","4f053238":"code","6c9e505f":"code","1c9f794b":"code","1000fbb8":"code","a05a3379":"code","cf8cf9a2":"code","7fd6e76e":"code","2db01a8f":"code","65f3c097":"code","48b2bb5e":"code","55025098":"code","991eda58":"code","e9c7d004":"code","bd4f311a":"markdown","c46e17c9":"markdown","5a304e7f":"markdown"},"source":{"ba9e2dd4":"from itertools import product\nimport random\nimport numpy as np\nimport pandas as pd\nfrom numba import njit\n\nimport matplotlib.pylab as plt\n#%pylab inline\nimport seaborn as sns\nfrom ortools.linear_solver import pywraplp\n\n#from numpy.core import fromnumeric","9cea16ea":"def get_penalty(n, choice):\n    penalty = None\n    if choice == 0:\n        penalty = 0\n    elif choice == 1:\n        penalty = 50\n    elif choice == 2:\n        penalty = 50 + 9 * n\n    elif choice == 3:\n        penalty = 100 + 9 * n\n    elif choice == 4:\n        penalty = 200 + 9 * n\n    elif choice == 5:\n        penalty = 200 + 18 * n\n    elif choice == 6:\n        penalty = 300 + 18 * n\n    elif choice == 7:\n        penalty = 300 + 36 * n\n    elif choice == 8:\n        penalty = 400 + 36 * n\n    elif choice == 9:\n        penalty = 500 + 36 * n + 199 * n\n    else:\n        penalty = 500 + 36 * n + 398 * n\n    return penalty\n\n\ndef GetPreferenceCostMatrix(data):\n    cost_matrix = np.zeros((N_FAMILIES, N_DAYS), dtype=np.int64)\n    for i in range(N_FAMILIES):\n        desired = data.values[i, :-1]\n        cost_matrix[i, :] = get_penalty(FAMILY_SIZE[i], 9)  #10\n        for j, day in enumerate(desired):\n            cost_matrix[i, day-1] = get_penalty(FAMILY_SIZE[i], j)\n    return cost_matrix\n\n\ndef GetAccountingCostMatrix():\n    ac = np.zeros((1000, 1000), dtype=np.float64)\n    for n in range(ac.shape[0]):\n        for n_p1 in range(ac.shape[1]):\n            diff = abs(n - n_p1)\n            ac[n, n_p1] = max(0, (n - 125) \/ 400 * n**(0.5 + diff \/ 50.0))\n    return ac","03b477e3":"penalty_values = []\nfor j in (2,3,4,5,6,7,8):\n    for i in range(10):\n        #print('Penalty for Choice', i ,'for ',j,'member family is: ' ,get_penalty(j, i))\n        penalty_values = pd.DataFrame([i,j,get_penalty(j, i)] for j in (2,3,4,5,6,7,8)  for i in range(10))\npenalty_values.columns = ['Choice', 'Family_Size', 'Penalty']        \nprint(penalty_values)","e966b64e":"import matplotlib as mpl\nlabel_size = 22\nmpl.rcParams['xtick.labelsize'] = label_size \nmpl.rcParams['ytick.labelsize'] = label_size\n# Generate a mask for the upper triangle\nsns.set_style(\"whitegrid\")\n\nax = plt.figure(figsize=(16,8))\n\n# Add transparency to colors\nfor patch in ax.artists:\n    r, g, b, a = patch.get_facecolor()\n    patch.set_facecolor((r, g, b, .9))\n \nax = sns.lineplot(x=\"Family_Size\", y=\"Penalty\", data=penalty_values,linewidth=4,hue=\"Choice\",color='#666666',\n                  marker='o',markersize=14,palette=\"Oranges\")\n\nplt.title(\"Penalty \\n\", loc=\"center\",size=32,color='#34495E',alpha=0.8)\nplt.xlabel('Family Size',color='#34495E',fontsize=20) \nplt.ylabel('Penalty',color='#34495E',fontsize=20)\nplt.xticks(size=15,color='#008abc',rotation='horizontal', wrap=True)\nplt.yticks(size=15,color='#006600')\nplt.ylim(0,2500)\nplt.legend(loc='best', labels=['Choice 0','Choice 1','Choice 2','Choice 3','Choice 4','Choice 5','Choice 6','Choice 7',\n                              'Choice 8','Choice 9'],\n           handlelength=6,fontsize=10,ncol=2,framealpha=0.99)","404aa770":"del penalty_values","e8d97eb4":"# cost_function, etc.\n\n# preference cost\n@njit(fastmath=True)\ndef pcost(prediction):\n    daily_occupancy = np.zeros(N_DAYS+1, dtype=np.int64)\n    penalty = 0\n    for (i, p) in enumerate(prediction):\n        n = FAMILY_SIZE[i]\n        penalty += PCOSTM[i, p]\n        daily_occupancy[p] += n\n    return penalty, daily_occupancy\n\n\n# accounting cost\n@njit(fastmath=True)\ndef acost(daily_occupancy):\n    accounting_cost = 0\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_p1 = daily_occupancy[day + 1]\n        n    = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        accounting_cost += ACOSTM[n, n_p1]\n    return accounting_cost, n_out_of_range\n\n\n@njit(fastmath=True)\ndef acostd(daily_occupancy):\n    accounting_cost = np.zeros(N_DAYS, dtype=np.float64)\n    n_out_of_range = 0\n    daily_occupancy[-1] = daily_occupancy[-2]\n    for day in range(N_DAYS):\n        n_p1 = daily_occupancy[day + 1]\n        n    = daily_occupancy[day]\n        n_out_of_range += (n > MAX_OCCUPANCY) or (n < MIN_OCCUPANCY)\n        accounting_cost[day] = ACOSTM[n, n_p1]\n    return accounting_cost, n_out_of_range\n\n\n@njit(fastmath=True)\ndef pcostd(prediction):\n    daily_occupancy = np.zeros(N_DAYS+1, dtype=np.int64)\n    penalty = np.empty_like(prediction)\n    for (i, p) in enumerate(prediction):\n        n = FAMILY_SIZE[i]\n        penalty[i] = PCOSTM[i, p]\n        daily_occupancy[p] += n\n    return penalty, daily_occupancy\n\n\n@njit(fastmath=True)\ndef cost_stats(prediction):\n    penalty, daily_occupancy = pcostd(prediction)\n    accounting_cost, n_out_of_range = acostd(daily_occupancy)\n    return penalty, accounting_cost, n_out_of_range, daily_occupancy[:-1]\n\n\n@njit(fastmath=True)\ndef cost_function(prediction):\n    penalty, daily_occupancy = pcost(prediction)\n    accounting_cost, n_out_of_range = acost(daily_occupancy)\n    return penalty + accounting_cost + n_out_of_range*100000000","81ccdfcc":"# fixMinOccupancy, fixMaxOccupancy + helpers\n\n@njit(fastmath=True)\ndef cost_function_(prediction):\n    penalty, daily_occupancy = pcost(prediction)\n    accounting_cost, n_out_of_range = acost(daily_occupancy)\n    return penalty + accounting_cost, n_out_of_range\n\n\n@njit(fastmath=True)\ndef findAnotherDay4Fam(prediction, fam, occupancy):\n    old_day = prediction[fam]\n    best_cost = np.inf\n    best_day = fam\n    n = FAMILY_SIZE[fam]\n    \n    daysrange = list(range(0,old_day))+list(range(old_day+1,N_DAYS))\n    for day in daysrange:\n        prediction[fam] = day\n        new_cost, _ = cost_function_(prediction)\n        \n        if (new_cost<best_cost) and (occupancy[day]+n<=MAX_OCCUPANCY):\n            best_cost = new_cost\n            best_day = day\n            \n    prediction[fam] = old_day\n    return best_day, best_cost\n\n\n@njit(fastmath=True)\ndef bestFamAdd(prediction, day, occupancy):\n    best_cost = np.inf\n    best_fam = prediction[day]\n    for fam in np.where(prediction!=day)[0]:\n        old_day = prediction[fam]\n        prediction[fam] = day\n        new_cost, _ = cost_function_(prediction)\n        prediction[fam] = old_day\n        n = FAMILY_SIZE[fam]\n        if (new_cost<best_cost) and (occupancy[old_day]-n>=MIN_OCCUPANCY):\n            best_cost = new_cost\n            best_fam = fam   \n    return best_fam\n\n\n@njit(fastmath=True)\ndef bestFamRemoval(prediction, day, occupancy):\n    best_cost = np.inf\n    best_day = day\n    \n    for fam in np.where(prediction==day)[0]:\n        new_day, new_cost = findAnotherDay4Fam(prediction, fam, occupancy)\n        if new_cost<best_cost:\n            best_cost = new_cost\n            best_fam = fam\n            best_day = new_day\n            \n    return best_fam, best_day\n\n\n@njit(fastmath=True)\ndef fixMaxOccupancy(prediction):\n    penalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)\n\n    for day in np.where(occupancy>MAX_OCCUPANCY)[0]:\n        while occupancy[day]>MAX_OCCUPANCY:\n            fam, new_day = bestFamRemoval(prediction, day, occupancy)\n            prediction[fam] = new_day\n            penalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)\n            \n            \n@njit(fastmath=True)\ndef fixMinOccupancy(prediction):\n    penalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)\n\n    for day in np.where(occupancy<MIN_OCCUPANCY)[0]:\n        while occupancy[day]<MIN_OCCUPANCY:\n            fam = bestFamAdd(prediction, day, occupancy)\n            prediction[fam] = day\n            penalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)","56c42f3b":"  # swappers\n\ndef findBetterDay4Family(pred):\n    fobs = np.argsort(FAMILY_SIZE)\n    score = cost_function(pred)\n    original_score = np.inf\n    \n    while original_score>score:\n        original_score = score\n        for family_id in fobs:\n            for pick in range(9):    #10\n                day = DESIRED[family_id, pick]\n                oldvalue = pred[family_id]\n                pred[family_id] = day\n                new_score = cost_function(pred)\n                if new_score<score:\n                    score = new_score\n                else:\n                    pred[family_id] = oldvalue\n\n        print(score, end='\\r')\n    print(score)\n    \n\ndef stochastic_product_search(top_k, fam_size, original, \n                              verbose=1000, verbose2=50000,\n                              n_iter=500, random_state=2019):\n    \"\"\"\n    original (np.array): The original day assignments.\n    \n    At every iterations, randomly sample fam_size families. Then, given their top_k\n    choices, compute the Cartesian product of the families' choices, and compute the\n    score for each of those top_k^fam_size products.\n    \"\"\"\n    \n    best = original.copy()\n    print('best',best)\n    best_score = cost_function(best)\n    print('best_score',best_score)\n    \n    np.random.seed(random_state)\n    print('np.random.seed(random_state)',np.random.seed(random_state))\n\n    for i in range(n_iter):\n        fam_indices = np.random.choice(range(DESIRED.shape[0]), size=fam_size)\n        #print('product(*DESIRED[fam_indices, :top_k].tolist())',product(*DESIRED[fam_indices, :top_k].tolist()))\n        changes = np.array(list(product(*DESIRED[fam_indices, :top_k].tolist())))\n\n        for change in changes:\n            new = best.copy()\n            new[fam_indices] = change\n\n            new_score = cost_function(new)\n\n            if new_score < best_score:\n                best_score = new_score\n                best = new\n                \n        if verbose and i % verbose == 0:\n            print(f\"Iteration #{i}: Best score is {best_score:.2f}      \", end='\\r')\n            \n        if verbose2 and i % verbose2 == 0:\n            print(f\"Iteration #{i}: Best score is {best_score:.2f}      \")\n    \n    print(f\"Final best score is {best_score:.2f}\")\n    return best","7fdd0b17":"def solveSantaLP():\n    \n    S = pywraplp.Solver('SolveAssignmentProblem', pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)\n\n    x = {}\n    for i in range(N_FAMILIES):\n        for j in range(N_DAYS):\n            x[i, j] = S.BoolVar('x[%i,%i]' % (i, j))\n            \n            \n    daily_occupancy = [S.Sum([x[i, j] * FAMILY_SIZE[i] for i in range(N_FAMILIES)])\n                                                       for j in range(N_DAYS)]\n    \n    family_presence = [S.Sum([x[i, j] for j in range(N_DAYS)])\n                                      for i in range(N_FAMILIES)]\n\n    \n    \n    # Objective\n    preference_cost = S.Sum([PCOSTM[i, j] * x[i,j] for i in range(N_FAMILIES)\n                                                   for j in range(N_DAYS)])\n    \n    S.Minimize(preference_cost)\n\n    \n    \n    # Constraints\n    for j in range(N_DAYS-1):\n        S.Add(daily_occupancy[j]   - daily_occupancy[j+1] <= 32)\n        S.Add(daily_occupancy[j+1] - daily_occupancy[j]   <= 31)\n                \n    for i in range(N_FAMILIES):\n        S.Add(family_presence[i] == 1)\n\n    for j in range(N_DAYS):\n        S.Add(daily_occupancy[j] >= MIN_OCCUPANCY)\n        S.Add(daily_occupancy[j] <= MAX_OCCUPANCY)\n\n        \n    res = S.Solve()\n                  \n    resdict = {0:'OPTIMAL', 1:'FEASIBLE', 2:'INFEASIBLE', 3:'UNBOUNDED', \n               4:'ABNORMAL', 5:'MODEL_INVALID', 6:'NOT_SOLVED'}\n    \n    print('Result:', resdict[res])\n\n    l = []\n    for i in range(N_FAMILIES):\n        for j in range(N_DAYS):\n            s = x[i, j].solution_value()\n            if s>0:\n                l.append((i, j, s))\n\n    df = pd.DataFrame(l, columns=['family_id', 'day', 'n'])\n\n    \n    if len(df)!=N_FAMILIES:\n        df = df.sort_values(['family_id', 'n']).drop_duplicates('family_id', keep='last') \n     \n    return df.day.values","791fe5b7":"N_DAYS = 100\nN_FAMILIES = 5000\nMAX_OCCUPANCY = 300\nMIN_OCCUPANCY = 125\n\ndata = pd.read_csv('\/kaggle\/input\/santa-workshop-tour-2019\/family_data.csv', index_col='family_id')\n\nFAMILY_SIZE = data.n_people.values\nDESIRED     = data.values[:, :-1] - 1\nPCOSTM = GetPreferenceCostMatrix(data) # Preference cost matrix\nACOSTM = GetAccountingCostMatrix()     # Accounting cost matrix","1e031b60":"data.head()","8e4b3f6a":"pivot_data = data.groupby(['choice_0'])['n_people'].agg(['sum'])\npivot_data = pd.DataFrame(pivot_data)\npivot_data.columns = ['Occupancy for all First Choices']","a7d3cc21":"pivot_data","e2026189":"import matplotlib as mpl\nlabel_size = 22\nmpl.rcParams['xtick.labelsize'] = label_size \nmpl.rcParams['ytick.labelsize'] = label_size\n# Generate a mask for the upper triangle\nsns.set_style(\"whitegrid\")\n\nax = plt.figure(figsize=(22,6))\n\n# Add transparency to colors\nfor patch in ax.artists:\n    r, g, b, a = patch.get_facecolor()\n    patch.set_facecolor((r, g, b, .9))\n \nax = sns.lineplot(data=pivot_data,color='#666666',marker='o',markersize=10,linewidth=3,alpha=0.5)\nax.plot([0,125],[125,125],'--',color='darkgreen')\nplt.text(90, 50, 'Mimimum Occupancy', fontsize=16,weight='bold',alpha=0.85,color='darkgreen')\n\nax.plot([0,300],[300,300],'--',color='red')\nplt.text(90, 370, 'Maximum Occupancy', fontsize=16,weight='bold',alpha=0.85,color='red')\nplt.title(\"If All were given the FIRST CHOICE \\n\", loc=\"center\",size=32,color='#34495E',alpha=0.8)\nplt.xlabel('Days before Christmas',color='#34495E',fontsize=20) \nplt.ylabel('Occupancy',color='#34495E',fontsize=20)\nplt.xticks(size=15,color='#008abc',rotation='horizontal', wrap=True)\nplt.yticks(size=15,color='#006600')\nplt.xlim(0,100)\nplt.legend(loc='best', fontsize=16,framealpha=0.99)","4e326330":"prediction = solveSantaLP()\npenalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)\nprint('{}, {:.2f}, ({}, {})'.format(penalty.sum(), \n                                    accounting_cost.sum(), \n                                    occupancy.min(), \n                                    occupancy.max()))","a00ebf56":"fixMinOccupancy(prediction)\nfixMaxOccupancy(prediction)\npenalty, accounting_cost, n_out_of_range, occupancy = cost_stats(prediction)\nprint('{}, {:.2f}, ({}, {})'.format(penalty.sum(), \n                                    accounting_cost.sum(), \n                                    occupancy.min(), \n                                    occupancy.max()))","140a9821":"round2 = stochastic_product_search(\n        top_k=2,\n        fam_size=6, \n        original=prediction, \n        n_iter=350000, #250000\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","3fe58024":"round3 = stochastic_product_search(\n        top_k=2,\n        fam_size=7, \n        original=round2, \n        n_iter=350000, #250000\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","bb97d81d":"round4 = stochastic_product_search(\n        top_k=2,\n        fam_size=8, \n        original=round3, \n        n_iter=350000, #250000\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","4f053238":"round5 = stochastic_product_search(\n        top_k=2,\n        fam_size=9, \n        original=round4, \n        n_iter=350000, #250000\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","6c9e505f":"final = stochastic_product_search(\n        top_k=2,\n        fam_size=12, \n        original=round5, \n        n_iter=150000, #250000\n        verbose=1000,\n        verbose2=50000,\n        random_state=2019\n        )","1c9f794b":"sub = pd.DataFrame(range(N_FAMILIES), columns=['family_id'])\nsub['assigned_day'] = final+1\nsub.to_csv('submission_5.csv', index=False)","1000fbb8":"df0 = data[['choice_0','n_people']]\ndf0.columns = ['choice_0','n_people']\ndf0","a05a3379":"df1 = pd.DataFrame([prediction]).transpose()\ndf1.columns = ['Prediction']\ndf1","cf8cf9a2":"df2 = pd.DataFrame([round2]).transpose()\ndf2.columns = ['Round2_Days']\ndf2","7fd6e76e":"df3 = pd.DataFrame([round3]).transpose()\ndf3.columns = ['Round3_Days']\ndf3","2db01a8f":"df4 = pd.DataFrame([round4]).transpose()\ndf4.columns = ['Round4_Days']\ndf4","65f3c097":"df5 = pd.DataFrame([round5]).transpose()\ndf5.columns = ['Round5_Days']\ndf5","48b2bb5e":"df6 = pd.DataFrame([final]).transpose()\ndf6.columns = ['Final_Days']\ndf6","55025098":"df = pd.concat([df0,df1,df2,df3,df4,df5,df6], axis=1)\ndf","991eda58":"pivot0 = df.groupby(['choice_0'])['n_people'].agg(['sum'])\npivot0 = pd.DataFrame(pivot0)\npivot0.columns = ['First Choice']\n\npivot1 = df.groupby(['Prediction'])['n_people'].agg(['sum'])\npivot1 = pd.DataFrame(pivot1)\npivot1.columns = ['Prediction']\n\npivot2 = df.groupby(['Round2_Days'])['n_people'].agg(['sum'])\npivot2 = pd.DataFrame(pivot2)\npivot2.columns = ['Round 2']\n\npivot3 = df.groupby(['Round3_Days'])['n_people'].agg(['sum'])\npivot3 = pd.DataFrame(pivot3)\npivot3.columns = ['Round 3']\n\npivot4 = df.groupby(['Round4_Days'])['n_people'].agg(['sum'])\npivot4 = pd.DataFrame(pivot4)\npivot4.columns = ['Round 4']\n\npivot5 = df.groupby(['Round5_Days'])['n_people'].agg(['sum'])\npivot5 = pd.DataFrame(pivot5)\npivot5.columns = ['Round 5']\n\npivot6 = df.groupby(['Final_Days'])['n_people'].agg(['sum'])\npivot6 = pd.DataFrame(pivot6)\npivot6.columns = ['Final']","e9c7d004":"#import matplotlib as mpl\nlabel_size = 22\nmpl.rcParams['xtick.labelsize'] = label_size \nmpl.rcParams['ytick.labelsize'] = label_size\n# Generate a mask for the upper triangle\n#sns.set_style(\"whitegrid\")\n \nsns.set_style('whitegrid', {'legend.frameon':True,'figure.facecolor': '#0b5e15',})\n\nax = plt.figure(figsize=(22,14))\n\n# Add transparency to colors\nfor patch in ax.artists:\n    r, g, b, a = patch.get_facecolor()\n    patch.set_facecolor((r, g, b, .9))\n \nax = sns.lineplot(data=pivot0,color='#666666',palette=\"Blues\",marker='o',markersize=10,linewidth=3,alpha=0.7)\nax = sns.lineplot(data=pivot1,color='#666666',palette=\"copper\",marker='o',markersize=10,linewidth=3,alpha=0.7)\n#ax = sns.lineplot(data=pivot2,color='#666666',palette=\"copper\",marker='o',markersize=10,linewidth=3,alpha=0.7)\nax = sns.lineplot(data=pivot3,color='#666666',palette=\"Oranges\",marker='o',markersize=10,linewidth=3,alpha=0.7)\n#ax = sns.lineplot(data=pivot4,color='#666666',palette=\"Oranges\",marker='o',markersize=10,linewidth=3,alpha=0.7)\nax = sns.lineplot(data=pivot5,color='#666666',palette=\"YlGn_r\",marker='o',markersize=10,linewidth=3,alpha=0.7)\nax = sns.lineplot(data=pivot6,color='#666666',palette=\"Greens\",marker='o',markersize=10,linewidth=3,alpha=0.7)\nax.plot([0,125],[125,125],'--',color='darkgreen')\nplt.text(72, 105, 'Mimimum Occupancy', fontsize=20,weight='bold',alpha=0.85,color='darkgreen')\n\nax.plot([0,300],[300,300],'--',color='red')\nplt.text(72, 315, 'Maximum Occupancy', fontsize=20,weight='bold',alpha=0.85,color='red')\nplt.title(\"Santa's Workshop Attendence Optimization\\n\", loc=\"center\",size=34,color='#ffffff',weight='bold',alpha=1)\nplt.xlabel('Days before Christmas',color='#ffffff',fontsize=20) \nplt.ylabel('Occupancy',color='#ffffff',fontsize=20)\nplt.xticks(size=15,color='#ffffff',rotation='horizontal', wrap=True)\nplt.yticks(size=15,color='#ffffff')\nplt.xlim(0,100)\nplt.ylim(0,450)\nplt.legend(fancybox=True, framealpha=0.5,loc='best', fontsize=20,ncol=5)","bd4f311a":"## Linear Programing","c46e17c9":"## Maximum 9 Choices to be considered","5a304e7f":"# References\nMainly\n\n**- https:\/\/www.kaggle.com\/vipito\/santa-ip**\n\nAnd Others\n- https:\/\/www.kaggle.com\/inversion\/santa-s-2019-starter-notebook\n- https:\/\/www.kaggle.com\/sekrier\/fast-scoring-using-c-52-usec\n- https:\/\/www.kaggle.com\/nickel\/250x-faster-cost-function-with-numba-jit\n- https:\/\/www.kaggle.com\/ilu000\/greedy-dual-and-tripple-shuffle-with-fast-scoring\n- https:\/\/www.kaggle.com\/xhlulu\/santa-s-2019-stochastic-product-search"}}