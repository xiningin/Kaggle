{"cell_type":{"1da27c14":"code","5d0e8ebc":"code","f1e3612f":"code","4bceb855":"code","9998a66e":"code","86a40bd5":"code","147f7825":"code","5c48bd27":"code","91d4f5b7":"code","978f604b":"code","53341b4a":"code","2b2d0698":"code","4fe19ce6":"code","97a6c518":"code","c3bfe386":"code","61fec550":"code","678803be":"code","942b99a4":"code","bd5b55bf":"code","8bf8f104":"code","c6bf5b98":"code","29f56ddc":"code","d6833167":"code","36c1fc83":"code","17345997":"code","86920f2c":"code","898b8c6a":"code","1f03e067":"code","46a50d9b":"code","ec934366":"code","500997fb":"code","c68b540d":"code","0683d093":"markdown","c04337d3":"markdown","9970a3c7":"markdown","aac9a91c":"markdown","d27ab2e6":"markdown","6773510d":"markdown","049f1272":"markdown","274ec814":"markdown","65fe5e06":"markdown","bcbc1cce":"markdown","6209e4b9":"markdown","80f0450f":"markdown","c4c9c418":"markdown","c035b54a":"markdown","4a2ec877":"markdown"},"source":{"1da27c14":"!conda install -c openbabel openbabel -y","5d0e8ebc":"import openbabel\nimport numpy as np\nimport pandas as pd\nimport os\nfrom tqdm import tqdm\ntqdm.pandas()","f1e3612f":"print(os.listdir('..\/input'))","4bceb855":"base_path = '..\/input\/champs-scalar-coupling'\n\nstructures = pd.read_csv(f'{base_path}\/structures.csv')\n\n# data reduction\ntrain = pd.read_csv(f'{base_path}\/train.csv')[::10]\ntest = pd.read_csv(f'{base_path}\/test.csv')[::10]","9998a66e":"obConversion = openbabel.OBConversion()\nobConversion.SetInFormat(\"xyz\")\nxyz_path = f'{base_path}\/structures\/'","86a40bd5":"def cis_trans_bond_indices(molecule_name):\n    mol = openbabel.OBMol()\n    obConversion.ReadFile(mol, f'{xyz_path}\/{molecule_name}.xyz')\n    obs = openbabel.OBStereoFacade(mol)\n    has_ct = [obs.HasCisTransStereo(n) for n in range(mol.NumBonds())]\n    return [i for i, x in enumerate(has_ct) if x == True] if has_ct else []","147f7825":"df = pd.DataFrame(structures.molecule_name.unique(), columns=['molecule_name'])\ndf.head()","5c48bd27":"df['bond_indices'] = df.molecule_name.progress_apply(lambda x: cis_trans_bond_indices(x))\ndf['len_bond_indices'] = df.bond_indices.progress_apply(lambda x:len(x))","91d4f5b7":"df.len_bond_indices.unique()","978f604b":"df[df['len_bond_indices']!=0].head()","53341b4a":"train = pd.merge(train, df, how='left', on='molecule_name')\ntest = pd.merge(test, df, how='left', on='molecule_name')","2b2d0698":"def is_cis_trans(molecule_name, bond_indices, atom_index_0, atom_index_1):\n    if len(bond_indices) == 0:\n        return pd.Series([0,0])\n\n    mol = openbabel.OBMol()\n    obConversion.ReadFile(mol, f'{xyz_path}\/{molecule_name}.xyz')\n    obs = openbabel.OBStereoFacade(mol)\n    \n    is_cis   = [obs.GetCisTransStereo(i).IsCis(atom_index_0, atom_index_1) for i in bond_indices]\n    is_trans = [obs.GetCisTransStereo(i).IsTrans(atom_index_0, atom_index_1) for i in bond_indices]\n    return pd.Series([int(True in is_cis), int(True in is_trans)])","4fe19ce6":"train[['is_cis','is_trans']] = train.progress_apply(lambda x: is_cis_trans(x.molecule_name,\n                                                                           x.bond_indices,\n                                                                           x.atom_index_0,\n                                                                           x.atom_index_1), axis=1)","97a6c518":"#test[['is_cis','is_trans']] = test.progress_apply(lambda x: is_Cis_Trans(x.molecule_name,\n#                                                                         x.bond_indices,\n#                                                                         x.atom_index_0,\n#                                                                         x.atom_index_1), axis=1)","c3bfe386":"#train.to_csv('train_cis_trans.csv')\n#test.to_csv('test_cis_trans.csv')","61fec550":"import plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\nfrom sympy.geometry import Point3D\n\n\ninit_notebook_mode(connected=True)\n\ndef plot_molecule(molecule_name, structures_df):\n    \"\"\"Creates a 3D plot of the molecule\"\"\"\n    \n    atomic_radii = dict(C=0.77, F=0.71, H=0.38, N=0.75, O=0.73)  \n    cpk_colors = dict(C='black', F='green', H='white', N='blue', O='red')\n\n    molecule = structures_df[structures_df.molecule_name == molecule_name]\n    coordinates = molecule[['x', 'y', 'z']].values\n    x_coordinates = coordinates[:, 0]\n    y_coordinates = coordinates[:, 1]\n    z_coordinates = coordinates[:, 2]\n    elements = molecule.atom.tolist()\n    radii = [atomic_radii[element] for element in elements]\n    \n    def get_bonds():\n        \"\"\"Generates a set of bonds from atomic cartesian coordinates\"\"\"\n        ids = np.arange(coordinates.shape[0])\n        bonds = dict()\n        coordinates_compare, radii_compare, ids_compare = coordinates, radii, ids\n        \n        for _ in range(len(ids)):\n            coordinates_compare = np.roll(coordinates_compare, -1, axis=0)\n            radii_compare = np.roll(radii_compare, -1, axis=0)\n            ids_compare = np.roll(ids_compare, -1, axis=0)\n            distances = np.linalg.norm(coordinates - coordinates_compare, axis=1)\n            bond_distances = (radii + radii_compare) * 1.3\n            mask = np.logical_and(distances > 0.1, distances <  bond_distances)\n            distances = distances.round(2)\n            new_bonds = {frozenset([i, j]): dist for i, j, dist in zip(ids[mask], ids_compare[mask], distances[mask])}\n            bonds.update(new_bonds)\n        return bonds            \n            \n    def atom_trace():\n        \"\"\"Creates an atom trace for the plot\"\"\"\n        colors = [cpk_colors[element] for element in elements]\n        markers = dict(color=colors, line=dict(color='lightgray', width=2), size=7, symbol='circle', opacity=0.8)\n        trace = go.Scatter3d(x=x_coordinates, y=y_coordinates, z=z_coordinates, mode='markers', marker=markers,\n                             text=elements, name='')\n        return trace\n\n    def bond_trace():\n        \"\"\"\"Creates a bond trace for the plot\"\"\"\n        trace = go.Scatter3d(x=[], y=[], z=[], hoverinfo='none', mode='lines',\n                             marker=dict(color='grey', size=7, opacity=1))\n        for i, j in bonds.keys():\n            trace['x'] += (x_coordinates[i], x_coordinates[j], None)\n            trace['y'] += (y_coordinates[i], y_coordinates[j], None)\n            trace['z'] += (z_coordinates[i], z_coordinates[j], None)\n        return trace\n    \n    bonds = get_bonds()\n    \n    zipped = zip(range(len(elements)), x_coordinates, y_coordinates, z_coordinates)\n    annotations_id = [dict(text=num, x=x, y=y, z=z, showarrow=False, yshift=15)\n                   for num, x, y, z in zipped]\n    \n    annotations_length = []\n    for (i, j), dist in bonds.items():\n        p_i, p_j = Point3D(coordinates[i]), Point3D(coordinates[j])\n        p = p_i.midpoint(p_j)\n        annotation = dict(text=dist, x=float(p.x), y=float(p.y), z=float(p.z), showarrow=False, yshift=15)\n        annotations_length.append(annotation)   \n    \n    updatemenus = list([\n        dict(buttons=list([\n                 dict(label = 'Atom indices',\n                      method = 'relayout',\n                      args = [{'scene.annotations': annotations_id}]),\n                 dict(label = 'Bond lengths',\n                      method = 'relayout',\n                      args = [{'scene.annotations': annotations_length}]),\n                 dict(label = 'Atom indices & Bond lengths',\n                      method = 'relayout',\n                      args = [{'scene.annotations': annotations_id + annotations_length}]),\n                 dict(label = 'Hide all',\n                      method = 'relayout',\n                      args = [{'scene.annotations': []}])\n                 ]),\n                 direction='down',\n                 xanchor = 'left',\n                 yanchor = 'top'\n            ),        \n    ])\n    \n    data = [atom_trace(), bond_trace()]\n    axis_params = dict(showgrid=False, showticklabels=False, zeroline=False, titlefont=dict(color='white'),\n                       showbackground=False)\n    layout = dict(scene=dict(xaxis=axis_params, yaxis=axis_params, zaxis=axis_params, annotations=annotations_id), \n                  margin=dict(r=0, l=0, b=0, t=0), showlegend=False, updatemenus=updatemenus)\n\n    fig = go.Figure(data=data, layout=layout)\n    iplot(fig)","678803be":"cis_mol = train[train.is_cis == 1].iloc[0]\nprint(cis_mol[['atom_index_0','atom_index_1']])","942b99a4":"plot_molecule(cis_mol.molecule_name, structures)","bd5b55bf":"trans_mol = train[train.is_trans == 1].iloc[0]\nprint(trans_mol[['atom_index_0','atom_index_1']])","8bf8f104":"plot_molecule(trans_mol.molecule_name, structures)","c6bf5b98":"angles = pd.read_csv(f'..\/input\/calculate-angles-and-dihedrals-with-networkx\/angles.csv')","29f56ddc":"train = pd.merge(train, \n                 angles[['molecule_name','atom_index_0','atom_index_1','dihedral']],\n                 how='left',\n                 on=['molecule_name','atom_index_0','atom_index_1'])","d6833167":"def map_atom_info(df, atom_idx):\n    df = pd.merge(df, structures, how = 'left',\n                  left_on  = ['molecule_name', f'atom_index_{atom_idx}'],\n                  right_on = ['molecule_name',  'atom_index'])\n    \n    df = df.drop('atom_index', axis=1)\n    df = df.rename(columns={'atom': f'atom_{atom_idx}',\n                            'x': f'x_{atom_idx}',\n                            'y': f'y_{atom_idx}',\n                            'z': f'z_{atom_idx}'})\n    return df","36c1fc83":"train = map_atom_info(train, 0)\ntrain = map_atom_info(train, 1)\n\ntrain_p_0 = train[['x_0', 'y_0', 'z_0']].values\ntrain_p_1 = train[['x_1', 'y_1', 'z_1']].values\n\ntrain['dist'] = np.linalg.norm(train_p_0 - train_p_1, axis=1)","17345997":"train.head()","86920f2c":"from mpl_toolkits.mplot3d import Axes3D\nfrom scipy import genfromtxt\nimport matplotlib.pyplot as plt\nfrom pylab import rcParams\nimport pylab","898b8c6a":"train_3JHC = train[train['type'] == '3JHC']\ntrain_normal = train_3JHC[(train_3JHC['is_cis'] == 0) & (train_3JHC['is_trans'] == 0)]\ntrain_cis    = train_3JHC[train_3JHC['is_cis']   == 1]\ntrain_trans  = train_3JHC[train_3JHC['is_trans'] == 1]","1f03e067":"rcParams['figure.figsize'] = 10,4\ntrain_normal['scalar_coupling_constant'].hist(bins=50)\npylab.suptitle(\"Not cis-trans\")\nplt.show()\ntrain_cis['scalar_coupling_constant'].hist(bins=30)\npylab.suptitle(\"Cis\")\nplt.show()\ntrain_trans['scalar_coupling_constant'].hist(bins=30)\npylab.suptitle(\"Trans\")\nplt.show()","46a50d9b":"rcParams['figure.figsize'] = 10,7\n\nfig = plt.figure()\nax = Axes3D(fig)\n\nax.set_xlabel(\"dihedral\")\nax.set_ylabel(\"scalar_coupling_constant\")\nax.set_zlabel(\"dist\")\n\nax.plot(train_normal.dihedral, \n        train_normal.dist, \n        train_normal.scalar_coupling_constant,\n        \"o\", color='gray', ms=1, mew=0.2)\nax.plot(train_cis.dihedral,\n        train_cis.dist,\n        train_cis.scalar_coupling_constant,\n        \"o\", color='blue', ms=2, mew=2)\nax.plot(train_trans.dihedral,\n        train_trans.dist,\n        train_trans.scalar_coupling_constant,\n        \"o\", color='red', ms=2, mew=2)\nplt.show()","ec934366":"train_3 = train[(train['type']=='3JHC') | (train['type']=='3JHH') | (train['type']=='3JHN')]\ntrain_normal = train_3[(train_3['is_cis'] == 0) & (train_3['is_trans'] == 0)]\ntrain_cis    = train_3[train_3['is_cis']   == 1]\ntrain_trans  = train_3[train_3['is_trans'] == 1]","500997fb":"rcParams['figure.figsize'] = 5,7\nplt.style.use('ggplot')\nleft = np.array(['not Cis-Trans', 'Cis', 'Trans'])\nheight = np.array([len(train_normal), len(train_cis), len(train_trans)])\nplt.bar(left, height)","c68b540d":"train_normal.plot(kind='scatter', x='dist', y='scalar_coupling_constant',\n                  figsize=(10,4), title='not Cis and not Trans')\ntrain_cis.plot(kind='scatter', x='dist', y='scalar_coupling_constant',\n               figsize=(10,4), title='is Cis')","0683d093":"There are very few cis-trans isomerism in dataset.<br>\nSo the score won't improve significantly.","c04337d3":"# Visualize molecule\n\nReference<br>\nhttps:\/\/www.kaggle.com\/mykolazotko\/3d-visualization-of-molecules-with-plotly","9970a3c7":"When I tried, isCis slightly improved the score.<br>","aac9a91c":"# Add analysis","d27ab2e6":"## trans","6773510d":"<img src=\"https:\/\/upload.wikimedia.org\/wikipedia\/commons\/e\/e7\/Dinitrogen-difluoride-cis-trans-3D-balls.png\" width=\"500\">","049f1272":"## cis ","274ec814":"# The effects of cis\u2013trans isomerism on scalar coupling constant","65fe5e06":"## Calculate distance\nReference<br>\nhttps:\/\/www.kaggle.com\/seriousran\/just-speed-up-calculate-distance-from-benchmark","bcbc1cce":"# Find cis-trans","6209e4b9":"## Plot 3JHC mol feature","80f0450f":"# Load data","c4c9c418":"Thank you for reading.<br>\nPlease let me know if I made a mistake.","c035b54a":"# How to find cis\u2013trans isomerism\n\nCis indicates that the functional groups are on the same side of the carbon chain while trans conveys that functional groups are on opposing sides of the carbon chain.","4a2ec877":"## Dihedrals Data\n\nkernel: https:\/\/www.kaggle.com\/soerendip\/calculate-angles-and-dihedrals-with-networkx\/output <br>\ndataset: https:\/\/www.kaggle.com\/soerendip\/angle-and-dihedral-for-the-champs-structures"}}