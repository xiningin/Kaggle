{"cell_type":{"cfc97575":"code","58b66b36":"code","29fbbbf4":"code","cfd46475":"code","87da6720":"code","7aa2be6a":"code","e4bd1bb7":"code","1228358f":"code","2191aee1":"code","421d381a":"code","e7c2a6a1":"code","0d7e342c":"code","5b62a835":"code","74ee7b86":"code","668a8392":"code","bdf92ad3":"code","28baad8f":"code","d0d98cd7":"code","e2d3a34a":"code","706e9cba":"code","4fc22e1d":"code","09758932":"code","2182e2e6":"markdown","fb96a83c":"markdown","63c29f90":"markdown","e445f3dc":"markdown","a88a6086":"markdown","561d4255":"markdown","9c157011":"markdown","7e6891b2":"markdown","6833da8c":"markdown"},"source":{"cfc97575":"from __future__ import absolute_import, division, print_function, unicode_literals\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nimport os\nimport pydicom\nimport cv2\nimport math\n\nimport scipy.ndimage\nfrom skimage import measure, morphology\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\nfrom sklearn.preprocessing import LabelEncoder \n\nimport tensorflow as tf\nfrom tensorflow.keras import datasets, layers, models, regularizers\n\nPATH = '\/kaggle\/input\/spieaapm-lung-ct\/'\nos.listdir(PATH)","58b66b36":"labels_df = pd.read_csv(PATH+'Labels.csv', index_col = 0)\nlabels_df = labels_df[:70]\nlabels_df.head()","29fbbbf4":"labels_df['Diagnosis'] = labels_df['Diagnosis'].str.strip()\n\nle = LabelEncoder() \nle.fit(labels_df['Diagnosis'])\nprint(list(le.classes_))\nlabels_df['Diagnosis'] = le.transform(labels_df['Diagnosis'])\nlabels_df.head()","cfd46475":"patients_dir = os.listdir(PATH+'Dataset\/Dataset')\n\ndef load_data(patient):\n    path = PATH+'Dataset\/Dataset\/'+patient\n    #print(patient)\n    \n    label = labels_df['Diagnosis'][patient]\n    #print(label)\n    \n    slices = [pydicom.dcmread(path + '\/' + s) for s in os.listdir(path)]\n    slices.sort(key = lambda x: int(x.ImagePositionPatient[2]))\n    try:\n        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])\n    except:\n        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)\n        \n    #print(slice_thickness)\n    for s in slices:\n        s.SliceThickness = slice_thickness\n    \n    #print(len(slices), slices[0].pixel_array.shape)\n    return label, slices","87da6720":"label, slices = load_data(patients_dir[0])","7aa2be6a":"def get_pixels_hu(slices):\n    image = np.stack([s.pixel_array for s in slices])\n    image = image.astype(np.int16)\n\n    # Set outside-of-scan pixels to 0 i.e. air\n    image[image == -2000] = 0\n    \n    # Convert to Hounsfield units (HU)\n    for slice_number in range(len(slices)):\n        \n        intercept = slices[slice_number].RescaleIntercept\n        slope = slices[slice_number].RescaleSlope\n        \n        if slope != 1:\n            image[slice_number] = slope * image[slice_number].astype(np.float64)\n            image[slice_number] = image[slice_number].astype(np.int16)\n            \n        image[slice_number] += np.int16(intercept)\n        \n    image = [cv2.resize(np.array(frame),(128,128)) for frame in image]\n            \n    return np.array(image, dtype=np.int16)","e4bd1bb7":"def chunks(l,n, hm_slices):\n    count=0\n    for i in range(0, len(l), n):\n        if(count < hm_slices):\n            yield l[i:i + n]\n            count=count+1\n\ndef mean(a):\n    return sum(a) \/ len(a)\n\ndef reshape_data(slices, hm_slices=128):\n    new_slices = []\n    \n    chunk_sizes = math.floor(len(slices) \/ hm_slices)\n    for slice_chunk in chunks(slices, chunk_sizes, hm_slices):\n        slice_chunk = list(map(mean, zip(*slice_chunk)))\n        new_slices.append(slice_chunk)\n        \n    #print(len(new_slices))\n    return np.array(new_slices)","1228358f":"images = get_pixels_hu(slices)\nimages = reshape_data(images)\nplt.hist(images.flatten(), bins=80, color='c')\nplt.xlabel(\"Hounsfield Units (HU)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n# Show some slice in the middle\nplt.imshow(images[20], cmap=plt.cm.gray)\nplt.show()","2191aee1":"def plot_3d(image, threshold=-300):\n    \n    # Position the scan upright, so the head of the patient would be at the top facing the camera\n    p = image.transpose(2,1,0)\n    \n    verts, faces, normals, values = measure.marching_cubes_lewiner(p, threshold)\n\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.add_subplot(111, projection='3d')\n\n    # Fancy indexing: `verts[faces]` to generate a collection of triangles\n    mesh = Poly3DCollection(verts[faces], alpha=0.70)\n    face_color = [0.45, 0.45, 0.75]\n    mesh.set_facecolor(face_color)\n    ax.add_collection3d(mesh)\n\n    ax.set_xlim(0, p.shape[0])\n    ax.set_ylim(0, p.shape[1])\n    ax.set_zlim(0, p.shape[2])\n\n    plt.show()","421d381a":"plot_3d(images, 400)","e7c2a6a1":"def largest_label_volume(im, bg=-1):\n    vals, counts = np.unique(im, return_counts=True)\n\n    counts = counts[vals != bg]\n    vals = vals[vals != bg]\n\n    if len(counts) > 0:\n        return vals[np.argmax(counts)]\n    else:\n        return None\n\ndef segment_lung_mask(image, fill_lung_structures=True):\n    binary_image = np.array(image > -320, dtype=np.int8)+1\n    labels = measure.label(binary_image)\n    \n    background_label = labels[0,0,0]\n    binary_image[background_label == labels] = 2\n    \n    if fill_lung_structures:\n        # For every slice we determine the largest solid structure\n        for i, axial_slice in enumerate(binary_image):\n            axial_slice = axial_slice - 1\n            labeling = measure.label(axial_slice)\n            l_max = largest_label_volume(labeling, bg=0)\n            \n            if l_max is not None: #This slice contains some lung\n                binary_image[i][labeling != l_max] = 1\n\n    \n    binary_image -= 1 #Make the image actual binary\n    binary_image = 1-binary_image # Invert it, lungs are now 1\n    \n    # Remove other air pockets insided body\n    labels = measure.label(binary_image, background=0)\n    l_max = largest_label_volume(labels, bg=0)\n    if l_max is not None: # There are air pockets\n        binary_image[labels != l_max] = 0\n \n    return binary_image","0d7e342c":"segmented_lungs = segment_lung_mask(images, False)\nsegmented_lungs_fill = segment_lung_mask(images, True)","5b62a835":"plot_3d(segmented_lungs, 0)","74ee7b86":"plot_3d(segmented_lungs_fill - segmented_lungs, 0)","668a8392":"MIN_BOUND = -1000.0\nMAX_BOUND = 400.0\n    \ndef normalize(image):\n    image = (image - MIN_BOUND) \/ (MAX_BOUND - MIN_BOUND)\n    image[image>1] = 1.\n    image[image<0] = 0.\n    return image\n\nPIXEL_MEAN = 0.25\n\ndef zero_center(image):\n    image = image - PIXEL_MEAN\n    return image","bdf92ad3":"def process_data(patient):\n    label, slices = load_data(patient)\n        \n    images = get_pixels_hu(slices)\n    images = [cv2.resize(np.array(frame),(64,64)) for frame in images]\n    images = reshape_data(images, hm_slices=64)\n    \n    segmented_lungs = segment_lung_mask(images, False)\n    segmented_lungs_fill = segment_lung_mask(images, True)\n    lungs = segmented_lungs-segmented_lungs_fill\n    \n    lungs = normalize(lungs)\n    lungs = zero_center(lungs)\n    \n    return lungs, label","28baad8f":"for i in patients_dir[:2]:\n    lungs, label = process_data(i)\n    print(lungs.shape, label)","d0d98cd7":"train_data = []\ntrain_labels = []\ntest_data = []\ntest_labels = []\n\nfor i, patient in enumerate(patients_dir):    \n    lungs, label = process_data(patient)\n    if i<60:\n        train_data.append(lungs)\n        train_labels.append(label)\n    else:\n        test_data.append(lungs)\n        test_labels.append(label)\n     \ntrain_data = np.array(train_data)\ntrain_labels = np.array(train_labels)\ntest_data = np.array(test_data)\ntest_labels = np.array(test_labels)","e2d3a34a":"print(test_data.shape,train_data.shape)\nprint(test_labels.shape, train_labels.shape)","706e9cba":"train_data = train_data.reshape((60, 64, 64, 64,1))\ntest_data = test_data.reshape((10, 64, 64, 64,1))\nprint(test_data.shape,train_data.shape)\n\ntf.compat.v2.random.set_seed(1)\nnp.random.seed(1)","4fc22e1d":"model = models.Sequential()\nmodel.add(layers.Conv3D(32, (3, 3, 3), activation='relu', input_shape=(64, 64, 64, 1)))\nmodel.add(layers.MaxPooling3D((2, 2, 2)))\nmodel.add(layers.Conv3D(64, (3, 3, 3), activation='relu'))\nmodel.add(layers.MaxPooling3D((2, 2, 2)))\nmodel.add(layers.Conv3D(64, (3, 3, 3), activation='relu'))\nmodel.add(layers.MaxPooling3D((2, 2, 2)))\nmodel.add(layers.Conv3D(64, (3, 3, 3), activation='relu'))\n\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(64, activation='relu'))\nmodel.add(layers.Dense(2, activation='relu'))\n\nmodel.summary()","09758932":"model.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\nhistory = model.fit(train_data, train_labels, epochs=10, validation_data=(test_data, test_labels))","2182e2e6":"## 3D Plotting the scan","fb96a83c":"* Getting Hounsfield Unit (HU) values from dicom files \n* Resizing the images to 128x128","63c29f90":"--------------------------------------------","e445f3dc":"## Normalization and Zero Centering","a88a6086":"## Loading the data ","561d4255":"## Lung Segmentation","9c157011":"## Reshaping the chunks of data to 128 slices per scan","7e6891b2":"## Processing Data","6833da8c":"## Training the model"}}