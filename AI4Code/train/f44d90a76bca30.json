{"cell_type":{"4e7c0b11":"code","d41fbefd":"code","06b95dcf":"code","1c80e13b":"code","4259f746":"code","5c468f0b":"code","06779ca6":"markdown","0884bd25":"markdown","56358c86":"markdown","23afed5e":"markdown"},"source":{"4e7c0b11":"!pip install \/kaggle\/input\/dfdc-packages\/mtcnn-0.1.0-py3-none-any.whl\n!pip uninstall numpy -y\n!pip uninstall opencv-python -y\n!pip install --upgrade --force-reinstall \/kaggle\/input\/dfdc-packages\/numpy-1.18.1-cp36-cp36m-manylinux1_x86_64.whl\n!pip install --upgrade --force-reinstall --no-deps \/kaggle\/input\/dfdc-packages\/opencv_contrib_python-4.2.0.32-cp36-cp36m-manylinux1_x86_64.whl","d41fbefd":"import os\nimport sys\nimport cv2\nimport csv\nimport time\nimport string\nimport random\nfrom mtcnn.mtcnn import MTCNN\nfrom datetime import timedelta\nfrom joblib import Parallel, delayed","06b95dcf":"def id_gen(chars=string.ascii_uppercase, id_len=6):\n    return ''.join(random.choice(chars) \n             for x in range(id_len)).lower()","1c80e13b":"def main(source, skip_frames=5, expiration=30):\n    cap = cv2.VideoCapture(source)\n    name = os.path.basename(source).replace('.mp4', '.csv')\n    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n    for idx in range(n_frames):\n        ret = cap.grab()\n        if ret:\n            if not idx % skip_frames:\n                ret, frame = cap.retrieve()\n                if not idx % expiration:\n                    file_dict, tracker_dict = {}, {}\n                    faces = [tuple(face['box']) for face in detector.detect_faces(frame)]\n                    for box in faces:\n                        tracker_id = id_gen()\n                        tracker = cv2.TrackerCSRT_create()\n                        tracker.init(frame, box)\n                        tracker_dict[tracker] = tracker_id\n                        dataFile = open(DATA_DIR + '{}_{}'.format(tracker_id, name), 'w')\n                        file_dict[tracker_id] = csv.writer(dataFile)\n                else:\n                    for tracker in list(tracker_dict.keys()):\n                        (success, box) = tracker.update(frame)\n                        box = list(map(int, box))\n                        file_dict[tracker_dict[tracker]].writerow([idx] + box)\n        else:\n            break\n    cap.release()\n    return              ","4259f746":"# Initialize face detector\ndetector = MTCNN()\n\nINPUT_DIR = \"\/kaggle\/input\/deepfake-detection-challenge\/test_videos\/\"\nDATA_DIR = '\/kaggle\/working\/'\n\nstart_time = time.time()\nfor vid_fl in os.listdir(INPUT_DIR):\n    main(INPUT_DIR + vid_fl)\nelapsed = time.time() - start_time\nprint(\"Elapsed time to process test set: \", str(timedelta(seconds=elapsed)))","5c468f0b":"!mkdir -p \/kaggle\/working\/output_parallel\/\n\nDATA_DIR = '\/kaggle\/working\/output_parallel\/'\ntest_videos = os.listdir(INPUT_DIR)\ntest_videos = [INPUT_DIR + fl for fl in test_videos]\n\nstart_time = time.time()\nParallel(n_jobs=4)(delayed(main)(fl) for fl in test_videos)\nelapsed = time.time() - start_time\nprint(\"Elapsed time to process test set: \", str(timedelta(seconds=elapsed)))","06779ca6":"Processing video files sequentially is time consuming and inefficient. To speed up our processing we can use the ```Parallel``` module from the ```joblib``` library and take advantage of all cores available to process chunks of videos.","0884bd25":"By skipping frames and using trackers, we can extract facial bounding boxes from video in the Deepfake Detection Challenge.\n\nTo begin, we install MTCNN, which has a dependency of opencv-python. \n\nThen we uninstall opencv-python so we can install opencv-contrib-python to use opencv's trackers.","56358c86":"We introduce a helper function to generate ids for each trackable face","23afed5e":"Finally, the main function iterates through frames in the source video.\n\nTo process videos more quickly, we grab frames and only load every skip_frame to perform face detection.\n\nSince trackers drift, we reinitialize trackers after an expiration period.\n\nWe write the frame number and corresponding bounding box to files for each trackable face."}}