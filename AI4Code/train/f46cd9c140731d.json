{"cell_type":{"9322d76d":"code","5f238370":"code","a2e7f004":"code","9b2223d4":"code","764ef772":"code","eb74e5a7":"code","aaf78420":"code","982258e2":"code","a3761e7c":"code","02807e34":"code","7b059041":"code","7008aa6f":"code","57f7ed5f":"code","8f0284d1":"code","5ff3fa37":"code","1f2df6a6":"code","cd5f1d3e":"code","3d77de83":"code","988e14bb":"code","282b7ac7":"code","00581c7d":"code","c7b41e4f":"markdown","f6d1bbf0":"markdown","784d567d":"markdown","de72b25d":"markdown","7d1dff10":"markdown","e1c63c5b":"markdown","067add8c":"markdown","241d5715":"markdown","f1199bd6":"markdown","722f6fd9":"markdown","9d53736b":"markdown","547fb089":"markdown","29ec56a9":"markdown","71e3a1e1":"markdown","f5b8472f":"markdown","8042af1f":"markdown","d0b985e5":"markdown","9a45da5f":"markdown"},"source":{"9322d76d":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns","5f238370":"df = pd.read_csv(\"..\/input\/iris\/Iris.csv\")\ndf = df.drop(\"Id\",1)","a2e7f004":"df","9b2223d4":"df.describe()","764ef772":"sns.pairplot(df, hue = 'Species')","eb74e5a7":"# We're seperating the species column\nspecies = df[\"Species\"].tolist()\nX = df.drop(\"Species\", 1)","aaf78420":"# Standardize the data\nX = (X - X.mean()) \/ X.std(ddof=0)","982258e2":"# Calculating the correlation matrix of the data\nX_corr = (1 \/ 150) * X.T.dot(X)","a3761e7c":"# Plotting the correlation matrix\nplt.figure(figsize=(10,10))\nsns.heatmap(X_corr, vmax=1, square=True,annot=True)\nplt.title('Correlation matrix')","02807e34":"# method1\nu,s,v = np.linalg.svd(X_corr)\neig_values, eig_vectors = s, u\neig_values, eig_vectors","7b059041":"# method2\nnp.linalg.eig(X_corr)","7008aa6f":"np.sum(eig_values)","57f7ed5f":"# plotting the variance explained by each PC \nexplained_variance=(eig_values \/ np.sum(eig_values))*100\nplt.figure(figsize=(8,4))\nplt.bar(range(4), explained_variance, alpha=0.6)\nplt.ylabel('Percentage of explained variance')\nplt.xlabel('Dimensions')","8f0284d1":"# calculating our new axis\npc1 = X.dot(eig_vectors[:,0])\npc2 = X.dot(eig_vectors[:,1])","5ff3fa37":"# plotting in 2D\ndef plot_scatter(pc1, pc2):\n    fig, ax = plt.subplots(figsize=(15, 8))\n    \n    species_unique = list(set(species))\n    species_colors = [\"r\",\"b\",\"g\"]\n    \n    for i, spec in enumerate(species):\n        plt.scatter(pc1[i], pc2[i], label = spec, s = 20, c=species_colors[species_unique.index(spec)])\n        ax.annotate(str(i+1), (pc1[i],pc2[i]))\n    \n    from collections import OrderedDict\n    handles, labels = plt.gca().get_legend_handles_labels()\n    by_label = OrderedDict(zip(labels, handles))\n    plt.legend(by_label.values(), by_label.keys(), prop={'size': 15}, loc=4)\n    \n    ax.set_xlabel('Principal Component 1', fontsize = 15)\n    ax.set_ylabel('Principal Component 2', fontsize = 15)\n    ax.axhline(y=0, color=\"grey\", linestyle=\"--\")\n    ax.axvline(x=0, color=\"grey\", linestyle=\"--\")\n    \n    plt.grid()\n    plt.axis([-4, 4, -3, 3])\n    plt.show()\n    \nplot_scatter(pc1, pc2)","1f2df6a6":"def plot_correlation_circle(pc1, pc2):    \n    fig, ax = plt.subplots(figsize=(16, 10))\n\n    for i in range(X.shape[1]):\n        x = np.corrcoef(pc1,X[X.columns[i]])[0,1]\n        y = np.corrcoef(pc2,X[X.columns[i]])[0,1]\n        ax.annotate(\"\", xy= (x,y), xytext=(0, 0),arrowprops=dict(arrowstyle=\"->\"))\n        ax.annotate(X.columns[i], (x+0.02,y+0.02), size=12)\n\n\n    ax.set_title('Correlation circle')\n    ax.axhline(y=0, color=\"grey\", linestyle=\"--\")\n    ax.axvline(x=0, color=\"grey\", linestyle=\"--\")\n\n    an = np.linspace(0, 2 * np.pi, 100)\n    plt.plot(np.cos(an), np.sin(an))\n    plt.axis('equal')\n    plt.show()\n    \nplot_correlation_circle(pc1,pc2)","cd5f1d3e":"from sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler","3d77de83":"X = df.drop(\"Species\", 1)\nX = StandardScaler().fit_transform(X)\npca = PCA()\nresult = pca.fit_transform(X)\n# Remember what we said about the sign of eigen vectors that might change ?\npc1 = - result[:,0]\npc2 = - result[:,1]\nplot_scatter(pc1, pc2)","988e14bb":"import plotly.express as px","282b7ac7":"pc3 = result[:,2]","00581c7d":"pcs = pd.DataFrame(list(zip(pc1, pc2, pc3, species)),columns =['pc1', 'pc2', 'pc3', 'Species']) \nfig = px.scatter_3d(pcs, x='pc1', y='pc2', z='pc3',color='Species')\nfig.show()","c7b41e4f":"# 2. PC What ? <a name=\"pca\"><\/a>\nPrincipal component analysis (PCA) allows us to summarize and to visualize the information in a data set containing individuals\/observations described by multiple inter-correlated quantitative variables. Each variable could be considered as a different dimension. If you have more than 3 variables in your data sets, it could be very difficult to visualize a multi-dimensional hyperspace.\n\nPrincipal component analysis is used to extract the important information from a multivariate data table and to express this information as a set of few new variables called principal components. These new variables correspond to a linear combination of the originals. The number of principal components is less than or equal to the number of original variables.\n\nThe information in a given data set corresponds to the total variation it contains. The goal of PCA is to identify directions (or principal components) along which the variation in the data is maximal.\n\nIn other words, PCA reduces the dimensionality of a multivariate data to two or three principal components, that can be visualized graphically, with minimal loss of information [[sthda](http:\/\/www.sthda.com\/english\/articles\/31-principal-component-methods-in-r-practical-guide\/112-pca-principal-component-analysis-essentials\/)].","f6d1bbf0":"Wooooooo, the sum of the eigen values is equal to number of variables. we're going in the right direction ;)","784d567d":"Well it seems that:\n* petal length & petal width are the main things that characterizes the data\n* virginica has relatively bigger petals while setosa has the smallest\n* a small group of setosa have a relatively big sepal_width","de72b25d":"The next step is to extract the eign values and their respective eigen vectors.\n(\nIt's important to have the sorted list of eigen values \/ eigen vectors) .\n\nWe'll try to calculate them using two methods :","7d1dff10":"### That's it, i'll be happy to receive your feedbacks :D ","e1c63c5b":"**Note**: instead of calculating the correlation matrix manually we can just use \n> X.corr()","067add8c":"Notice how the direction of some vectors is not the same in the two outputs. Despite that,our analysis will [still be valid](https:\/\/stats.stackexchange.com\/questions\/88880\/does-the-sign-of-scores-or-of-loadings-in-pca-or-fa-have-a-meaning-may-i-revers)","241d5715":"# 1. Notebook goal <a name=\"notebookgoal\"><\/a>\nIn this notebook we'll focus on implementing PCA  with little help possible from sklearn; You'll see how easy it is; And don't worry we'll compare the results ;)","f1199bd6":"# 2. Let's code <a name=\"letscode\"><\/a> ","722f6fd9":"In this section we'll use the famous sklearn library instead","9d53736b":"This bar chart shows us that the first two dimensions will be enough to represent the data.\n\nSo let's find these principal components:","547fb089":"These are the libraries we need, nothing special \u00af\\\\\\_(\u30c4)\\_\/\u00af","29ec56a9":"# 4. Bonus <a name=\"bonus\"><\/a>","71e3a1e1":"1. [Notebook goal](#notebookgoal)\n2. [PC What ?](#pca)\n3. [Let's code](#letscode)\n4. [PCA with sklearn](#sklearn)\n5. [Bonus](#bonus)","f5b8472f":"This Free DLC consists of plotting the data in 3D.\n\nRemember that in our case plotting the data in 2D is sufficient.","8042af1f":"**Note**: instead of standardizing the data manually, we can use sklearns StandardScaler \n> StandardScaler().fit_transform(X)","d0b985e5":"# 4. PCA with sklearn <a name=\"sklearn\"><\/a>","9a45da5f":"The same plot, isn't it ?"}}