{"cell_type":{"bf8099fb":"code","1b278d59":"code","ab806e72":"code","c0f7bdf5":"code","b2a391cb":"code","79fcfac9":"code","80f373d8":"code","569ed932":"code","fc5cb34a":"code","575c869a":"code","f768be9c":"code","ecc63f6c":"code","175511c3":"code","0558aa37":"code","168b71c5":"code","e552d7b5":"code","c98fee17":"code","3b1ea66d":"code","71e96363":"code","5b5abc03":"markdown","edcb6ce5":"markdown","36c9f6da":"markdown","f5d7b59b":"markdown","e6759e87":"markdown","4c15d494":"markdown","4fafd72c":"markdown","5cc772d4":"markdown","a466961d":"markdown","a75d52ce":"markdown","ceb1897e":"markdown","75a216ee":"markdown","b74c5876":"markdown","6661a2c5":"markdown","2649c419":"markdown","7da9ee7e":"markdown","2a4599a6":"markdown","cb05d9ff":"markdown","d0b5ee84":"markdown","9c3a09a8":"markdown","e1f54150":"markdown","7c5f89d9":"markdown","d32b8509":"markdown","807aeaf7":"markdown","9c011d03":"markdown"},"source":{"bf8099fb":"%matplotlib inline\nimport matplotlib.pyplot as plt\nimport random as rnd\nimport pandas as pd\nimport numpy as np\nimport time\nimport datetime\nimport calendar\nimport json\nimport statistics\n\n# fix what is missing with the datetime\/time\/calendar package\ndef add_months(sourcedate,months):\n    month = sourcedate.month - 1 + months\n    year = int(sourcedate.year + month \/ 12 )\n    month = month % 12 + 1\n    day = min(sourcedate.day,calendar.monthrange(year, month)[1])\n    return datetime.date(year,month,day)\n\n# measure how long it takes to run the script\nstartit = time.time()\ndtstartit = datetime.datetime.now()","1b278d59":"class Seller():\n    def __init__(self, name):\n        self.name = name\n        self.wta = []\n        self.step = 0\n        self.prod = 2000\n        self.lb_price = 10\n        self.lb_multiplier = 0\n        self.ub_price = 20\n        self.ub_multiplier = 0\n        self.init_reserve = 500000\n        self.reserve = 500000\n        self.init_unproven_reserve = 0\n        self.unproven_reserve = 0\n        #multiple market idea, also 'go away from market'\n        self.subscr_market = {}\n        self.last_price = 15\n        self.state_hist = {}\n        self.cur_scenario = ''\n        self.count = 0\n        self.storage = 0\n        self.q_to_market = 0\n        self.ratio_sold = 0\n        self.ratio_sold_hist = []\n\n    # the supplier has n quantities that they can sell\n    # they may be willing to sell this quantity anywhere from a lower price of l\n    # to a higher price of u\n    def set_quantity(self):\n        self.count = 0\n        self.update_price()\n        n = self.prod\n        l = self.lb_price + self.lb_multiplier\n        u = self.ub_price + self.ub_multiplier\n        wta = []\n        for i in range(n):\n            p = rnd.uniform(l, u)\n            wta.append(p)\n        if len(wta) < self.reserve:\n            self.wta = wta\n        else:\n            self.wta = wta[0:(self.reserve-1)]\n            self.prod = self.reserve\n        if len(self.wta) > 0:\n            self.wta = self.wta #sorted(self.wta, reverse=False)\n        self.q_to_market = len(self.wta)\n        \n        \n    def get_name(self):\n        return self.name\n\n    def get_asks(self):\n        return self.wta\n\n    def extract(self, cur_extraction):\n        if self.reserve > 0:\n            self.reserve = self.reserve - cur_extraction\n        else:\n            self.prod = 0\n\n    # production costs rise a 100% \n    def update_price(self):\n        depletion = (self.init_reserve - self.reserve) \/ self.init_reserve\n        self.ub_multiplier = int(self.ub_price * depletion)\n        self.lb_multiplier = int(self.lb_price * depletion)\n        \n    def return_not_cleared(self, not_cleared):\n        self.count = self.count + (len(self.wta) - len(not_cleared))\n        self.wta = not_cleared\n\n    def get_price(self, price):\n        self.last_price = price\n        \n    def update_production(self):\n        if (self.step\/12).is_integer():\n            if self.prod > 0 and self.q_to_market > 0:\n                rp_ratio = self.reserve \/ self.prod\n                self.ratio_sold = self.count \/ self.q_to_market\n                self.ratio_sold_hist.append(self.ratio_sold)\n                yearly_average = statistics.mean(self.ratio_sold_hist[-12:])\n                if (rp_ratio > 15) and (yearly_average > .9):\n                    self.prod = int(self.prod * 1.1)\n                    if print_details:\n                        print(\"%s evaluate production\" % self.name)\n                if (self.unproven_reserve > 0) and (self.cur_scenario == 'PACES'):\n                    self.reserve = self.reserve + int(0.1 * self.init_unproven_reserve)\n                    self.unproven_reserve = self.unproven_reserve - int(0.1 * self.init_unproven_reserve)\n                    \n    def evaluate_timestep(self):\n        self.update_production()\n\n    # record every step into an dictionary, nog pythonic look into (vars)\n    def book_keeping(self):\n        self.state_hist[self.step] = self.__dict__\n","ab806e72":"class Buyer():\n    def __init__(self, name):\n        self.name = name\n        self.type = 0\n        self.rof = 0\n        self.wtp = []\n        self.step = 0\n        self.offset= 0\n        self.base_demand = 0\n        self.max_demand = 0\n        self.lb_price = 10\n        self.ub_price = 20\n        self.last_price = 15\n        self.subscr_market = {}\n        self.state_hist = {}\n        self.cur_scenario = ''\n        self.count = 0\n        self.real_demand = 0\n        self.storage_cap = 1\n        self.storage = 0\n        self.storage_q = 0\n\n    # the supplier has n quantities that they can buy\n    # they may be willing to sell this quantity anywhere from a lower price of l\n    # to a higher price of u\n    def set_quantity(self):\n        self.count = 0\n        self.update_price()\n        n = int(self.consumption(self.step))\n        l = self.lb_price\n        u = self.ub_price\n        wtp = []\n        for i in range(n):\n            p = rnd.uniform(l, u)\n            wtp.append(p)\n        self.wtp = wtp #sorted(wtp, reverse=True)\n        \n    # gets a little to obvious\n    def get_name(self):\n        return self.name\n    \n    # return list of willingness to pay\n    def get_bids(self):\n        return self.wtp\n    \n    def consumption(self, x):\n        # make it initialise to seller\n        b = self.base_demand\n        m = self.max_demand\n        y = b + m * (.5 * (1 + np.cos(((x+self.offset)\/6)*np.pi)))\n        self.real_demand = y\n        s = self.storage_manager()\n        return(y+s)\n    \n    def update_price(self):\n        # adjust Q\n        if self.type == 1: #home\n            if (self.step\/12).is_integer():\n                self.base_demand = home_savings[self.cur_scenario] * self.base_demand\n                self.max_demand = home_savings[self.cur_scenario] * self.max_demand\n        if self.type == 2: # elec for eu + us\n            if (self.step\/12).is_integer():\n                cur_elec_df = elec_space['RELATIVE'][self.cur_scenario]\n                period_now = add_months(period_null, self.step)\n                index_year = int(period_now.strftime('%Y'))\n                #change_in_demand = cur_elec_df[index_year]\n                self.base_demand = self.base_demand * cur_elec_df[index_year]\n                self.max_demand = self.max_demand * cur_elec_df[index_year]\n        if self.type == 3: #indu\n            if (self.step\/12).is_integer():\n                if (self.rof == 0) and (self.cur_scenario == 'PACES'):\n                    #cur_df = economic_growth['ECONOMIC GROWTH'][self.cur_scenario]\n                    period_now = add_months(period_null, self.step)\n                    index_year = int(period_now.strftime('%Y'))\n                    #growth = cur_df[index_year]\n                    growth = np.arctan((index_year-2013)\/10)\/(.5*np.pi)*.05+0.03\n                    self.base_demand = (1 + growth) * self.base_demand\n                    self.max_demand = (1 + growth) * self.max_demand\n                else:\n                    cur_df = economic_growth['ECONOMIC GROWTH'][self.cur_scenario]\n                    period_now = add_months(period_null, self.step)\n                    index_year = int(period_now.strftime('%Y'))\n                    growth = cur_df[index_year]\n                    self.base_demand = (1 + growth) * self.base_demand\n                    self.max_demand = (1 + growth) * self.max_demand\n                    \n        ## adjust P now to get_price, but adress later\n        ## moved to get_price, rename update_price function (?)\n        #self.lb_price = self.last_price * .75\n        #self.ub_price= self.last_price * 1.25\n\n    def return_not_cleared(self, not_cleared):\n        self.count = self.count + (len(self.wtp)-len(not_cleared))\n        self.wtp = not_cleared\n\n    def get_price(self, price):\n        self.last_price = price\n        if self.last_price > 100:\n            self.last_price = 100\n        self.lb_price = self.last_price * .75\n        self.ub_price= self.last_price * 1.25\n    \n    # writes complete state to a dictionary, see if usefull\n    def book_keeping(self):\n        self.state_hist[self.step] = self.__dict__\n        \n    # there has to be some accountability for uncleared bids of the buyers\n    def evaluate_timestep(self):\n        if self.type==1:\n            not_cleared = len(self.wtp)\n            #total_demand = self.real_demand + self.storage_q\n            storage_delta = self.storage_q - not_cleared\n            self.storage = self.storage + storage_delta\n            if print_details:\n                print(self.name, storage_delta)\n\n    def storage_manager(self):\n        # check if buyer is household buyer\n        if self.type==1:\n            if self.storage < 0:\n                self.storage_q = -self.storage\n            else:\n                self.storage_q = 0\n            return(self.storage_q)\n        else:\n            return(0)","c0f7bdf5":"# the book is an object of the market used for the clearing procedure\nclass Book():\n    def __init__(self):\n        self.ledger = pd.DataFrame(columns = (\"role\",\"name\",\"price\",\"cleared\"))\n\n    def set_asks(self,seller_list):\n        # ask each seller their name\n        # ask each seller their willingness\n        # for each willingness append the data frame\n        for seller in seller_list:\n            seller_name = seller.get_name()\n            seller_price = seller.get_asks()\n            ar_role = np.full((1,len(seller_price)),'seller', dtype=object)\n            ar_name = np.full((1,len(seller_price)),seller_name, dtype=object)\n            ar_cleared = np.full((1,len(seller_price)),'in process', dtype=object)\n            temp_ledger = pd.DataFrame([*ar_role,*ar_name,seller_price,*ar_cleared]).T\n            temp_ledger.columns= [\"role\",\"name\",\"price\",\"cleared\"]\n            self.ledger = self.ledger.append(temp_ledger, ignore_index=True)\n\n    def set_bids(self,buyer_list):\n        # ask each seller their name\n        # ask each seller their willingness\n        # for each willingness append the data frame\n        for buyer in buyer_list:\n            buyer_name = buyer.get_name()\n            buyer_price = buyer.get_bids()\n            ar_role = np.full((1,len(buyer_price)),'buyer', dtype=object)\n            ar_name = np.full((1,len(buyer_price)),buyer_name, dtype=object)\n            ar_cleared = np.full((1,len(buyer_price)),'in process', dtype=object)\n            temp_ledger = pd.DataFrame([*ar_role,*ar_name,buyer_price,*ar_cleared]).T\n            temp_ledger.columns= [\"role\",\"name\",\"price\",\"cleared\"]\n            self.ledger = self.ledger.append(temp_ledger, ignore_index=True)\n            \n    def update_ledger(self,ledger):\n        self.ledger = ledger\n        \n    def get_ledger(self):\n        return self.ledger\n    \n    def clean_ledger(self):\n        self.ledger = pd.DataFrame(columns = (\"role\",\"name\",\"price\",\"cleared\"))\n","b2a391cb":"class Market():\n    def __init__(self, name):\n        self.name= name\n        self.count = 0\n        self.last_price = ''\n        self.book = Book()\n        self.b = []\n        self.s = []\n        self.buyer_list = []\n        self.seller_list = []\n        self.buyer_dict = {}\n        self.seller_dict = {}\n        self.ledger = ''\n        self.seller_analytics = {}\n        self.buyer_analytics = {}\n\n            \n    def book_keeping_all(self):\n        for i in self.buyer_dict:\n            self.buyer_dict[i].book_keeping()\n        for i in self.seller_dict:\n            self.seller_dict[i].book_keeping()\n    \n    \n    def add_buyer(self,buyer):\n        if buyer.subscr_market[self.name] == 1:\n            self.buyer_list.append(buyer)\n        \n        \n    def add_seller(self,seller):\n        if seller.subscr_market[self.name] == 1:       \n            self.seller_list.append(seller)\n        \n        \n    def set_book(self):\n        self.book.set_bids(self.buyer_list)\n        self.book.set_asks(self.seller_list)\n        \n        \n    def get_bids(self):\n        # this is a data frame\n        ledger = self.book.get_ledger()\n        rows= ledger.loc[ledger['role'] == 'buyer']\n        # this is a series\n        prices=rows['price']\n        # this is a list\n        bids = prices.tolist()\n        return bids\n    \n    \n    def get_asks(self):\n        # this is a data frame\n        ledger = self.book.get_ledger()\n        rows = ledger.loc[ledger['role'] == 'seller']\n        # this is a series\n        prices=rows['price']\n        # this is a list\n        asks = prices.tolist()\n        return asks\n    \n    # return the price at which the market clears\n    # this fails because there are more buyers then sellers\n    \n    \n    def get_clearing_price(self):\n        # buyer makes a bid starting with the buyer which wants it most\n        b = self.get_bids()\n        s = self.get_asks()\n        # highest to lowest\n        self.b=sorted(b, reverse=True)\n        # lowest to highest\n        self.s=sorted(s, reverse=False)\n        \n        # find out whether there are more buyers or sellers\n        # then drop the excess buyers or sellers; they won't compete\n        n = len(b)\n        m = len(s)\n        \n        # there are more sellers than buyers\n        # drop off the highest priced sellers \n        if (m > n):\n            s = s[0:n]\n            matcher = n\n        # There are more buyers than sellers\n        # drop off the lowest bidding buyers \n        else:\n            b = b[0:m]\n            matcher = m\n        \n        # -It's possible that not all items sold actually clear the market here\n        # -Produces an error when one of the two lists are empty\n        #  something like 'can't compare string and float'\n        count = 0\n        for i in range(matcher):\n            if (self.b[i] > self.s[i]):\n                count +=1\n                self.last_price = self.b[i]\n        \n        # copy count to market object\n        self.count = count\n        return self.last_price\n    \n    \n    # TODO: Annotate the ledger\n    # this procedure takes up 80% of processing time\n    def annotate_ledger(self,clearing_price):\n        ledger = self.book.get_ledger()\n        \n        # logic test\n        # b or s can not be zero, probably error or unreliable results\n        # so annote everything as false in that case and move on\n        b = self.get_bids()\n        s = self.get_asks()\n        if (len(s)==0 or len(b)==0):\n            new_col = [ 'False' for i in range(len(ledger['cleared']))]\n            ledger['cleared'] = new_col\n                \n            self.book.update_ledger(ledger)\n            \n            return\n        # end logic test\n        \n        for index, row in ledger.iterrows():\n            if (row['role'] == 'seller'):\n                if (row['price'] < clearing_price):\n                    ledger.loc[index,'cleared'] = 'True'\n                else:\n                    ledger.loc[index,'cleared'] = 'False'\n            else:\n                if (row['price'] > clearing_price):\n                    ledger.loc[index,'cleared'] = 'True'\n                else:\n                    ledger.loc[index,'cleared'] = 'False'  \n                    \n        self.book.update_ledger(ledger)\n    \n    \n    def get_units_cleared(self):\n        return self.count\n    \n    \n    def clean_ledger(self):\n        self.ledger = ''\n        self.book.clean_ledger()\n\n        \n    def run_it(self):\n        self.pre_clearing_operation()\n        self.clearing_operation()\n        self.after_clearing_operation()\n        \n        \n        # pre clearing empty out the last run and start\n        # clean ledger is kind of sloppy, rewrite functions to overide the ledger\n    def pre_clearing_operation(self):\n        self.clean_ledger()\n        \n        \n    def clearing_operation(self):\n        self.set_book()\n        clearing_price = self.get_clearing_price()\n        if print_details:\n            print(self.name, clearing_price)\n        self.annotate_ledger(clearing_price)\n        \n        \n    def after_clearing_operation(self):\n        for agent in self.seller_list:\n            name = agent.name\n            cur_extract = len(self.book.ledger[(self.book.ledger['cleared'] == 'True') &\n                                               (self.book.ledger['name'] == name)])\n            agent.extract(cur_extract)\n            agent.get_price(self.last_price)\n            self.seller_analytics[name] = cur_extract\n            if cur_extract >0:\n                agent_asks = agent.get_asks()\n                agent_asks = sorted(agent_asks, reverse=False)\n                not_cleared = agent_asks[cur_extract:len(agent_asks)]\n                agent.return_not_cleared(not_cleared)\n \n        for agent in self.buyer_list:\n            name = agent.name\n            cur_extract = len(self.book.ledger[(self.book.ledger['cleared'] == 'True') &\n                                               (self.book.ledger['name'] == name)])\n            agent.get_price(self.last_price)\n            self.buyer_analytics[name] = cur_extract  \n            if cur_extract >0:\n                agent_bids = agent.get_bids()\n                agent_bids = sorted(agent_bids, reverse=True)\n                not_cleared = agent_bids[cur_extract:len(agent_bids)]\n                agent.return_not_cleared(not_cleared)\n \n                \n        # cleaning up the books\n        self.book_keeping_all()\n","79fcfac9":"class Observer():\n    def __init__(self, init_buyer, init_seller, timesteps, scenario):\n        self.init_buyer = init_buyer\n        self.init_seller = init_seller\n        self.init_market = init_market\n        self.maxrun = timesteps\n        self.cur_scenario = scenario\n        self.buyer_dict = {}\n        self.seller_dict = {}\n        self.market_dict = {}\n        self.timetick = 0\n        self.gas_market = ''\n        self.market_hist = []\n        self.seller_hist = []\n        self.buyer_hist = []\n        self.market_origin = []\n        self.market_origin_df = pd.DataFrame(columns=['seller_analytics','buyer_analytics'])\n        self.all_data = {}\n\n    def set_buyer(self, buyer_info):\n        for name in buyer_info:\n            self.buyer_dict[name] = Buyer('%s' % name)\n            self.buyer_dict[name].base_demand = buyer_info[name]['offset']\n            self.buyer_dict[name].base_demand = buyer_info[name]['b']\n            self.buyer_dict[name].max_demand = buyer_info[name]['m']\n            self.buyer_dict[name].lb_price = buyer_info[name]['lb_price']\n            self.buyer_dict[name].ub_price = buyer_info[name]['ub_price']\n            self.buyer_dict[name].type = buyer_info[name]['type']\n            self.buyer_dict[name].rof = buyer_info[name]['rof']\n            self.buyer_dict[name].cur_scenario = self.cur_scenario\n            self.buyer_dict[name].subscr_market = dict.fromkeys(init_market,0)\n            for market in buyer_info[name]['market']:\n                self.buyer_dict[name].subscr_market[market] = 1\n\n    def set_seller(self, seller_info):\n        for name in seller_info:\n            self.seller_dict[name] = Seller('%s' % name)\n            self.seller_dict[name].prod = seller_info[name]['prod']\n            self.seller_dict[name].lb_price = seller_info[name]['lb_price']\n            self.seller_dict[name].ub_price = seller_info[name]['ub_price']\n            self.seller_dict[name].reserve = seller_info[name]['reserve']\n            self.seller_dict[name].init_reserve = seller_info[name]['reserve']\n            self.seller_dict[name].unproven_reserve = seller_info[name]['UP_reserve']\n            self.seller_dict[name].init_unproven_reserve = seller_info[name]['UP_reserve']\n            #self.seller_dict[name].rof = seller_info[name]['rof']\n            self.seller_dict[name].cur_scenario = self.cur_scenario\n            self.seller_dict[name].subscr_market = dict.fromkeys(init_market,0)\n            for market in seller_info[name]['market']:\n                self.seller_dict[name].subscr_market[market] = 1\n    \n    def set_market(self, market_info):\n        for name in market_info:\n            self.market_dict[name] = Market('%s' % name)\n        #add suplliers and buyers to this market\n            for supplier in self.seller_dict.values():\n                self.market_dict[name].add_seller(supplier)\n            for buyer in self.buyer_dict.values():\n                self.market_dict[name].add_buyer(buyer)\n            self.market_dict[name].seller_dict = self.seller_dict\n            self.market_dict[name].buyer_dict = self.buyer_dict\n    \n    def update_buyer(self):\n        for i in self.buyer_dict:\n            self.buyer_dict[i].step += 1\n            self.buyer_dict[i].set_quantity()\n    \n    def update_seller(self):\n        for i in self.seller_dict:\n            self.seller_dict[i].step += 1\n            self.seller_dict[i].set_quantity()\n\n    def evaluate_timestep(self):\n        for i in self.buyer_dict:\n            self.buyer_dict[i].evaluate_timestep()\n        for i in self.seller_dict:\n            self.seller_dict[i].evaluate_timestep()\n\n    def get_reserve(self):\n        reserve = []\n        for name in self.seller_dict:\n            reserve.append(self.seller_dict[name].reserve)\n        return reserve            \n\n    def get_data(self):\n        for name in self.seller_dict:\n            self.all_data[name] = self.seller_dict[name].state_hist\n        for name in self.buyer_dict:\n            self.all_data[name] = self.buyer_dict[name].state_hist\n\n    def run_it(self):\n        # Timing\n        # time initialising\n        startit_init = time.time()\n        \n        # initialise, setting up all the agents (firstrun not really needed anymore, since outside the loop)\n        # might become useful again if run_it is used for parametersweep\n        first_run = True\n        if first_run:\n            self.set_buyer(self.init_buyer)\n            self.set_seller(self.init_seller)\n            self.set_market(self.init_market)\n            first_run=False\n            \n        # time init stop\n        stopit_init = time.time() - startit_init\n        if print_details:\n            print('%s : initialisation time' % stopit_init)\n        \n        # building the multiindex for origin dataframe\n        listing = []\n        for m in self.market_dict:\n            listing_buyer = [(runname, m,'buyer_analytics',v.name) for v in self.market_dict[m].buyer_list]\n            listing = listing + listing_buyer\n            listing_seller = [(runname, m,'seller_analytics',v.name) for v in self.market_dict[m].seller_list]\n            listing = listing + listing_seller\n        multi_listing = pd.MultiIndex.from_tuples(listing)\n        # recording everything in dataframes, more dependable than lists?\n        \n        #reserve_df = pd.DataFrame(data=None, columns=[i for i in self.seller_dict])\n        #iterables = [[i for i in self.market_dict], ['buyer_analytics', 'seller_analytics']]\n        #index = pd.MultiIndex.from_product(iterables)\n        market_origin_df = pd.DataFrame(data=None, columns=multi_listing)\n        \n\n        for period in range(self.maxrun):\n            # time the period\n            startit_period = time.time()\n\n            self.timetick += 1\n            period_now = add_months(period_null, self.timetick-1)\n            if print_details:\n                print('#######################################')\n                print(period_now.strftime('%Y-%b'), self.cur_scenario)\n            \n            # update the buyers and sellers (timetick+ set Q)\n            self.update_buyer()\n            self.update_seller()\n            \n            # real action on the market\n            for market in self.market_dict:\n                if market != 'lng':\n                    self.market_dict[market].run_it()\n            self.market_dict['lng'].run_it()\n\n            #tell buyers timetick has past\n            self.evaluate_timestep()\n                \n\n            # data collection\n            for name in self.market_dict:\n                p_clearing = self.market_dict[name].last_price\n                q_sold = self.market_dict[name].count\n                self.market_hist.append([period_now.strftime('%Y-%b'), p_clearing, q_sold, name])\n            \n            for name in self.seller_dict:\n                reserve = self.seller_dict[name].reserve\n                produced = self.seller_dict[name].count\n                self.seller_hist.append([period_now.strftime('%Y-%b'), reserve, produced, name])\n                \n            for name in self.buyer_dict:\n                storage = self.buyer_dict[name].storage\n                consumed = self.buyer_dict[name].count\n                self.buyer_hist.append([period_now.strftime('%Y-%b'), storage, consumed, name])\n            \n            # means to caption the origin of stuff sold on the market,\n            # but since dictionaries are declared global of some sort\n            # Dataframe has to be used to capture the real values\n            for name in self.market_dict:\n                seller_analytics = self.market_dict[name].seller_analytics\n                buyer_analytics = self.market_dict[name].buyer_analytics\n                for seller in seller_analytics:\n                    market_origin_df.loc[period_now.strftime('%Y-%b'),\n                                         (runname, name,'seller_analytics',seller)] = seller_analytics[seller]\n                for buyer in buyer_analytics:\n                    market_origin_df.loc[period_now.strftime('%Y-%b'),\n                                         (runname, name,'buyer_analytics',buyer)] = buyer_analytics[buyer]\n\n            # recording the step_info\n            # since this operation can take quite a while, print after every operation\n            period_time = time.time() - startit_period\n            if print_details:\n                print('%.2f : seconds to clear period' % period_time)\n        #safe df as attribute\n        self.market_origin_df = market_origin_df","80f373d8":"!pip install openpyxl","569ed932":"# import scenarios\ninputfile = '..\/input\/matching-market-dataset\/economic growth scenarios.xlsx'\n# economic growth percentages\neconomic_growth = pd.read_excel(inputfile, sheet_name='ec_growth', index_col=0, header=[0,1])\n\n# demand for electricity import scenarios spaced by excel\nelec_space = pd.read_excel(inputfile, sheet_name='elec_space', index_col=0, header=[0,1])\n\n# gasdemand home (percentage increases)\nhome_savings = {'PACES': 1.01, 'TIDES': .99, 'CIRCLES': .97}\n\n# multilevel ecgrowth\neconomic_growth2 = pd.read_excel(inputfile, sheet_name='ec_growth', index_col=0, header=[0,1])\n","fc5cb34a":"read_file = '..\/input\/matching-market-dataset\/init_buyers_sellers_LNG.xlsx'\ndf_buyer = pd.read_excel(read_file,sheet_name='buyers')\ndf_seller = pd.read_excel(read_file,sheet_name='sellers')\ndf_buyer['market'] = [eval(i) for i in df_buyer['market'].values]\ndf_seller['market'] = [eval(i) for i in df_seller['market'].values]\ninit_buyer = df_buyer.to_dict('index')\ninit_seller = df_seller.to_dict('index')\n\nmarket = []\nfor i in init_seller:\n    for x in init_seller[i]['market']: market.append(x)\nfor i in init_buyer:\n    for x in init_buyer[i]['market']: market.append(x)\nmarket = list(set(market))\ninit_market = market\n\n# set the starting time\nperiod_null= datetime.date(2013,1,1)","575c869a":"years = 35\nprint_details = False\nrun_market = {}\nrun_seller = {}\nrun_buyer = {}\nrun_market_origin = {}\nrun_market_origin_df = {}\nfor i in range(10):\n    curscen = 'CIRCLES'\n    runname = \"%s_%s\" %(curscen, i)\n    dtrunstart = datetime.datetime.now()\n    print('\\n%s scenario %d year run started' %(runname,years))\n    obser1 = Observer(init_buyer, init_seller, years*12, curscen)\n    obser1.run_it()\n    #get the info from the observer\n    run_market[runname] = obser1.market_hist\n    run_seller[runname] = obser1.seller_hist\n    run_buyer[runname] = obser1.buyer_hist\n    run_market_origin_df[runname] = obser1.market_origin_df\n    dtrunstop = datetime.datetime.now()\n    print('%s scenario %d year run finished' %(runname,years))\n    print('this run took %s (h:m:s) to complete'% (dtrunstop - dtrunstart))","f768be9c":"# timeit\n\nstopit = time.time()\ndtstopit = datetime.datetime.now()\n\nprint('it took us %s seconds to get to this conclusion' % (stopit-startit))\nprint('in another notation (h:m:s) %s'% (dtstopit - dtstartit))","ecc63f6c":"# print the time of last run\nprint('last run of this notebook:')\ntime.strftime(\"%a, %d %b %Y %H:%M:%S\", time.localtime())","175511c3":"plt.subplots()\nfor market in init_market:\n    for i in run_market:\n        run_df = pd.DataFrame(run_market[i])\n        run_df = run_df[run_df[3]==market]\n        run_df.set_index(0, inplace=True)\n        run_df.index = pd.to_datetime(run_df.index)\n        run_df.index.name = 'month'\n        run_df.rename(columns={1: 'price', 2: 'quantity'}, inplace=True)\n        run_df = run_df['price'].resample('A').mean().plot(label=i, title=market,figsize=(20,5))\n        run_df.grid()\n    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n    plt.ylabel('TWh')\n    plt.xlabel('Year')\n    plt.show();","0558aa37":"today = datetime.date.today().strftime('%Y%m%d')\noutputexcel = '.\\exceloutput\\%srun.xlsx' %today\nwriter = pd.ExcelWriter(outputexcel)\n\ndef write_to_excel():\n    for i in run_market:\n        run_df = pd.DataFrame(run_market[i])\n        run_df.set_index(0, inplace=True)\n        run_df.index = pd.to_datetime(run_df.index)\n        run_df.index.name = 'month'\n        run_df.rename(columns={1: 'price', 2: 'quantity'}, inplace=True)\n        run_df.to_excel(writer, sheet_name=i)","168b71c5":"# Writing JSON data\n# market data\ndata = run_market\nwith open('.\/marketdata.json', 'w') as f:\n     json.dump(data, f)","e552d7b5":"# seller\/reserve data\ndata = run_seller\nwith open('.\/sellerdata.json', 'w') as f:\n     json.dump(data, f)","c98fee17":"# buyer data\ndata = run_buyer\nwith open('.\/buyerdata.json', 'w') as f:\n     json.dump(data, f)","3b1ea66d":"# Merge Dataframes\nresult = pd.concat([run_market_origin_df[i] for i in run_market_origin_df], axis=1)\n#pickle does the job\nresult.to_pickle('.\/marketdataorigin.pickle', compression='infer', protocol=4)","71e96363":"# testing if complex frames did what it is expected to do\ndf_pickle = result\nfor i in df_pickle.columns.levels[0]:\n    scen=i\n    market='eu'\n    df = df_pickle[scen][market]['seller_analytics']\n    df.index = pd.to_datetime(df.index)\n    df.resample('A').sum().plot.area(title='%s %s'%(scen,market),figsize=(20,5))\n    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\n    plt.ylabel('TWh')\n    plt.xlabel('Year')\n    plt.grid()\n","5b5abc03":"# To save data for later use ","edcb6ce5":"# Microeconomic Foundations","36c9f6da":"# Example Market","f5d7b59b":"A possible addition of this model would be to have a weekly varying demand of customers, for instance caused by the use of natural gas as a heating agent. This would require the bids and asks to be time varying, and for the market to be run over successive time periods. A second addition would be to create transport costs, or enable intermediate goods to be produced. This would need a more elaborate market operator. Another possible addition would be to add a profit maximizing broker. This may require adding belief, fictitious play, or message passing.\n\nThe object-orientation of the models will probably need to be further rationalized. Right now the market requires very particular ordering of calls to function correctly.\n\n","e6759e87":"# Matching Market","4c15d494":"The following section presents three objects which can be used to make an agent-based model of an efficient, two-sided market.","4fafd72c":"Below we are constructing the buyers and sellers in classes.","5cc772d4":"# Next Steps","a466961d":"# Agent-Based Objects","a75d52ce":"Time and date of the last run of this notebook file","ceb1897e":"This simple model consists of a buyer, a supplier, and a market.\n\nThe buyer represents a group of customers whose willingness to pay for a single unit of the good is captured by a vector of prices wta. You can initiate the buyer with a set_quantity function which randomly assigns the willingness to pay according to your specifications. You may ask for these willingness to pay quantities with a getbid function.\n\nThe supplier is similar, but instead the supplier is willing to be paid to sell a unit of technology. The supplier for instance may have non-zero variable costs that make them unwilling to produce the good unless they receive a specified price. Similarly the supplier has a get_ask function which returns a list of desired prices.\n\nThe willingness to pay or sell are set randomly using uniform random distributions. The resultant lists of bids are effectively a demand curve. Likewise the list of asks is effectively a supply curve. A more complex determination of bids and asks is possible, for instance using time of year to vary the quantities being demanded.","75a216ee":"# Operations Research Formulation","b74c5876":"For the market two classes are made. The market itself, which controls the buyers and the sellers, and the book. The market has a book where the results of the clearing procedure are stored.","6661a2c5":"# Plotting scenario runs","2649c419":"# Classes for buyers and sellers","7da9ee7e":"The observer holds the clock and collects data. In this setup it tells the market another tick has past and it is time to act. The market will instruct the other agents. The observer initializes the model, thereby making real objects out of the classes defined above.","2a4599a6":"# Observer","cb05d9ff":"# Time of last run","d0b5ee84":"ABM market model based on the natural gas market written in Python. The model is created to run a simulation for roughly 35 years and represents a time frame of the year 2013 to 2050.","9c3a09a8":"The market can also be formulated as a very simple linear program or linear complementarity problem. It is clearer and easier to implement this market clearing mechanism with agents. One merit of the agent-based approach is that we don't need linear or linearizable supply and demand function.\n\nThe auctioneer is effectively following a very simple linear program subject to constraints on units sold. The auctioneer is, in the primal model, maximizing the consumer utility received by customers, with respect to the price being paid, subject to a fixed supply curve. On the dual side the auctioneer is minimizing the cost of production for the supplier, with respect to quantity sold, subject to a fixed demand curve. It is the presumed neutrality of the auctioneer which justifies the honest statement of supply and demand.\n\nAn alternative formulation is a linear complementarity problem. Here the presence of an optimal space of trades ensures that there is a Pareto optimal front of possible trades. The perfect opposition of interests in dividing the consumer and producer surplus means that this is a zero sum game. Furthermore the solution to this zero-sum game maximizes societal welfare and is therefore the Hicks optimal solution.","e1f54150":"The market assumes the presence of an auctioneer which will create a book, which seeks to match the bids and the asks as much as possible. If the auctioneer is neutral, then it is incentive compatible for the buyer and the supplier to truthfully announce their bids and asks. The auctioneer will find a single price which clears as much of the market as possible. Clearing the market means that as many willing swaps happens as possible. You may ask the market object at what price the market clears with the get_clearing_price function. You may also ask the market how many units were exchanged with the get_units_cleared function.","7c5f89d9":"For the scenario runs we vary the external factors according to the scenarios. Real plotting is done in a seperate visualization file","d32b8509":"To keep this file as clear as possible and for efficiency we visualize the results in a separate file. To transfer the model run data we use the Json library (and possibly excel).","807aeaf7":"In the following code example we use the buyer and supplier objects to create a market. At the market a single price is announced which causes as many units of goods to be swapped as possible. The buyers and sellers stop trading when it is no longer in their own interest to continue.","9c011d03":"# Construct the market"}}