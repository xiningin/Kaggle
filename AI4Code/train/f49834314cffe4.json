{"cell_type":{"749dbd5f":"code","a89de3a7":"code","b22dfce6":"code","274a3845":"code","6005147d":"code","91c47f1f":"code","3abdb115":"code","b0aa05ba":"code","3a75d0c5":"code","0d3b7676":"code","d86591e1":"code","8ad3aa08":"code","c5ffc40f":"code","18e8f826":"code","961935be":"code","317d1f56":"code","16ef5656":"code","da3022fa":"code","2cfb9b0d":"code","6f75db73":"code","3a8512ab":"code","a7cab621":"code","0e967ebc":"code","15ab7f6b":"code","82415939":"code","fda32623":"code","8ee5d604":"code","bdcac917":"code","6e5de0b3":"code","309d9dbd":"code","60a92a4a":"code","60d20f29":"code","61b1e51e":"code","c7c9770c":"code","8f8e5638":"code","46956529":"markdown","26f3d426":"markdown","020bcba6":"markdown","58a5c37b":"markdown"},"source":{"749dbd5f":"import numpy as np # linear algebra\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport tqdm\nimport gc\nimport sys\nimport warnings\nwarnings.filterwarnings(\"ignore\")","a89de3a7":"date = pd.read_csv('..\/input\/bosch-production-line-performance\/train_date.csv.zip', nrows=10000)\nnumeric = pd.read_csv('..\/input\/bosch-production-line-performance\/train_numeric.csv.zip', nrows=10000)\ncategory = pd.read_csv('..\/input\/bosch-production-line-performance\/train_categorical.csv.zip', nrows=10000)","b22dfce6":"date","274a3845":"numeric","6005147d":"category","91c47f1f":"num_feats = ['Id',\n       'L3_S30_F3514', 'L0_S9_F200', 'L3_S29_F3430', 'L0_S11_F314',\n       'L0_S0_F18', 'L3_S35_F3896', 'L0_S12_F350', 'L3_S36_F3918',\n       'L0_S0_F20', 'L3_S30_F3684', 'L1_S24_F1632', 'L0_S2_F48',\n       'L3_S29_F3345', 'L0_S18_F449', 'L0_S21_F497', 'L3_S29_F3433',\n       'L3_S30_F3764', 'L0_S1_F24', 'L3_S30_F3554', 'L0_S11_F322',\n       'L3_S30_F3564', 'L3_S29_F3327', 'L0_S2_F36', 'L0_S9_F180',\n       'L3_S33_F3855', 'L0_S0_F4', 'L0_S21_F477', 'L0_S5_F114',\n       'L0_S6_F122', 'L1_S24_F1122', 'L0_S9_F165', 'L0_S18_F439',\n       'L1_S24_F1490', 'L0_S6_F132', 'L3_S29_F3379', 'L3_S29_F3336',\n       'L0_S3_F80', 'L3_S30_F3749', 'L1_S24_F1763', 'L0_S10_F219',\n 'Response']","3abdb115":"length = date.drop('Id', axis=1).count()\ndate_cols = length.reset_index().sort_values(by=0, ascending=False)\nstations = sorted(date_cols['index'].str.split('_',expand=True)[1].unique().tolist())\ndate_cols['station'] = date_cols['index'].str.split('_',expand=True)[1]\ndate_cols = date_cols.drop_duplicates('station', keep='first')['index'].tolist()","b0aa05ba":"data = None\nfor chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/train_date.csv.zip',usecols=['Id'] + date_cols,chunksize=50000,low_memory=False):\n\n    chunk.columns = ['Id'] + stations\n    chunk['start_station'] = -1\n    chunk['end_station'] = -1\n    \n    for s in stations:\n        chunk[s] = 1 * (chunk[s] >= 0)\n        id_not_null = chunk[chunk[s] == 1].Id\n        chunk.loc[(chunk['start_station']== -1) & (chunk.Id.isin(id_not_null)),'start_station'] = int(s[1:])\n        chunk.loc[chunk.Id.isin(id_not_null),'end_station'] = int(s[1:])   \n    data = pd.concat([data, chunk])","3a75d0c5":"for chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/test_date.csv.zip',usecols=['Id'] + date_cols,chunksize=50000,low_memory=False):\n    \n    chunk.columns = ['Id'] + stations\n    chunk['start_station'] = -1\n    chunk['end_station'] = -1\n    for s in stations:\n        chunk[s] = 1 * (chunk[s] >= 0)\n        id_not_null = chunk[chunk[s] == 1].Id\n        chunk.loc[(chunk['start_station']== -1) & (chunk.Id.isin(id_not_null)),'start_station'] = int(s[1:])\n        chunk.loc[chunk.Id.isin(id_not_null),'end_station'] = int(s[1:])   \n    data = pd.concat([data, chunk])\ndel chunk\ngc.collect()   ","0d3b7676":"data = data[['Id','start_station','end_station']]\nusefuldatefeatures = ['Id']+date_cols","d86591e1":"minmaxfeatures = None\nfor chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/train_date.csv.zip',usecols=usefuldatefeatures,chunksize=50000,low_memory=False):\n    features = chunk.columns.values.tolist()\n    features.remove('Id')\n    df_mindate_chunk = chunk[['Id']].copy()\n    df_mindate_chunk['mindate'] = chunk[features].min(axis=1).values\n    df_mindate_chunk['maxdate'] = chunk[features].max(axis=1).values\n    df_mindate_chunk['min_time_station'] =  chunk[features].idxmin(axis = 1).apply(lambda s: int(s.split('_')[1][1:]) if s is not np.nan else -1)\n    df_mindate_chunk['max_time_station'] =  chunk[features].idxmax(axis = 1).apply(lambda s: int(s.split('_')[1][1:]) if s is not np.nan else -1)\n    minmaxfeatures = pd.concat([minmaxfeatures, df_mindate_chunk])\n\ndel chunk\ngc.collect()","8ad3aa08":"for chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/test_date.csv.zip',usecols=usefuldatefeatures,chunksize=50000,low_memory=False):\n    features = chunk.columns.values.tolist()\n    features.remove('Id')\n    df_mindate_chunk = chunk[['Id']].copy()\n    df_mindate_chunk['mindate'] = chunk[features].min(axis=1).values\n    df_mindate_chunk['maxdate'] = chunk[features].max(axis=1).values\n    df_mindate_chunk['min_time_station'] =  chunk[features].idxmin(axis = 1).apply(lambda s: int(s.split('_')[1][1:]) if s is not np.nan else -1)\n    df_mindate_chunk['max_time_station'] =  chunk[features].idxmax(axis = 1).apply(lambda s: int(s.split('_')[1][1:]) if s is not np.nan else -1)\n    minmaxfeatures = pd.concat([minmaxfeatures, df_mindate_chunk])\n\ndel chunk\ngc.collect()","c5ffc40f":"minmaxfeatures.sort_values(by=['mindate', 'Id'], inplace=True)\nminmaxfeatures['min_Id_rev'] = -minmaxfeatures.Id.diff().shift(-1)\nminmaxfeatures['min_Id'] = minmaxfeatures.Id.diff()","18e8f826":"cols = [['Id']+date_cols,num_feats]","961935be":"traindata = None\ntestdata = None","317d1f56":"trainfiles = ['train_date.csv.zip','train_numeric.csv.zip']\ntestfiles = ['test_date.csv.zip','test_numeric.csv.zip']","16ef5656":"for i,f in enumerate(trainfiles):\n    \n    subset = None\n    \n    for chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/' + f,usecols=cols[i],chunksize=100000,low_memory=False):\n        subset = pd.concat([subset, chunk])\n    \n    if traindata is None:\n        traindata = subset.copy()\n    else:\n        traindata = pd.merge(traindata, subset.copy(), on=\"Id\")\n        \ndel subset,chunk\ngc.collect()\ndel cols[1][-1]","da3022fa":"for i, f in enumerate(testfiles):\n    subset = None\n    \n    for chunk in pd.read_csv('..\/input\/bosch-production-line-performance\/' + f,usecols=cols[i],chunksize=100000,low_memory=False):\n        subset = pd.concat([subset, chunk])\n        \n    if testdata is None:\n        testdata = subset.copy()\n    else:\n        testdata = pd.merge(testdata, subset.copy(), on=\"Id\")\n    \ndel subset,chunk\ngc.collect()","2cfb9b0d":"traindata = traindata.merge(minmaxfeatures, on='Id')\ntraindata = traindata.merge(data, on='Id')\ntestdata = testdata.merge(minmaxfeatures, on='Id')\ntestdata = testdata.merge(data, on='Id')","6f75db73":"del minmaxfeatures,data\ngc.collect()","3a8512ab":"train = traindata[::2]\nvalid = traindata[1::2]","a7cab621":"del traindata\ngc.collect()","0e967ebc":"def mcc(tp, tn, fp, fn):\n    num = tp * tn - fp * fn\n    den = (tp + fp) * (tp + fn) * (tn + fp) * (tn + fn)\n    if den == 0:\n        return 0\n    else:\n        return num \/ np.sqrt(den)","15ab7f6b":"def eval_mcc(y_true, y_prob):\n    idx = np.argsort(y_prob)\n    y_true_sort = y_true[idx]\n    n = y_true.shape[0]\n    nump = 1.0 * np.sum(y_true) \n    numn = n - nump \n    tp,fp = nump,numn\n    tn,fn = 0.0,0.0\n    best_mcc = 0.0\n    best_id = -1\n    mccs = np.zeros(n)\n    for i in range(n):\n        if y_true_sort[i] == 1:\n            tp -= 1.0\n            fn += 1.0\n        else:\n            fp -= 1.0\n            tn += 1.0\n        new_mcc = mcc(tp, tn, fp, fn)\n        mccs[i] = new_mcc\n        if new_mcc >= best_mcc:\n            best_mcc = new_mcc\n            best_id = i\n    return best_mcc","82415939":"def mcc_eval(y_prob, dtrain):\n    y_true = dtrain.get_label()\n    best_mcc = eval_mcc(y_true, y_prob)\n    return 'MCC', best_mcc","fda32623":"import xgboost as xgb\nparams = {'objective':\"binary:logistic\",\n          'max_depth':25,\n          'base_score':0.005,\n          'eval_metric':'auc',\n          'n_jobs':-1\n}","8ee5d604":"trainm = xgb.DMatrix(train.drop(['Response','Id'],axis=1),train['Response'])\nvalidm = xgb.DMatrix(valid.drop(['Response','Id'],axis=1),valid['Response'])\n\ntest = xgb.DMatrix(testdata.drop(['Id'],axis=1))","bdcac917":"#del train,valid,testdata\n#gc.collect()","6e5de0b3":"watchlist = [(trainm, 'train'), (validm, 'val')]\nclf = xgb.train(params, trainm,\n                num_boost_round=100,\n                evals=watchlist,\n                early_stopping_rounds=20,\n                feval=mcc_eval,\n                maximize=True\n                )","309d9dbd":"predictions = clf.predict(validm)","60a92a4a":"from sklearn.metrics import matthews_corrcoef\nthresholds = np.linspace(0.01, 0.99, 50)\nmcc = np.array([matthews_corrcoef(valid.Response, predictions>threshold) for threshold in thresholds])\n\nplt.plot(thresholds, mcc)\nbest_prob = thresholds[mcc.argmax()]\nbest_prob","60d20f29":"fig, ax = plt.subplots(figsize=(12,18))\nxgb.plot_importance(clf,ax=ax)","61b1e51e":"test = clf.predict(test)","c7c9770c":"testdata['Response'] = (test>best_prob).astype(int)\ntestdata[['Id','Response']].to_csv(\"submitwoId.csv\",index=False)","8f8e5638":"!gzip submitwoId.csv","46956529":"# Note: The dataset is too large in terms of features we will be using the dataset in form of chunks in the entire solution","26f3d426":"# MODELLING","020bcba6":"# FEATURE ENGINEERING","58a5c37b":"### The list of numeric features is selected based on the other XGBOOST classifier check the numericclassifier notebook"}}