{"cell_type":{"a3f137bc":"code","47c0ecbf":"code","3a7eaf10":"code","f8a9bf3f":"code","7ff5ef80":"code","e201e200":"markdown","7c4a998d":"markdown"},"source":{"a3f137bc":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import recall_score,precision_score,accuracy_score,classification_report,precision_recall_curve,f1_score\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom IPython.lib.display import Audio\n\n\nframerate = 4410\nplay_time_seconds = 3\n\nt = np.linspace(0, play_time_seconds, framerate*play_time_seconds)\naudio_data = np.sin(2*np.pi*300*t) + np.sin(2*np.pi*240*t)\nBEEP = Audio(audio_data, rate=framerate, autoplay=True)","47c0ecbf":"def mean_roc(iteration,test_size, early_stop=0):\n    data = pd.read_csv('..\/input\/heart-failure-prediction\/heart.csv')\n\n    num_cols = ['Age','RestingBP','Cholesterol','FastingBS','MaxHR']\n\n    data = data.dropna()\n    data = pd.get_dummies(data,drop_first=True)\n\n    # data_norm=(data[num_cols]-data[num_cols].mean())\/data[num_cols].std()\n    # data = data.drop(num_cols,axis = 1)\n    # data = pd.concat([data,data_norm],axis=1)\n    # data = pd.get_dummies(data,drop_first=True)\n\n\n    # data['age+restbp'] = data['Age']*data['RestingBP']\n\n    # data['BP*HR'] = data['RestingBP']*data['MaxHR']*-1\n    # data['age+fast'] = (data['Age']*data['FastingBS'])**2\/10\n\n    # data['new_feat'] = data['BP*HR']\/data['age+restbp']+0.001\n    # data['new_feat_2'] = data['new_feat']*data['Oldpeak']+0.001\n    # data['ExerciseAngina_Y*age']= data['ExerciseAngina_Y']+data['Oldpeak']+data['ST_Slope_Flat']\n    df_2 = data\n    y = df_2['HeartDisease']\n    df_2.drop(columns='HeartDisease',inplace=True)\n    X = df_2\n\n    \n    number_cycle =1\n    list_roc = []\n\n\n    for i in range(iteration):\n      X_train, X_test, y_train, y_test =train_test_split(X,y,test_size=test_size,random_state=None)\n\n      model = GradientBoostingClassifier(ccp_alpha=0.0, criterion='friedman_mse', init=None,\n                                learning_rate=0.1, loss='deviance', max_depth=4,\n                                max_features=None, max_leaf_nodes=None,\n                                min_impurity_decrease=0.0, min_impurity_split=None,\n                                min_samples_leaf=1, min_samples_split=0.1,\n                                min_weight_fraction_leaf=0.0, n_estimators=28,\n                                n_iter_no_change=None, presort='deprecated',\n                                random_state=None, subsample=1.0, tol=0.0001,\n                                validation_fraction=0.1, verbose=0,\n                                warm_start=False)\n      model.fit(X_train,y_train)\n      predict= model.predict_proba(X_test)\n      predict_binar = model.predict(X_test)\n      result = roc_auc_score(y_test, predict[:,1])\n      list_roc.append(result)\n      number_cycle += 1\n      if number_cycle % 50 == 0:\n        print(number_cycle)\n      if early_stop == 1:\n        if result >= 0.96 :\n            break\n        if accuracy_score(y_test,predict_binar) >= 0.91 and recall_score(y_test,predict_binar) >= 0.91 and precision_score(y_test,predict_binar) >= 0.91 and f1_score(y_test,predict_binar) >= 0.91:\n                            break\n\n\n    visual = pd.DataFrame(data= list_roc)\n    return visual.hist(),print(\"last iteraion roc \",roc_auc_score(y_test, predict[:,1]),'mean_roc ', visual.mean()),print('last iteraion',classification_report(y_test, predict_binar))\n    # BEEP","3a7eaf10":"mean_roc(300,0.2)","f8a9bf3f":"mean_roc(300,0.5)","7ff5ef80":"mean_roc(1000,0.3,early_stop=1)","e201e200":"if we want best score, just use \"**early_stop=1**\" and 500 or more iteraton  \n","7c4a998d":"**My goal:**\n\n1 - Make stable prediction based on ROC -- so I use 300 iteraton of train test split \n\n2 - dont overfit - so i use test split 20% and 50%"}}