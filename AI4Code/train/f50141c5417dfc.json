{"cell_type":{"3fec6034":"code","e26f660f":"code","39ac4079":"code","f793013c":"code","6c13dcec":"code","a6361996":"code","c399282f":"code","5f242e47":"code","089a42cf":"code","428f734b":"code","df77f892":"code","62e92594":"code","881ff198":"code","98ae4065":"code","d56b5cda":"code","9beb3927":"code","9b3e2433":"code","43d0e930":"code","1ac852dc":"code","fe69348f":"code","fe7faaf0":"code","00a80e8a":"code","e26f503b":"code","1d6e5e30":"code","79b2cd68":"code","712f6c53":"code","18119bbf":"code","17942646":"code","276dd10f":"code","1209cdb2":"code","22db837c":"code","d9c22b40":"code","f7379044":"code","dab5185e":"markdown","f1eaccae":"markdown","a2948d92":"markdown","584c18db":"markdown","a2a5543e":"markdown","67d96645":"markdown","a584136e":"markdown","9d5c231e":"markdown","906d5d15":"markdown","328f890f":"markdown","6143f4ba":"markdown","918729b8":"markdown","dcd41fe2":"markdown","547716ac":"markdown","0971767e":"markdown","7a64e8cd":"markdown","5d7b6673":"markdown","92789016":"markdown","d06ba6dd":"markdown","fccb6832":"markdown"},"source":{"3fec6034":"import numpy as np\nimport pandas as pd\nfrom pathlib import Path\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\n","e26f660f":"trainfile = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_train.csv\")\ntestfile = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/baseline_locations_test.csv\")\nsubmission = pd.read_csv(\"..\/input\/google-smartphone-decimeter-challenge\/sample_submission.csv\")\n# submission = submission.assign(latDeg=test.latDeg.round(6), lngDeg=test.lngDeg.round(6))","39ac4079":"trainfile.head(2)","f793013c":"testfile.head(2)","6c13dcec":"trainfile.info()","a6361996":"testfile.info()","c399282f":"datapath = Path(\"..\/input\/google-smartphone-decimeter-challenge\")\ntruths = (datapath \/ 'train').rglob('ground_truth.csv')\n\n\ncols = ['collectionName', 'phoneName', 'millisSinceGpsEpoch', 'latDeg',\n       'lngDeg']\ntruth_list =[]\nfor filepath in tqdm(truths, total=73):\n    file = pd.read_csv(filepath, usecols=cols)\n    truth_list.append(file)\n    \ntruth_data = pd.concat(truth_list, ignore_index=True)\n\ntrain = trainfile[cols]\n\ntrain = train.merge(truth_data, on=cols[:3], suffixes=(\"_current\",\"_truth\"))","5f242e47":"train.head(2)","089a42cf":"train.iloc[:,3:].corr()","428f734b":"test = testfile.copy()\n\nprint(\"############### collectionName unique values ##############################\")\nprint(\"train: {}\".format(train.collectionName.nunique()))\nprint(train.collectionName.unique())\nprint(\"----------------------------------------------\")\nprint(\"test: {}\".format(test.collectionName.nunique()))\nprint(test.collectionName.unique())\nprint(\"----------------------------------------------\")\n\nprint(\"\\n\")\n\nprint(\"############### phoneName unique values ##############################\")\nprint(\"train: {}\".format(train.phoneName.nunique()))\nprint(train.phoneName.unique())\nprint(\"----------------------------------------------\")\nprint(\"test: {}\".format(test.phoneName.nunique()))\nprint(test.phoneName.unique())\nprint(\"----------------------------------------------\")","df77f892":"train_phone = pd.get_dummies(train.loc[:,\"phoneName\"])\ntest_phone = pd.get_dummies(test.loc[:,\"phoneName\"])\n\nprint(\"train_phone shape:{}\".format(train_phone.shape))\nprint(\"test_phone shape:{}\".format(test_phone.shape))","62e92594":"train_phone1, test_phone1 = train_phone.align(test_phone, join=\"outer\",axis=1, fill_value=0)\nprint(\"Updated train shape {}\".format(train_phone.shape))\n\nprint(\"Updated test shape {}\".format(test_phone.shape))","881ff198":"train1 = pd.concat([train.iloc[:,3:], train_phone1], axis=1, ignore_index=False)\ntest1 = pd.concat([test.iloc[:,3:5], test_phone1], axis=1, ignore_index=False)","98ae4065":"print(\"train1_shape:\",train1.shape)\ntrain1.columns","d56b5cda":"print(\"test1-shape:\",test1.shape)\ntest1.columns","9beb3927":"plt.figure(figsize=[10,5])\nplt.plot(train1[\"latDeg_current\"][:200],train1[\"lngDeg_current\"][:200],\"bo\",label=\"current\")\nplt.plot(train1[\"latDeg_truth\"][:200],train1[\"lngDeg_truth\"][:200],\"r*\",label=\"truth\")\nplt.title(\"current vs truth\", fontweight=\"bold\")\nplt.xlabel(\"latDeg\")\nplt.ylabel(\"lngDeg\")\nplt.legend()\n\nplt.figure(figsize=[15,5])\nplt.subplot(1,2,1)\nplt.plot(train1[\"latDeg_current\"][:200],train1[\"latDeg_truth\"][:200],\"bo\")\nplt.title(\"lat (current vs truth)\", fontweight=\"bold\")\n\nplt.subplot(1,2,2)\nplt.plot(train1[\"lngDeg_current\"][:200],train1[\"lngDeg_truth\"][:200],\"bo\")\nplt.title(\"lng (current vs truth)\", fontweight=\"bold\")","9b3e2433":"# for lat\ncolumns1 = list(train1.columns[4:])\nX1,y1 = train1.loc[:,[train1.columns[0]]+columns1],train1[\"latDeg_truth\"].values\n  \n#for lng\ncolumns2 = list(train1.columns[4:])\nX2,y2 = train1.loc[:,[train1.columns[1]]+columns2],train1[\"lngDeg_truth\"].values\n\n\nXt1 = test1.loc[:,[test1.columns[0]]+columns1] #for lat\nXt2 = test1.loc[:,[test1.columns[1]]+columns2] #for lng\n\nprint(\"X1 columns:\", X1.columns.tolist())\nprint(\"Xt1 columns:\", Xt1.columns.tolist())\nprint(\"\\n\")\nprint(\"X2 columns:\", X2.columns.tolist())\nprint(\"Xt2 columns:\", Xt2.columns.tolist())","43d0e930":"xtr1,xval1,ytr1,yval1 = train_test_split(X1, y1, test_size=0.3, random_state=10)\nxtr2,xval2,ytr2,yval2 = train_test_split(X2, y2, test_size=0.3, random_state=10)\n\nprint(\"xtr1 shape:{}; xval1 shape:{}\".format(xtr1.shape,xval1.shape))\nprint(\"xtr2 shape:{}; xval2 shape:{}\".format(xtr2.shape,xval2.shape))","1ac852dc":"xval1.head()","fe69348f":"xval2.head()","fe7faaf0":"from math import radians, cos, sin, asin, sqrt\ndef lat_lon_dist(df):\n    \"\"\"\n    Calculate the great circle distance between two points \n    on the earth (specified in decimal degrees)\n    \"\"\"\n    dist_list = []\n    for i in tqdm(range(df.shape[0]),total=100):\n        lat1 = df[\"latDeg_truth\"][i]\n        lon1 = df[\"lngDeg_truth\"][i]\n        lat2 = df[\"latDeg_pred\"][i]\n        lon2 = df[\"lngDeg_pred\"][i]\n        # convert decimal degrees to radians \n        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])\n        # haversine formula \n        dlon = lon2 - lon1 \n        dlat = lat2 - lat1 \n        a = sin(dlat\/2)**2 + cos(lat1) * cos(lat2) * sin(dlon\/2)**2\n        c = 2 * asin(sqrt(a)) \n        # Radius of earth in kilometers is 6371\n        mdist = 6371* c*1000\n        dist_list.append(mdist)\n    \n    return dist_list","00a80e8a":"lr1 = LinearRegression() #selected as a starting point\nmodel_lat = lr1.fit(xtr1,ytr1)\npred_yval1 = model_lat.predict(xval1) # prediction for val data (lat)\n\n\nlr2 = LinearRegression()\nmodel_lng = lr2.fit(xtr2,ytr2)\npred_yval2 = model_lng.predict(xval2) # prediction for val data (long)","e26f503b":"val_df = pd.concat([xval1[[\"latDeg_current\"]], xval2], ignore_index=False, axis=1).reset_index(drop=[\"index\"])","1d6e5e30":"#truth\nval_df[\"latDeg_truth\"] = yval1\nval_df[\"lngDeg_truth\"] = yval2\n\n#pred\nval_df[\"latDeg_pred\"] = pred_yval1\nval_df[\"lngDeg_pred\"] = pred_yval2","79b2cd68":"val_df[\"dist\"] = lat_lon_dist(val_df)\n\nval_df.head(2)","712f6c53":"phone = val_df.iloc[:,2:-5].idxmax(axis=1) #Reversing one-hot decoding for phoneName\n\nval_df1 = pd.concat([val_df.iloc[:,:2],val_df.iloc[:,-3:]], axis=1, ignore_index=False)\nval_df1[\"phoneName\"] = phone\n\nval_df1 = val_df1[val_df1.columns[-1:].tolist()+val_df1.columns[:-1].tolist()]\nval_df1.head(2)","18119bbf":"import seaborn as sns\nplt.figure(figsize=[15,7])\n\n# ax, fig = plt.subplots(figsize=[15,7])\nsns.boxplot(x=\"phoneName\", y=\"dist\",data=val_df1)\nplt.ylabel(\"Dist (m)\") # distance in meters\nplt.ylim([0,30]) # for better visualization","17942646":"val_df2 = pd.DataFrame()\nval_df2[\"phoneName\"] =  val_df1.phoneName.unique().tolist()\nval_df2[\"dist_50\"] = [np.percentile(val_df1[val_df1.phoneName==ph][\"dist\"],50) for ph in val_df2[\"phoneName\"].tolist()]\nval_df2[\"dist_95\"] = [np.percentile(val_df1[val_df1.phoneName==ph][\"dist\"],95) for ph in val_df2[\"phoneName\"].tolist()]\nval_df2[\"avg_dist_50_95\"] = np.mean(np.array(val_df2.iloc[:,1:]),axis=1)\nprint(\"Val evaluation details:\\n\",val_df2)\n\nprint(\"\\n\")\nprint(\"------------------------------------------------------\")\nprint(\"Final val evaluation score: {}\".format(val_df2.iloc[:,-1].mean()))\nprint(\"------------------------------------------------------\")","276dd10f":"lr1 = LinearRegression()\nmodel_lat = lr1.fit(X1,y1)\npred_yt1 = model_lat.predict(Xt1) # prediction for test data (lat)\n\nlr2 = LinearRegression()\nmodel_lng = lr2.fit(X2,y2)\npred_yt2 = model_lng.predict(Xt2) # prediction for test data (long)","1209cdb2":"test.columns","22db837c":"submission = test[['phone','millisSinceGpsEpoch']]\nsubmission['latDeg'] = list(pred_yt1)\nsubmission['lngDeg'] = list(pred_yt2)","d9c22b40":"submission.shape","f7379044":"submission.to_csv(\".\/submission.csv\",index=False)","dab5185e":"**Plotting current vs truth coordinates**","f1eaccae":"**Defining a function to get prediction and ground truth distance estimation (in meters)**\n\n[Haversine formula for distance estimation using GPS co-ordinates](https:\/\/stackoverflow.com\/questions\/15736995\/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points)","a2948d92":"**Box-plot analysis for dist  analysis for each phone**","584c18db":"**Adding truth & predicted lat-long values to val_df**","a2a5543e":"**Extracting ground truths and aligning with train inputs**","67d96645":"**Model evaluation on validation data**","a584136e":"**Checking the correlation between current & truth coordinates**","9d5c231e":"**Train-test data after addition of one-hot encoded columns**","906d5d15":"**Aligning train & test columns**","328f890f":"**Input-output**","6143f4ba":"**Reference Notebooks:**\n* [EDA+Google Smartphone Decimeter](https:\/\/www.kaggle.com\/yasserhessein\/eda-google-smartphone-decimeter)","918729b8":"**Import Required libraries**","dcd41fe2":"**Note:** Here, collectionName would be useless to consider as it would be different in train and test data but **phoneName** might be helpful","547716ac":"**Training the model on complete data and predict for test data**","0971767e":"**Loading train, test & submission files**","7a64e8cd":"* Basically, there is no change is one-hot encoded phoneName columns for train or test data","5d7b6673":"**Preparing evaluation score for each phone (50th & 95th percentile)**","92789016":"**Model building**","d06ba6dd":"**One-hot encoding for 'phoneName' of train and test data**","fccb6832":"* In above correlation table, we can see that ***latDeg_current is highly correlated with latDeg_truth*** and ***lngDeg_current is highly correlated with lngDeg_truth***\n* That would help us to build a baseline model"}}