{"cell_type":{"8778bfa5":"code","a8a6f17e":"code","85bf5c00":"code","65580a8e":"code","a92430f1":"code","52e566c1":"code","3bea7359":"code","359ee1a0":"code","8cac2db4":"code","bea26300":"code","139703de":"code","2feec7ef":"code","cb14507d":"code","474d45c1":"code","e75d0d8d":"code","a52884b4":"code","c5fc2ef7":"code","e2d96769":"code","cc7ddc4b":"code","67841796":"code","42c58b00":"code","3fa544d3":"code","23e0b22c":"code","bfe9bf64":"code","0b0c4f48":"code","6849fe82":"code","f4f3c905":"code","b17f069c":"code","5a9064d9":"code","b11a1f1b":"code","58a7c5ef":"code","9f247bf1":"code","1b7c85d0":"code","7846c260":"code","3f7ce8e9":"code","96bb7414":"code","f6c94553":"code","ea24de2a":"code","374febd7":"code","a67347bd":"code","afd214e4":"code","24b3533f":"code","e6c2de9a":"code","93b43b56":"code","383001de":"code","104e98d4":"code","7b5f1a58":"code","746103d2":"code","2ee53abf":"markdown","194abc8a":"markdown","a3d10d2b":"markdown","364e196c":"markdown","03e09b8b":"markdown","5bbe4625":"markdown","2de08ffe":"markdown","37ac9f13":"markdown","4d3966bf":"markdown","19fa86c5":"markdown","09e5b9ea":"markdown","03dcdd70":"markdown","136b8963":"markdown","f63a22da":"markdown","f26d6bf2":"markdown","565b4a41":"markdown","1163cfa0":"markdown","8933fd87":"markdown"},"source":{"8778bfa5":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nimport datetime as dt\n\nimport sklearn\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\n\nfrom scipy.cluster.hierarchy import linkage\nfrom scipy.cluster.hierarchy import dendrogram\nfrom scipy.cluster.hierarchy import cut_tree\n\nfrom math import isnan\nfrom sklearn.neighbors import NearestNeighbors\nfrom random import sample\nfrom numpy.random import uniform\n\nimport warnings\nwarnings.filterwarnings('ignore')\n","a8a6f17e":"country_df = pd.read_csv(\"..\/input\/unsupervised-learning-on-country-data\/Country-data.csv\", sep=\",\", encoding=\"ISO-8859-1\", header=0)\ncountry_df.head()","85bf5c00":"country_df.info()","65580a8e":"country_df.shape","a92430f1":"country_df.describe()","52e566c1":"country_df.isnull().sum()\n# there is no null values in any column ","3bea7359":"\n\nfig, axs = plt.subplots(3,3,figsize = (15,15))\n\n# Child Mortality Rate : Death of children under 5 years of age per 1000 live births\n\ntop10_child_mort = country_df[['country','child_mort']].sort_values('child_mort', ascending = False).head(10)\nplt1 = sns.barplot(x='country', y='child_mort', data= top10_child_mort, ax = axs[0,0])\nplt1.set(xlabel = '', ylabel= 'Child Mortality Rate')\n\n# Fertility Rate: The number of children that would be born to each woman if the current age-fertility rates remain the same\ntop10_total_fer = country_df[['country','total_fer']].sort_values('total_fer', ascending = False).head(10)\nplt1 = sns.barplot(x='country', y='total_fer', data= top10_total_fer, ax = axs[0,1])\nplt1.set(xlabel = '', ylabel= 'Fertility Rate')\n\n# Life Expectancy: The average number of years a new born child would live if the current mortality patterns are to remain same\n\nbottom10_life_expec = country_df[['country','life_expec']].sort_values('life_expec', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='life_expec', data= bottom10_life_expec, ax = axs[0,2])\nplt1.set(xlabel = '', ylabel= 'Life Expectancy')\n\n# Health :Total health spending as %age of Total GDP.\n\nbottom10_health = country_df[['country','health']].sort_values('health', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='health', data= bottom10_health, ax = axs[1,0])\nplt1.set(xlabel = '', ylabel= 'Health')\n\n# The GDP per capita : Calculated as the Total GDP divided by the total population.\n\nbottom10_gdpp = country_df[['country','gdpp']].sort_values('gdpp', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='gdpp', data= bottom10_gdpp, ax = axs[1,1])\nplt1.set(xlabel = '', ylabel= 'GDP per capita')\n\n# Per capita Income : Net income per person\n\nbottom10_income = country_df[['country','income']].sort_values('income', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='income', data= bottom10_income, ax = axs[1,2])\nplt1.set(xlabel = '', ylabel= 'Per capita Income')\n\n\n# Inflation: The measurement of the annual growth rate of the Total GDP\n\ntop10_inflation = country_df[['country','inflation']].sort_values('inflation', ascending = False).head(10)\nplt1 = sns.barplot(x='country', y='inflation', data= top10_inflation, ax = axs[2,0])\nplt1.set(xlabel = '', ylabel= 'Inflation')\n\n\n# Exports: Exports of goods and services. Given as %age of the Total GDP\n\nbottom10_exports = country_df[['country','exports']].sort_values('exports', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='exports', data= bottom10_exports, ax = axs[2,1])\nplt1.set(xlabel = '', ylabel= 'Exports')\n\n\n# Imports: Imports of goods and services. Given as %age of the Total GDP\n\nbottom10_imports = country_df[['country','imports']].sort_values('imports', ascending = True).head(10)\nplt1 = sns.barplot(x='country', y='imports', data= bottom10_imports, ax = axs[2,2])\nplt1.set(xlabel = '', ylabel= 'Imports')\n\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation = 90)\n    \nplt.tight_layout()\nplt.savefig('eda')\nplt.show()\n    \n\n","359ee1a0":"plt.figure(figsize = (16, 10))\nsns.heatmap(country_df.corr(), annot = True, cmap=\"YlGnBu\")\nplt.savefig('correlationplot')\nplt.show()","8cac2db4":"plt.figure(figsize=(20, 12))\nplt.subplot(3,3,1)\nsns.boxplot(country_df.child_mort)\nplt.subplot(3,3,2)\nsns.boxplot(country_df.exports)\nplt.subplot(3,3,3)\nsns.boxplot(country_df.health)\nplt.subplot(3,3,4)\nsns.boxplot(country_df.imports)\nplt.subplot(3,3,5)\nsns.boxplot(country_df.income)\nplt.subplot(3,3,6)\nsns.boxplot(country_df.inflation)\nplt.subplot(3,3,7)\nsns.boxplot(country_df.life_expec)\nplt.subplot(3,3,8)\nsns.boxplot(country_df.total_fer)\nplt.subplot(3,3,9)\nsns.boxplot(country_df.gdpp)\nplt.show()","bea26300":"#gdpp seems to have a lot of outliers\ncountry_df.gdpp.describe()","139703de":"# exports, health and imports are given as percentage of GDP. Hence, to get the actual value of these quantities multiply these columns \n# by (GDP\/100) or quantity =  0.01*percentagevalue *GDP\n\n\ncountry_df['exports'] = country_df.exports.multiply(country_df.gdpp)\ncountry_df['exports'] = country_df.exports.multiply(0.01)\n\ncountry_df['health'] = country_df.health.multiply(country_df.gdpp)\ncountry_df['health'] = country_df.health.multiply(0.01)\n\ncountry_df['imports'] = country_df.imports.multiply(country_df.gdpp)\ncountry_df['imports'] = country_df.imports.multiply(0.01)\n","2feec7ef":"country_df.head()","cb14507d":"country_df.gdpp.quantile([0.5, 0.7, 0.9, 0.95, 0.99])","474d45c1":"column = ['income', 'total_fer']\n\nfor i in column:\n    q1 = country_df[i].quantile(0.95)\n    country_df[i][country_df[i] >= q1] = q1\n\n\n\n\ncolumns = ['imports', 'health', 'exports', 'gdpp']\n\n\nfor j in columns:\n    q2 = country_df[j].quantile(0.90)\n    country_df[j][country_df[j] >= q2] = q2\n\n\n","e75d0d8d":"plt.figure(figsize=(20, 12))\nplt.subplot(3,3,1)\nsns.boxplot(country_df.child_mort)\nplt.subplot(3,3,2)\nsns.boxplot(country_df.exports)\nplt.subplot(3,3,3)\nsns.boxplot(country_df.health)\nplt.subplot(3,3,4)\nsns.boxplot(country_df.imports)\nplt.subplot(3,3,5)\nsns.boxplot(country_df.income)\nplt.subplot(3,3,6)\nsns.boxplot(country_df.inflation)\nplt.subplot(3,3,7)\nsns.boxplot(country_df.life_expec)\nplt.subplot(3,3,8)\nsns.boxplot(country_df.total_fer)\nplt.subplot(3,3,9)\nsns.boxplot(country_df.gdpp)\nplt.show()","a52884b4":"li = list(country_df.columns)","c5fc2ef7":"li.remove('country')","e2d96769":"rfm_df = country_df[li]\nscaler = StandardScaler()\n\n# fit_transform\nrfm_df_scaled = scaler.fit_transform(rfm_df)\nrfm_df_scaled.shape","cc7ddc4b":"rfm_df_scaled = pd.DataFrame(rfm_df_scaled)\nrfm_df_scaled.columns = li\nrfm_df_scaled.head()","67841796":"def hopkins(X):\n    d = X.shape[1]\n    #d = len(vars) # columns\n    n = len(X) # rows\n    m = int(0.1 * n) \n    nbrs = NearestNeighbors(n_neighbors=1).fit(X.values)\n \n    rand_X = sample(range(0, n, 1), m)\n \n    ujd = []\n    wjd = []\n    for j in range(0, m):\n        u_dist, _ = nbrs.kneighbors(uniform(np.amin(X,axis=0),np.amax(X,axis=0),d).reshape(1, -1), 2, return_distance=True)\n        ujd.append(u_dist[0][1])\n        w_dist, _ = nbrs.kneighbors(X.iloc[rand_X[j]].values.reshape(1, -1), 2, return_distance=True)\n        wjd.append(w_dist[0][1])\n \n    H = sum(ujd) \/ (sum(ujd) + sum(wjd))\n    if isnan(H):\n        print(ujd, wjd)\n        H = 0\n \n    return H","42c58b00":"hopkins(rfm_df)\n\n# before scaling","3fa544d3":"kmeans = KMeans(n_clusters=4, max_iter=50, random_state= 50)\nkmeans.fit(rfm_df_scaled)","23e0b22c":"kmeans.labels_","bfe9bf64":"# elbow-curve\/SSD\nssd = []\nrange_n_clusters = [2, 3, 4, 5, 6, 7, 8]\nfor num_clusters in range_n_clusters:\n    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)\n    kmeans.fit(rfm_df_scaled)\n    \n    ssd.append(kmeans.inertia_)\n    \n# plot the SSDs for each n_clusters\n# ssd\nplt.plot(ssd)","0b0c4f48":"# silhouette analysis\nrange_n_clusters = [2, 3, 4, 5, 6, 7, 8]\n\nfor num_clusters in range_n_clusters:\n    \n    # intialise kmeans\n    kmeans = KMeans(n_clusters=num_clusters, max_iter=50)\n    kmeans.fit(rfm_df_scaled)\n    \n    cluster_labels = kmeans.labels_\n    \n    # silhouette score\n    silhouette_avg = silhouette_score(rfm_df_scaled, cluster_labels)\n    print(\"For n_clusters={0}, the silhouette score is {1}\".format(num_clusters, silhouette_avg))\n    ","6849fe82":"kmeans = KMeans(n_clusters=3, random_state= 50)\nkmeans.fit(rfm_df_scaled)","f4f3c905":"kmeans.labels_","b17f069c":"country_df['cluster_id'] = kmeans.labels_\ncountry_df.head()","5a9064d9":"sns.boxplot(x='cluster_id', y='gdpp', data=country_df)","b11a1f1b":"sns.boxplot(x='cluster_id', y='child_mort', data=country_df)","58a7c5ef":"sns.boxplot(x='cluster_id', y='income', data=country_df)","9f247bf1":"country_df.head()","1b7c85d0":"country_df.drop(['country', 'gdpp','exports', 'health', 'imports', 'inflation', 'life_expec', 'total_fer'], axis = 1).groupby('cluster_id').mean().plot(kind = 'bar')","7846c260":"country_df.drop(['country', 'income','exports', 'health', 'imports', 'inflation', 'life_expec', 'total_fer'], axis = 1).groupby('cluster_id').mean().plot(kind = 'bar')","3f7ce8e9":"country_df.drop(['country', 'child_mort','exports', 'health', 'imports', 'inflation', 'life_expec', 'total_fer'], axis = 1).groupby('cluster_id').mean().plot(kind = 'bar')","96bb7414":"sns.scatterplot(x = 'child_mort', y = 'income' , hue = 'cluster_id' ,data = country_df, palette = 'Set1')","f6c94553":"sns.scatterplot(x = 'child_mort', y = 'gdpp' , hue = 'cluster_id' ,data = country_df, palette = 'Set1')","ea24de2a":"sns.scatterplot(x = 'gdpp', y = 'income' , hue = 'cluster_id' ,data = country_df, palette = 'Set1')","374febd7":"rfm_df_scaled.head()","a67347bd":"plt.figure(figsize = (20,10))\nmergings = linkage(rfm_df_scaled, method=\"single\", metric='euclidean')\ndendrogram(mergings)\nplt.show()","afd214e4":"plt.figure(figsize = (20,10))\nmergings = linkage(rfm_df_scaled, method=\"complete\", metric='euclidean')\ndendrogram(mergings)\nplt.show()","24b3533f":"# 3 clusters\ncluster_labels = cut_tree(mergings, n_clusters=3).reshape(-1, )\ncluster_labels","e6c2de9a":"country_df['hcluster_labels'] = cluster_labels\ncountry_df.head()","93b43b56":"sns.boxplot(x='hcluster_labels', y='gdpp', data=country_df)","383001de":"sns.boxplot(x='hcluster_labels', y='child_mort', data=country_df)","104e98d4":"sns.boxplot(x='hcluster_labels', y='income', data=country_df)","7b5f1a58":"country_df[country_df['cluster_id'] == 2 ].sort_values(by = ['income', 'child_mort','gdpp'], ascending = ['True', 'False', 'True']).head()","746103d2":"country_df[country_df['hcluster_labels'] == 0].sort_values(by = ['income', 'child_mort', 'gdpp'], ascending = ['True', 'False', 'True']).head()","2ee53abf":"Hopkins value at around 80% or more gives us a sureity that this dataset is clusterable. In other words, higher is the percentage (>0.80) mean that the dataset can be expressed as clusters, or have the tendency to form clusters.","194abc8a":"From the graphs above, ","a3d10d2b":"### EDA on the dataset","364e196c":"#### Silhouette analysis\nSilhouette analysis gives the effectiveness of the cluster, and higher the value higher it can be chosen as cluster optimum","03e09b8b":"#### SSD or elbow curve \nElbow curve is done to figure out the optimal number of clusters based on maximum intra-cluster distance and minimum intercluster distance (at the point of the elbow)\n","5bbe4625":"#### List of the countries are -\n1. Congo, Dem. Rep\n2. Liberia\n3. Burundi\n4. Niger\n5. Central African Republic","2de08ffe":"\nThe job is to categorise the countries using some socio-economic and health factors that determine the overall development of the country. Then you need to suggest the countries which the HELP International's CEO needs to focus on the most. \n\n## Objectives\nThe main task is to cluster the countries by the factors mentioned above and then present your solution and recommendations.  The following approach is done :\n\n \n\n- Started off with the necessary data inspection and EDA tasks suitable for this dataset - data cleaning, univariate analysis, bivariate analysis etc.\n- Outlier Analysis:  Performed the Outlier Analysis on the dataset. However, there is a flexibility of not removing the outliers if it suits the business needs or a lot of countries are getting removed. Hence, all that needs to be done is to find the outliers in the dataset, and then choose whether to keep them or remove them depending on the results gotten.\n- Trying both K-means and Hierarchical clustering(both single and complete linkage) on this dataset to create the clusters. \n- Analysing the clusters and identifying the ones which are in dire need of aid. You can analyse the clusters by comparing how these three variables - [gdpp, child_mort and income] vary for each cluster of countries to recognise and differentiate the clusters of developed countries from the clusters of under-developed countries.\n- Also, there is a need to perform visualisations on the clusters that have been formed.  One can do this by choosing any two of the three variables mentioned above on the X-Y axes and plotting a scatter plot of all the countries and differentiating the clusters. Also, making sure of creating visualisations for all the three pairs. One can also choose other types of plots like boxplots, etc. \n- Both K-means and Hierarchical may give different results because of previous analysis (whether you chose to keep or remove the outliers, how many clusters you chose,  etc.). Hence, there might be some subjectivity in the final number of countries that one might think should be reported back to the CEO since they depend upon the preceding analysis as well. ","37ac9f13":"## Cleaning the data","4d3966bf":"# Clustering the Countries by using Unsupervised Learning for HELP International\n### Objective:\nTo categorise the countries using socio-economic and health factors that determine the overall development of the country.\n\n### About organization:\nHELP International is an international humanitarian NGO that is committed to fighting poverty and providing the people of backward countries with basic amenities and relief during the time of disasters and natural calamities.\n\n### Problem Statement:\nHELP International have been able to raise around $ 10 million. Now the CEO of the NGO needs to decide how to use this money strategically and effectively. So, CEO has to make decision to choose the countries that are in the direst need of aid. Hence, your Job as a Data scientist is to categorise the countries using some socio-economic and health factors that determine the overall development of the country. Then you need to suggest the countries which the CEO needs to focus on the most.","19fa86c5":"It is found that some factors `income`, `child_mort`, `gdpp` or `inflation`, `life_expec` plays a vital role in deciding a socio-economic status of a country. Based on which, the decision to choose a country that requires an aid are also chosen. Note that the list of countries are bound to change based on clustering method, linkages, number of clusters chosen, etc. ","09e5b9ea":"## Hopkins test\n\n","03dcdd70":"#### Complete heirarchical clustering","136b8963":"## K means","f63a22da":"## Heirarchical clustering","f26d6bf2":"Here, we see that the maximum value occurs at 2. Clusters 3 and 4 have almost similar high values, right next to cluster = 2.\nSince, 2 is usually not preferred for any business problems, 3 is chosen.","565b4a41":"Here, the elbow seems to appear at index 1 (i.e. cluster = 3) and index 3(i.e. cluster = 5), Since, the value is only decreasing little between 3 and 5, 3 is chosen as the index","1163cfa0":"#### Single heirarchical clustering","8933fd87":"## Finding optimal number of clusters"}}