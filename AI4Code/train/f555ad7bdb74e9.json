{"cell_type":{"0bbda5fe":"code","d89914bd":"code","38f7b298":"code","5c39f554":"code","229d3bf7":"code","12df6384":"code","cce55dee":"markdown","ef71c07b":"markdown","27a3290d":"markdown","a2993025":"markdown","a05d5a42":"markdown","6040592b":"markdown","80a723c0":"markdown"},"source":{"0bbda5fe":"import matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.datasets import make_blobs","d89914bd":"\ndata, _ = make_blobs(n_samples=1000, centers=[(-10,10), (10,-10), (10,10), (-10,-10)], n_features=2,\n                  random_state=0)\nprint('data.shape :', data.shape)\nplt.plot(data[:,0], data[:,1], '.')","38f7b298":"W = np.array([[20,20,-20,-20], [20,-20,20,-20]], dtype = 'float')\n# W.shape\nW = W.T\nW.shape\nplt.scatter(W[:,0], W[:,1])","5c39f554":"lr = 0.001\nfor iter in range(10):\n    for i in range(data.shape[0]):\n        edist = np.linalg.norm(W - data[i,:], axis=1)\n        ind = np.argmin(edist)\n        W[ind,:] = (1 - lr)*W[ind,:] + lr*data[i,:]\n    ","229d3bf7":"plt.scatter(W[:,0], W[:,1])","12df6384":"print(\"updated weights :\\n\", W)","cce55dee":"# Creating data with 4 clusters","ef71c07b":"# Updated Weights","27a3290d":"# Applying Kohonen's weight update rule","a2993025":"## WIP, will update the notebook soon","a05d5a42":"# SOM was able to identify the optimum locations for all the nodes\/Ws ","6040592b":"## **Let's define the initial weight vector for SOM**","80a723c0":"# Self Organizing Map \n## SOM is an unsupervised learning method. One of its uses is for clustering the data"}}