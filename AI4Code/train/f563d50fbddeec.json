{"cell_type":{"d1ad9e09":"code","a2a261c5":"code","3b51496f":"code","37b85ab0":"code","4d4eaa02":"code","89aedf8c":"code","4e6c9745":"code","1ede421e":"code","039a5bb4":"code","b9f93486":"code","3e585aed":"code","6251178e":"code","42e41a46":"code","0c2f440f":"code","d9b2dc7d":"code","2cddf9d6":"code","6e4d0423":"code","6d0530e0":"code","2d95b918":"code","7aa73a30":"code","8166909f":"markdown"},"source":{"d1ad9e09":"import numpy as np # linear algebra\nimport cv2\n\nimport os\nimport random\nimport pickle\nimport matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split","a2a261c5":"import tensorflow as tf\nfrom tensorflow.keras.layers import (\n    Conv2D, MaxPooling2D, \n    Dense, Dropout, \n    Flatten)\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator","3b51496f":"print(os.listdir(\"..\/input\/cell_images\/cell_images\"))","37b85ab0":"IMG_SIZE = 50","4d4eaa02":"CATEGORIES = ['Parasitized', 'Uninfected']\ndataset = []\n\ndef generate_data():\n    for category in CATEGORIES:\n        path = f'..\/input\/cell_images\/cell_images\/{category}'\n        class_id = CATEGORIES.index(category)\n        for image in os.listdir(path):\n            try:\n                image_array = cv2.imread(os.path.join(path, image), cv2.IMREAD_COLOR)\n                image_array = cv2.resize(image_array, (IMG_SIZE , IMG_SIZE))\n                dataset.append([image_array, class_id])\n            except Exception as e:\n                print(e)\n    random.shuffle(dataset)\n                \ngenerate_data()","89aedf8c":"print(len(dataset))","4e6c9745":"data = []\nlabels = []\nfor features, label in dataset:\n    data.append(features)\n    labels.append(label)","1ede421e":"data = np.array(data)\ndata.reshape(-1, 50, 50, 3)","039a5bb4":"train_data, data, train_labels, labels = train_test_split(data, \n                                                          labels,\n                                                          test_size=0.15)\n\ntest_data, validation_data, test_labels, validation_labels = train_test_split(data, \n                                                                    labels,\n                                                                    test_size=0.7)","b9f93486":"plt.figure(figsize=(10, 10))\ni = 0\nfor i in range(25):\n    plt.subplot(5, 5, i+1)\n    plt.xticks([])\n    plt.yticks([])\n    plt.imshow(test_data[i])\n    if(test_labels[i] == 0):\n        plt.xlabel('Infected')\n    else:\n        plt.xlabel('Uninfected')\n    i += 1\nplt.show()","3e585aed":"datagen_train = ImageDataGenerator(rescale=1.\/255,\n                            rotation_range=45,\n                            width_shift_range=0.2,\n                            height_shift_range=0.2,\n                            shear_range=0.2,\n                            zoom_range=0.2,\n                            horizontal_flip=True)\n\ndatagen_test = ImageDataGenerator(rescale=1.\/255)\ndatagen_validation = ImageDataGenerator(rescale=1.\/255)","6251178e":"datagen_train.fit(train_data)\ndatagen_test.fit(test_data)\ndatagen_test.fit(validation_data)\n","42e41a46":"model = Sequential([\n    Conv2D(32, (3, 3), activation='relu', input_shape=(IMG_SIZE, IMG_SIZE, 3)),\n    MaxPooling2D((2, 2)),\n    \n    Conv2D(64, (3, 3), activation=\"relu\"),\n    MaxPooling2D((2, 2)),\n    \n    Conv2D(128, (3, 3), activation=\"relu\"),\n    MaxPooling2D((2, 2)),\n    \n    Conv2D(256, (3, 3), activation=\"relu\"),\n    MaxPooling2D((2, 2)),\n    \n    Flatten(),\n    Dense(256, activation=\"relu\"),\n    Dense(2, activation='softmax')\n])","0c2f440f":"model.compile(optimizer='adam',\n             loss='sparse_categorical_crossentropy',\n             metrics=['accuracy'])","d9b2dc7d":"BATCH_SIZE = 32\nepochs = 30\nhistory = model.fit_generator(datagen_train.flow(train_data, train_labels, batch_size=BATCH_SIZE),\n                   steps_per_epoch=len(train_data) \/ BATCH_SIZE,\n                   epochs=epochs,\n                   validation_data=datagen_validation.flow(validation_data, \n                                                     validation_labels, batch_size=BATCH_SIZE),\n                    \n                   )","2cddf9d6":"accuracy = history.history['acc']\nloss = history.history['loss']\nval_accuracy = history.history['val_acc']\nval_loss = history.history['val_loss']\n\nprint(f'Training Accuracy: {np.max(accuracy)}')\nprint(f'Training Loss: {np.min(loss)}')\nprint(f'Validation Accuracy: {np.max(val_accuracy)}')\nprint(f'Validation Loss: {np.min(val_loss)}')","6e4d0423":"epochs_range = range(epochs)\n\nplt.figure(figsize=(8, 8))\nplt.subplot(1, 2, 1)\nplt.plot(epochs_range, accuracy, label=\"Training Accuracy\")\nplt.plot(epochs_range, val_accuracy, label=\"Validation Accuracy\")\nplt.legend(loc=\"lower right\")\nplt.title(\"Training and Validation Accuracy\")\n\nplt.subplot(1, 2, 2)\nplt.plot(epochs_range, loss, label=\"Training Loss\")\nplt.plot(epochs_range, val_loss, label=\"Validation Loss\")\nplt.legend(loc=\"upper right\")\nplt.title(\"Training and Validation Loss\")\nplt.show()","6d0530e0":"class_names = ['Infected', 'Uninfected']\ndef plot_images(i, predictions_array, true_labels, images):\n    predictions_array, true_label, img = predictions_array[i], true_labels[i],images[i]\n    plt.grid(False)\n    plt.xticks([])\n    plt.yticks([])\n    \n    plt.imshow(img)\n    \n    predicted_label = np.argmax(predictions_array)\n        \n    plt.xlabel(\"{} {:2.0f}% ({})\".format(class_names[predicted_label],\n                                        100*np.max(predictions_array),\n                                        class_names[true_label]))","2d95b918":"random.shuffle(test_data)\npredictions = model.predict(test_data)","7aa73a30":"num_rows = 8\nnum_cols = 6\nnum_images = num_rows * num_cols\nplt.figure(figsize=(2*2*num_cols, 2*num_rows))\nfor i in range(num_images):\n    plt.subplot(num_rows, 2*num_cols, 2*i+1)\n    plot_images(i, predictions, test_labels, test_data)","8166909f":"**Save the data**\n\npickle.dump(data, open(\"data.pickle\", \"wb\"))\n\npickle.dump(labels, open(\"labels.pickle\", \"wb\"))\n\n**Load the saved data**\n\ndata = pickle.load(open(\"data.pickle\", \"rb\"))\n\nlabels = pickle.load(open(\"labels.pickle\", \"rb\"))\n"}}