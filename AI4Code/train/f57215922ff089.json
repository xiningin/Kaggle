{"cell_type":{"c01640bd":"code","60abd2b0":"code","3ee30169":"code","7a114c03":"code","b29270f7":"code","f572e40f":"code","8931fdc8":"markdown","390373d8":"markdown","97684e70":"markdown"},"source":{"c01640bd":"import numpy as np\nimport cv2\nfrom PIL import Image\nimport pytesseract as tess\nimport matplotlib.pyplot as plt","60abd2b0":"def ratioCheck(area, width, height):\n    ratio = float(width) \/ float(height)\n    if ratio < 1:\n        ratio = 1 \/ ratio\n    if (area < 1063.62 or area > 73862.5) or (ratio < 3 or ratio > 6):\n        return False\n    return True","3ee30169":"def isMaxWhite(plate):\n    avg = np.mean(plate)\n    if(avg>=115):\n        return True\n    else:\n         return False","7a114c03":"def ratio_and_rotation(rect):\n    (x, y), (width, height), rect_angle = rect\n\n    if(width>height):\n        angle = -rect_angle\n    else:\n        angle = 90 + rect_angle\n\n    if angle>15:\n         return False\n\n    if height == 0 or width == 0:\n        return False\n\n    area = height*width\n    if not ratioCheck(area,width,height):\n        return False\n    else:\n        return True","b29270f7":"def clean2_plate(plate):\n    gray_img = cv2.cvtColor(plate, cv2.COLOR_BGR2GRAY)\n\n    _, thresh = cv2.threshold(gray_img, 110, 255, cv2.THRESH_BINARY)\n    if cv2.waitKey(0) & 0xff == ord('q'):\n        pass\n    num_contours,hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n\n    if num_contours:\n        contour_area = [cv2.contourArea(c) for c in num_contours]\n        max_cntr_index = np.argmax(contour_area)\n\n        max_cnt = num_contours[max_cntr_index]\n        max_cntArea = contour_area[max_cntr_index]\n        x,y,w,h = cv2.boundingRect(max_cnt)\n\n        if not ratioCheck(max_cntArea,w,h):\n            return plate,None\n\n        final_img = thresh[y:y+h, x:x+w]\n        return final_img,[x,y,w,h]\n\n    else:\n        return plate, None","f572e40f":"img = cv2.imread(\"\/kaggle\/input\/testing4\/test.jpg\")\n#cv2.imshow(\"input\",img)\n#############################################\nplt.subplot(3, 3, 1)\nplt.imshow(img)\n\nimg2 = cv2.GaussianBlur(img, (3,3), 0)\n#############################################\nplt.subplot(3, 3, 2)\nplt.imshow(img2)\n\nimg2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)\n#############################################\nplt.subplot(3, 3, 3)\nplt.imshow(img2,cmap = plt.get_cmap('gray'))\n\nimg2 = cv2.Sobel(img2,cv2.CV_8U,1,0,ksize=3)    \n_,img2 = cv2.threshold(img2,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)\n#############################################\nplt.subplot(3, 3, 4)\nplt.imshow(img2,cmap = plt.get_cmap('gray'))\n\nelement = cv2.getStructuringElement(shape=cv2.MORPH_RECT, ksize=(17, 3))\nmorph_img_threshold = img2.copy()\ncv2.morphologyEx(src=img2, op=cv2.MORPH_CLOSE, kernel=element, dst=morph_img_threshold)\nnum_contours, hierarchy= cv2.findContours(morph_img_threshold,mode=cv2.RETR_EXTERNAL,method=cv2.CHAIN_APPROX_NONE)\ncv2.drawContours(img2, num_contours, -1, (0,255,0), 1)\n#############################################\nplt.subplot(3, 3, 5)\nplt.imshow(img2,cmap = plt.get_cmap('gray'))\n\n\nfor i,cnt in enumerate(num_contours):\n\n    min_rect = cv2.minAreaRect(cnt)\n\n    if ratio_and_rotation(min_rect):\n\n        x,y,w,h = cv2.boundingRect(cnt)\n        plate_img = img[y:y+h,x:x+w]\n        #cv2.imshow(\"num plate image\",plate_img)\n        #############################################\n        plt.subplot(3, 3, 6)\n        plt.imshow(plate_img,cmap = plt.get_cmap('gray'))\n\n        if(isMaxWhite(plate_img)):\n            clean_plate, rect = clean2_plate(plate_img)\n            if rect:\n                fg=0\n                x1,y1,w1,h1 = rect\n                x,y,w,h = x+x1,y+y1,w1,h1\n                ##########################################\n                plt.subplot(3, 3, 7)\n                plt.imshow(clean_plate,cmap=plt.get_cmap('gray'))\n                plate_im = Image.fromarray(clean_plate)\n                text = tess.image_to_string(plate_im, lang='eng')\n                print(\"Number  Detected Plate Text : \",text)","8931fdc8":"**Simplifying and Cleaning the image before passing it to pytesseract.**\n1. we convert the image to grayscale.\n2. we apply a treshold to the grayscale image so that every pixel value smaller than 110 is set to 0 otherwise is set to 255 (third arg)\n3. using the binary image we got after applying the treshold we look for the boundary points of the plate(cordinates in list num_contours)\n4. we get the area and the region of interest(boundingRect to get the rectangle coordinates that contain the region of interest)\n5. after passing the ratiocheck we return the region of interest","390373d8":"the objective of this projet is to extract number plate from a car image for traffic monitoring","97684e70":"we take an image input.\n1. we first apply a gaussianBlurr(low pass filter) to get ride of low light noise and  to soften the image so the text stands out\n2. Sobel filter(high pass filter) to detect contours (vertical)\n3. we transform our graysclae image to a binary one using otsu treshold(it auto calculate the treshold)\n4. we create a kernel(element a all one matrix (17,3))\n5. we apply a closing (Dilation followed by Erosion) to close small holes inside the foreground\n6. we get the contour and draw it\n7. we get bounding rectangle with minimum area and if it pass ratio_and rotaion and the maxwhite tests we get the rectangle cordinates and pass it to clean function\n8. we pass the final image to pytessrect to extract the text"}}