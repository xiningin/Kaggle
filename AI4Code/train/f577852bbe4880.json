{"cell_type":{"a4a7644b":"code","dcd5ece1":"code","e124b308":"code","522d805b":"code","e045a653":"code","fdd380c7":"code","f388e1f1":"code","978ddd0d":"code","930ada11":"code","4b39640a":"code","45b6b85a":"code","78f9f294":"code","5d7fa619":"code","1b985ba2":"code","7d89cf5e":"markdown","4a9cb042":"markdown","330a13bf":"markdown","aacfb35a":"markdown","85390053":"markdown","f8816227":"markdown","0ea9556e":"markdown","6eaef49d":"markdown","a608bb17":"markdown","6c0cd32e":"markdown","908838c3":"markdown","0e872414":"markdown","0fe38741":"markdown","23e90206":"markdown","00775b9c":"markdown","c47575d2":"markdown","798eb5ac":"markdown","6db33163":"markdown"},"source":{"a4a7644b":"import numpy as np\n# Provide Beautiful plots of numerous type that are either static, animated and\/or interactiv\nimport matplotlib.pylab as plt\nfrom numpy import random\n\n# A python List\nlist_1 = [1, 2, 3, 4, 5]\n\n# Create NumPy 1 dimensional (a axis) array list object of type byte (-128 to 127)\n# A N-dimensional array is a usually fixed size multi dimensional\n# array that contains items of the same type.\nnp_arr_1 = np.array(list_1, dtype = np.int8)\nnp_arr_1\n# Create multidimensional list\nm_list_1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n# Create NumPy multidimensional (2 axis) array without defining type\nnp_m_arr_1 = np.array(m_list_1)\n\n# you can also create arrays by defining the start value,\n# stop value (upto but not include stop) and step amount\nnp.arange(1, 10)\n\n# With floats define start, end and number of values\nnp.linspace(0, 5, 4)\n\n# You can Create a 3 item arrays of Zeros\nnp.zeros(3)\n\n# you can create multidimensional arrays of zeros by passing\n# a tuple with th 1st value being rows and the 2nd columns\nnp.zeros((2, 3))\n\n# Create array of 1s\nnp.ones((2, 3))\n\n# Create array with defined values\nnp_arr_2 = np.array([1, 2, 3, 4, 5, 6])\n\n# Get type for array\nnp_arr_2.dtype\n\n# Data Types\n# Boolean : np.bool_\n# Char : np.byte\n# Short : np.short\n# Integer : np.short_\n# Long : np.int_\n# Float : np.single & np.float32\n# Doulbe : np.double & np.float64\n# np.int8 : -128 to 127\n# np.int16 : -32768 to 32767\n# np.int32 : -2147483648 to 2147483647\n# np.int64 : -9223372036854775808 to 9223372036854775807\n\n# Create random 5 value 1D array from 10 to 50\nnp.random.randint(10, 50, 5)\n# create random matrix 2x3 with values between 10 and 50\nnp.random.randint(10, 50, size=(2,3))\n\n# Get help with a function\nnp.random.randint?","dcd5ece1":"# Change value at index\n# np_m_arr_1[0, 0] = 2\n# np_m_arr_1.itemset((0,1),1)\nnp_m_arr_1\n# Get size and shape of array\nnp_m_arr_1.shape\nnp_m_arr_1.size\n# Get value by index\nnp_m_arr_1[0,1]\nnp_m_arr_1.item(0,1)\n\n# Get specific indices\nnp.take(np_m_arr_1, [0, 3, 6])\n# Replace provided index values with new values\nnp.put(np_m_arr_1, [0, 3, 6], [10, 10, 10])\nprint(np_m_arr_1)\n\n# Start at 1st through 5th with 2 step\nnp_arr_1[:5:2]\n# Get 2nd value from each row\nnp_m_arr_1[:,1]\n# Flip array\nnp_arr_1[::-1]\n\n# Get evens\nevens = np_m_arr_1[np_m_arr_1%2==0]\nevens\n\n# Get values > 5\nnp_m_arr_1[np_m_arr_1 > 5]\n# 5 < values < 9\nnp_m_arr_1[(np_m_arr_1 > 5) & (np_m_arr_1 < 9)]\n# 5 < values or values = 10\nnp_m_arr_1[(np_m_arr_1 > 5) | (np_m_arr_1 == 10)]\n\n# Find Uniques\nnp.unique(np_m_arr_1)","e124b308":"# Reshape array to 1 by 9\n#np_m_arr_1.reshape((1, 9))\nnp_m_arr_1\n# Reshape array to 2 by 5 (Items are either lost or 0 is added)\nnp_m_arr_1.resize((2,5))\nnp_m_arr_1\n# Transpose axes\nnp_m_arr_1.transpose()\n# Swap axes\nnp_m_arr_1.swapaxes(0, 1)\n# Flatten in order\nnp_m_arr_1.flatten()\n# Flatten in column order\nnp_m_arr_1.flatten('F')\n# Sort rows\nnp_m_arr_1.sort(axis=1)\nprint(np_m_arr_1)\n# Sort columns\nnp_m_arr_1.sort(axis=0)\nnp_m_arr_1","522d805b":"# Generate random arrays\nss_arr_1 = np.random.randint(10, size=(2, 2))\nprint(f\"ss_arr_1\\n{ss_arr_1}\")\nss_arr_2 = np.random.randint(10, size=(2, 2))\nprint(f\"ss_arr_2\\n{ss_arr_2}\")\n\n# Stack arr_2 under arr_1\nnp.vstack((ss_arr_1, ss_arr_2))\n# Stack horizontally\nnp.hstack((ss_arr_1, ss_arr_2))\n\n# Delete 2nd row on each array\nss_arr_3 = np.delete(ss_arr_1, 1, 0)\nss_arr_4 = np.delete(ss_arr_2, 1, 0)\nprint(f\"ss_arr_3\\n{ss_arr_3}\")\nprint(f\"ss_arr_4\\n{ss_arr_4}\")\n\n# Combine arrays\nnp.column_stack((ss_arr_3, ss_arr_4))\n# Stack in a 2D array\nnp.row_stack((ss_arr_3, ss_arr_4))\n\n# Generate 2x10 array\nss_arr_5 = np.random.randint(10, size=(2, 10))\nprint(f\"ss_arr_5\\n{ss_arr_5}\")\n# Split into 5 arrays taking from both arrays in multidimensional array\nnp.hsplit(ss_arr_5, 5)\n# Split after 2nd & 4th column\nnp.hsplit(ss_arr_5, (2, 4))","e045a653":"cp_arr_1 = np.random.randint(10, size=(2, 2))\n# Both variables point at the same array\ncp_arr_2 = cp_arr_1\n# Change value\ncp_arr_1[0,0] = 2\nprint(f\"cp_arr_1\\n{cp_arr_1}\")\nprint(f\"cp_arr_2\\n{cp_arr_2}\")\n","fdd380c7":"arr_3 = np.array([1, 2, 3, 4])\narr_4 = np.array([2, 4, 6, 8])\n# Add Values\narr_3 + arr_4\n# Subtract\narr_3 - arr_4\n# Multiply\narr_3 * arr_4\n# Divide\narr_3 \/ arr_4\n# Random 4 digit 1D array between 0 to 100\narr_5 = random.randint(100, size=(4))\narr_5\n# Random 2 by 3 digit 2D array between 0 to 100\narr_6 = random.randint(100, size=(2, 3))\narr_6\n# 4 random floats\nrandom.rand(4)\n# Get random value from an array\nrandom.choice(arr_3)\n\n# Sum of values in array\narr_3.sum()\n# Sum columns\nprint(arr_6)\narr_6.sum(axis=0)\n# Cumulative sum of rows\narr_6.cumsum(axis=1)\n\n# Minimum of each row\narr_6.min(axis=1)\n# Maximumof each column\narr_6.max(axis=0)\n\nprint(f\"arr_3 {arr_3}\")\nprint(f\"arr_4 {arr_4}\")\n# Adding individual numbers to array\nnp.add(arr_3, 5)\n# Add arrays\nnp.add(arr_3, arr_4)\n# Subtract\nnp.subtract(arr_3, arr_4)\n# Multiply\nnp.multiply(arr_3, arr_4)\n# Divide\nnp.divide(arr_3, arr_4)\n\narr_5 = np.array([[1, 2], [3, 4]])\narr_6 = np.array([[2, 4], [6, 9]])\nprint(f\"arr_5\\n{arr_5}\")\nprint(f\"arr_6\\n{arr_6}\")\n# Divides elments in 1st array by 2nd array and returns remainder\nnp.remainder(arr_6, arr_5)\n\n# Return values in 1st array to powers defined in 2nd array\nnp.power(arr_6, arr_5)\n# Square root\nnp.sqrt(arr_3)\n# Cube root\nnp.cbrt(arr_3)\n# Absolute value of every element\nnp.absolute([-1, -2])\n# Exponential of all element in array\nnp.exp(arr_3)\n# Log functions\nnp.log(arr_3)\nnp.log2(arr_3)\nnp.log10(arr_3)\n# Greatest common divisor\nnp.gcd.reduce([9, 12, 15])\n# Lowest common multiple\nnp.lcm.reduce([9, 12, 15])\n\n# Round down\nnp.floor([1.2, 2.5])\n# Round up\nnp.ceil([1.2, 2.5])\n\n# can receive 6 values and square them\nsq_arr = np.arange(6)**2\nsq_arr[arr_3]\n\narr_7 = random.randint(100, size=(5, 3))\nprint(f\"arr_7\\n{arr_7}\")\n# Get index for max value per column\nmc_index = arr_7.argmax(axis=0)\nmc_index\n# Get numbers corresponding to indexes\nmax_nums = arr_7[mc_index]\nmax_nums\narr_7[mc_index, range(arr_7.shape[1])]","f388e1f1":"# Pandas is use to manipulate tabular data and more\nimport pandas as pd\n# Import using Numpy\nfrom numpy import genfromtxt\n\n# Read table of data from CSV file and convert to Numpy array\nic_sales = pd.read_csv('..\/input\/icecreamsales\/icecreamsales.csv').to_numpy()\nic_sales\n\n# Read data using NumPy\nic_sales_2 = genfromtxt('..\/input\/icecreamsales\/icecreamsales.csv', delimiter=',')\n# Remove NaNs\nic_sales_2 = [row[~np.isnan(row)] for row in ic_sales_2]\nic_sales_2","978ddd0d":"# Array 1 - 5\nsarr_1 = np.arange(1, 6)\nnp.mean(sarr_1)\nnp.median(sarr_1)\nnp.average(sarr_1)\nnp.std([4, 6, 3, 5, 2]) # Standard Deviation\nnp.var([4, 6, 3, 5, 2]) # Variance\n# Also nanmedian, nanmean, nanstd, nanvar\n\nprint(\"ic_sales\\n\", ic_sales)\n# Get the 50th percentile of the data\nnp.percentile(ic_sales, 50, axis=0)\n# Get 1st column\nic_sales[:,0]\n\n# Correlation coefficient : Measure of correlation between data\n# Closer to 1 the more the data is correlated\nnp.corrcoef(ic_sales[:,0], ic_sales[:,1])\n\n# Calculating Regression line\n# \u03a3(x-x\u0305)*(y-\u0233) \/ \u03a3(x-x\u0305)2\ntemp_mean = np.mean(ic_sales[:,0])\nsales_mean = np.mean(ic_sales[:,1])\nnumerator = np.sum(((ic_sales[:,0] - temp_mean)*(ic_sales[:,1] - sales_mean)))\ndenominator = np.sum(np.square(ic_sales[:,0] - temp_mean))\nslope = numerator\/denominator\n# Calculate y intercept\ny_i = sales_mean - slope * temp_mean\ny_i\nreg_arr = ic_sales[:,0] * slope + y_i\nreg_arr","930ada11":"# Generate array of 200 values between -pi & pi\nt_arr = np.linspace(-np.pi, np.pi, 200)\n\n# Plot with x axis & y axis data \n# plt.plot(t_arr, np.sin(t_arr)) # SIN\n# plt.plot(t_arr, np.cos(t_arr)) # COS\n# plt.plot(t_arr, np.tan(t_arr)) # TAN\n# Display plot\n# plt.show()\n\n# Provides inverse of If y = cos(x), x = arccos(y)\nnp.arcsin(1)\nnp.arccos(1)\nnp.arctan(0)\n\n# Also arctan2, sinh, cosh, tanh, arcsinh, arccosh, arctanh\n\n# Radians to degrees\nnp.rad2deg(np.pi)\n# Degrees to radians\nnp.deg2rad(180)\n\n# Hypotenuse c = \u221aw\u00b2 + h\u00b2\nnp.hypot(10,10)","4b39640a":"from numpy import linalg as LA\n\nprint(\"arr_5\\n\", arr_5)\nprint(\"arr_6\\n\", arr_6)\narr_8 = np.array([[5, 6], [7, 8]])\n\n# Matrix multiplication with Dot Product\n# (1 * 2) + (2 * 6) = 14 [0,0]\n# (1 * 4) + (2 * 9) = 22 [0,1]\n# (3 * 2) + (4 * 6) = 30 [1,0]\n# (3 * 4) + (4 * 9) = 12 + 36 = 48 [1,1]\nnp.dot(arr_5, arr_6)\n# Compute dot product of 2 or more arrays\nLA.multi_dot([arr_5, arr_6, arr_8])\n\n# Inner product \n# (1 * 2) + (2 * 4) = 10 [0,0]\n# (1 * 6) + (2 * 9) = 24 [0,1]\n# (3 * 2) + (4 * 4) = 22 [1,0]\n# (3 * 6) + (4 * 9) = 54 [1,1]\nnp.inner(arr_5, arr_6)\nnp.dot(arr_5, arr_6)\n\n# Tensor Dot Product\n# (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) = 30\n# (5 * 1) + (6 * 2) + (7 * 3) + (8 * 4) = \narr_9 = np.array([[[1, 2],\n        [3, 4]],\n       [[5, 6],\n        [7, 8]]])\narr_10 = np.array([[1, 2],\n       [3, 4]], dtype=object)\nnp.tensordot(arr_9, arr_10)\n\n# Einstein Summation : Provides many ways to perform\n# operations on multiple arrays\narr_11 = np.array([0, 1])\narr_12 = np.array([[0, 1, 2, 3], [4, 5, 6, 7]])\n# Left Side of -> : 1 axis for arr_11 and 2 axis for arr_12\n# Right of -> : Array we want (1D Array)\n# ij : Means multiply arr_11 single item by each column of arr_12 and sum\n# [0, 4 + 5 + 6 + 7]\nnp.einsum('i,ij->i', arr_11, arr_12)\n# Sum values in arr_11\nnp.einsum('i->', arr_11)\n# Dot Product\nprint(\"arr_3\\n\", arr_3)\nprint(\"arr_4\\n\", arr_4)\nnp.einsum('i,i->', arr_3, arr_4)\n# Matrix multiplication\nnp.einsum('ij,jk', arr_5, arr_6)\n# Get diagonal\nnp.einsum('ii', arr_5)\n# Transpose\nnp.einsum('ji', arr_5)\n\n# Raise matrix to the power of n\n# Given [[a, b], [c, d]]\n# [[a\u00b2 + bc, ab +db], [ac + dc, d\u00b2 + bc]\nLA.matrix_power(arr_5, 2)\n\n# Kronecker product of 2 arrays\n# Given [[a, b], [c, d]], [[e, f], [g, h]]\n# [[a*e, a*f, b*e, b*f], [a*g, a*h, b*g, b*h], ...]\nnp.kron(arr_5, arr_6)\n\n# Compute eigenvalues\nLA.eig(arr_5) # Returns eigenvectors\nLA.eigvals(arr_5)\n\n# Get Vector Norm sqrt(sum(x**2))\nLA.norm(arr_5)\n\n# Get Multiplicative Inverse of a matrix\nLA.inv(arr_5)\n\n# Get Condition number of matrix\nLA.cond(arr_5)\n\n# Determinates are used to compute volume, area, to solve systems\n# of equations and more. It is a way you can multiply values in a\n# matrix to get 1 number.\n# For a matrix to have an inverse its determinate must not equal 0\n# det([[a, b], [c, d]]) = a*d - b*c\narr_12 = np.array([[1, 2], [3, 4]])\n# 1*4 - 2*3 = -2\nLA.det(arr_12)\n\n# Determinate of 3x3 Matrix\n# det([[a, b, c], [d, e, f], [g, h, i]]) = a*e*i - b*d*i + c*d*h\n# - a*f*h + b*f*g - c*e*g\n\n# When we multiply a matrix times its inverse we get the identity\n# matrix [[1,0],[0,1]] for a 2x2 matrix\n# Calculate the inverse 1\/(a*d - b*c) * [[d, -b], [-c, a]]\n# 1\/(4 - 6) = -.5 -> [[-.5*4, -.5*-2], [-.5*-3, -.5*a]]\narr_12_i = LA.inv(arr_12)\narr_12_i\n\nnp.dot(arr_12, arr_12_i)\n\n# Solving Systems of Linear Equations\n# If you have 3x + 5 = 9x -> 5 = 6x -> x = 5\/6\n# If you have x + 4y = 10 & 6x + 18y = 42\n# Isolate x -> x = 10 - 4y\n# 6(10 - 4y) + 18y = 42 -> 60 - 24y + 18y = 42 - > -6y = -18 -> y = 3\n# x + 4*3 = 10 -> x = -2\narr_13 = np.array([[1, 4], [6, 18]])\narr_14 = np.array([10, 42])\n# Solve will solve this for you as well\nLA.solve(arr_13, arr_14)\n\n# Return a identity matrix with defined number of rows and columns\nnp.eye(2, 2, dtype=int)","45b6b85a":"arr_15 = np.array([[1, 2], [3, 4]])\n# Save as randarray.npy\nnp.save('randarray', arr_15)\n# Load saved array \narr_16 = np.load('randarray.npy')\narr_16\n\n# Save as a CSV \nnp.savetxt('randcsv.csv', arr_15)\n# Load CSV\narr_17 = np.loadtxt('randcsv.csv')\narr_17","78f9f294":"pip install numpy-financial","5d7fa619":"# pip install numpy-financial\nimport numpy_financial as npf\n\n# Compute future value of $400 investment every month\n# with an annual rate of 8% after 10 years\nnpf.fv(.08\/12, 10*12, -400, -400)\n\n# Calculate interest portion of payment on a loan of $3,000\n# at 9.25% per year compounded monthly\n# Period of loan (year)\nperiod = np.arange(1*12) + 1\nprinciple = 3000.00\n# Interest Payment\nipmt = npf.ipmt(0.0925\/12, period, 1*12, principle)\n# Principle Payment\nppmt = npf.ppmt(0.0925\/12, period, 1*12, principle)\nfor payment in period:\n    index = payment - 1\n    principle = principle + ppmt[index]\n    print(f\"{payment}   {np.round(ppmt[index], 2)}    {np.round(ipmt[index],2)}    {np.round(principle, 2)}\")\n\n# Compute number of payments to pay off $3,000 if you paid\n# $150 per month with an interest rate of 9.25%\nnp.round(npf.nper(0.0925\/12, -150, 3000.00), 2)\n\n# Calculate net present value of cash flows of $4,000, $5,000\n# $6,000, $7,000 after $15,000 investment with .08 rate per period\nnpf.npv(0.08, [-15000, 4000, 5000, 6000, 7000]).round(2)","1b985ba2":"carr_1 = np.array([2, 3])\ncarr_2 = np.array([3, 2])\n# Returns boolean based on whether arr_1 value Comparison arr_2 value\nnp.greater(carr_1, carr_2)\nnp.greater_equal(carr_1, carr_2)\nnp.less(carr_1, carr_2)\nnp.less_equal(carr_1, carr_2)\nnp.not_equal(carr_1, carr_2)\nnp.equal(carr_1, carr_2)","7d89cf5e":"# <a id='BM'>Basic Math<\/a>\n[Go back to the main page](#main)","4a9cb042":"### In this notebook we are going to discuss a vast majority of the NumPy Library using numerous Examples","330a13bf":"# <a id='NA'>NumPy Arrays : Creating Arrays<\/a>\n[Go back to the main page](#main)","aacfb35a":"# <a id='CF'>Comparison Functions<\/a>\n[Go back to the main page](#main)","85390053":"# <a id='RA'>Reshaping Arrays<\/a>\n[Go back to the main page](#main)","f8816227":"## Why is Numpy Fast?\nVectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just \u201cbehind the scenes\u201d in optimized, pre-compiled C code. Vectorized code has many advantages, among which are:\n\n* vectorized code is more concise and easier to read\n* fewer lines of code generally means fewer bugs\n* the code more closely resembles standard mathematical notation (making it easier, typically, to correctly code mathematical constructs)\n* vectorization results in more \u201cPythonic\u201d code. Without vectorization, our code would be littered with inefficient and difficult to read for loops.\n\nBroadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, a and b could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is \u201cexpandable\u201d to the shape of the larger in such a way that the resulting broadcast is unambiguous.","0ea9556e":"# <a id='S&I'>Slicing & Indexes<\/a>\n[Go back to the main page](#main)","6eaef49d":"# <a id='FF'>Financial Functions<\/a>\n[Go back to the main page](#main)","a608bb17":"<div>\n<img src=\"https:\/\/numpy.org\/images\/logos\/numpy.svg\" width=\"250\"\/>\n<\/div>","6c0cd32e":"# <a id='SF'>Statistics Functions<\/a>\n[Go back to the main page](#main)","908838c3":"# <a id='TF'>Trigonometric Functions<\/a>\n[Go back to the main page](#main)","0e872414":"# <a id='C'>Copying<\/a>\n[Go back to the main page](#main)","0fe38741":"# <a id='main'>Table of Contents<\/a>\n- [NumPy Arrays : Creating Arrays](#NA)\n- [Slicing and Indexes](#S&I)\n- [Reshaping Arrays](#RA)\n- [Stacking & Splitting](#S&S)\n- [Copying](#C)\n- [Basic Math](#BM)\n- [Reading from Files](#RFF)\n- [Statistics Functions](#SF)\n- [Trigonometric Functions](#TF)\n- [Matrix Functions](#MF)\n- [Saving & Loading NumPy Objects](#S&LNO)\n- [Financial Functions](#FF)\n- [Comparison Functions](#CF)","23e90206":"# <a id='RFF'>Reading from Files<\/a>\n[Go back to the main page](#main)","00775b9c":"# What is NumPy?\nNumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I\/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.\n\nAt the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:\n\n* NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an ndarray will create a new array and delete the original.\n\n* The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.\n\n* NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python\u2019s built-in sequences.\n\n* A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays. In other words, in order to efficiently use much (perhaps even most) of today\u2019s scientific\/mathematical Python-based software, just knowing how to use Python\u2019s built-in sequence types is insufficient - one also needs to know how to use NumPy arrays.\n","c47575d2":"# <a id='S&S'>Stacking & Splitting<\/a>\n[Go back to the main page](#main)","798eb5ac":"# <a id='S&LNO'>Saving & Loading NumPy Objects<\/a>\n[Go back to the main page](#main)","6db33163":"# <a id='MF'>Matrix Functions<\/a>\n[Go back to the main page](#main)"}}