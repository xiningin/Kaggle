{"cell_type":{"c3dd9266":"code","6d8dad49":"code","07125058":"code","d9b0a594":"code","3d082d73":"code","84b1f13e":"code","77da792e":"code","b3201679":"code","6e51683b":"code","83ebc21b":"code","912c9abe":"code","fc986e4e":"code","7973b0c6":"code","6182e909":"code","d29e229f":"code","07f7d869":"code","5ccfa5e7":"code","a3fd98b0":"code","4583f560":"code","68c579e8":"code","1cc7d050":"code","89fd3aae":"code","4a2b8459":"code","c6a7b11c":"code","36ed2182":"code","d063dd7c":"code","2fb44c97":"code","26ec18fc":"code","f06b4d0f":"code","842f2bb2":"code","57d10adf":"code","66a67333":"code","157ec26c":"code","7beedab8":"code","e5027ab0":"code","81c9fff7":"code","8c71bd12":"code","bd6fe4be":"code","b52ebf3e":"code","640dcf9b":"code","f07a13cd":"code","7aa4eff9":"code","43228264":"code","fe1d37a8":"code","ee57e8b3":"code","1dda53c1":"code","a3bb3266":"code","17987478":"code","b17ef3af":"code","ee37641c":"code","fb7e07b9":"code","6d7315f0":"code","0288e76e":"code","8da69f9d":"code","2fd98fc3":"code","fd3e995c":"code","7efcf2e6":"code","263ae5c2":"code","b2de24b2":"code","3ea76e5d":"code","7fe6b3bd":"code","7b50107b":"markdown","ab03d146":"markdown","4ef0e9fa":"markdown","4cdb8e98":"markdown","503bfdb0":"markdown","170c789f":"markdown","611b10ac":"markdown","68aa985c":"markdown","fa7dacc1":"markdown","3448f08b":"markdown","c86684a1":"markdown","4638121e":"markdown","0518b8ed":"markdown","0998e29e":"markdown","0de8fee3":"markdown","2668a610":"markdown","ccf528a0":"markdown","22efe2f4":"markdown","7edb6b38":"markdown","ed30a5f1":"markdown","fe318a90":"markdown","4ec96e81":"markdown","ac7b9ed7":"markdown","30b5d97d":"markdown","8a9beea4":"markdown","4a7a9d38":"markdown","a36a12be":"markdown","4ababdf4":"markdown","44747b64":"markdown","9f535c89":"markdown","43310116":"markdown","f97dee3f":"markdown","02c364ce":"markdown","933b2541":"markdown","2401d454":"markdown","cca096f0":"markdown","a06e92dc":"markdown","4c4e632c":"markdown","53dd8681":"markdown","c47c6b83":"markdown","dafc6d90":"markdown","3592978b":"markdown","4f769670":"markdown","5d1fc9c2":"markdown","ff0c4a12":"markdown","ee621de7":"markdown","fe7ea5ce":"markdown","c6489ac2":"markdown","bfa68109":"markdown","becac458":"markdown","47cb5fcf":"markdown","0237322a":"markdown","aea9a24b":"markdown","73f7bf87":"markdown","3988c9c7":"markdown","02e931bd":"markdown","679908cf":"markdown","902c8023":"markdown","d3623857":"markdown","a5e93939":"markdown","b55f952c":"markdown","46a9f1c0":"markdown","663484de":"markdown","bbc40c91":"markdown","29e3b07c":"markdown"},"source":{"c3dd9266":"# data structures\nimport numpy as np\nimport pandas as pd\n\n# visualization\nimport plotly\nimport plotly.graph_objs as go\nimport plotly.express as px\nplotly.offline.init_notebook_mode(connected=True)\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nfrom sklearn import linear_model\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.decomposition import PCA\nimport scipy.cluster.hierarchy as sch\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint('Data files:', os.listdir(\"..\/input\/ufcdataset\"))\n\n# Any results you write to the current directory are saved as output.","6d8dad49":"# read the dataset to a Pandas DataFrame\ndf = pd.read_csv('..\/input\/ufcdataset\/data.csv')","07125058":"# \"meta\" stats\n[ col for col in df.columns.values if 'Round' not in col ]","d9b0a594":"# round stats\n[ col for col in df.columns.values if 'Round1' in col ]","3d082d73":"df.describe()","84b1f13e":"df.head()","77da792e":"df[['B_Name', 'R_Name', 'Last_round']][df['Max_round'] == 4]","b3201679":"# replacing Max_round of 4 to 3 instead\ndf.loc[df['Max_round'] == 4, 'Max_round'] = 3\n\n# print to double check\nprint('There are', df['Max_round'][df['Max_round'] == 3].size, 'fights with max 3 rounds')\nprint('There are', df['Max_round'][df['Max_round'] == 4].size, 'fights with max 4 rounds')\nprint('There are', df['Max_round'][df['Max_round'] == 5].size, 'fights with max 5 rounds')","6e51683b":"df[['R_Name', 'R_Age', 'Date']][df['R_Name'] == 'Jose Aldo']","83ebc21b":"# find the date of the last fight\ndf['Date'].max()","912c9abe":"# outliers should bubble to the top or bottom\ndf.sort_values('Date')['Date']","fc986e4e":"# setting outliers to standard slash format\ndf.at[12, 'Date'] = '02\/16\/2014'\ndf.at[197, 'Date'] = '06\/08\/2014'\ndf.at[78, 'Date'] = '06\/29\/2014'\ndf.at[384, 'Date'] = '10\/04\/2014'\ndf.at[449, 'Date'] = '11\/17\/2014'\ndf.at[334, 'Date'] = '12\/20\/2014'\ndf.at[686, 'Date'] = '05\/23\/2015'\n\n# indicate added column with \"_\" prefix\ndf['_Date_year'] = df['Date'].transform(lambda date: int(date[-4:]))","7973b0c6":"# recalculate age\n# formula: Age - (last_year - fight_year)\ndf['R_Age'] = df['R_Age'] - (df['_Date_year'].max() - df['_Date_year'])\ndf['B_Age'] = df['B_Age'] - (df['_Date_year'].max() - df['_Date_year'])","6182e909":"# checking our work\ndf[['R_Name', 'R_Age', 'Date']][df['R_Name'] == 'Jose Aldo']","d29e229f":"# get names of fighters will missing weights\nmissing_weight_names = pd.concat([df['B_Name'][df['B_Weight'].isnull()], df['R_Name'][df['R_Weight'].isnull()]]).unique()\nprint(missing_weight_names)","07f7d869":"# fill in with Googled values\nweights = {\n    'Lipeng Zhang': 70,\n    'Antonio Carlos Junior': 84,\n    'Aleksei Oleinik': 65,\n    'Cat Zingano': 65,\n    'Yao Zhikui': 56,\n    'Jack Marshman': 84,\n    'Allan Zuniga': 70 \n}\nfor name in missing_weight_names:\n    df['B_Weight'][df['B_Name'] == name] = weights[name]\n    df['R_Weight'][df['R_Name'] == name] = weights[name]\n","5ccfa5e7":"sorted([ weight for weight in pd.concat([df['B_Weight'], df['R_Weight']]).unique() if weight <= 93 ])","a3fd98b0":"df['B_Weight'][df['B_Weight'] == 76] = 77\ndf['R_Weight'][df['R_Weight'] == 76] = 77","4583f560":"df[['R_Name', 'R_Weight', 'Date']][df['R_Name'] == 'Diego Sanchez']","68c579e8":"no_winby = df[df['winby'].isnull()]\nprint(len(no_winby), \"rows where 'winby' is not set.\")","1cc7d050":"print(df['winner'][df['winner'] == 'no contest'].size, 'no contests')\nprint(df['winner'][df['winner'] == 'draw'].size, 'draws')","89fd3aae":"print(no_winby['winner'][no_winby['winner'] == 'draw'].size, 'draws with an empty \\'winby\\' value')\nprint(no_winby['winner'][no_winby['winner'] == 'no contest'].size, 'no contest with an empty \\'winby\\' value')","4a2b8459":"# set on the original dataset, and recompute `no_winby`\ndf.loc[df['winner'] == 'draw', 'winby'] = 'DRAW'\nno_winby = df[df['winby'].isnull()]","c6a7b11c":"df[['B_Name', 'R_Name', 'Date', 'Last_round', 'winner', 'winby']][(df['winner'] == 'no contest') & (df['winby'].notnull())] # exclude the no-contests with no 'winby'","36ed2182":"b = 'blue'\nr = 'red'\n\ndf.at[40, 'winner'] = b\ndf.at[70, 'winner'] = r\ndf.at[234, 'winner'] = r\ndf.at[255, 'winner'] = r\ndf.at[301, 'winner'] = b\ndf.at[403, 'winner'] = r\ndf.at[428, 'winner'] = r\ndf.at[513, 'winner'] = r\ndf.at[628, 'winner'] = r\ndf.at[734, 'winner'] = r\ndf.at[894, 'winby'] = np.NaN\ndf.at[1179, 'winner'] = r\ndf.at[1389, 'winner'] = b\ndf.at[1473, 'winner'] = b\ndf.at[1475, 'winner'] = b\ndf.at[1522, 'winner'] = b\ndf.at[1664, 'winner'] = b\ndf.at[1764, 'winner'] = b\n\n# recompute no_winby\nno_winby = df[df['winby'].isnull()]","d063dd7c":"# extract any column that would help with Googling the match\nno_winby[['B_Name', 'R_Name', 'Date', 'Last_round', 'winner']]","2fb44c97":"s = 'SUB'\nd = 'DEC'\nnc = 'NC'\nk = 'KO\/TKO'\ndq = 'DQ'\n\ndf.at[36, 'winby'] = s # Omari Akhmedov\tGunnar Nelson: SUB\ndf.at[170, 'winby'] = s # Johnny Bedford\tRani Yahya: head bump NC\ndf.at[177, 'winby'] = d # Rashid Magomedov vs Rodrigo Damm: DEC\ndf.at[364, 'winby'] = d # Efrain Escudero\tLeonardo Santos: DEC\ndf.at[493, 'winby'] = nc # Daron Cruickshank\tKJ Noons: eye poke NC\ndf.at[622, 'winby'] = nc # Norifumi Yamamoto\tRoman Salazar: eye poke NC\ndf.at[894, 'winby'] = nc # Jim Alers\tCole Miller: eye poke NC\ndf.at[973, 'winby'] = nc # Kevin Casey\tAntonio Carlos Junior: eye poke NC\ndf.at[1450, 'winby'] = nc # Tim Means\tAlex Oliveira: knees on downed opponent, NC\ndf.at[1576, 'winby'] = nc # Dustin Poirier\tEddie Alvarez: illegal knees, NC\ndf.at[1803, 'winby'] = k # Gilbert Burns\tJason Saggo: KO\/TKO\ndf.at[1875, 'winby'] = dq # Mark Godbeer\tWalt Harris: DQ (After a knee landed on Godbeer\u2019s groin, the referee verbally signaled and seemingly touched Harris\u2019 leg to call a time out. Just as he did that, though, Harris threw a head kick that also landed.)\ndf.at[2008, 'winby'] = dq # Hector Lombard\tCB Dollaway: DQ (post-bell punches)\ndf.at[2234, 'winby'] = d # Liu Pingyuan\tDamian Stasiak: DEC\n\n# fights in \"DW's Contender Series 2018: Week 4\"\ndf.at[2286, 'winby'] = d # Joey Gomez\tKevin Aguilar: DEC\ndf.at[2287, 'winby'] = k # Alton Cunningham\tBevon Lewis: KO\/TKO\ndf.at[2288, 'winby'] = d # Ricky Palacios\tToby Misech: DEC\ndf.at[2289, 'winby'] = k # Rilley Dutro\tJordan Espinosa: KO\/TKO\ndf.at[2290, 'winby'] = k # Jamie Colleen\tMaycee Barber: KO\/TKO\ndf.at[2291, 'winby'] = s # Dom Pilarte\tVincent Morales: SUB\ndf.at[2292, 'winby'] = k # Josh Appelt\tJeff Hughes: KO\/TKO\n\nno_winby[['B_Name', 'R_Name', 'Date', 'Last_round', 'winner', 'winby']]","26ec18fc":"# fight in question\ndf[(df['Max_round'] == 3) & (df['winby'] == 'DEC') & (df['Last_round'] < 3 )]","f06b4d0f":"# correct it to 3 (verified using Google)\ndf['Last_round'].iloc[334] = 3\nprint('\"Last_round\" set to', df['Last_round'].iloc[334], 'for the fight:', df['B_Name'].iloc[334], 'vs', df['R_Name'].iloc[334])","842f2bb2":"df.to_csv('cleaned_data.csv', index = False)","57d10adf":"# store fight outcomes for reuse and to standardize ordering\nfight_outcomes = df['winby'].unique().tolist()\nprint('Possible fight outcomes:', fight_outcomes)","66a67333":"# average number of rounds in max-3-round fight\nprint('Distribution of the # of rounds in a max-3-round fight')\nprint(df['Last_round'][df['Max_round'] == 3].describe(), '\\n\\n')\n\n# average number of rounds in max-5-round fight\nprint('Distribution of the # of rounds in a max-5-round fight')\nprint(df['Last_round'][df['Max_round'] == 5].describe())","157ec26c":"# 3- vs 5-round fights by win type\nfor outcome in ['KO\/TKO', 'SUB']:\n    max_3_round_stats = df['Last_round'][(df['Max_round'] == 3) & (df['winby'] == outcome)].describe().rename('Num Rounds with Max 3')\n    max_5_round_stats = df['Last_round'][(df['Max_round'] == 5) & (df['winby'] == outcome)].describe().rename('Num Rounds with Max 5')\n    print('Win by', outcome, ':', '\\n', pd.concat([max_3_round_stats, max_5_round_stats], axis=1), '\\n')","7beedab8":"# collect data\nall_fights = {3: {}, 5: {}}\n\n# calculate outcomes by # max rounds\nfor num_max_rounds in [3, 5]:\n    for outcome in fight_outcomes:\n        fights_by_round_and_outcome = df['Last_round'][(df['Max_round'] == num_max_rounds) & (df['winby'] == outcome)].size\n        if outcome in all_fights[num_max_rounds]:\n            all_fights[num_max_rounds][outcome] += fights_by_round_and_outcome\n        else:\n            all_fights[num_max_rounds][outcome] = fights_by_round_and_outcome\n        \nall_3round = sum(all_fights[3].values())\nall_5round = sum(all_fights[5].values())\n\nfig = {\n  \"data\": [\n    {\n      \"values\": list(all_fights[3].values()),\n      \"labels\": list(all_fights[3].keys()),\n      \"text\": list(all_fights[3].keys()),\n      \"domain\": {\"column\": 0},\n      \"name\": \"Max 3 rounds \" + str(all_3round),\n      \"hoverinfo\":\"label+percent+value\",\n      \"hole\": .4,\n      \"type\": \"pie\"\n    },\n    {\n      \"values\": list(all_fights[5].values()),\n      \"labels\": list(all_fights[5].keys()),\n      \"text\": list(all_fights[5].keys()),\n      \"textposition\":\"inside\",\n      \"domain\": {\"column\": 1},\n      \"name\": \"Max 5 rounds \" + str(all_5round),\n      \"hoverinfo\":\"label+percent+value\",\n      \"hole\": .4,\n      \"type\": \"pie\"\n    }],\n  \"layout\": {\n        \"title\":\"Fights by Win Type\",\n        \"grid\": {\"rows\": 1, \"columns\": 2},\n        \"annotations\": [\n            {\n                \"font\": {\n                    \"size\": 12\n                },\n                \"showarrow\": False,\n                \"text\": \"Max 3 rounds\",\n                \"x\": 0.16,\n                \"y\": 0.55\n            },\n            {\n                \"font\": {\n                    \"size\": 12\n                },\n                \"showarrow\": False,\n                \"text\": str(all_3round) + \" examples\",\n                \"x\": 0.16,\n                \"y\": 0.45\n            },\n            {\n                \"font\": {\n                    \"size\": 12\n                },\n                \"showarrow\": False,\n                \"text\": \"Max 5 rounds\",\n                \"x\": 0.84,\n                \"y\": 0.55\n            },\n            {\n                \"font\": {\n                    \"size\": 12\n                },\n                \"showarrow\": False,\n                \"text\": str(all_5round) + \" examples\",\n                \"x\": 0.84,\n                \"y\": 0.45\n            },\n        ]\n    }\n}\nplotly.offline.iplot(fig, filename='donut')","e5027ab0":"# correlation won't work on nominal columns - we'll represent the 'winner' column numerically, where 1 is a blue win and 0 is a blue loss (red win)\nbluewinner_df = pd.concat([df, (df['winner'] == 'blue').astype(int)], axis=1)\ncorr = bluewinner_df.corr().fillna(0)\ncorr","81c9fff7":"# sort features by correlation and print\n# usually a correlation plot is helpful, but we have too many features here for it to be legible\ncorr_copy = corr['winner'].copy()\ncorr_copy.sort_values(inplace=True, ascending=False)\nprint(\"Sorted list of features that correlate with 'winner' - strongest correlations at the top and bottom (positive and negative correlation respectively)\\n\")\nprint(corr_copy)","8c71bd12":"# init values to 0\nunique_names = pd.concat([df['B_Name'], df['R_Name']]).unique()\nfighter_records = { name: {'wins': 0, 'losses': 0} for name in unique_names }\n\n# calc wins and losses\nblue_ratio = []\nred_ratio = []\nblue_wins = []\nred_wins = []\nblue_losses = []\nred_losses = []\nfor index, row in df.iterrows():\n    bluename = row['B_Name']\n    redname = row['R_Name']\n    \n    # record stats\n    blue_wins.append(fighter_records[bluename]['wins'])\n    red_wins.append(fighter_records[redname]['wins'])\n    blue_losses.append(fighter_records[bluename]['losses'])\n    red_losses.append(fighter_records[redname]['losses'])\n    \n    # win ratio = wins \/ (wins + losses)\n    blue_ratio.append(float(fighter_records[bluename]['wins']) \/ max(1, fighter_records[bluename]['wins']+fighter_records[bluename]['losses']))\n    red_ratio.append(float(fighter_records[redname]['wins']) \/ max(1, fighter_records[redname]['wins']+fighter_records[redname]['losses']))\n\n    # update stats\n    if row['winby'] in ['KO\/TKO', 'SUB', 'DEC', 'DQ']:\n        winner = bluename if row['winner'] == 'blue' else redname\n        loser = redname if row['winner'] == 'blue' else bluename\n        fighter_records[winner]['wins'] += 1\n        fighter_records[loser]['losses'] += 1\n\n# save after aggregating\ndf['_B_WinRatio'] = pd.Series(blue_ratio)\ndf['_R_WinRatio'] = pd.Series(red_ratio)\ndf['_B_Prev_Wins'] = pd.Series(blue_wins)\ndf['_R_Prev_Wins'] = pd.Series(red_wins)\ndf['_B_Prev_Losses'] = pd.Series(blue_losses)\ndf['_R_Prev_Losses'] = pd.Series(red_losses)\ndf['BPrev'] = df['_B_Prev_Wins'] + df['_B_Prev_Losses']\ndf['RPrev'] = df['_R_Prev_Wins'] + df['_R_Prev_Losses']","bd6fe4be":"# correlation won't work on nominal columns - we'll represent the 'winner' column numerically\nrecord_df = pd.concat([(df['winner'] == 'blue').astype(int), df[['_B_WinRatio', '_R_WinRatio', '_B_Prev_Wins', '_R_Prev_Wins', '_B_Prev_Losses', '_R_Prev_Losses', 'BPrev', 'RPrev', 'winner']]], axis=1)\nrecord_corr = record_df.corr().fillna(0)\nranked_metrics = record_corr['winner'].copy().iloc[1:]\nranked_metrics.sort_values(inplace=True, ascending=False)\nprint('blue winning correlates with:\\n', ranked_metrics)","b52ebf3e":"df['_B_Weight_Class'] = df['B_Weight'].apply(lambda x: int(x) if x <= 93 else 93)\ndf['_R_Weight_Class'] = df['R_Weight'].apply(lambda x: int(x) if x <= 93 else 93)\n\nweight_classes = sorted(pd.concat([df['_B_Weight_Class'], df['_R_Weight_Class']]).unique())\nprint('The weight classes are:', weight_classes)","640dcf9b":"mismatched_fights = df[['_B_Weight_Class', '_R_Weight_Class']][df['_B_Weight_Class'] != df['_R_Weight_Class']]\nprint('There are', len(mismatched_fights), 'fights with mismatched weight classes')","f07a13cd":"df['winby'].unique()","7aa4eff9":"bar_charts = []\nfor winby in ['DEC', 'KO\/TKO', 'SUB', 'DRAW']:\n    fights_by_class = []\n    for cl in weight_classes:\n        recent_df = df[df['_Date_year'] == df['_Date_year'].max()] # use only last year of data for reliable weight classes\n        fights_for_class = len(recent_df[recent_df['winby'] == winby][(recent_df['B_Weight'] == cl) | (recent_df['R_Weight'] == cl)])\n        fights_by_class.append(fights_for_class)\n    bar = go.Bar(name=winby, x=[ str(cl)+'kg' for cl in weight_classes ], y=fights_by_class)\n    bar_charts.append(bar)\n    \nlayout = go.Layout(\n    xaxis={'title': 'Weight Classes'},\n    yaxis={'title': \"Number fights by 'winby'\"}\n)\nfig = go.Figure(data=bar_charts)\nfig.update_layout(barmode='stack')\nfig.show()","43228264":"heavier_blue_wins = len(df[(df['_B_Weight_Class'] > df['_R_Weight_Class']) & (df['winner'] == 'blue')])\nheavier_blue_total_fights = len(df[df['_B_Weight_Class'] > df['_R_Weight_Class']])\n\nheavier_red_wins = len(df[(df['_B_Weight_Class'] < df['_R_Weight_Class']) & (df['winner'] == 'red')])\nheavier_red_total_fights = len(df[df['_B_Weight_Class'] < df['_R_Weight_Class']])\n\nheavier_win_probability = float(heavier_blue_wins + heavier_red_wins) \/ (heavier_blue_total_fights + heavier_red_total_fights)\nprint('Probability of heavier fighter winning: ', heavier_win_probability)","fe1d37a8":"def map_win(winner):\n    if winner == 'blue':\n        return 1\n    elif winner == 'red':\n        return -1\n    else:\n        return 0\n\nweight_diff = (df['_B_Weight_Class'] - df['_R_Weight_Class']).apply(lambda x: min(x, 27.2155)) # cap weight diffs >60lbs\nwins = df['winner'].apply(map_win)\n\n# Create linear regression object\nregr = linear_model.LinearRegression()\n\n# Train the model using the training sets\nregr.fit(np.array(weight_diff).reshape(-1, 1), wins)\nvariance = '%.3f' % regr.score(np.array(weight_diff).reshape(-1, 1), wins)\n\nlayout = go.Layout(\n    title='Correlation Coefficient = ' + variance,\n    xaxis={'title': 'Weight Difference (kg)'},\n    yaxis={'title': 'Did Win?'},\n    shapes=[\n        go.layout.Shape(\n            type=\"line\",\n            x0=weight_diff.min(),\n            y0=regr.predict([[weight_diff.min()]])[0],\n            x1=weight_diff.max(),\n            y1=regr.predict([[weight_diff.max()]])[0],\n            line=dict(\n                color=\"Red\",\n                width=3\n            )\n        )\n    ]\n)\n\nfig = go.Figure(data=go.Scatter(x=weight_diff, y=wins, mode='markers'), layout=layout)\nfig.show()","ee57e8b3":"min_age = min(df['R_Age'].min(), df['B_Age'].min())\nmax_age = max(df['R_Age'].max(), df['B_Age'].max())\n\nprint('The youngest fighter in the dataset is', min_age)\nprint('The oldest fighter in the dataset is', max_age)","1dda53c1":"df_notnull = df[df['B_Age'].notnull() & df['R_Age'].notnull() & df['B_Weight'].notnull() & df['R_Weight'].notnull()]\nages = pd.concat([df_notnull['B_Age'], df_notnull['R_Age']])\nweights = pd.concat([df_notnull['B_Weight'], df_notnull['R_Weight']])\n\n# Create linear regression object\nregr = linear_model.LinearRegression()\n\n# Train the model using the training sets\nregr.fit(np.array(ages).reshape(-1, 1), weights)\nvariance = '%.3f' % regr.score(np.array(ages).reshape(-1, 1), weights)\n\nlayout = go.Layout(\n    title='Correlation Coefficient = ' + variance,\n    xaxis={'title': 'Age'},\n    yaxis={'title': 'Weight (kg)'},\n    shapes=[\n        go.layout.Shape(\n            type=\"line\",\n            x0=19,\n            y0=regr.predict([[19]])[0],\n            x1=47,\n            y1=regr.predict([[47]])[0],\n            line=dict(\n                color=\"Red\",\n                width=3\n            )\n        )\n    ]\n)\n\nfig = go.Figure(data=go.Scatter(x=ages, y=weights, mode='markers'), layout=layout)\nfig.show()","a3bb3266":"age_ranges = [(19,24), (25,29), (30,34), (35,39), (40,44), (45,49)]\n\n# get total fights for each fight\nmean_fights = []\nfor lower_age, upper_age in age_ranges:\n    # get total number of fights with a fighter who is in the age range (double count fights with two such fighters)\n    num_fights_for_age = len(df[(df['R_Age'] >= lower_age) & (df['R_Age'] <= upper_age)])\n    num_fights_for_age += len(df[(df['B_Age'] >= lower_age) & (df['B_Age'] <= upper_age)])\n    \n    # calculate avg fights per fighter at that age\n    fights_for_age = df[((df['R_Age'] >= lower_age) & (df['R_Age'] <= upper_age)) | ((df['B_Age'] >= lower_age) & (df['B_Age'] <= upper_age))]\n    num_fighters = len(pd.concat([fights_for_age['B_Name'], fights_for_age['R_Name']]).unique())\n    mean_fights_for_age = num_fights_for_age \/ num_fighters\n    \n    mean_fights.append(mean_fights_for_age)\n        \n# plot the results\nlayout = go.Layout(\n    xaxis={'title': 'Age Ranges'},\n    yaxis={'title': 'Fights per year'})\nfig = go.Figure([go.Bar(x=[ str(age) for age in age_ranges ], y=mean_fights)], layout=layout)\nfig.show()","17987478":"# get relevant columns\nclustering_columns = [ col for col in df.columns if ('Round' in col and 'TIP' not in col and 'Round4' not in col and 'Round5' not in col) ]\nb_clustering_columns = [ col for col in clustering_columns if col.startswith('B_') ]\nr_clustering_columns = [ col for col in clustering_columns if col.startswith('R_') ]\n\n# filter out 5-round fights\ndf_3round = df[df['Max_round'] == 3]\n\n# combine blue and red fighters into a single dataframe with the relevant stats, and add name column\nclustering_df = pd.concat([df_3round[b_clustering_columns].rename(lambda x: x[3:], axis='columns'), df_3round[r_clustering_columns].rename(lambda x: x[3:], axis='columns')], ignore_index=True)\naggregated_columns = list(set([ col[7:] for col in clustering_df.columns.values if col ])) + ['Name'] # remove \"RoundX_\" from the start of each column\nclustering_df['Name'] = pd.concat([df_3round['B_Name'], df_3round['R_Name']], ignore_index=True)\n\n# aggregate round stats\nnew_rows = []\nfor index, row in clustering_df.iterrows():\n    row_dict = {}\n    for aggregated_column in aggregated_columns:\n        if aggregated_column is 'Name':\n            row_dict['Name'] = row['Name']\n        else:\n            col_sum = 0\n            num_rounds = 0\n            for round_num in range(1,4):\n                round_column = 'Round' + str(round_num) + '_' + aggregated_column\n                if not np.isnan(row[round_column]):\n                    num_rounds += 1\n                    col_sum += row[round_column]\n            row_dict[aggregated_column] = col_sum \/ num_rounds if num_rounds > 0 else np.nan\n    new_rows.append(row_dict)\n    \n# fill Nan values (missing stats for all 3 rounds) with the mean of each column\naggregated_clustering_df_raw = pd.DataFrame(new_rows)\naggregated_clustering_df_raw = aggregated_clustering_df_raw.fillna(aggregated_clustering_df_raw.mean())","b17ef3af":"# combine all rows for a single fighter into one row for that fighter\nfighter_rows = []\nnames = aggregated_clustering_df_raw['Name'].unique()\n\nfor name in names:\n    fights_for_fighter = aggregated_clustering_df_raw[aggregated_clustering_df_raw['Name'] == name]\n    if len(fights_for_fighter) >= 5:\n        fighter_row = fights_for_fighter.mean()\n        fighter_row['Name'] = name # add name back in\n        fighter_rows.append(fighter_row)\n\naggregated_clustering_df_raw_byname = pd.DataFrame(fighter_rows)","ee37641c":"# let's look at the data\naggregated_clustering_df_raw_byname.describe()","fb7e07b9":"# normalize the data - note the mean becomes 0 and the standard deviation becomes 1\npre_normalized = aggregated_clustering_df_raw_byname.drop('Name', axis=1)\naggregated_clustering_df = (pre_normalized - pre_normalized.mean()) \/ pre_normalized.std()\naggregated_clustering_df.describe()","6d7315f0":"clustering_data = aggregated_clustering_df.values\nlinked = sch.linkage(clustering_data, 'ward')\nlabelList = range(0, len(clustering_data))\n\nplt.figure(figsize=(10, 7))\nsch.dendrogram(linked,\n            orientation='top',\n            labels=labelList,\n            distance_sort='descending',\n            show_leaf_counts=True)\nplt.show()","0288e76e":"n_clusters = 3\ncluster = AgglomerativeClustering(n_clusters=n_clusters, affinity='euclidean', linkage='ward')\n\ncluster.fit_predict(clustering_data)\n\nprint('First 10 classifications:')\nfor name, label in zip(aggregated_clustering_df_raw_byname['Name'].as_matrix()[:10], cluster.labels_[:10]):\n    print(name, label)","8da69f9d":"# 2D PCA\npca_model = PCA(n_components=2)\ncomponents = pca_model.fit_transform(clustering_data)\n\n# plot the components with their cluster labels\ncluster_data = pd.DataFrame(components, columns=['pca_x', 'pca_y'])\ncluster_data['Name'] = aggregated_clustering_df_raw_byname['Name']\ncluster_data['label'] = cluster.labels_\nfig = px.scatter(cluster_data, x=\"pca_x\", y=\"pca_y\", color=\"label\", hover_data=['Name'])\nfig.show()","2fd98fc3":"fighter_cluster_data = pd.concat([cluster_data, aggregated_clustering_df_raw_byname.drop('Name', axis=1)], sort=False, axis=1)\n\n# we'll throw in age, height, weight, and win ratio for more context\ndef max_no_nan(series):\n    return -1 if np.isnan(series.max()) else series.max()\n\n# unfortunately, a join isn't possible with the original dataset (red and blue fighters), so we'll have to perform the lookup one-by-one\nfor idx, row in fighter_cluster_data.iterrows():\n    fighter_as_blue = df[df['B_Name'] == row['Name']]\n    fighter_as_red = df[df['R_Name'] == row['Name']]\n    fighter_cluster_data.at[idx, 'Age'] = max(max_no_nan(fighter_as_blue['B_Age']), max_no_nan(fighter_as_red['R_Age']))\n    fighter_cluster_data.at[idx, 'Height'] = max(max_no_nan(fighter_as_blue['B_Height']), max_no_nan(fighter_as_red['R_Height']))\n    fighter_cluster_data.at[idx, 'Weight'] = max(max_no_nan(fighter_as_blue['B_Weight']), max_no_nan(fighter_as_red['R_Weight']))\n    fighter_cluster_data.at[idx, 'Win_Ratio'] = (fighter_as_blue['_B_WinRatio'].mean() + fighter_as_red['_R_WinRatio'].mean()) \/ 2.0","fd3e995c":"fighter_cluster_data","7efcf2e6":"fighter_cluster_data.to_csv('fighter_cluster_data.csv', index = False)","263ae5c2":"label_rows = []\nfor label in range(n_clusters):\n    label_rows.append(fighter_cluster_data[fighter_cluster_data['label'] == label].mean())\n\nlabel_cluster_data = pd.DataFrame(label_rows, columns=fighter_cluster_data.columns.values).drop(['Name', 'pca_x', 'pca_y'], axis=1)\nlabel_cluster_data","b2de24b2":"label_cluster_data.to_csv('label_cluster_data.csv', index = False)","3ea76e5d":"column_max_by_label = dict([(label, []) for label in range(n_clusters) ])\ncolumn_min_by_label = dict([(label, []) for label in range(n_clusters) ])\n\nfor column in label_cluster_data.drop('label', axis=1).columns.values:\n    # compute the label that performs significantly more of this action\n    column_top_two = label_cluster_data[column].nlargest(2)\n    if max(column_top_two) >= min(column_top_two) * 1.25: # 25% more of a given action is our threshold\n        max_label = label_cluster_data[column].argmax()\n        column_max_by_label[max_label].append(column)\n        \n    # compute the label that performs significantly less of this action\n    column_bottom_two = label_cluster_data[column].nsmallest(2)\n    if min(column_bottom_two) <= max(column_bottom_two) * 0.75: # 25% less is our threshold\n        min_label = label_cluster_data[column].argmin()\n        column_min_by_label[min_label].append(column)\n\n    \nfor label in range(n_clusters):\n    print('label', label, 'performs more of the following actions than any other class:')\n    print(column_max_by_label[label], '\\n')\n    print('label', label, 'performs less of the following actions than any other class:')\n    print(column_min_by_label[label], '\\n')","7fe6b3bd":"df.to_csv('final_data.csv', index = False)","7b50107b":"<a id='agestatic'><\/a>\n## Age is static","ab03d146":"<a id='savingcleaned'><\/a>\n## Saving Cleaned Dataset\n\nI'll save it at this step so you can download the cleaned dataset.","4ef0e9fa":"After Googling each of these fights, I added two new values for `\"winby\"`, `\"DQ\"` for disqualifications and `\"NC\"` for no-contests (note that this won't be applied to wins that were overturned to become no-contests, as explained above).","4cdb8e98":"Let's try to find out what these missing values should be. First thought is maybe draws and no-contests don't populate this column.","503bfdb0":"Why Diego Sanchez? He's fought in 3 different weight classes since 2015 (and he's not the only one, as <a href=\"https:\/\/www.bloodyelbow.com\/2015\/8\/5\/9100525\/ufc-fighters-little-success-changing-weight-classes-mma\">moving up or down is relatively common<\/a>). Then `B_Weight` and `R_Weight` are probably only the most recent weight class for each fighter, instead of their weight class at the time of the fight - drats!\n\nNot much cleaning we can do here if the actual data is missing, let's just make a note to only use the last year of data if we need this column to be reliable.","170c789f":"In this graph, +1 is a win, 0 is a draw\/no-contest, and -1 is a loss.\n\nThe slope of the trend line indicates that heavier fighters are more likely to win; however, the correlation is very small at 0.001, meaning the weight difference is likely not a strong estimator of victory.","611b10ac":"Let's check the unique weight class values (ignoring anything above 93kg, which is representative of the highest weight class):","68aa985c":"Let's run PCA to visualize the clusters in 2 dimensions.","fa7dacc1":"Now let's look into the remaining no-contests - this will give us the context we need to deal with the no-contests with a missing \"winby\"","3448f08b":"Looks like a good split would be at the three colored groups. Let's use K-means clustering to divide and visualize the 3 groups.","c86684a1":"<a id='emptywinby'><\/a>\n## Empty 'winby' column?\nLooks like not every row has an entry for \"winby\" (e.g. KO, submission, or decision):","4638121e":"In Googling those fights, I stumbled across another \"dirty\" piece of data:","0518b8ed":"When I Googled some of these fights, most of the 3-round fights were by decision (as opposed to KO\/submission) - this means that there was no opportunity for a 4th round. Let's replace any `Max_round` of 4 with a 3 instead.","0998e29e":"<a id='exploration'><\/a>\n# Exploration","0de8fee3":"Tired of round-stats yet? Let's get a better overall look at the other features with:\n\n<a id='corr'><\/a>\n## Feature correlation matrix","2668a610":"<a id='ageweight'><\/a>\n### Weight Class\nLet's revisit weight and see how a fighter's age correlates with their weight class. Since it tends to be hard to stay lean at an old age (especially maintaining muscle mass), I predict a positive correlation.","ccf528a0":"<a id='agefights'><\/a>\n### Annual Fights\nNow let's see how many matches a fighter at a given age will have each year.\n\nAnticipating a skewed right distribution: maybe younger fighters fight more, and older fighters fight less?","22efe2f4":"Now let's look at the weight data for Diego Sanchez:","7edb6b38":"As you can see above, one of these must be true:\n- the `Age` field represents the fighter's age at the time of dataset creation, not at the time of the fight.\n- Jose Aldo is a time lord...\n\nSince we'll be exploring age later, let's adjust this column to reflect age at time of fight. We'll do this by taking the fighter's age and subtract the time difference between the fight's date and the last fight in the dataset. We'll leave it as an integer, for discrete grouping.","ed30a5f1":"The probability of the heavier fighter winning is 55.6%, as opposed to the chance of a random fighter winning their match being 50%.\n\nLet's try to visualize a correlation between weight difference and win percentage.\n\nNote: Because the weight class is recorded as of the current date, there will be some weight differentials that are >60lbs, which is not a legal matchup in the UFC. We'll cap those at ~27kg (60lbs) below.","fe318a90":"Now let's print summary statistics for each class:","4ec96e81":"<a id='weight'><\/a>\n## Weight\n\nThe weight classes in the UFC are: 52, 56, 61, 65, 70, 76, 77, 84, and 93 kg (or 115, 125, 135, 145, 155, 170, 185, and 205 in pounds).  \nFor more info on weight classes: https:\/\/www.ladbrokes.com.au\/info\/ufc\/weight-divisions\/\n\nA lot of the fight's details are determined by the fighters' weight class: a heavyweight fight is very different to watch than a featherweight fight. Let's start with just a broad look at how different classes end their fights.","ac7b9ed7":"The weight classes follow a relatively normal distribution with a peak at 70kg \/ 154 lbs.\n\nOther observations:\n- Wins by decision are most common with lighter fighters, and wins by KO are most common with the heaviest fighters\n- The likelihood of a match ending by submission seems independent of weight class","30b5d97d":"<a id='dateoff'><\/a>\n## Date is off","8a9beea4":"<a id='clustering'><\/a>\n## Clustering Fighters\n\nLet's use the numerical round stats to see if we can separate fighters into different groups based on their fighting styles. We'll aggregate a stat for each round into a sum for the match. \n\nOther processing details:\n- Let's exclude the TIP stats for now, as they aren't specific to a single fight. \n- We'll also exclude 5-round matches, as there are relatively few of those and can't necessarily be compared to 3-round match styles.\n- Let's also limit this to fighters with at least 5 fights to get accurate data on their fighting style","4a7a9d38":"<a id='age'><\/a>\n## Age","a36a12be":"# <center>UFC Fight Data - Cleaning, Visualization, and Insights<\/center>\n<center>Kaggle Dataset Page: https:\/\/www.kaggle.com\/calmdownkarm\/ufcdataset<\/center>\n<center>If you liked this kernel and\/or found it helpful, please upvote it so others can see it too!<\/center>","4ababdf4":"Next, it's helpful to use hierarchical clustering to get a feel for how many groups we should pass to our clustering algorithm.","44747b64":"Let's take a first look at the data...","9f535c89":"There is a positive correlation, but it's very weak. From ages 22 until 40, there are fighters from almost all weight classes.\n\nHowever, there is definitinely a pattern at the extremes: the whitespace in the lower right and upper left shows us that the oldest fighters are never below 77kg, and the youngest fighters are never above 77kg.","43310116":"Max-3-round fights are ~2.3 rounds on average, while max-5-round fights are ~3 rounds on average.","f97dee3f":"Looks like every draw counts for an empty winby, but not every \"no contest\". Let's set all the draws to a new win type - `\"DRAW\"`","02c364ce":"Uh-oh. The \"max\" date is in European format, while the majority of the dates are in American format. We'll have to omit month\/day to be sure of an accurate calculation. Let's take a closer look at the date formats.","933b2541":"<a id='overview'><\/a>\n<a id='about'><\/a>\n# About the dataset\n\n### Overview\nUFC is a 3-to-5-round, 1v1 mixed martial arts competition where a winner is decided either by KO, submission, decision, or (rarely) disqualification. The organization was formed in 1993.\n\nMore details about the sport and specific rules can be found on the UFC website here:\nhttps:\/\/www.ufc.com\/unified-rules-mixed-martial-arts\n\n### Structure\nThe dataset is granular fight-level data including previous records (post-2013), height\/weight\/age, and kicks\/punches\/etc per round. Each row represents a single fight. Stats are recorded per fighter, per round.","2401d454":"Similar to the 3-round data. What's interesting is that submission wins tend to happen a little after halfway through the fight: average 1.7 rounds in a max-3-round fight, 2.6 in a max-5-round.\n\nLooks like the match duration affects the distribution of win type. See below how KOs are most likely in a max-5-round match, while decisions are most common for max-3-rounders.","cca096f0":"Let's see if we can learn a bit more about what these classes represent. We'll separate the actions (columns) by which class does that action the most. Let's also filter out any columns that are close to a two-way tie.","a06e92dc":"\"Feature correlation\" refers to the linear correlation between two variables, as a decimal between 0 and 1. A feature correlation matrix is simply a matrix of these correlations, for a set of features. \n\nGiven feature at index `n`, the matrix will have value 1.0 at cell `(n,n)`, as a feature correlates perfectly with itself. If a feature at index `m` has absolutely no correlation with feature `n`, then the values at `(m,n)` and `(n,m)` will be 0.0, and inverse correlation is represented with a negative decimal.\n\nFor more on feature correlation matrices, check out: https:\/\/towardsdatascience.com\/feature-selection-correlation-and-p-value-da8921bfb3cf","4c4e632c":"Pretty much what we expected: fighters aged 25-35 fight ~2x more than older fighters AND ~2x more than the youngest (age 19-24) fighters. \n\nThe former likely due (in part) to longer recovery times and lower viewer demand for older fighters. The latter possibly due to being busy fighting in other MMA leagues, or having a harder time getting fights as a newcomer.","53dd8681":"\n\nNow by win type:","c47c6b83":"<a id='wrongrounds'><\/a>\n## Wrong rounds\n\nThere's a max-3-round fight that ends in decision...that had less than 3 rounds?","dafc6d90":"<a id='clean'><\/a>\n# Cleaning","3592978b":"<a id='imports'><\/a>\n# Imports \/ Dataset Structure","4f769670":"<a id='savefinal'><\/a>\n## Saving Dataset with Added Columns\n\nWoo! We did it! Here's the resulting dataset.","5d1fc9c2":"<a id='weightwintype'><\/a>\n### Weight and 'winby'","ff0c4a12":"### Initial Observations\n- Looks like there are plenty of NaNs, which is disappointing for a relatively small dataset\n- There are multiple ways to win ('DEC', 'KO\/TKO', 'SUB', and, of course, NaN)\n- Since the rows represent fights, we may have to query multiple columns to get stats for a single fighter (B_Name and R_Name)\n- An X-round match has NaN for all subsequent rounds\n- The data starts at 2013, so many of these fighters may have unrecorded matches, skewing their \"previous record\" values for a single row\/fight\n\n### Additional Context\n- The dataset contains fights for both male and female fighters (although of course, there are no MvF fights)\n- The weight classes are recorded as the discrete lower limits for each class (kg), instead of the fighter's actual weight at the time of the fight\n- Ways to win:\n    - knockout\/technical knockout (KO\/TKO): when a fighter is knocked out, or the referee stops the fight because the fighter can't defend themselves.\n    - submission (SUB): \"when the referee or doctor stops the fight because a fighter has sustained an injury or is rendered unconscious while in a submission hold.\" (source: Google)\n    - decision (DEC): when the last round concludes, the judges tally each fighter's score to determine the winner\n- What is a \"strike\"?\n    - Striking includes punches, kicks, knee strikes and elbows (https:\/\/entertainment.howstuffworks.com\/ufc2.htm)\n    - \"significant strikes\" refer to all strikes at distance and power strikes in the clinch and on the ground. More research into this reveals that it tends not to be a very informative stat or one that is easily misinterpreted\n- \"Distance\", \"Clinch\", \"Ground\":\n    - distance: fighters are standing with distance between them\n    - clinch: fighters are performing a \"standing grapple\"\n    - ground: fighters are on the floor of the ring\n- \"Reversal\", \"Standup\", \"Submission\", \"Takedown\": https:\/\/www.mmafighting.com\/2011\/05\/09\/fightmetric-stats-glossary\n- The \"TIP\" stats (e.g. `R__Round1_TIP_Standing Time`) are the \"Time in Past\/Previous\" in seconds for various stats (e.g. standing time) for a given fighter\/round","ee621de7":"Turns out, either in the previous set of fights OR from the dataset as a whole, the `\"Date\"` column is not accurate! Most examples are within a week of the real fight, but I ran into some that were 1-2 months off from the date of the fight. This could be due to delayed fights, or dates of the weigh-in\/press conferences rather than the fight itself. Let's just remember this when referencing the `\"Date\"` column, and possibly just reference the year if date queries are necessary.","fe7ea5ce":"After Googling these, turns out the majority (all but 1!) are from wins being overturned by failed drug test results. Research on drugs in the UFC reveals that performance-enhancing-drug (PED) use is rampant:\nhttps:\/\/www.lowkickmma.com\/gsp-details-why-its-still-easy-to-use-peds-in-ufc\/\nhttps:\/\/www.mmamania.com\/2015\/2\/12\/8026617\/epidemic-joe-rogan-estimates-that-50-60-percent-of-ufc-fighters-using-steroids-mma\n(hard to find a WaPo or NYT article on this, will have to settle for these sources)\n\nTherefore, I'm deciding to overwrite the `\"winner\"` column here with the original winner, because drugs are so common and a failed drug test shouldn't really affect the individual fight itself.\n\nTwo outliers:\n- Drew Dober vs Leandro Silva - Silva's win was overturned due to a ref mistaking Dober for being unconcious; still treating this as a win for Silva, as his position at the time was extremely advantageous\n- Jim Alers vs Cole Miller - the `\"winby\"` is not correct as there was no KO - setting this to NaN to pick up with the next batch of no-contests","c6489ac2":"76 is abnormal, as 77 is representative of the middeweight class. Let's set it to 77.","bfa68109":"Max-3-round matches tend often end in decision, meaning a clear winner wasn't declared by the end of the fight. However, max-5-round matches end in KO or submission 2\/3 of the time! Makes sense why these would be the norm for title fights, which are designed to be more exciting to watch!\n\nIt also seems the likelihood of submission is relatively low but constant.","becac458":"Now let's look at the remaining matches, in more granular detail.","47cb5fcf":"<a id='prevrecord'><\/a>\n## Previous Record\nWinning fighters tend to win, and losing ones tend to lose, right? Let's find out for ourselves.\n\nFirst let's compare different \"winningness\" metrics: num wins, num losses, win ratio, and total fights.","0237322a":"You can hover your mouse over any of the points to see the fighter's name and label. Let's add in relevant variables to save this data, in case you want to download it yourself.","aea9a24b":"<a id='rounds'><\/a>\n## Rounds\n\nWe'll explore the characteristics of max-3-round and max-5-round fights, including average length and most common ways to win for each.","73f7bf87":"<a id='weightadvantage'><\/a>\n### Weight class mismatches\n\nNow let's see how fighting at mismatched weight classes affects who wins.","3988c9c7":"<!--<img src=\"https:\/\/thumbor.forbes.com\/thumbor\/960x0\/https%3A%2F%2Fspecials-images.forbesimg.com%2Fdam%2Fimageserve%2F1164642336%2F960x0.jpg%3Ffit%3Dscale\">-->\n![](https:\/\/thumbor.forbes.com\/thumbor\/960x0\/https%3A%2F%2Fspecials-images.forbesimg.com%2Fdam%2Fimageserve%2F1164642336%2F960x0.jpg%3Ffit%3Dscale)","02e931bd":"<a id='4rounds'><\/a>\n## 4-round matches?\nLet's try to figure out why some fights have \"Max_round\" set to 4 - I couldn't find any explanation for this on Google...","679908cf":"There is a TON to unpack here, let's just point out a few interesting observations (keep in mind, correlation is NOT causation!).\n\nObservations:\n- A younger fighter tends to win more, but having an older opponent seems not to be equally significant.\n- Late-round (4 and 5) leg strikes seem to be a last-resort mechanism? They correlate stronger than any other stat with a loss. \n- In general, late-round stats seem to have the strongest correlations - this may be because they are indicative of how the previous rounds went (a fighter who got pummeled in round 1 likely won't be as aggressive in later rounds).","902c8023":"Below is the table of contents. Approximately half of the kernel is dedicated to cleaning the dataset, with the other half dedicated to exploration and feature engineering of the cleaned dataset. Feel free to skip ahead using the links below if data cleaning isn't your thing - the coolest stuff is at the end anyway!\n\nWe save both the cleaned and engineered datasets, as well as a couple other formats of the data that may be helpful or interesting to download. Enjoy!\n\n# Table of Contents\n\n* [Overview](#overview)\n    * [About](#about)  \n    * [Imports](#imports)  \n    * [Observations](#observations)  \n* [Cleaning](#clean)\n    * [4-Round matches](#4rounds)\n    * [Age is static](#agestatic)\n    * [Weight is static and sparse](#weightsparse)\n    * [Missing win type](#emptywinby)\n    * [Date is off](#dateoff)\n    * [Wrong rounds](#wrongrounds)\n    * [Saving the cleaned dataset](#savingcleaned)\n* [Exploration](#exploration)\n    * [3 vs 5 Round Matches](#rounds)\n    * [Feature correlation matrix](#corr)\n    * [Previous Record](#prevrecord)\n    * [Weight](#weight)\n        * [Weight and win type](#weightwintype)\n        * [Weight advantage](#weightadvantage)\n    * [Age](#age)\n        * [Age and weight](#ageweight)\n        * [Fights per year](#agefights)\n    * [Unsupervised clustering of fighting styles](#clustering)\n    * [Saving the final dataset](#savefinal)\n* [Conclusion](#conclusion)<br>","d3623857":"Interpretation of each label:\n- **Label 0 aka The Striker:** Fighters in this class throw the most punches and kicks in almost any situation. Whether they're body, leg, or head strikes doesn't seem to matter. When their opponent is down, the Striker showers them with standing kicks and punches. These are also (on average) the shortest, lightest, and skinniest fighters. They appear to be the most successful fighters, with the highest win ratio.\n- **Label 1 aka The Grappler:** Class 1 fighters are heavy grapplers, with the most submissions and reversals. They dominate on the ground, with the most ground strikes attempted AND landed, which speaks to their precision from that position. These are on average the heaviest and \"thickest\" (highest BMI) fighters.\n- **Label 2 aka ... The Reacher?:** We don't have much information here: these fighters are on average the tallest of the classes, and have the fewest grapples and clinches. My GUESS is that these are fighters with long reach, keeping the opponent at a safe distance, which reduces the number of opportunities to throw a punch. However, it's also possible that these are simply \"less outstanding\" fighters, with low numbers across the board and also the lowest win ratio (with due credit, of course, to the extremely hard work it takes to even compete in the UFC).","a5e93939":"<a id='conclusion'><\/a>\n# Conclusion\n\nThere's a lot more left to do with the data, but I'll leave that up to you! Feel free to use my cleaned dataset or feature-engineered dataset as a starting point. I'd love to hear ideas for more analysis or feedback on any part of the kernel, no matter how nitpicky.","b55f952c":"Now that we've calculated the relevant stat, let's use another correlation matrix to see how each metric relates to the chance of winning.","46a9f1c0":"<a id='observations'><\/a>\n# Data Context and Observations","663484de":"Because there are so many fights where the weight classes are mismatched, we'll just double-count those fights as outcomes for both weight classes.","bbc40c91":"Looks like the blue fighter winning correlates strongest with the red fighter's number of previous losses (positive correlation).\n\nIt also correlates very weakly than expected with blue's win ratio, blue's previous number of losses, and red's previous number of fights.\n\nHowever, let's note that none of these stats are a great predictor (even ignoring correlation != causation) because none of the metrics correlate with the `winner` column by more than `abs(R) = 0.1`.","29e3b07c":"<a id='weightsparse'><\/a>\n## Weight: static and missing values\n\nLooks like there are some null values, let's see if we can fill those in."}}