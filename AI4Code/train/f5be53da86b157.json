{"cell_type":{"2496e580":"code","abb30300":"code","5d70a587":"code","87ffecdc":"code","c202602a":"code","2b1f5f65":"code","8bd6eb68":"code","9a940f55":"code","f5c15b8c":"code","d747a958":"code","f69ada60":"code","44a25222":"code","5331e4f2":"code","b4efb6cb":"code","2ad0b1ee":"code","67eb939f":"code","5c2b9e69":"code","87ceea42":"code","af6299ab":"code","70dd08eb":"code","a33fbe83":"code","0c032dcd":"code","7505ad26":"code","a6897db6":"code","58a02781":"code","eb6450cd":"code","38170fc2":"code","c338c973":"code","c6d33e41":"code","ee4f2a39":"code","cce5abd4":"code","9f753d57":"code","a07d9291":"code","391d7966":"code","b186985e":"code","cf81f9fd":"code","71d7be65":"code","94ceb8ac":"code","8ef3e2fc":"code","b4aa2ff8":"code","883ab7d6":"code","e7df6e5d":"code","f396af4d":"code","88a4ed52":"code","d77747e8":"code","abf24176":"code","1e21d499":"code","6d25b3b2":"code","df3791a3":"code","6c2995fe":"code","bc3bcd04":"code","045b4b77":"code","c2a0550d":"code","aaee526c":"code","ccc5edd4":"code","69fe45f5":"code","5b2dd457":"markdown","a50536b9":"markdown","4f14e321":"markdown","de1bfc9d":"markdown","97eef415":"markdown","c66a0050":"markdown","919e5f0c":"markdown","f9240ef8":"markdown","440e1dd9":"markdown","809e55bd":"markdown","811fbe09":"markdown","d0b8f632":"markdown","fe2ca0ba":"markdown","7cd20093":"markdown"},"source":{"2496e580":"!pip install imutils==0.5.3","abb30300":"# import the necessary packages\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\n\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom IPython.display import FileLink\nfrom imutils import paths\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nnp.random.seed(0)\n\nimport random\nimport shutil\nimport cv2\nimport os\n","5d70a587":"dataset_path = '.\/dataset'","87ffecdc":"%%bash\nrm -rf dataset\nmkdir -p dataset\/covid\nmkdir -p dataset\/normal","c202602a":"samples = 25","2b1f5f65":"covid_dataset_path = '..\/input\/covid-chest-xray'","8bd6eb68":"# construct the path to the metadata CSV file and load it\ncsvPath = os.path.sep.join([covid_dataset_path, \"metadata.csv\"])\ndf = pd.read_csv(csvPath)\n\n# loop over the rows of the COVID-19 data frame\nfor (i, row) in df.iterrows():\n    # if (1) the current case is not COVID-19 or (2) this is not\n    # a 'PA' view, then ignore the row\n    if row[\"finding\"] != \"COVID-19\" or row[\"view\"] != \"PA\":\n        continue\n\n    # build the path to the input image file\n    imagePath = os.path.sep.join([covid_dataset_path, \"images\", row[\"filename\"]])\n\n    # if the input image file does not exist (there are some errors in\n    # the COVID-19 metadeta file), ignore the row\n    if not os.path.exists(imagePath):\n        continue\n\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = row[\"filename\"].split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/covid\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","9a940f55":"pneumonia_dataset_path ='..\/input\/chest-xray-pneumonia\/chest_xray'","f5c15b8c":"basePath = os.path.sep.join([pneumonia_dataset_path, \"train\", \"NORMAL\"])\nimagePaths = list(paths.list_images(basePath))\n\n# randomly sample the image paths\nrandom.seed(42)\nrandom.shuffle(imagePaths)\nimagePaths = imagePaths[:samples]\n\n# loop over the image paths\nfor (i, imagePath) in enumerate(imagePaths):\n    # extract the filename from the image path and then construct the\n    # path to the copied image file\n    filename = imagePath.split(os.path.sep)[-1]\n    outputPath = os.path.sep.join([f\"{dataset_path}\/normal\", filename])\n\n    # copy the image\n    shutil.copy2(imagePath, outputPath)","d747a958":"def ceildiv(a, b):\n    return -(-a \/\/ b)\n\ndef plots_from_files(imspaths, figsize=(20,10), rows=1, titles=None, maintitle=None):\n    \"\"\"Plot the images in a grid\"\"\"\n    f = plt.figure(figsize=figsize)\n    if maintitle is not None: plt.suptitle(maintitle, fontsize=10)\n    for i in range(len(imspaths)):\n        sp = f.add_subplot(rows, ceildiv(len(imspaths), rows), i+1)\n        sp.axis('Off')\n        if titles is not None: sp.set_title(titles[i], fontsize=16)\n        img = plt.imread(imspaths[i])\n        plt.imshow(img)","f69ada60":"normal_images = list(paths.list_images(f\"{dataset_path}\/normal\"))\ncovid_images = list(paths.list_images(f\"{dataset_path}\/covid\"))","44a25222":"normal_images","5331e4f2":"covid_images","b4efb6cb":"plots_from_files(normal_images, rows=5, maintitle=\"Normal X-ray images\")","2ad0b1ee":"plots_from_files(covid_images, rows=5, maintitle=\"Covid-19 X-ray images\")","67eb939f":"# grab the list of images in our dataset directory, then initialize\n# the list of data (i.e., images) and class images\n\nprint(\"[INFO] loading images...\")\nimagePaths = list(paths.list_images(dataset_path))\n\ndata = []\nlabels = []\n\n# loop over the image paths\nfor imagePath in imagePaths:\n    # extract the class label from the filename\n    label = imagePath.split(os.path.sep)[-2]\n    # load the image, swap color channels, and resize it to be a fixed\n    # 224x224 pixels while ignoring aspect ratio\n    image = cv2.imread(imagePath)\n    image = cv2.cvtColor(image, cv2.IMREAD_GRAYSCALE)\n    image = cv2.resize(image, (224, 224))\n    # update the data and labels lists, respectively\n    image_np = (image).flatten()\n    data.append(image_np)\n    labels.append(label)\n    \n# convert the data and labels to NumPy arrays while scaling the pixel\n# intensities to the range [0, 1]\ndata_train = np.array(data) \/ 255\nlabels_train = np.array(labels)","5c2b9e69":"data","87ceea42":"len(data)","af6299ab":"labels","70dd08eb":"len(labels)","a33fbe83":"data_train","0c032dcd":"labels_train","7505ad26":"# perform one-hot encoding on the labels\nlb = LabelBinarizer()\nlabels_train_y = lb.fit_transform(labels_train)\nlabels_train_cat = to_categorical(labels_train_y)\n\n# partition the data into training and testing splits using 80% of\n# the data for training and the remaining 20% for testing\n\n(X_train, X_test, y_train, y_test) = train_test_split(data, labels, test_size=0.20, stratify=labels, random_state=42)\n\n","a6897db6":"X_train","58a02781":"y_train","eb6450cd":"from sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.calibration import calibration_curve\n\n\n\n# Create classifiers\nlr = LogisticRegression(max_iter=10000)\ngnb = GaussianNB()\nsvc = LinearSVC(C=1.0, max_iter=10000)\nrfc = RandomForestClassifier()\n\n\n\n","38170fc2":"LR_Model = lr.fit(X_train, y_train)\n","c338c973":"GNB_Model = gnb.fit(X_train, y_train)\n","c6d33e41":"SVC_Model = svc.fit(X_train, y_train)\n","ee4f2a39":"RFC_Model = rfc.fit(X_train, y_train)","cce5abd4":"import pickle\n\nwith open('LR_model.pkl', 'wb') as f1:\n    pickle.dump(LR_Model,f1)\n    f1.close()\n\nwith open('GNB_model.pkl', 'wb') as f2:\n    pickle.dump(GNB_Model,f2)\n    f2.close()\n\nwith open('SVM_model.pkl', 'wb') as f3:\n    pickle.dump(SVC_Model,f3)\n    f3.close()\n\nwith open('RF_model.pkl', 'wb') as f4:\n    pickle.dump(RFC_Model,f4)\n    f4.close()\n\n\n    \n","9f753d57":"from IPython.display import FileLink\n\nFileLink(r'LR_model.pkl')\n","a07d9291":"FileLink(r'GNB_model.pkl')\n","391d7966":"FileLink(r'SVM_model.pkl')\n","b186985e":"FileLink(r'RF_model.pkl')","cf81f9fd":"from sklearn.metrics import accuracy_score\n\n\nLR_y_pred = LR_Model.predict(X_test)\nGNB_y_pred = GNB_Model.predict(X_test)\nSVC_y_pred = SVC_Model.predict(X_test)\nRFC_y_pred = RFC_Model.predict(X_test)\n\n\n# accuracy_score(y_true, y_pred)\n","71d7be65":"LR_acc_sc = accuracy_score(y_test, LR_y_pred)\nLR_acc_sc","94ceb8ac":"GNB_acc_sc = accuracy_score(y_test, GNB_y_pred)\nGNB_acc_sc","8ef3e2fc":"SVC_acc_sc = accuracy_score(y_test, SVC_y_pred)\nSVC_acc_sc","b4aa2ff8":"RFC_acc_sc = accuracy_score(y_test, RFC_y_pred)\nRFC_acc_sc","883ab7d6":"print('LogisticRegression score: %f' % LR_Model.score(X_test, y_test))\nprint('Naive Bayes score: %f' % GNB_Model.score(X_test, y_test))\nprint('SVM score: %f' % SVC_Model.score(X_test, y_test))\nprint('Random Forest score: %f' % RFC_Model.score(X_test, y_test))","e7df6e5d":"import itertools","f396af4d":"def plot_confusion_matrix(cm, classes, normalize=False,title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    \n    plt.figure(figsize=(8,8), dpi=100)\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    \n    savefilename = title+'.png'\n        \n    plt.savefig(savefilename)\n    ","88a4ed52":"cm_plot_labels = ['covid -ve','covid +ve']","d77747e8":"cm_lr = confusion_matrix(y_test, LR_y_pred)\nplot_confusion_matrix(cm=cm_lr, classes=cm_plot_labels, title='Logistic Regression Confusion Matrix')\n","abf24176":"cm_nb = confusion_matrix(y_test, GNB_y_pred)\nplot_confusion_matrix(cm=cm_lr, classes=cm_plot_labels, title='Support Vector Machine Regression Confusion Matrix')\n","1e21d499":"cm_svc = confusion_matrix(y_test, SVC_y_pred)\nplot_confusion_matrix(cm=cm_nb, classes=cm_plot_labels, title='Gaussian Naive Bayes Confusion Matrix')\n","6d25b3b2":"cm_rf = confusion_matrix(y_test, RFC_y_pred)\nplot_confusion_matrix(cm=cm_rf, classes=cm_plot_labels, title='Random Forest Confusion Matrix')\n","df3791a3":"# #############################################################################\n# Plot calibration plots\n\nplt.figure(figsize=(10, 10))\nax1 = plt.subplot2grid((3, 1), (0, 0), rowspan=2)\nax2 = plt.subplot2grid((3, 1), (2, 0))\n\nax1.plot([0, 1], [0, 1], \"k:\", label=\"Perfectly calibrated\")\nfor clf, name in [(lr, 'Logistic'),\n                  (gnb, 'Naive Bayes'),\n                  (svc, 'Support Vector Classification'),\n                  (rfc, 'Random Forest')]:\n    clf.fit(X_train, y_train)\n    if hasattr(clf, \"predict_proba\"):\n        prob_pos = clf.predict_proba(X_test)[:, 1]\n    else:  # use decision function\n        prob_pos = clf.decision_function(X_test)\n        prob_pos = \\\n            (prob_pos - prob_pos.min()) \/ (prob_pos.max() - prob_pos.min())\n    fraction_of_positives, mean_predicted_value = \\\n        calibration_curve(y_test, prob_pos, n_bins=10)\n\n    ax1.plot(mean_predicted_value, fraction_of_positives, \"s-\",\n             label=\"%s\" % (name, ))\n\n    ax2.hist(prob_pos, range=(0, 1), bins=10, label=name,\n             histtype=\"step\", lw=2)\n\nax1.set_ylabel(\"Fraction of positives\")\nax1.set_ylim([-0.05, 1.05])\nax1.legend(loc=\"lower right\")\nax1.set_title('Calibration plots  (reliability curve)')\n\nax2.set_xlabel(\"Mean predicted value\")\nax2.set_ylabel(\"Count\")\nax2.legend(loc=\"upper center\", ncol=2)\n\nplt.tight_layout()\nplt.show()\n","6c2995fe":"import os\n\nfiles = os.listdir(\"..\/input\/covid-chest-xray\/images\")\ncovid_final = 0\nnormal_final = 0\n\n\nfor i in files:\n    dir = \"..\/input\/covid-chest-xray\/images\" + \"\/\" + i\n    test_image = cv2.imread(dir)\n    #print(dir)\n    test_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\n    test_image = cv2.resize(test_image, (224, 224))\n    test_img = test_image.flatten().reshape(1, -1)\n\n\n    result= [LR_Model.predict(test_img), GNB_Model.predict(test_img), SVC_Model.predict(test_img), RFC_Model.predict(test_img)]\n    \n    #print(result)\n\n    occ = []\n \n    for i in result:\n        occ.append(result.count(i))\n    \n    if result[occ.index(max(occ))] == \"covid\":\n        covid_final += 1\n        print(\"covid\")\n    else:\n        normal_final += 1\n        print(\"normal\")\n\n","bc3bcd04":"print(\"covid\" , covid_final)\nprint(\"normal\", normal_final)","045b4b77":"covid = [0] * 4 \nnormal = [0] * 4","c2a0550d":"import os\n\nfiles = os.listdir(\"..\/input\/covid-chest-xray\/images\")\n\nfor i in files:\n    dir = \"..\/input\/covid-chest-xray\/images\" + \"\/\" + i\n    test_image = cv2.imread(dir)\n    #print(dir)\n    test_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\n    test_image = cv2.resize(test_image, (224, 224))\n    test_img = test_image.flatten().reshape(1, -1)\n\n\n    result= RFC_Model.predict(test_img)\n    \n    if result == \"covid\":\n        covid[3] += 1\n        print(\"covid\")\n    else:\n        normal[3] += 1\n        print(\"normal\")\n    ","aaee526c":"print(covid)\nprint(normal)","ccc5edd4":"data = {'Algorithms':[\"Logistic Regression\", \"Naive Bayes\", \"Support Vector Classifier\", \"Random Forest Classifier\"],\n       'Covid':covid,\n       'Normal':normal}\n\ndf = pd.DataFrame(data, columns = ['Algorithms', 'Covid', 'Normal'])\n\nprint(df)","69fe45f5":"\n\ntest_image = cv2.imread('..\/input\/chest-xray-pneumonia\/chest_xray\/test\/NORMAL\/IM-0003-0001.jpeg')\ntest_image = cv2.cvtColor(test_image, cv2.IMREAD_GRAYSCALE)\ntest_image = cv2.resize(test_image, (224, 224))\ntest_img = test_image.flatten().reshape(1, -1)\n\n\nresult= [LR_Model.predict(test_img), GNB_Model.predict(test_img), SVC_Model.predict(test_img), RFC_Model.predict(test_img)]\n\nocc = []\n \nfor i in result:\n    occ.append(result.count(i))\n    \nprint(result[occ.index(max(occ))])\n        \n\n","5b2dd457":"Test on normal image:","a50536b9":"### Covid xray dataset","4f14e321":"## Build Dataset","de1bfc9d":"> \/opt\/conda\/lib\/python3.7\/site-packages\/sklearn\/svm\/_base.py:977: ConvergenceWarning: Liblinear failed to converge, increase the number of iterations.\n>   \"the number of iterations.\", ConvergenceWarning)","97eef415":"# Metrics","c66a0050":"Test on covid image:","919e5f0c":"## Comparison of Calibration of Classifiers","f9240ef8":"# Confusion Matrix","440e1dd9":"## Data preprocessing","809e55bd":"## Plot x-rays","811fbe09":"Helper function to plot the images in a grid","d0b8f632":"# FIT MODELS","fe2ca0ba":"# Now save the model","7cd20093":"### Build normal xray dataset"}}