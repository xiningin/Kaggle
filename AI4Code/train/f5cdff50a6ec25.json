{"cell_type":{"b7ee6bce":"code","e919d9ea":"code","3cdd4725":"code","f8a6b1e2":"code","2c4d61b5":"code","7943da71":"code","15267f84":"code","46f2adfd":"code","5e88e48d":"code","24794ce4":"code","fd20623f":"code","ddfcb4f9":"code","a431721f":"code","a4219b13":"code","9b08aa17":"code","b26e52e8":"code","3da39e4d":"code","a5e7c973":"code","82dd23bc":"code","506b818a":"code","76dca1c8":"code","5c811c5b":"code","c5f585a8":"code","45228b69":"code","26de70a8":"markdown","4a83886b":"markdown","fa344a21":"markdown","e13381a6":"markdown","dc6770c5":"markdown","40fe6963":"markdown","2c1cdfba":"markdown","9b04e570":"markdown","43dee9c8":"markdown","ba673d92":"markdown","5b672378":"markdown","fc979345":"markdown","555b0957":"markdown","eee91bd8":"markdown","a9b8c903":"markdown"},"source":{"b7ee6bce":"import numpy as np \nfrom tqdm import tqdm\nimport re\n\nimport gc\nimport time\nimport seaborn as sns; sns.set()\n \n\nimport pandas as pd\n\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom pytz import timezone\nfrom dateutil import tz\n\nimport geopandas as gpd\nfrom geopandas.tools import sjoin\n\nfrom fiona.crs import from_epsg\nimport os, json\nfrom shapely.geometry import shape, Point, Polygon, MultiPoint\nimport matplotlib.pyplot as plt\n\nfrom IPython.display import IFrame\nimport folium\n\nfrom branca.colormap import  linear\nimport branca.colormap as cm\n\nimport matplotlib.cm as cm\nimport matplotlib.colors as colors\n\nimport networkx as nx\nimport pickle\nimport osmnx as ox\n\nimport holoviews as hv\nfrom holoviews import opts\n\n! pip install hvplot\nimport hvplot.networkx as hvnx\n# hv.extension('bokeh')\n\n# defaults = dict(width=1000, height=800)\n# hv.opts.defaults(\n#     opts.EdgePaths(**defaults), opts.Graph(**defaults), opts.Nodes(**defaults))\n","e919d9ea":"class G_fromOSM:\n    \n    def __init__(self, area, drive, query, buffer):\n        \n        self.area = area\n        \n        self.drive = drive\n        \n        self.query = query\n        \n        self.buffer = buffer\n        \n        \n    def retrieve(self):\n        \n        if  self.drive == 'none':\n            \n            G = ox.graph_from_place(self.area, network_type = self.drive, custom_filter = self.query)\n            \n        else:\n            \n            G = ox.graph_from_place(self.area, network_type = self.drive)\n        \n        G = ox.project_graph(G, to_crs = 'epsg:4326')\n        \n        return G\n        \n        \n    def deconstruct(self, G):\n        \n        intersections, streets = ox.graph_to_gdfs(G)\n        \n        print('Graph representation of road network:')\n        print('')\n        print('streets: edges '+str(streets.shape))\n        print('')\n        print('street intersections: nodes '+str(intersections.shape))\n        print('')\n        \n        return intersections, streets\n        \n\n    def vis_BW(self, G, node_size, edge_width ):\n        \n        fig, ax = ox.plot_graph(G, bgcolor='k', node_size = node_size, \n                                node_color='#999999', node_edgecolor='none', node_zorder=1,\n                                edge_color='#555555', edge_linewidth = edge_width, edge_alpha=1)\n        \n        \n    def vis_FOLIUM(self, G, node_size, edge_width ):\n        \n        m1 = ox.plot_graph_folium(G, popup_attribute='name', edge_color='blue', edge_width= edge_width, edge_opacity=50)\n        \n        filepath = '.\/graph.html'\n        \n        m1.save(filepath)\n        \n        return IFrame(filepath, width=800, height=700)\n    \n    \n    def save_toGeoJSON(self, G, name):\n        \n        ECKERT_IV_PROJ4_STRING = \"+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs\"\n        \n        edges = ox.graph_to_gdfs(G, nodes = False, edges = True)\n        \n        edges_meter = edges.to_crs(ECKERT_IV_PROJ4_STRING)\n        \n        edges_meter = edges_meter.geometry.buffer(self.buffer) \n        \n        edges_meter = edges_meter.to_crs({'init' :'epsg:4326'})\n        \n        streets_net = gpd.GeoDataFrame(edges_meter.geometry)\n        \n        streets_net.columns = ['geometry']\n        \n        streets_net.crs = {'init' :'epsg:4326'}\n        \n        streets_net.to_file(name + '.json', driver = 'GeoJSON')\n        \n    \n    def save_toPickle(self, G, intersections, streets, name):\n                \n        with open( str(name) + '.pkl', 'wb') as f:\n            \n            pickle.dump([G, intersections, streets], f)\n        \n     ","3cdd4725":"query_overpass = '[\"highway\"~\"motorway|motorway_link|primary|primary_link|secondary|secondary_link|tertiary|tertiary_link|trunk_link\"]'\n\narea = 'Brussels Capital Region, Belgium'\n\ntype_ = 'none'\n\nbuffer = 4.5\n\ng = G_fromOSM(area, type_, query_overpass, buffer)\n\nG = g.retrieve()","f8a6b1e2":"intersections, streets = g.deconstruct(G)","2c4d61b5":"intersections.head(5)","7943da71":"streets.head(5)","15267f84":"g.vis_BW(G, node_size = 10,  edge_width = 0.5)","46f2adfd":"g.vis_FOLIUM(G, node_size = 10, edge_width = 0.5)","5e88e48d":"g.save_toGeoJSON(G, 'Bruxelles_streets')","24794ce4":"g.save_toPickle(G, intersections, streets, 'Bruxelles_streets')","fd20623f":"def clean_name_street(row):\n\n    if type(row) == str:\n        \n        if row.find(\"-\") != -1 :\n            \n            name = re.search('(?<=-)(.*)', row).groups()[0]\n            \n        else:\n            \n            name = row\n\n    elif type(row) == list:\n        \n        if row[0].find(\"-\") != -1 :\n            \n            name = re.search('(?<=-)(.*)', row[0]).groups()[0]\n            \n        else:\n            \n            name = row[0]\n\n    else:\n        \n        name = 'none'\n\n    return name","ddfcb4f9":"def consecutive_streets( fix, roll ):\n    \n    # 1: beginning street\n    \n    # 2: end street\n    \n    if (fix[1] == roll[2]) and (fix[2] == roll[1]):\n\n            u_1 = str(roll[0])\n            v_1 = str(fix[0])\n                        \n            u_2 = str(fix[0])\n            v_2 = str(roll[0])\n            \n\n\n    elif (fix[1] == roll[2]) and (fix[2] != roll[1]): \n\n            u_1 = str(roll[0])\n            v_1 = str(fix[0])\n            \n            u_2 = 'no consecutive'\n            v_2 = 'no consecutive'\n            \n                        \n            \n    elif (fix[1] != roll[2]) and (fix[2] == roll[1]): \n\n            u_1 = str(fix[0])\n            v_1 = str(roll[0])\n            \n            u_2 = 'no consecutive'\n            v_2 = 'no consecutive'\n            \n                               \n    else:\n\n            u_1 = 'no consecutive'\n            v_1 = 'no consecutive'\n            \n            u_2 = 'no consecutive'\n            v_2 = 'no consecutive'\n            \n            \n    return  u_1, v_1, u_2, v_2 ","a431721f":"def build_df_graph(DF):\n    \n    u_list = [ ]\n    v_list = [ ]\n    \n#     weight_list = [ ]\n\n    df = DF[ [ 'node', 'first', 'last']].values\n\n    for i in tqdm( range( len( df))):\n\n        df_iter = df[ i + 1: , : ]\n\n        fixed_row = df[ i , : ]\n\n        for k in range( len( df_iter)):\n\n            roll_row = df_iter[ k ]\n\n            u_1, v_1, u_2, v_2 = consecutive_streets( fixed_row, roll_row )\n\n            u_list.extend([ u_1, u_2 ])\n            v_list.extend([ v_1, v_2 ])\n            \n    df_u = pd.DataFrame( u_list, columns = ['u'])\n    df_v = pd.DataFrame( v_list, columns = ['v'])\n    \n    # df_weight = pd.DataFrame (weight_list,columns=['weight'])\n    # df_union = pd.concat([df_u ,df_v, df_weight], axis=1)\n\n    dfg = pd.concat( [ df_u, df_v ], axis=1)\n    \n    dfg = dfg[ dfg.u != 'no consecutive']\n    \n    return dfg","a4219b13":"class G_forGCN:\n    \n    def __init__( self, streets ):\n        \n        self.streets = streets\n                \n        \n    def prepare_streets_DF( self ):\n        \n        # first and last gps point in street segment \n        \n        first_points = [ Point( self.streets.iloc[ row ].geometry.coords[0] ) for row in range(len( self.streets )) ]\n        \n        end_points = [ Point( self.streets.iloc[ row ].geometry.coords[-1] ) for row in range(len( self.streets )) ]\n\n        self.streets['first'] = [ Point( x.coords[0][1], x.coords[0][0] ) for x in first_points ]\n        \n        self.streets['last'] = [ Point( x.coords[0][1], x.coords[0][0] ) for x in end_points ]\n        \n        \n        # midpoint in street segment\n        \n        list_streets = [ list( x.coords ) for x in list( self.streets.geometry ) ]\n        \n        list_midpoint = [ list_streets[ i ][ int( len(list_streets[i])\/2 ) ] for i in range( len( list_streets ) ) ]\n        \n        self.streets['midpoint'] = [ ( x[1], x[0] ) for x in list_midpoint]\n        \n        \n        # create a list of clean street names\n        \n        list_ = [clean_name_street(row) for row in self.streets['name']]\n        \n        # count consecutive street segments with same name\n        \n        self.streets['street_name'] = [row + '_' + str(list_[:index].count(row))  if row in list_[:index] else row for index, row in enumerate(list_)]\n\n        \n        # select df columns\n        \n        streets_df = self.streets.reset_index()\n        \n        streets_df['node'] = streets_df[ 'index' ].astype( str ) + '_' + streets_df[ 'u' ].astype( str )  + '_' + streets_df[ 'v' ].astype( str )\n        \n        streets_df = streets_df[[ 'node', 'first', 'last', 'oneway', 'highway', 'street_name', 'midpoint', 'geometry', 'length' ]]\n\n        return streets_df\n    \n  \n    def build_graph_DF(self, streets_df, with_type, with_attr):\n        \n        df_streets = self.prepare_streets_DF()\n        \n        dfg = build_df_graph(df_streets)\n        \n        df_graph = dfg[[ 'u', 'v' ]]\n        \n        G = nx.Graph()\n        \n        if with_type == 'direct':\n            \n            G = nx.from_pandas_edgelist( df_graph, 'u', 'v', create_using = nx.DiGraph() )\n            \n            components = [G.subgraph(c).copy() for c in nx.weakly_connected_components(G)] \n            \n            for idx, g in enumerate(components, start=1):\n    \n                print(f\"subgraph {idx}\")\n\n            G_ = components[0]\n            \n        else:\n            \n            G = nx.from_pandas_edgelist(df_graph, 'u', 'v')\n            \n            components = [G.subgraph(c).copy() for c in nx.connected_components(G)]\n            \n            G_ = components[0]\n            \n        \n#         if set(streets_df['node']) != set(G_.nodes):\n    \n        streets_df = streets_df[streets_df['node'].isin(list(G_.nodes))] \n\n        streets_graph = list(streets_df.geometry)\n\n#             streets = streets[ streets['geometry'].isin( streets_graph ) ]\n                \n        \n        \n        if with_attr == False:\n            \n            return streets_graph, df_graph, G_\n        \n        \n        else:\n            \n            position_attr = {}\n\n            for node in streets_df.values: \n\n                position_attr[node[0]] = node[-3][::-1]\n\n            nx.set_node_attributes(G_, position_attr, 'pos')\n\n\n            # --------------------------------------\n\n            type_street_attr = {}\n\n            for node in streets_df.values: # Loop through the list, one row at a time\n\n                if type(node[-5]) == list:\n\n                    type_street_attr[node[0]] = node[-5][1]\n\n                else:\n\n                    type_street_attr[node[0]] = node[-5]\n\n            nx.set_node_attributes(G_, type_street_attr, 'type_street')\n\n\n            # --------------------------------------\n\n            one_way_attr = {}\n\n            for node in streets_df.values: \n\n                one_way_attr[node[0]] = node[-6]\n\n            nx.set_node_attributes(G_, one_way_attr, 'one_way')\n\n\n            # --------------------------------------\n\n            relabeling = {}\n\n            for node in streets_df.values: \n\n                relabeling[node[0]] = node[-4]\n\n            H = nx.relabel_nodes(G_, relabeling)\n\n            return streets_graph, df_graph, H\n        \n        \n    def extract_Adjancency(self, H_):\n        \n        A_ = nx.to_numpy_matrix(H_)\n        \n        return A_\n    \n    \n    def save_Gr_Adj_toPickle(self, H_, A_, name):\n        \n        with open( str(name) + '.pkl', 'wb') as f:\n            \n            pickle.dump([H_, A_], f)\n            \n\n        ","9b08aa17":"g = G_forGCN( streets )\n\ndf_streets = g.prepare_streets_DF()\n\ndf_streets.head()","b26e52e8":"streets_graph, df_graph, H = g.build_graph_DF(df_streets, with_type = 'direct', with_attr = True)\n\npos = nx.get_node_attributes( H, 'pos')\n\nplt.figure( figsize=(20, 20) )\n\nnx.draw( H, pos = pos, node_size = 50)\n\nplt.show()","3da39e4d":"streets_graph_undir, df_graph_undir, H_undir = g.build_graph_DF(df_streets, with_type = 'undirect', with_attr = True)\n\npos = nx.get_node_attributes( H_undir, 'pos')\n\nplt.figure( figsize=(20, 20) )\n\nnx.draw( H_undir, pos = pos, node_size = 50)\n\nplt.show()","a5e7c973":"streets = streets[streets['geometry'].isin( streets_graph_undir ) ]\n    \nprint(streets.shape[0])\n\nprint(' ')\n\nprint(len(streets_graph_undir))\n\n\nplt.figure(figsize=(30, 30))\n\nstreets['geometry'].plot(figsize=(30, 30), color='gold')\n\nNode = nx.draw_networkx_nodes(H_undir, pos,  node_size=20, node_color=\"blue\")\n\nEdges = nx.draw_networkx_edges(H_undir, pos, node_size=20, arrowstyle=\"->\", arrowsize=10)\n\n# Labels = nx.draw_networkx_labels(H, pos)\n\nplt.show()","82dd23bc":"def visualize_attr_graph( H_undir, attr, nodes_size, w, h ):\n    \n    viz = hvnx.draw(H_undir, pos = pos, font_size = nodes_size, node_color = attr, cmap = 'Category10', width = w, height = h) \n    \n    return viz \n ","506b818a":"visualize_attr_graph( H_undir, 'type_street', nodes_size = '5pt', w = 1000, h = 1000)","76dca1c8":"visualize_attr_graph( H_undir, 'one_way', nodes_size = '5pt', w = 1000, h = 1000)","5c811c5b":"from shapely.ops import transform\n\n# from shapely.geometry import Point, LineString\n\n# >>> LineString([Point(0, 0), Point(1, 1)]).wkt\n\n\nlist_point = [Point(coord) for coord in list(pos.values())]\n\nlatlon = list(pos.values())\n\nlist_street_name = list(H_undir.nodes.keys())\n\nlist_streets_inv = list(streets['geometry'])\n\nlist_streets = [transform(lambda x, y: (y, x), list_streets_inv[i]) for i in range(len(list_streets_inv))]\n\nmapit = folium.Map( location = [50.830144, 4.340218], zoom_start = 16)\n\nt=0\n\nfor coord in list_point:\n    \n    folium.Circle( location = [coord.y, coord.x], fill_color='red', radius=10 ).add_child(folium.Popup(list_street_name[t])).add_to( mapit ) #.\n    \n    t = t+1\n    \nfor line in list_streets:\n    \n    folium.PolyLine( locations = line.coords, weight=5).add_to( mapit )\n    \n    \n\nmapit","c5f585a8":"Adj = g.extract_Adjancency(H_undir)","45228b69":"g.save_Gr_Adj_toPickle(H_undir, Adj, 'Graph_Adjancency')","26de70a8":"## visualize the road network on Folium with OSMNX","4a83886b":"## visualize nodes representing street segments on Folium","fa344a21":"## Save graph to Geojson","e13381a6":"## visualize retrieved road network from OSM with OSMNX","dc6770c5":"## Build a new graph for the road network: nodes represent street segment and edges the connections between streets.\n## This is useful to encode traffic features and use Deep Learning.","40fe6963":"## Save graph and related adjancency matrix to Pickle","2c1cdfba":"# Retrieve Streets Network with OSMNX from OSM","9b04e570":"## visualize graph with 'type of street' attribute","43dee9c8":"## Extract Adjancency Matrix","ba673d92":"## visualize graph with 'one way' attribute","5b672378":"## build direct graph","fc979345":"#### General Import","555b0957":"## build undirect graph","eee91bd8":"## Save graph to Pickle","a9b8c903":"## Road network graph representation for Deep Learning."}}