{"cell_type":{"1da78878":"code","9880feec":"code","99d26a47":"code","a484cffc":"code","7b16e12b":"code","2d1ac38e":"code","6b371e92":"code","64be0621":"code","091ba10e":"code","90e9b6cd":"code","b5ac1394":"code","c5753007":"code","c05267c3":"code","c6580b3b":"code","653dc02d":"code","751c046e":"code","f7ccf3a9":"code","c6f6987e":"code","b48b7de0":"code","080e5a88":"code","9707a371":"code","39e97f97":"code","402fc90b":"code","239b1a1c":"code","bbf4822a":"code","eceed2d7":"code","bbe262e9":"code","8d5a8942":"code","014c95d7":"code","68d9a6fc":"code","00ae7d2d":"code","dcfdd62d":"code","a7e9f66d":"code","1369e120":"code","18d84b8c":"code","abc180d3":"code","3a3de5e3":"code","2b41b003":"code","c1460296":"code","4cfaed27":"code","5739adc4":"code","448f4632":"code","6f786eca":"code","199ba6bf":"code","989efef9":"code","1f6c751b":"code","18c7ffcf":"code","879c6835":"code","ee3eafe3":"code","d7dc088f":"code","cae1475a":"markdown","67e3e8a7":"markdown","e2103eeb":"markdown","4f067027":"markdown","683aeab6":"markdown","5f1f1cd4":"markdown","5bf8e9d2":"markdown","5f9179b0":"markdown","27f472fb":"markdown","6c64c795":"markdown","0ce97bc6":"markdown","fa2ce813":"markdown","43aff2f5":"markdown","32cd9de4":"markdown","f36e2c7d":"markdown","799d3543":"markdown","19ad8ed6":"markdown","1aad0a95":"markdown","eac552d2":"markdown","b368eefd":"markdown","09b74d3e":"markdown","084c2f58":"markdown","208a1a57":"markdown","7b64a809":"markdown","2c2560d2":"markdown","01bc0d31":"markdown","40206ef8":"markdown","4fa256a8":"markdown","d6dfe0c5":"markdown","37cf140f":"markdown","52dcb45d":"markdown","7746ae91":"markdown"},"source":{"1da78878":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\n\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","9880feec":"# Importing required libraries\n\nimport os\nimport re\nimport warnings\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom itertools import product, combinations\n\nfrom sklearn.preprocessing import StandardScaler\n\nfrom sklearn.linear_model import LogisticRegression\n\nfrom sklearn.metrics import f1_score # Will use for validation of our model by prediction throgh various models\n","99d26a47":"# Setting important options to make visualization easier\n\npd.set_option('display.max_rows', 400)\npd.set_option('display.max_columns', 160)\npd.set_option('display.max_colwidth', 40)\npd.set_option('display.max_columns', None)\n\nwarnings.filterwarnings(\"ignore\")\n","a484cffc":"base_path = \"\/kaggle\/input\/ncaam-march-mania-2021\/MDataFiles_Stage1\/\"\n\nfor filename in os.listdir(base_path):\n    print(filename)","7b16e12b":"# Import basic datasets to get started on a base model\n# We will skip using the regular tournamen data for the base model\n# Teams.csv, MSeasons.csv, MNCAATourneySeeds.csv, MRegularSeasonCompactResults.csv, MNCAATourneyCompactResults.csv, MSampleSubmissionStage1.csv\n\nteams = pd.read_csv(base_path + \"MTeams.csv\")\nseasons = pd.read_csv(base_path + \"MSeasons.csv\")\nseeds = pd.read_csv(base_path + \"MNCAATourneySeeds.csv\")\nresults = pd.read_csv(base_path + \"MNCAATourneyCompactResults.csv\")\nregular_results = pd.read_csv(base_path + \"MRegularSeasonCompactResults.csv\")\n\nsample = pd.read_csv(base_path + \"MSampleSubmissionStage1.csv\")\n\nlist_datasets = [teams, seasons, seeds, results,regular_results, sample]\n\nstring_list_datasets = ['teams', 'seasons', 'seeds', 'results', 'regular_results','sample']","2d1ac38e":"for i, dataset in enumerate(list_datasets):\n    print(string_list_datasets[i])\n    print(\"\\n\")\n    print(dataset.head())\n    print(\"\\n\")\n    print(dataset.tail())\n    print(\"\\n\\n\\n\")","6b371e92":"for i, dataset in enumerate(list_datasets):\n    print(string_list_datasets[i])\n    display(dataset.describe())","64be0621":"all_teams = teams['TeamID'].unique()\nall_seeds = seeds['Seed'].unique()\nall_years = results['Season'].unique()\n","091ba10e":"# We will focus on just 1 main dataset.. i.e. results dataset for first pass at baseline\n\ndf = regular_results","90e9b6cd":"# Create a score gap variable\n\ndf['ScoreGap'] = df['WScore'] - df['LScore']","b5ac1394":"def rollup_df(base_df,rollup_cols,aggregation):\n    temp = base_df.groupby(rollup_cols).agg(aggregation)\n    temp = temp.reset_index()\n    return temp","c5753007":"# Get number of wins and losses per year per team\n\nnum_wins = rollup_df(df,['Season','WTeamID'],{'DayNum':'count','WScore':'mean','ScoreGap':'mean'})\n\nnum_wins = num_wins.rename(columns = {'WTeamID':'TeamID','DayNum':'num_wins','WScore':'WScore_avg','ScoreGap':'WScoreGap_avg'})\n\nnum_loss = rollup_df(df,['Season','LTeamID'],{'DayNum':'count','LScore':'mean','ScoreGap':'mean'})\n\nnum_loss = num_loss.rename(columns = {'LTeamID':'TeamID','DayNum':'num_loss','LScore':'LScore_avg','ScoreGap':'LScoreGap_avg'})\n","c05267c3":"num_loss","c6580b3b":"# Create set with all possible combos of season and teams\n\ndf_feat_merged = num_wins[['Season','TeamID']].append(num_loss[['Season','TeamID']])\n\ndf_feat_merged = df_feat_merged.drop_duplicates().reset_index().drop(['index'],axis = 1)","653dc02d":"df_feat_1 = pd.merge(df_feat_merged,num_wins, on = ['Season','TeamID'], how = 'left')\ndf_feat_2 = pd.merge(df_feat_1,num_loss, on = ['Season','TeamID'], how = 'left')\n\ndf_feat_2 = df_feat_2.fillna(0)","751c046e":"df_feat_2.head()","f7ccf3a9":"df_feat_final = df_feat_2\n\ndf_feat_final['WinRatio'] = df_feat_final['num_wins']\/(df_feat_final['num_wins'] + df_feat_final['num_loss'])\n\ndf_feat_final['total_win_gap'] = df_feat_final['WScore_avg']* df_feat_final['num_wins']\n\ndf_feat_final['total_lose_gap'] = df_feat_final['LScore_avg']* df_feat_final['num_loss']\n                                  \ndf_feat_final['ScoreGapAvg'] = (df_feat_final['total_win_gap'] - df_feat_final['total_lose_gap'])\/(df_feat_final['num_wins'] + df_feat_final['num_loss']) \n\n","c6f6987e":"df_feat_final = df_feat_final.drop(['num_wins','num_loss','total_win_gap','total_lose_gap','WScoreGap_avg','LScoreGap_avg'],axis = 1)","b48b7de0":"df_feat_final.head(5)\ndf_feat_final.tail(5)","080e5a88":"df_reg_season_feat = df_feat_final.copy()","9707a371":"df = results\n\ndf = df.drop(columns = ['WLoc','NumOT'], axis = 1)","39e97f97":"df = pd.merge(\n    df,\n    seeds,\n    how = 'left',\n    left_on=['Season','WTeamID'],\n    right_on = ['Season','TeamID']).drop(columns = ['TeamID'],axis = 1).rename(columns = {'Seed':'WSeed'})","402fc90b":"df = pd.merge(\n    df,\n    seeds,\n    how = 'left',\n    left_on=['Season','LTeamID'],\n    right_on = ['Season','TeamID']\n    ).drop(columns = ['TeamID'],axis = 1).rename(columns = {'Seed':'LSeed'})","239b1a1c":"def clean_seed(seed):\n    return int(re.sub(\"[^0-9]\",\"\",seed))","bbf4822a":"df['LSeed'] = df['LSeed'].apply(clean_seed)\ndf['WSeed'] = df['WSeed'].apply(clean_seed)\n","eceed2d7":"df.head()","bbe262e9":"df_reg_season_feat.head()\ndf_reg_season_feat.columns.values","8d5a8942":"df = pd.merge(df,\n             df_reg_season_feat,\n             how = 'left',\n             left_on = ['Season','WTeamID'],\n             right_on = ['Season','TeamID'],\n             ).rename(columns = \n                      {'WScore_avg':'WScore_avg_W', \n                       'LScore_avg':'LScore_avg_W',\n                       'WinRatio':'WinRatio_W',\n                       'ScoreGapAvg':'ScoreGapAvg_W'}\n                     ).drop(['TeamID'],axis = 1)","014c95d7":"df = pd.merge(df,\n             df_reg_season_feat,\n             how = 'left',\n             left_on = ['Season','WTeamID'],\n             right_on = ['Season','TeamID'],\n             ).rename(columns = \n                      {'WScore_avg':'WScore_avg_L', \n                       'LScore_avg':'LScore_avg_L',\n                       'WinRatio':'WinRatio_L',\n                       'ScoreGapAvg':'ScoreGapAvg_L'}\n                     ).drop(['TeamID'],axis = 1)","68d9a6fc":"df.head()","00ae7d2d":"# Rename winning team identifiers as A and losing as B\nwin_rename = {'WTeamID':'TeamID_A',\n              'WScore':'Score_A',\n              'LTeamID':'TeamID_B',\n              'LScore':'Score_B',\n              'WSeed':'Seed_A',\n              'LSeed':'Seed_B',\n              'WScore_avg_W':'WScore_avg_A',\n              'LScore_avg_W':'LScore_avg_A',\n              'WinRatio_W':'WinRatio_A',\n              'ScoreGapAvg_W':'ScoreGapAvg_A',\n              'WScore_avg_L':'WScore_avg_B',\n              'LScore_avg_L':'LScore_avg_B',\n              'WinRatio_L':'WinRatio_B',\n              'ScoreGapAvg_L':'ScoreGapAvg_B'}\n\n# Rename losing team identifiers as A and winning as B\nlose_rename = {'WTeamID':'TeamID_B',\n              'WScore':'Score_B',\n              'LTeamID':'TeamID_A',\n              'LScore':'Score_A',\n              'WSeed':'Seed_B',\n              'LSeed':'Seed_A',\n              'WScore_avg_W':'WScore_avg_B',\n              'LScore_avg_W':'LScore_avg_B',\n              'WinRatio_W':'WinRatio_B',\n              'ScoreGapAvg_W':'ScoreGapAvg_B',\n              'WScore_avg_L':'WScore_avg_A',\n              'LScore_avg_L':'LScore_avg_A',\n              'WinRatio_L':'WinRatio_A',\n              'ScoreGapAvg_L':'ScoreGapAvg_A'}","dcfdd62d":"win_df = df.copy()\nwin_df = win_df.rename(columns = win_rename)\n\nlose_df = df.copy()\nlose_df = lose_df.rename(columns = lose_rename)\n\nfinal_df = pd.concat([win_df,lose_df], axis = 0).reset_index().drop(columns = ['index'])\n\nfinal_df['Win_A'] = final_df.apply(lambda x: 1 if x['Score_A'] > x['Score_B'] else 0, axis = 1)","a7e9f66d":"final_df","1369e120":"final_df['SeedDiff'] = final_df['Seed_A'] - final_df['Seed_B']\n\nfinal_df['ScoreGapDiff'] = final_df['ScoreGapAvg_A'] - final_df['ScoreGapAvg_B']\n\nfinal_df['WinRatioDiff'] = final_df['WinRatio_A'] - final_df['WinRatio_B']","18d84b8c":"sample.head()\n\ndf_test = sample.copy()","abc180d3":"df_test['Season'] = df_test['ID'].apply(lambda x: int(x.split('_')[0])) \n\ndf_test['TeamID_A'] = df_test['ID'].apply(lambda x: int(x.split('_')[1])) \n\ndf_test['TeamID_B'] = df_test['ID'].apply(lambda x: int(x.split('_')[2])) ","3a3de5e3":"df_test = pd.merge(df_test,\n                  seeds,\n                  how = 'left',\n                  left_on = ['Season','TeamID_A'],\n                  right_on = ['Season','TeamID']\n                  ).rename(columns = {'Seed':'Seed_A'}).drop(['TeamID'], axis = 1) ","2b41b003":"df_test = pd.merge(df_test,\n                  seeds,\n                  how = 'left',\n                  left_on = ['Season','TeamID_B'],\n                  right_on = ['Season','TeamID']\n                  ).rename(columns = {'Seed':'Seed_B'}).drop(['TeamID'], axis = 1) ","c1460296":"df_test['Seed_A'] = df_test['Seed_A'].apply(clean_seed)\ndf_test['Seed_B'] = df_test['Seed_B'].apply(clean_seed)","4cfaed27":"df_test['SeedDiff'] = df_test['Seed_A'] - df_test['Seed_B']","5739adc4":"df_test = pd.merge(df_test,\n             df_reg_season_feat,\n             how = 'left',\n             left_on = ['Season','TeamID_A'],\n             right_on = ['Season','TeamID'],\n             ).rename(columns = \n                      {'WScore_avg':'WScore_avg_A', \n                       'LScore_avg':'LScore_avg_A',\n                       'WinRatio':'WinRatio_A',\n                       'ScoreGapAvg':'ScoreGapAvg_A'}\n                     ).drop(['TeamID'],axis = 1)","448f4632":"df_test = pd.merge(df_test,\n             df_reg_season_feat,\n             how = 'left',\n             left_on = ['Season','TeamID_B'],\n             right_on = ['Season','TeamID'],\n             ).rename(columns = \n                      {'WScore_avg':'WScore_avg_B', \n                       'LScore_avg':'LScore_avg_B',\n                       'WinRatio':'WinRatio_B',\n                       'ScoreGapAvg':'ScoreGapAvg_B'}\n                     ).drop(['TeamID'],axis = 1)","6f786eca":"df_test['SeedDiff'] = df_test['Seed_A'] - df_test['Seed_B']\n\ndf_test['ScoreGapDiff'] = df_test['ScoreGapAvg_A'] - df_test['ScoreGapAvg_B']\n\ndf_test['WinRatioDiff'] = df_test['WinRatio_A'] - df_test['WinRatio_B']","199ba6bf":"print(final_df.columns.values)\n\nprint(final_df.Season.unique())\n","989efef9":"features = [\n    'Seed_A',\n    'Seed_B',\n    'WinRatio_A',\n    'ScoreGapAvg_A',\n    'WinRatio_B',\n    'ScoreGapAvg_B',\n    'SeedDiff',\n    'WinRatioDiff',\n    'ScoreGapDiff']","1f6c751b":"final_df\ndf_test","18c7ffcf":"seasons = final_df.Season.unique()    \n\nf_score = [] # Store the season and the f-score for predictions.\npredictions = [] # Store the predictions on test set based on all intermediate models. We will average the predictions\n\nSEED = 11\n\nfor season_yr in seasons[10:]:\n    \n    model = LogisticRegression(C = 10, random_state=SEED)\n    \n    std_scaler = StandardScaler()\n    \n    train_X = final_df.loc[final_df['Season'] < season_yr,features]\n    val_X = final_df.loc[final_df['Season'] == season_yr,features]\n    \n    train_y = final_df.loc[final_df['Season'] < season_yr, ['Win_A']]\n    val_y = final_df.loc[final_df['Season'] == season_yr, ['Win_A']]\n    \n    train_X = std_scaler.fit_transform(train_X)\n    val_X = std_scaler.transform(val_X)\n    test_X = std_scaler.transform(df_test[features])\n    \n    model.fit(train_X, train_y)\n    \n    pred_y = model.predict(val_X)\n    \n    f_score.append([season_yr, f1_score(val_y, pred_y)])\n    \n    test_y = model.predict_proba(test_X)[:,1]\n    \n    predictions.append(test_y)\n    \npredictions = np.vstack(predictions).transpose()","879c6835":"exp_df = pd.DataFrame(predictions)\n\nexp_df.to_csv('.\/temp.csv')","ee3eafe3":"f_score\n#pred_y\n#predictions.shape\n","d7dc088f":"results = np.mean(predictions,axis = 1)\nsubmission = df_test.loc[:,['ID']]\n\nsubmission['Pred'] = results\n\nsubmission.to_csv('submission.csv', index=False)","cae1475a":"# Validate model via k-fold validations \n\nWe use older seasons to predict model output for next season and check score ","67e3e8a7":"## Base list creation\n\nWe need to predict for 2015 to 2019 seasons.\nWe can create a dataset containing all years, all team combinations on which we can keep adding features","e2103eeb":"Join match seeds as we will use this dataset as base for our predictions","4f067027":"### Merge the NCAA results with season features we made previously","683aeab6":"## Set useful options \n\nSetting display options for pandas dataframe to make visualization easier in notebook","5f1f1cd4":"# Importing important libraries\n\nImport statements for all libraries used throughout the code","5bf8e9d2":"Remove the regions from seeds. We wont need the regions in seeds for our model","5f9179b0":"### Drop columns from dataset\n\nWe will drop few columns which cannot be considered as features for final predictions.\ni.e. num_wins, num_loss, Score Gaps","27f472fb":"Clean seeds","6c64c795":"Create a score gap variable by Winning score - Losing score","0ce97bc6":"### Dataset comments\n\n0. regular_results:\n    - has non-NCAA results starting from 1985 until 2019\n    - We can use this to create few metrics that can support our model. All features can be siilar to ones made for NCAA as data format is same\n    - Wloc and NumOT can be safely removed as it might create significant bias in model and we have no way of predicting if some team will run into an overtime\n1. results:\n    - has NCAA results starting from 1985 until 2019\n    - We can directly use this to evaluate our model since task is to predict 2015 to 2019 matches\n    - Wloc and NumOT can be safely removed as it might create significant bias in model and we have no way of predicting if some team will run into an overtime\n2. teams:\n    - Has Team Ids and their respecitve years for first tournament match played\n    - Can be used to calculate age of teams. It might help our model to factor in experience of the team into results\n\n3. seasons:\n    - Has start dates and region areas mentioned\n    - We can safely ignore this dataset as results already have a standardized date variable\n\n4. Seeds:\n    - Has the seed information for the teams per season.\n    - Since it directly correlates with the round of play, we may provide it as a factor which can account for player exhaustion\n\n5. sample:\n    - Sample submission.\n    - We can use this file as base for creating our model dataframe and test models on it","fa2ce813":"Join match Seeds","43aff2f5":"### Function for quick rollups","32cd9de4":"### Join previously created features for each team\n\nHere, we make a single consistent dataset with appropriate wins\/loss values attached to each team","f36e2c7d":"Since our data only has winning teams as base, we need to create a general dataset which has winning and losing teams both in same columns.\n\nWe will duplicate the dataframe and swap winning and losing rows for this","799d3543":"Get # of wins, avg score and avg. score gap for eac set of winnng and losing teams","19ad8ed6":"# EDA and feature creation\n\nMain focus is on using results table to generate basic variables\n\nFollowing variables will be created:\n1. Avg. wins\/loss per team per season\n2. Avg. Score for win\/lose team per team per season\n3. Avg. Score gap","1aad0a95":"## Visualize the datasets\n\nPrint top 5 rows to get general idea of datasets\n\nAlso, generate summary of datasets for few preliminary observations","eac552d2":"### COmpute difference b\/w team A and team B\n\nWe will compute difference feature as it will help us assess if A is worse\/better than B","b368eefd":"## Generate similar variables based on regular season results\n\nWe will use dtaa for matches played before actual NCAA tournaments for computing similar features","09b74d3e":"all_teams = teams['TeamID'].unique()\nall_seeds = seeds['Seed'].unique()\nall_years = results['Season'].unique()\n\nprint(\"# of seeds: n = %d\\n\" % len(all_seeds))\n\nprint(\"# of teams: n = %d\\n\" % len(all_teams))\n\nprint(\"years: %d to %d \\n\" % (min(all_years),max(all_years)))\n\n# Create base file with IDs in required format\n\nbase_team_matchups =list(combinations(all_teams, 2))\n\nprint(\"Combinations array: \\n\")\nprint(base_team_matchups[1:10])","084c2f58":"# Create base dataframe with all teams and the created variables\n\nWe remove distinction b\/w winning and losing teams and join all features.\nSince same team can have won and lost match, we can deduplicate to ensure we have 1 entry per team per season\n","208a1a57":"### Join Season stats","7b64a809":"Split out the team ID and Season year","2c2560d2":"# Build test\/submission dataset","01bc0d31":"# Before I start off\n\nKudos to @theoviel (https:\/\/www.kaggle.com\/theoviel\/ncaa-starter-the-simpler-the-better) for the reference code notebook.\n\nI am trying to learnhow to solve these problems and these simple implementations really help me practice my python and help me in implementation in case I get lost","40206ef8":"Creating copies of required datasets to make it easier to process","4fa256a8":"# Preprocessing and creating base lists\n\nWe will be using datasets to understand participating teams, regions, etc and creating submission file based on all possible team combinations for predictions","d6dfe0c5":"## Using NCAA compact results to generate features based on the tournament","37cf140f":"# Importing datasets\n\nImport required datasets for stage 1 competition\n\nWe will mainly focus on results and seeds for base set of predictions\n","52dcb45d":"# Initial setup\n\nKaggle setup for listing directories and files available","7746ae91":"## Computing features based on wins and losses\n\nWe compute a ratio of # of wins for the team in the specific season\n\nAlso, we will average out the score gap by using # of wins and win score gap (vice versa for losing score) and establish a general score gap team establishes in each season"}}