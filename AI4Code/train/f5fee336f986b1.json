{"cell_type":{"f66c3f40":"code","3bab15a6":"code","aac9e668":"code","13e322d0":"code","6944e3f4":"code","3ae6d25d":"code","558e1b29":"code","aa14a2e6":"code","8b4328e0":"code","a6e93a1a":"code","a667fe8a":"code","bbd3355b":"markdown","efcb91e5":"markdown","ee09b8d0":"markdown","779a45b6":"markdown","0e8aca27":"markdown"},"source":{"f66c3f40":"import pandas as pd","3bab15a6":"# This will be an helper method to re-use the code between train and test set\n\nclass Household():\n    def __init__(self, individuals): \n        self.individuals = individuals\n        self.grouped_individuals = individuals.groupby('idhogar')\n        self.household = pd.DataFrame()\n\n    def add_SQBedjefe(self):\n        self.household['SQBedjefe'] = self.grouped_individuals.SQBedjefe.mean()\n        \n    def add_SQBdependency(self):\n        self.household['SQBdependency'] = self.grouped_individuals.SQBdependency.mean()\n        \n    def add_overcrowding(self):\n        self.household['overcrowding'] = self.grouped_individuals.overcrowding.mean()\n        \n    def add_qmobilephone(self):\n        self.household['qmobilephone'] = self.grouped_individuals.qmobilephone.mean()\n        \n    def add_rooms(self):\n        self.household['rooms'] = self.grouped_individuals.rooms.mean()\n        \n    def add_SQBhogar_nin(self):\n        self.household['SQBhogar_nin'] = self.grouped_individuals.SQBhogar_nin.mean()\n        \n    def add_Target(self):\n        self.household['Target'] = self.grouped_individuals.Target.mean().round().astype(int)","aac9e668":"# Build dataset on Household level.\nindividuals = pd.read_csv('..\/input\/train.csv')\ntrain = Household(individuals)\n\ntrain.add_SQBedjefe()\ntrain.add_SQBdependency()\ntrain.add_overcrowding()\ntrain.add_qmobilephone()\ntrain.add_rooms()\ntrain.add_SQBhogar_nin()\ntrain.add_Target()","13e322d0":"X = train.household.loc[:, train.household.columns != 'Target']\ny = train.household.Target\n\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_valid, y_train, y_valid = train_test_split(X, y, random_state=112, test_size=0.2)","6944e3f4":"from sklearn.ensemble import RandomForestClassifier\n\nclf= RandomForestClassifier()\nclf.fit(X_train, y_train)","3ae6d25d":"y_predict = clf.predict(X_valid)","558e1b29":"from sklearn.metrics import f1_score\n\nf1_score(y_valid, y_predict, average='macro')","aa14a2e6":"# Build test dataset on Household level\ndf_test = pd.read_csv('..\/input\/test.csv')\ntest = Household(df_test)\n\ntest.add_SQBedjefe()\ntest.add_SQBdependency()\ntest.add_overcrowding()\ntest.add_qmobilephone()\ntest.add_rooms()\ntest.add_SQBhogar_nin()","8b4328e0":"X_test = test.household\nX_test['Target'] = clf.predict(X_test)","a6e93a1a":"df_test['Target'] = None\n\ndef target(idhogar):\n    return X_test.Target[idhogar]\n\ndf_test['Target'] = df_test.idhogar.map(target)","a667fe8a":"df_test[['Id', 'Target']].to_csv('sample_submission.csv', index=False)","bbd3355b":"Now we need to copy the result on a household level to an individual level:","efcb91e5":"# Test model & export predictions","ee09b8d0":"# Train model & validate locally \nOn macro F1-score","779a45b6":"# How to reproduce macro F1-score locally\nAt the beginning of the challenge, Isaw lot of people having a different macro F1-score locally than the result given by Kaggle. I successfully got the same results. The key is to build a dataset on Household level, not on an individual level.","0e8aca27":"# First feature engineering\nOut of my notebook feature-selection (1), I am selecting the important features, that are already aggregated on a Household level. Improvements are definitivly possible.\n\n(1) https:\/\/www.kaggle.com\/gobert\/data-selection-with-randomforest"}}