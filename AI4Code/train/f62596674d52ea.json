{"cell_type":{"0a34a031":"code","72594357":"code","81a07708":"code","710cd6ab":"code","59ea821e":"code","b156f02c":"code","90b1d021":"code","a11aaaee":"code","e3b0ba2f":"code","bf77ca95":"code","7d609948":"code","353a2210":"code","25eea7af":"code","e7e6695c":"code","c7a356fb":"code","54d5e87a":"code","95e933af":"code","9e3b7e84":"code","bc475c26":"code","ee7de8c9":"code","84ba9438":"code","177a95ff":"code","f82be708":"code","ace66968":"code","af18511d":"markdown","2b26ddfa":"markdown","269e2cc7":"markdown","2336b112":"markdown","a789d545":"markdown","a18894a4":"markdown","403fb96b":"markdown","42850c17":"markdown","894164de":"markdown","977ade2b":"markdown","3e668ca7":"markdown","dd4f8fb1":"markdown","faf87988":"markdown","22a06780":"markdown","10fa7f55":"markdown","274aaa2f":"markdown","0c6eeb00":"markdown","ededf2f7":"markdown","c8f3c46c":"markdown","20f9ef66":"markdown","79a9a3b4":"markdown","fbbc2aee":"markdown","7db67c58":"markdown","93f3a4a1":"markdown","9793c861":"markdown","63a9bf5a":"markdown","38a53be2":"markdown","f473ef99":"markdown","413d89c0":"markdown","0ab5fc06":"markdown","48f5f19a":"markdown","3da6e39d":"markdown","453c1f12":"markdown","2f8a4221":"markdown","944cde34":"markdown","8460ecb6":"markdown","49c94373":"markdown","88c04703":"markdown","f5549260":"markdown","016c0528":"markdown","2f43503a":"markdown","dd29fdd0":"markdown","3c58441d":"markdown","8dc46a93":"markdown"},"source":{"0a34a031":"#Precisamos fazer o download do ambiente de Connect X:\n# Vamos precisar de um kaggle-enviroments customizado para a avalia\u00e7\u00e3o.\n!pip install git+https:\/\/github.com\/matheusgmaia\/kaggle-environments\n    ","72594357":"#Criar ambiente\nfrom kaggle_environments import evaluate, make, utils\npeca_my_algorithm = 1\npeca_algorithm_adv = 2\n\nenv = make(\"connectx\", debug=True)\nenv.render()","81a07708":"import numpy as np\nimport random \nimport math","710cd6ab":"AI = 1\nOPPONENT = 2\nNONE = 0\nWINDOW_SIZE = 4\nROW_LIMIT = 6\nCOL_LIMIT = 7","59ea821e":"def getValidColumns(table):\n    valid_columns = []\n    # percorre as colunas do tabuleiro\n    for col in range(table.shape[1]):\n        if table[0][col] == 0:\n            valid_columns.append(col)\n    #retorna uma lista com as colunas ainda dispon\u00edveis\n    return valid_columns","b156f02c":"def getRowAssociated(table,col):\n    actual_row = 0\n    #Percorre as linhas do tabuleiro com a coluna fixa\n    for row in np.arange(0,6,1):\n        if table[row][col] == 0:\n            actual_row = row\n    return actual_row","90b1d021":"def simulatePieceDrop(table,row,col,player):\n    table[row][col] = player\n    return table","a11aaaee":"def getPositiveDiagonal(table,row,col):\n    array = []\n    for index in range(WINDOW_SIZE):\n        # o indexador serve para percorrer os elementos da matriz de forma diagonal, aumentando uma unidade em rela\u00e7\u00e3o ao deslocamento anterior em ambas as dimens\u00f5es\n        array.append(table[row+index][col+index])\n    return np.array(array)","e3b0ba2f":"def getNegativeDiagonal(table,row,col):\n    array = []\n    for index in range(WINDOW_SIZE):\n        # o indexador serve para percorrer os elementos da matriz de forma diagonal, aumentando uma unidade em rela\u00e7\u00e3o ao deslocamento anterior na dimens\u00e3o da linha e \n        #diminuindo uma unidade na dimens\u00e3o das colunas (percurso da diagonal negativa)\n        array.append(table[row-index][col+index])\n    return np.array(array)","bf77ca95":"for index in range(WINDOW_SIZE):\n    print(index)","7d609948":"def getScore(elements):\n    window = list(elements)\n    score = 0\n    #-------------- ATAQUE ------------------\n    #Caso haja quatro pe\u00e7as referentes ao agente inteligente, a maior bonifica\u00e7\u00e3o deve ser atribu\u00edda a esta situa\u00e7\u00e3o. Essa seria a situa\u00e7\u00e3o de vit\u00f3ria\n    if window.count(AI) == 4:\n        score = 1000\n    #Se houver tr\u00eas pe\u00e7as associadas ao agente inteligente em sequencia e uma posi\u00e7\u00e3o vazia, significa que a bonifica\u00e7\u00e3o deve ser m\u00e9dia\n    elif (window.count(AI) == 3) and (window.count(NONE) == 1):\n        score = 250\n    #No caso de haver duas pe\u00e7as da IA em sequ\u00eancia na janela e uma posi\u00e7\u00e3o vazia, esta \u00e9 a menor das bonifica\u00e7\u00f5es\n    elif (window.count(AI) == 2) and (window.count(NONE == 2)):\n        score = 100\n    # ------------ DEFESA ------------------\n    # A l\u00f3gica de an\u00e1lise da janela aqui \u00e9 a mesma, mas punindo o agente em situa\u00e7\u00f5es que favore\u00e7am o oponente\n    elif (window.count(OPPONENT) == 4):\n        score = -2000\n    elif (window.count(OPPONENT) == 3) and (window.count(NONE) == 1):\n        score = -1000\n    elif (window.count(OPPONENT) == 2) and (window.count(NONE) == 2):\n        score = -300\n    return score","353a2210":"\ndef analyze(table):\n    score = 0\n    for row in range(ROW_LIMIT):\n        for col in range(COL_LIMIT):\n            #Teste vertical. S\u00f3 pode ir at\u00e9 a coluna central do tabuleiro, pois somente at\u00e9 ela \u00e9 poss\u00edvel selecionar 4 elementos em sequ\u00eancia\n            if col < COL_LIMIT - 3:\n                #seleciona uma janela de quatro elementos que corresponde a um vetor linha\n                horizontal =  table[row][col:col+4]\n                score = score + getScore(horizontal)\n            #Teste horizontal. S\u00f3 pode ir at\u00e9 a linha 2, j\u00e1 que somente at\u00e9 ela pode-se selecionar quatro elementos seguidos. \n            if row < ROW_LIMIT-3: \n                #pega um slice de quatro elementos na vertical\n                vertical = table[row:row+4,[col]]\n                #faz um transpose para transformar o array coluna\n                vertical = vertical.transpose()[0]\n                score = score + getScore(vertical)\n            #Teste da diagonal positiva. \u00c9 uma combina\u00e7\u00e3o das condi\u00e7\u00f5es anteriores que permite selecionar quatro elementos em sequ\u00eancia sem exceder os limites da matriz\n            if (col < COL_LIMIT - 3) & (row < ROW_LIMIT -3):\n                positive_diagonal =  getPositiveDiagonal(table,row,col)\n                score = score + getScore(positive_diagonal)\n            #Esta \u00e9 o inverso da anterior para ser poss\u00edvel analisar os elementos na diagonal positiva sem exceder os limites do tabuleiro.\n            if (row >=3) & (col<=3):\n                negative_diagonal = getNegativeDiagonal(table,row,col)\n                score = score + getScore(negative_diagonal)\n                \n    return score","25eea7af":"def getBestColumnToDrop(table,valid_columns):\n    max_score = -50000\n    #escolhe qualquer uma da lista s\u00f3 para servir de base para a troca\n    best_column = random.choice(valid_columns)\n    \n    for valid_column in valid_columns:\n        #chama a fun\u00e7\u00e3o que diz qual \u00e9 a linha associada \u00e0 coluna v\u00e1lida atual do la\u00e7o\n        row = getRowAssociated(table,valid_column)\n        table_simulated = table.copy()\n        #chama a fun\u00e7\u00e3o para simular o tabuleiro com a atual coluna v\u00e1lida e a linha. \n        table_simulated = simulatePieceDrop(table_simulated,row,valid_column,AI)\n        #chama a fun\u00e7\u00e3o para analisar o tabuleiro diante dessa jogada\n        temp_score = analyze(table_simulated)\n        #se a jogada atual resultar em uma pontua\u00e7\u00e3o melhor do que a anterior, a pontua\u00e7\u00e3o m\u00e1xima \u00e9 atualizada e a melhor coluna tamb\u00e9m.\n        if temp_score > max_score:\n            max_score = temp_score\n            best_column = valid_column\n    \n    return best_column","e7e6695c":"def isLastMove(table,player):\n    \n    for row in range(ROW_LIMIT):\n        for col in range(COL_LIMIT):\n            \n            #Teste vertical. S\u00f3 pode ir at\u00e9 a coluna central do tabuleiro, pois somente at\u00e9 ela \u00e9 poss\u00edvel selecionar 4 elementos em sequ\u00eancia\n            if col < COL_LIMIT - 3:\n                #seleciona uma janela de quatro elementos que corresponde a um vetor linha\n                horizontal =  table[row][col:col+4]\n                window = list(horizontal)\n                if window.count(player) == 4:\n                    return True\n                \n            #Teste horizontal. S\u00f3 pode ir at\u00e9 a linha 2, j\u00e1 que somente at\u00e9 ela pode-se selecionar quatro elementos seguidos. \n            if row < ROW_LIMIT-3: \n                #pega um slice de quatro elementos na vertical\n                vertical = table[row:row+4,[col]]\n                vertical = vertical.transpose()[0]\n                window = list(vertical)\n                if window.count(player) == 4:\n                    return True\n                \n            #Teste da diagonal positiva. \u00c9 uma combina\u00e7\u00e3o das condi\u00e7\u00f5es anteriores que permite selecionar quatro elementos em sequ\u00eancia sem exceder os limites da matriz\n            if (col < COL_LIMIT - 3) & (row < ROW_LIMIT -3):\n                positive_diagonal =  getPositiveDiagonal(table,row,col)\n                window = list(positive_diagonal)\n                if window.count(player) == 4:\n                    return True\n            #Esta \u00e9 o inverso da anterior para ser poss\u00edvel analisar os elementos na diagonal positiva sem exceder os limites do tabuleiro.\n            if (row >=3) & (col<=3):\n                negative_diagonal = getNegativeDiagonal(table,row,col)\n                window = list(negative_diagonal)\n                if window.count(player) == 4:\n                    return True\n    return False","c7a356fb":"def isLastNode(table):\n    return len(getValidColumns(table)) == 0 or isLastMove(table,AI) or isLastMove(table,OPPONENT)","54d5e87a":"def minimax(table, depth,alfa,beta, maximizing_player):\n    #testa se \u00e9 a ultima jogada de qualquer um dos jogadores ou se o tabuleiro j\u00e1 foi preenchido \n    if (isLastNode(table) == 1) or (depth==0):\n        #testa se eh o ultimo cenario possivel\n        if isLastNode(table) == 1:\n            #Caso haja 1 pe\u00e7a faltante da IA, isso indica que o jogo j\u00e1 foi ganho. A heur\u00edstica retorna um valor muito alto e nenhuma coluna\n            if isLastMove(table,AI):\n                return (None,+math.inf)\n            elif isLastMove(table,OPPONENT):\n                return (None,-math.inf)\n            else:\n                return (None,0)\n        #trata-se do caso em que depth==0\n        else:\n            #Caso ainda nao seja o ultimo cen\u00e1rio, a pontua\u00e7\u00e3o do tabuleiro deve ser avaliada pela fun\u00e7\u00e3o analyze(), que vai procurar por linhas horizontais, verticais e diagonais positivas e negativas\n            return (None,analyze(table))\n    # Caso o parametro seja passado como True (maximizar as chances de um determinado player), entra aqui\n    if maximizing_player == 1:\n        #valor minimo para ser substituido logo nas primeiras itera\u00e7\u00f5es\n        value = -math.inf\n        valid_columns = getValidColumns(table)\n        #print(\"colunas validas: \", valid_columns)\n        best_column = random.choice(valid_columns)\n        #diante das poss\u00edveis colunas a se jogar, percorre cada uma delas avaliando qual produz maior score\n        for valid_column in valid_columns:\n            #pega a linha associada a essa coluna vazia\n            row = getRowAssociated(table,valid_column)\n            table_simulated = table.copy()\n            #simula a queda de uma pe\u00e7a na posi\u00e7\u00e3o vazia em quest\u00e3o\n            table_simulated = simulatePieceDrop(table_simulated,row,valid_column,AI)\n            #chama recursivamente o minimax. O argumento \u00e9 false porque busca-se avaliar qual seria a jogada do oponente\n            score = minimax(table_simulated,depth - 1,alfa,beta,False)[1]\n            #caso o score da coluna associada retorne um valor superior ao anterior, este \u00e9 atualizado e a melhor coluna tamb\u00e9m\n            if score > value:\n                value = score\n                best_column = valid_column\n            alfa  = max(alfa,value)\n            if alfa>=beta:\n                break\n        return (best_column, value)\n                \n    else:\n        value = math.inf\n        valid_columns = getValidColumns(table)\n        best_column = random.choice(valid_columns)\n        for valid_column in valid_columns:\n            row = getRowAssociated(table,valid_column)\n            table_simulated = table.copy()\n            table_simulated = simulatePieceDrop(table_simulated,row,valid_column,OPPONENT)\n            #chama recursivamente a pr\u00f3xima jogada do AI at\u00e9 que depth=0\n            score = minimax(table_simulated,depth-1,alfa,beta,True)[1]\n            #Como o objetivo \u00e9 minimizar as chances do oponente, quanto menor o valor do score associado ao tabuleiro, melhor. A coluna \u00e9 atualizada e o valor de value tamb\u00e9n\n            if score < value:\n                value = score \n                best_column = valid_column\n            beta = min(beta,value)\n            if beta >= alfa:\n                break\n            #print(\"BEST COL: \", best_column)\n        return (best_column,value)\n            \n        ","95e933af":"#minimax(table, depth,alfa,beta,maximizing_player):\ndef my_agent(obs, cfg): #recebe o estado atual do jogo e a configura\u00e7\u00e3o do jogo\n    tabuleiro = obs.board\n    tabuleiro = np.asarray(tabuleiro).reshape(6,7)\n    alfa = -math.inf\n    beta = +math.inf\n    coluna, score = minimax(tabuleiro,2,alfa,beta,True)\n    return coluna","9e3b7e84":"env.reset()\nenv.run([\"negamax\",my_agent]) #Agente definido em my_agent versus angente rand\u00f4mico.\nenv.render(mode=\"ipython\", width=500, height=450)","bc475c26":"# Play as first position against random agent.\ntrainer = env.train([None, \"negamax\"])\n\nobservation = trainer.reset()\n\nwhile not env.done:\n    my_action = my_agent(observation, env.configuration)\n    print(\"A\u00e7\u00e3o do seu agente: Coluna\", my_action+1)\n    observation, reward, done, info = trainer.step(my_action)\n    env.render(mode=\"ipython\", width=100, height=90, header=False, controls=False)\n    #print(env.configuration.rows)\nenv.render()","ee7de8c9":"# \"None\" represents which agent you'll manually play as (first or second player).\nenv.play([None, my_agent], width=500, height=450) #Altere \"rules\" por my_agent para jogar contra o seu agente\n","84ba9438":"def mean_win_draw(rewards):\n    return sum( 1 for r in rewards if (r[0] == 1 or r[0] == 0.)) \/ len(rewards)\n\n# Run multiple episodes to estimate its performance.\nvs_random = mean_win_draw(evaluate(\"connectx\", [my_agent, \"random\"], num_episodes=10))\nprint(\"My Agent vs Random Agent:\", vs_random)\n\nvs_negamax = mean_win_draw(evaluate(\"connectx\", [my_agent, \"negamax\"], num_episodes=10))\nprint(\"My Agent vs Negamax Agent:\", vs_negamax)\n\nvs_rules = mean_win_draw(evaluate(\"connectx\", [my_agent, \"rules\"], num_episodes=10))\nprint(\"My Agent vs Rule Agent:\", vs_rules)\n\nvs_greedy = mean_win_draw(evaluate(\"connectx\", [my_agent, \"greedy\"], num_episodes=10))\nprint(\"My Agent vs Greedy Agent:\", vs_greedy)","177a95ff":"import csv\n\nseu_nome = \"Arthur Dimitri\"\n\nrows = [['Id', 'Predicted'],['random',vs_random],[ 'negamax', vs_negamax],[ 'rules', vs_rules],[ 'greedy', vs_greedy]]\nf = open(seu_nome+'-ConnectX.csv', 'w')\nwith f:\n    writer = csv.writer(f)\n    for row in rows:\n        writer.writerow(row)","f82be708":"import inspect\nimport os\n\ndef write_agent_to_file(function, file):\n    with open(file, \"a\" if os.path.exists(file) else \"w\") as f:\n        f.write(inspect.getsource(function))\n        print(function, \"written to\", file)\n\nwrite_agent_to_file(my_agent, \"submission.py\")","ace66968":"# Note: Stdout replacement is a temporary workaround.\nimport sys\nout = sys.stdout\nsubmission = utils.read_file(\"\/kaggle\/working\/submission.py\")\nagent = utils.get_last_callable(submission)\nsys.stdout = out\n\nenv = make(\"connectx\", debug=True)\nenv.run([agent, agent])\nprint(\"Success!\" if env.state[0].status == env.state[1].status == \"DONE\" else \"Failed...\")","af18511d":"## 1.5 getNegativeDiagonal() ","2b26ddfa":"# Jogue voc\u00ea mesmo\nClick on any column to place a checker there (\"manually select action\").\n\nVoc\u00ea pode jogar contra o seu agente ou contra qualquer um dos 4 agentes j\u00e1 definidos (random, negamax, rules, greedy).","269e2cc7":"Do livro Artificial Intelligence, se\u00e7\u00e3o 5.2.2, temos o pseudoc\u00f3digo do minimax. ","2336b112":"H\u00e1 tr\u00eas possibilidades para que o atual cen\u00e1rio seja o \u00faltimo:\n* O tabuleiro j\u00e1 foi preenchido e n\u00e3o h\u00e1 mais colunas v\u00e1lidas\n* H\u00e1 quatro pe\u00e7as da IA em sequ\u00eancia\n* H\u00e1 quatro pe\u00e7as do oponente em sequencia\nRetorna uma opera\u00e7\u00e3o l\u00f3gica OR entre as condi\u00e7\u00f5pes poss\u00edveis","a789d545":"# 1. Defini\u00e7\u00e3o de Jogadores ","a18894a4":"## 1.1. getValidColumns()","403fb96b":"Onde: \n* N\u00f3: representa um estado. No nosso caso, cada poss\u00edvel coluna \u00e9 um n\n* Profundidade: qu\u00e3o profundamente deseja-se ir nas poss\u00edveis decis\u00f5es\n* Maximizador: \u00e9 o que indica qual \u00e9 o nosso objetivo. Se \u00e9 maximizar as chances de vit\u00f3ria da IA ou minimizar as chances do oponente vencer","42850c17":"# Sua vez\n\n* Redefina o seu agente com as t\u00e9cnicas de IA cl\u00e1ssicas aprendidas durante o curso. \n* \u00c9 fundamental entender bem como funciona o jogo e como interagir com ele.\n* Utilize as fun\u00e7\u00f5es de teste e avalia\u00e7\u00e3o para te ajudar. \n* Consulte Tutoriais e discurss\u00f5es (N\u00e3o copie c\u00f3digo).","894164de":"Nessa fun\u00e7\u00e3o, o estado atual do tabuleiro \u00e9 convertido para um array bidimensional. Este \u00e9 passado para a fun\u00e7\u00e3o minimax e esta, recursivamente, analisa uma \u00e1rvore de possibilidades que retorne, para o estado atual, a melhor coluna a ser jogada. ","977ade2b":"A fun\u00e7\u00e3o recebe a matriz referente ao tabuleiro e a coluna para a qual deseja-se descobrir a linha associada. Retorna esta linha","3e668ca7":"A fun\u00e7\u00e3o recebe o tabuleiro, linha e coluna da jogada e qual o jogador teria a jogada simulada. Retorna o tabuleiro com a jogada deste jogador. ","dd4f8fb1":"## 1.2 getRowAssociated()","faf87988":"A fun\u00e7\u00e3o analyze(), por sua vez, \u00e9 respons\u00e1vel pelo la\u00e7o que percorre todo o tabuleiro. Recebe como parametro o tabuleiro e retorna a pontua\u00e7\u00e3o associada a ele. ","22a06780":"# Validar Submiss\u00e3o para Connect-X Original\nPlay your submission against itself.  This is the first episode the competition will run to weed out erroneous agents.\n\nWhy validate? This roughly verifies that your submission is fully encapsulated and can be run remotely.","10fa7f55":"A fun\u00e7\u00e3o getValidColumns() serve para informar quais colunas ainda est\u00e3o dispon\u00edveis. A l\u00f3gica se baseia em:\n\n[[0 0 1 0 0 1 2] <br>\n[1 2 1 2 1 2 1] <br>\n[1 2 1 2 1 2 1] <br>\n[2 1 2 1 2 1 2] <br>\n[1 2 1 2 1 2 1] <br>\n[1 2 1 2 1 2 1]] <br>\n\nPara qualquer caso, se o primeiro elemento da coluna (de cima para baixo) da matriz estiver com o valor 0, significa que ainda \u00e9 poss\u00edvel adicionar uma pe\u00e7a nessa posi\u00e7\u00e3o.","274aaa2f":"## 1.4 getPositiveDiagonal()","0c6eeb00":"## 1.11.1 Implementando o minimax()","ededf2f7":"# Exemplo de Agente\n\nTo create the submission, an agent function should be fully encapsulated (no external dependencies).  \n\nWhen your agent is being evaluated against others, it will not have access to the Kaggle docker image.  Only the following can be imported: Python Standard Library Modules, gym, numpy, scipy, pytorch (1.3.1, cpu only), and more may be added later.\n\n\/\/\/\/\n\n\nPara a submiss\u00e3o funcionar o agente deve funcionar de maneira encapsulada (sem depend\u00eancias externas).\n\n(Competi\u00e7\u00e3o Oficial) Quando o seu seu agente for avaliado em rela\u00e7\u00e3o a outros agentes n\u00e3o teremos acesso \u00e1 sua imagem docker do Kaggle. S\u00f3 as seguintes bibliotecas podem ser importadas: Python Standard Library Modules, gym, numpy, scipy, pytorch (1.3.1, cpu only), e outras podem ser adicionadas no futuro.\n\n(Competi\u00e7\u00e3o Virtus Up) Pode utilizar bibliotecas diferentes.","c8f3c46c":"# 1.10 isLastNode()","20f9ef66":"## 1.11 Minimax","79a9a3b4":"### Macros","fbbc2aee":"# Setup do Notebook\n\n## IMPORTATE: Habilite a internet no painel lateral. Settings\/Internet\/On","7db67c58":"# Submiss\u00e3o Connect-X Original\n\nComo gerar um arquivo .py do seu agente.\n\nVamos pedir o arquivo do notebook (.ipynb) ou o arquivo python (.py) em um formul\u00e1rio.\n\nCaso queira competir na competi\u00e7\u00e3o  original.\n\n\n","93f3a4a1":"Esta fun\u00e7\u00e3o recebe o tabuleiro e as colunas dispon\u00edveis para jogada. Retorna a melhor coluna, ou seja, a que resulta em uma maior pontua\u00e7\u00e3o no sistema de recompensas. Ela \u00e9 uma esp\u00e9cie de simula\u00e7\u00e3o para verificar o sistema de pontua\u00e7\u00e3o, um minimax com profundiade 1.","9793c861":"# 2. Defini\u00e7\u00e3o do Agente","63a9bf5a":"## 1.3 simulatePieceDrop()","38a53be2":"1. Em Data\/output voc\u00ea pode baixar o .csv com o seu resultado atual. Isso est\u00e1 acess\u00edvel no painel lateral ou ap\u00f3s realizar um commit no kernel. \n2. Submeta o csv na p\u00e1gina da competi\u00e7\u00e3o.\n\nNo fim da competi\u00e7\u00e3o os monitores v\u00e3o fazer um campeonato com todos os agentes.","f473ef99":"Esta fun\u00e7\u00e3o recebe como argumentos o tabuleiro, e as referidas linha e coluna do tabuleiro.  Retorna uma janela de quatro elementos na forma de lista representando a diagonal positiva que se inicia na posi\u00e7\u00e3o table[row][col]","413d89c0":"# Submiss\u00e3o para Connect-X Original\n\n1. Commit this kernel.\n2. View the commited version.\n3. Go to \"Data\" section and find submission.py file.\n4. Click \"Submit to Competition\"\n5. Go to [My Submissions](https:\/\/kaggle.com\/c\/connectx\/submissions) to view your score and episodes being played.","0ab5fc06":"O minimax age de forma recursiva. Utilizou-se a poda alfa-beta para limitar o n\u00famero de jogadas poss\u00edveis somente \u00e0s que mais compensam ao maximizing player. Alguns coment\u00e1rios abaixo ilustram as codifica\u00e7\u00f5es feitas.","48f5f19a":"## 1.7 analyze()","3da6e39d":"## 1.9 isLastMove()","453c1f12":"# Avalie o seu Agente\n\nA submiss\u00e3o na competi\u00e7\u00e3o do kaggle ser\u00e1 o resultado do seu agente contra 4 agentes previamente definidos.\nPode utilizar ","2f8a4221":"## 1.8 getBestColumnToDrop()","944cde34":"# Debug\/Train o seu Agent.\n\nAqui \u00e9 poss\u00edvel ver como o seu agente funciona a cada etapa.","8460ecb6":"# Testar o seu Agente\n\nEste trecho simula o comportamento do agente contra um agente rand\u00f4mico.","49c94373":"### Depend\u00eancias","88c04703":"## 1.6 getScore()","f5549260":"![minimax.png](attachment:minimax.png)","016c0528":"# Submiss\u00e3o para O Connect-X Virtus Up","2f43503a":"Esta fun\u00e7\u00e3o recebe como argumentos o tabuleiro, e as referidas linha e coluna do tabuleiro.  Retorna uma janela de quatro elementos na forma de lista representando a diagonal negativa que se inicia na posi\u00e7\u00e3o table[row][col]","dd29fdd0":"Esta fun\u00e7\u00e3o recebe uma janela de quatro elementos e retorna a pontua\u00e7\u00e3o associada a ela. Ela serve como base para avaliar uma jogada hipot\u00e9tica e descobrir se ela \u00e9 a mais apropriada para o momento. Maiores detalhes encontram-se como coment\u00e1rios no c\u00f3digo.","3c58441d":"# Notebook template para a competi\u00e7\u00e3o Connect X do Virtus-UP.\n\nNessa competi\u00e7\u00e3o vamos criar agentes inteligentes para o jogo connect X. Vamos utilizar o mesmo ambiente utilizado na competi\u00e7\u00e3o https:\/\/www.kaggle.com\/c\/connectx\/, essa competi\u00e7\u00e3o ainda est\u00e1 em andamento.\n\nPara a nossa competi\u00e7\u00e3o n\u00e3o vamos permitir apenas t\u00e9cnicas da IA cl\u00e1ssica.\n\nLeia com aten\u00e7\u00e3o os textos. Qualquer d\u00favida crie uma discurs\u00e3o na p\u00e1gina da competi\u00e7\u00e3o ou mande mensagem para os monitores.","8dc46a93":"# 1. Definini\u00e7\u00e3o de Fun\u00e7\u00f5es"}}