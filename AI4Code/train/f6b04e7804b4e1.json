{"cell_type":{"96c88eb4":"code","0ee87ecd":"code","fbfbfaed":"code","3eed0779":"code","64192f66":"code","6adabf4d":"markdown","a9940cc5":"markdown","dfcd3bc4":"markdown"},"source":{"96c88eb4":"import numpy as np\nimport pandas as pd\nimport sys\nimport json\nfrom collections import namedtuple\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","0ee87ecd":"dtypes = {\n    \"title\": \"category\",\n    \"event_count\": \"int16\",\n    \"event_code\": \"int16\",\n    \"game_time\": \"int32\",\n    \"title\": \"category\",\n    \"type\": \"category\",\n    \"world\": \"category\",\n}\n\nD = pd.read_csv(\"\/kaggle\/input\/data-science-bowl-2019\/train.csv\", dtype=dtypes, parse_dates=[\"timestamp\"])\n\nD.info(memory_usage='deep')","fbfbfaed":"def factorize(dd):\n    id_maps={}\n\n    for col, dtype in [(\"event_id\", \"int16\"), (\"game_session\", \"int32\"), (\"installation_id\", \"int16\")]:\n        factors, id_map = pd.factorize(dd[col])\n        dd[col]=factors.astype(dtype)\n        \n        if col in [\"event_id\"]:\n            id_maps[col]=id_map\n    \n    return id_maps\n\nid_maps = factorize(D)   # the map for event_id might be needed later\nD.head()","3eed0779":"namedtuple_types={}\n\n\ndef parse_event_data(text):\n    result = json.loads(text)\n    for col in [\"event_code\", \"event_count\", \"game_time\"]:\n        if col in result:\n            del result[col]\n            \n    if \"identifier\" in result:\n        result[\"identifier\"]=tuple(result[\"identifier\"].split(\",\"))\n        \n    result = recur_str_intern(result)\n    \n    return result\n\n\ndef recur_str_intern(obj):\n    if isinstance(obj, str):\n        return sys.intern(obj)\n    \n    if isinstance(obj, dict):\n        keys = frozenset(obj.keys())\n        sorted_keys = sorted(keys)\n        \n        if keys not in namedtuple_types:\n            namedtuple_types[keys]=namedtuple(f\"EventData{len(namedtuple_types)}\", sorted_keys)\n            \n        cur_type=namedtuple_types[keys]\n            \n        return cur_type(*[recur_str_intern(obj[k]) for k in sorted_keys])\n    \n    if isinstance(obj, list):\n        return tuple(recur_str_intern(x) for x in obj)  # convert to tuple anyway\n    \n    if isinstance(obj, tuple):\n        return tuple(recur_str_intern(x) for x in obj)\n    \n    return obj\n\nfor dd in [D]:\n    dd[\"event_data\"] = dd[\"event_data\"].apply(parse_event_data)\n    \nD.head()   # Unfortunately Pandas does not display namedtuples right","64192f66":"D.info(memory_usage='deep')  # doubt that it takes everything into account, but let's see","6adabf4d":"# Parse event_data","a9940cc5":"Data minification idea. Let me know if you know how to evaluate memory consumption correctly. Somehow displayed RAM usage in the notebook never decreases.","dfcd3bc4":"# Read CSV"}}