{"cell_type":{"7e599061":"code","7619d192":"code","7c97d9e4":"code","f01b63cf":"code","294c2cc8":"code","a73750e3":"code","a4845f2a":"code","2481906b":"code","cb255882":"code","d7ef2db5":"code","7012daab":"code","4978690c":"code","b21f1b18":"code","063ae2b3":"code","4ddda1fe":"code","92e44e57":"code","05f705ec":"code","99326b7a":"code","67610f13":"markdown","f7490b9b":"markdown","579ed687":"markdown","585d3e65":"markdown","0a7d218a":"markdown","3590cc77":"markdown","0f7af56c":"markdown","fbbc9b3a":"markdown","21baabce":"markdown","dac2770c":"markdown","9314c3c8":"markdown","8f224792":"markdown","a6b6507d":"markdown","6a98ee3b":"markdown","1fc5587d":"markdown","ec2fc15a":"markdown","698a4f54":"markdown","57e60b4c":"markdown","747fb9ac":"markdown","49d2820f":"markdown","fd2bc543":"markdown","4c45e48b":"markdown"},"source":{"7e599061":"!pip install yfinance\n","7619d192":"import numpy as np\nimport yfinance as yf\nimport pandas as pd\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential \nfrom tensorflow.keras.layers import Dense, Dropout, LSTM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import TimeSeriesSplit\nimport matplotlib.pyplot as plt\nfrom keras.callbacks import History \nfrom matplotlib.pylab import rcParams","7c97d9e4":"# define stock class which stores raw and processed data\nclass Stock():\n    \n    def __init__(self, normalize=True, days_back = 400, ticker_name=\"\"):\n        \n        \n        # check if ticker name came from user\n        if ticker_name == \"\":\n            self.ticker_name = input(\"Please Input Ticker  \") \n        else:\n            self.ticker_name = ticker_name\n        self.days_back = days_back\n        self.gen_data()\n        # 5 years worth of data\n        if normalize == True:\n            self.normalize_data()\n        \n    def gen_data(self):\n        \n        tick = yf.Ticker(self.ticker_name)\n        # get stock info while checking if data is possible to obtain\n        try: \n            tick.info\n            # get historical market data\n            self.data_df = tick.history(period=\"max\")\n            # remove unnecessary  columns and fix date column\n            self. data_df = self.data_df.drop(['Stock Splits','Dividends'], axis=1)\n        except:\n            print(\"no such ticker\")\n        \n        # extract data dates and store them \n        self.dates = self.data_df.index\n        self.data_no_dates = self.data_df.reset_index(drop=True)    \n        # convert pandas df to numpy array\n        self.data_np = np.array(self.data_no_dates)\n        # processed data for model, sliced 5 years back\n        self.data = self.data_np[:-(self.days_back+1):-1,:]\n        # form in ascending order\n        self.data = np.flip(self.data, axis=0)\n\n     \n    def normalize_data(self):\n        \n        # initiate data_scaled\n        self.data_scaled = self.data\n        # set scaler to normalize\n        self.scaler = MinMaxScaler(feature_range=(0,1), copy=True)\n        # copy of data_np but normalized\n        self.scaler.fit(self.data)\n        self.data_scaled = self.scaler.transform(self.data_scaled)\n        # create scaler for each column for many to one model\n        self.scalers = []\n        for i in range(self.data.shape[1]):\n            my_scaler = 0 \n            my_scaler = MinMaxScaler(feature_range=(0,1), copy=True)\n            # fit each scaler for each column\n            column = self.data[:,i]\n            column = np.expand_dims(column,1)\n            my_scaler.fit(column)\n            self.scalers.append(my_scaler)\n    ","f01b63cf":"# split data to 75% and 25%\ndef split_data(data, percentage=0.75):\n    \n    # get indices of split by percentage\n    last_train_index = int(np.floor(len(data)*0.75))\n    data_train_index = list(range(last_train_index))\n    \n    # generate train and test according to last index\n    data_train = data[data_train_index]\n    data_test = data[last_train_index:,:]\n    \n    return data_train, data_test","294c2cc8":"def build_lstm_model(overlap, many=False):\n    \n    # for building many to many and many to one, default 1\n    output = 1\n    # for building many to many \n    if many:\n        output = 5\n    # arbitrary 256 units, try out other values later\n    lstm_model = Sequential()\n    lstm_model.add(LSTM(256, input_shape=(overlap,5), return_sequences=True))\n    lstm_model.add(Dropout(0.2))\n    # another lstm layer\n    lstm_model.add(LSTM(256))\n    lstm_model.add(Dropout(0.2))\n    # fully connected\n    lstm_model.add(Dense(output))\n    \n    return lstm_model ","a73750e3":"\ndef create_shingled_data(data_x, overlap, train=False):\n    \n    new_data_x = []\n    new_data_y = []\n    # create overlapping data\n    for i in range(overlap,len(data_x)):\n        # overlap number of days back\n        new_data_x.append(my_stock.data_scaled[i-overlap:i,:])\n        if train:\n            # next day row\n            new_data_y.append(my_stock.data_scaled[i,:])\n    # if in training\n    if train:\n        return new_data_x, new_data_y\n    # not in training\n    else:\n        return new_data_x","a4845f2a":"ticker = \"fb\"\n# days back for model\nyears = 5 \ndays = int(years*365)\nepoch = 5\nmy_stock = Stock(normalize=True, days_back=days, ticker_name=ticker)\ndata = my_stock.data_scaled\n\nfeature_names = {0: \"High\", 1:\"Low\", 2: \"Open\", 3: \"Close\", 4: \"Volume\"}\n\n# set overlapping value for how much back to go\noverlap = 60\n","2481906b":"my_stock.data_df.tail()","cb255882":"my_stock.data_scaled[:-5:-1]","d7ef2db5":"# create first model\nmany2many = build_lstm_model(overlap, many=True)\n\n# make data shingled:\ndata_shingles, target_shingles = create_shingled_data(data, overlap, train=True)\ndata_shingles, target_shingles = np.array(data_shingles),np.array(target_shingles)\nx_train, x_test = split_data(data_shingles)\ny_train, y_test = split_data(target_shingles)\n\n#create model\nmany2many.compile(loss='mean_squared_error',optimizer='adam')\n","7012daab":"\n# to get the loss for graph title\nhistory = History()\n\n# callback history for loading losses\nprint(\"many to many training start.\")\nmany2many.fit(x_train ,y_train ,epochs=epoch ,batch_size=1,verbose=1, callbacks=[history])\nprint(\"many to many training finish.\")\n\n# save model with name of ticker\nmany2many.save( ticker + \"many2many_model.h5\")\n\n# run model on test data\npredictions = many2many.predict(x_test)\n\n# test predictions\npredictions = my_stock.scaler.inverse_transform(predictions)","4978690c":"# creating data for plotting\nfor_graph = my_stock.data[overlap:]\ntest_range = np.arange(len(y_train),len(for_graph))\nfor i in range(5):\n    f1 = plt.figure()\n    ax = f1.add_subplot(111)\n    ax.plot(for_graph[:len(y_train),i], label = feature_names[i] + ' Train Data')\n    ax.plot(test_range, predictions[:,i], label= feature_names[i] + ' M2M Predictions')\n    ax.plot(test_range ,for_graph[len(y_train):len(for_graph),i], label = feature_names[i] +' Target')\n    ax.grid(color='silver', linestyle='--', linewidth=1)\n    ax.legend(loc=2)\n    f1.suptitle('Many to Many Test Results')","b21f1b18":"# store all 5 models outcome\nmany2one_list = []\nall_predictions =[]\n\n\n# train 5 many to one models\nfor i in range(5):\n    many2one = build_lstm_model(overlap)\n    \n    # compile\n    many2one.compile(loss='mean_squared_error',optimizer='adam')\n    \n    # create single output for each column\n    y_train_feature = y_train[:,i]\n    y_test_feature = y_test[:,i]\n    \n    # fit new model\n    print(\"many to one \" + feature_names[i] +  \" training start.\")\n    many2one.fit(x_train, y_train_feature, batch_size = 1, epochs=epoch, verbose=1)\n    print(\"many to one \" + feature_names[i] +  \" training end.\")\n    many2one.save( ticker + \"many2one_\" + feature_names[i] + \"_model.h5\")\n    # save each many-to-one model in list\n    many2one_list.append(many2one)\n\n    # get many to on prediction on close price\n    feature_predictions = many2one.predict(x_test)\n    feature_predictions = my_stock.scalers[i].inverse_transform(feature_predictions)\n    all_predictions.append(feature_predictions) \n\n# cast all predictions to array\nall_predictions = np.array(all_predictions)","063ae2b3":"# plot in same plot (5 subplots)\nfig, axs = plt.subplots(5,1)\nfor i in range(5):\n    axs[i].plot(for_graph[:len(y_train),i], label = feature_names[i] + ' Train Data')\n    axs[i].plot(test_range, predictions[:,i], label= feature_names[i] + ' M2M Predictions')\n    axs[i].plot(test_range, all_predictions[i], label = feature_names[i] + ' M2One Predictions')\n    axs[i].plot(test_range ,for_graph[len(y_train):len(for_graph),i], label = feature_names[i] +' Target')\n    axs[i].grid(color='silver', linestyle='--', linewidth=1)\n    axs[i].legend(loc=2)\n    \n    \n# plot in different plots\nfor i in range(5):\n    f1 = plt.figure()\n    ax = f1.add_subplot(111)\n    ax.plot(for_graph[:len(y_train),i], label = feature_names[i] + ' Train Data')\n    ax.plot(test_range, predictions[:,i], label= feature_names[i] + ' M2M Predictions')\n    ax.plot(test_range, all_predictions[i], label = feature_names[i] + ' M2One Predictions')\n    ax.plot(test_range ,for_graph[len(y_train):len(for_graph),i], label = feature_names[i] +' Target')\n    ax.grid(color='silver', linestyle='--', linewidth=1)\n    ax.legend(loc=2)","4ddda1fe":"# retrain on all data many-to-many \nmany2many.fit(data_shingles ,target_shingles ,epochs=epoch ,batch_size=1,verbose=1, callbacks=[history])","92e44e57":"# retrain on all data many-to-one\nfor i in range(5):\n    \n    # create single output for each column\n    y_train_feature = target_shingles[:,i]\n    # train\n    print(\"many to one \" + feature_names[i] +  \" training start.\")\n    many2one_list[i].fit(data_shingles, y_train_feature, batch_size = 1, epochs=epoch, verbose=1)\n    print(\"many to one \" + feature_names[i] +  \" training end.\")","05f705ec":"# five future days to predict using many to many \nm2m_future_predictions = []\n# intiating data for predictions\nnext_days = data[-1]\nnext_days = np.expand_dims(next_days,0)\n# iteratively predict next day and add it to 60 days back in order to predict next day\nfor day in range(5):\n    # on day one, 59 points and next day prediction, on day two, 58 real points and two days predictions etc...\n    past_days = data[:(-(overlap-day)):-1]\n    # combine to form 60 days alltogether\n    past_60_days = np.vstack((past_days,next_days))\n    # predict next day\n    m2m_next_day_prediction = many2many.predict(np.expand_dims(past_60_days,0))\n    m2m_next_day_prediction = np.squeeze(m2m_next_day_prediction, axis=0)\n    # add to prediction list\n    m2m_future_predictions.append(m2m_next_day_prediction)\n    next_days = m2m_future_predictions\n    next_days = np.array(next_days)\n\n# cast to numpy \nm2m_future_predictions = np.array(m2m_future_predictions)\n# rescale to original scales\nm2m_future_predictions = my_stock.scaler.inverse_transform(m2m_future_predictions)\nm2m_df = pd.DataFrame(data = m2m_future_predictions, index = ['1 day forward', '2 day forward','3 day forward', '4 day forward','5 day forward'], columns = [\"High\", \"Low\",  \"Open\",  \"Close\", \"Volume\"])\nprint(\"next 5 days prediction according to many-to-many model\")\nprint(m2m_df)","99326b7a":"next_days = data[-1]\n# next_days = np.expand_dims(next_days,0)\n\nm21_future_predictions = []\nfor day in range(5):\n    past_days = data[:(-(overlap-day)):-1]\n    # combine to form 60 days alltogether\n    past_60_days = np.vstack((past_days,next_days))\n    # build a single day out of 5 seperate predictions\n    future_day =np.empty(5)\n    for i, model in enumerate(many2one_list):\n        # predict next day\n        m21_feature_prediction = model.predict(np.expand_dims(past_60_days,0))\n        m21_feature_prediction = np.squeeze(m21_feature_prediction, axis=0)\n        # add feature prediction to full day prediction array\n        future_day[i] = m21_feature_prediction\n    # add full day to 5 days predictions\n    m21_future_predictions.append(future_day)\n    next_days = np.array(m21_future_predictions)\n\n# cast to array\nm21_future_predictions = np.array(m21_future_predictions)\n# inverse transform to get original scale\nm21_future_predictions = my_stock.scaler.inverse_transform(m21_future_predictions)\nm21_df = pd.DataFrame(data = m21_future_predictions, index = ['1 day forward', '2 day forward','3 day forward', '4 day forward','5 day forward'], columns = [\"High\", \"Low\",  \"Open\",  \"Close\", \"Volume\"])\nprint(m21_df)","67610f13":"Predict 5 future days using many-to-one model:","f7490b9b":"7. Plotting ","579ed687":"![vix.PNG](attachment:vix.PNG)","585d3e65":"steps **1,2,3** are done inside class object.","0a7d218a":"Plotting many to one graphs, firstly in a combined figure, and later individualy ","3590cc77":"5.Build Model Function","0f7af56c":"9.Predict 5 future days using many to many model","fbbc9b3a":"Let us have a look on how the data looks like, before and after processing. \nBefore:","21baabce":"in all graphs, x axis is number of days back from today","dac2770c":"The next function is used to set up the time series data prior to the spliting. The data is shingled (or overlapping) my model takes in 60 days back and outputs the next day, day 61 - meaning:\n\n    x_train_shingled[0] = t1, t2..... t60\n    y_train_shingled[0] = t61 (next day)\n    x_train_shingled[1] = t2, t3, t4..... t61 according to overlap value, in this case, 60 is the overlapping value\n    y_train_shingled[1] = t62 (next day)\n   ","9314c3c8":"6.Calling the model, creating overlapping data for train and test.","8f224792":"now that we have finished many to many train, let's move on the many to one training ","a6b6507d":"8.Retrain models on all data points. Starting with many to many.","6a98ee3b":"many-to-one train on all data points.","1fc5587d":"Let us check the next five days (starting 15 of march 2021) and see which is more accurate.","ec2fc15a":"a couple of points:\n\n1.     We can see that in the case of FB (Face Book) stock the many-to-many model outperformed the many-to-one model. \n       This wasn't the case for all stocks. Each stock should be evaluated seperatly.\n    \n2.     We can see that in the first half of the test both models performed relatively well.\n        It is twards the second half of the test when both models became less accurate. \n        This might be due to post COVID uncertainty, as can be seen in the picture below of the VIX (volatilty index) \n        which is also named \"fear index\" the higher it is the higher people are uncertain about the market. \n        Also, when the VIX index is unstable, predicting future prices becomes a bigger challenge. \n        \n3.      The spike right after the beggining of 2020 is the COVID outbrake point, and since then the VIX has yet settled  ","698a4f54":"So here we go....\n\nimporting libraries\n\nnote about yfinance- it is not found in the conda pannel, write \"conda install yfinance\" in the comand prompt under the desired env. ","57e60b4c":"After processing and scaling:","747fb9ac":"# This code uses LSTM networks to predict future stock behaviour. The scope of the notebook:\n#  \n\nI will use FB Stock (Face Book) for this example\n\n**1.Obtaining the necessary data**- a certain amount of days going back:\n  metrics: High, Low, Open, Close, Volume\n  \n**2.Arranging** the data and casting it to numpy\n\n**3.Normalizing** the data on scale from 0 to 1\n\n**4.Splitting the data into train and test:**\n  train data defined as 60 days back of metrics, test data is data in day 61 etc...\n  \n**5.Build 2 models** (all LSTM):                                                                    \n1.    many to many- predicting all metrics                                                                                           \n2.    many to one- for each metric (i.e 5 models each predicting a single metric)\n  \n**6.Train each model**\n\n**7.Plotting** test outputs and comparison to target data\n\n**8.Train** on ALL of the data (train & test)\n\n**9.Predict** next 5 next days (iteratively) using many to many, later build a prediction using many to one, 5 outputs merging into a single instance \n\n\n  \n  ","49d2820f":"Training the model.","fd2bc543":"4.Splitting the Data by Percentage","4c45e48b":"setting values for ticker, how many days worth of information to get when calling yfinance."}}