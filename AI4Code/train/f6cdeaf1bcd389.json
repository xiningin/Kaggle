{"cell_type":{"791ce289":"code","0527ef9a":"code","c4c4a2db":"code","7696c16f":"code","2a0a9341":"code","9077b0a2":"code","998398df":"code","618bb4a6":"code","87b90d74":"code","a3b84e10":"code","a2f2da9e":"code","925176e8":"markdown","77ed0248":"markdown","f595bb22":"markdown","9acdbb9e":"markdown","16dc703e":"markdown"},"source":{"791ce289":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","0527ef9a":"class GCSandwich(object):   \n    def __init__(self,ing1=\"white\", ing2=\"none\", ing3=\"none\", ing4=\"none\", ing5=\"none\",ing6= \"none\"):\n        self.ing1 = ing1\n        self.ing2 = ing2\n        self.ing3 = ing3\n        self.ing4 = ing4\n        self.ing5 = ing5\n        self.ing6 = ing6\n    def calories(self):\n        calories = {\"white\":132,\"wheat\":156,\"rye\":166,\"cheddar\":90,\"swiss\":80,\"gouda\":101,\"colby\":110,\"pepperjack\":50,\"fontina\":109,\"none\":0,\"tomato\":4,\"shittake\":44}    \n        return (calories[self.ing1]+calories[self.ing2]+calories[self.ing3]+calories[self.ing4]+calories[self.ing5]+calories[self.ing6]) \n    def price(self):\n        price = {\"white\":.15,\"wheat\":.27,\"rye\":.30,\"cheddar\":.25,\"swiss\":.20,\"gouda\":.43,\"colby\":.4,\"pepperjack\":.37,\"fontina\":.61,\"none\":0,\"tomato\":.06,\"shittake\":.74}\n        return round((price[self.ing1] + price[self.ing2] + price[self.ing3] + price[self.ing4] + price[self.ing5] + price[self.ing6]),2)\n\nSandwich1 = GCSandwich(\"white\",\"cheddar\",\"colby\",\"fontina\",\"shittake\")\nprint(\"My sandwich has\",Sandwich1.calories(),\"calories\")\nprint(\"The price of my sandwich is\",Sandwich1.price())","c4c4a2db":"# we are searching for a number which is between 10000 and 1 million which if read backwards is equal to read forward. \n# If we convert it into a list of the component numbers and as a string we can search for equality moving from 1 mil down and breaking when\n# we find a palindrome, we can also test whether our number is prime before breaking\n# as part of the process of solving problem 1 we came up with a number of formulas relating to palindromes","7696c16f":"def ispal1(x):\n    '''This function checks if an input x is a numeric palindrome'''\n    x = str(x)\n    if x == x[::-1]:\n        return True\n    else:\n        return False\n\ndef Test1():\n    if (ispal(11011))==True and (ispal(11021))== False and (ispal(101))== True and (ispal(71917))== True and (ispal(72917))== False and (ispal(99999))==True:\n          print(\"the ispal function works\")\n    else:\n        print(\"the ispal function does not work\")\n\n# by defining a test function I can easily test changes in the ispal function to see if the function is working\n# in order to define a useful test it is imperative to test a number of distinct input cases. \n# the test above is not optimal and prints a string telling us that is pal works when there are several \n# inputs that would evaluate incorrectly\n# for could for example test palindromes and non-palindromes of odd and even digits, \n# test negative numbers, single digit numbers, different classes of input\n# Alternatively instead of coding this test function we can define a range of input for which the \n# function operates and understand that if we do not enter this type of data we will not get proper results.\n\n# Consider that we have a palindromic string input of \"racecar\", if it is passed into the function ispal() \n# it will evaluate to True but if we want a function to test whether an input is a palindromic integer\n# the result should be false. The same applies to input of other classes of data such as floats\n\nprint(\"the float 51.15 incorrectly evaluates to\", ispal(51.15))\nprint(\"racecar incorrectly evaluates to\", ispal(\"racecar\"))\n\n# we can update our function to check whether the input is an integer\n\ndef ispal2(x):\n    '''This function checks if an input x is a numeric palindrome'''\n    string = str(x)\n    if x==int(x) and string == string[::-1]:\n        return True\n    else:\n        return False\n\n# Tests inside of outside functions can be asked to return specific output that would let us know where the test is failing\n# and why, besides preforming tests in the function or outside of the function another \n# way to evaluate the performance of a function is to\n# insert print commands in the function and solve for the output we are trying to correct. we will examine this method later\n\n# the function below creates a list of palindromes in between two numbers by checking every number in a given range\n\ndef listpal(a,b):\n    '''lists the palindromes in some range'''\n    listpal = []\n    list1=list(range(a,b))\n    list1.reverse()\n    for num in list1:\n        if ispal(num)==True:\n            listpal.append(num)\n    return listpal\n\n# If we have a large amount of memory or a short list or range to iterate through and we wanted information on palindromes\n# we could save our palindromes that were the output of listpal along with other info as a nested dictionary. \n# the keys of the outer dictionary corresponding to each palindrome in the range \n# and the value of the outer dictionary corresponding to a dictionary with \n# keys = information type and values = corresponding values \n# the dictionary for the first 3 palindromes greater than 10000 would look something like this:\n\n# dictpals = {10001:{id:91, multiple:False},10101:{id:92, multiple:False},10201:{id:93, multiple:True}}\n\n# using hashmaps and this method we quickly obtain information pertaining to palindromes","2a0a9341":"%%time\n# How about a faster way to do this problem\n\ndef ispal2(x):\n    '''This function checks if an input x is a numeric palindrome'''\n    string = str(x)\n    if x==int(x) and string == string[::-1]:\n        return True\n    else:\n        return False\npal = False\nn = 999\nwhile pal == False:\n    if ispal2(n*n)==True:\n        pal = n*n\n    if ispal2(n*(n-1))==True:\n        pal = (n*(n-1))\n    n = n-1\npal\n\n","9077b0a2":"%%time\ndef firstequalslast(n):\n    if n\/\/100000 == n%10:\n        return True\n    else:\n        return False\npal = False\nn = 999\nwhile pal == False:\n    if firstequalslast(n*n):\n        if ispal2(n*n)==True:\n            pal = n*n\n    if firstequalslast(n*(n-1)):\n        if ispal2(n*(n-1))==True:\n            pal = (n*(n-1))\n    n = n-1\npal\n","998398df":"# to find the highest palindrome with a value less than the input\n\ndef lastpal(num):\n    '''finds the closest palindrome that is less than or equal to a number'''\n    string = str(num)\n    length = len(str(num))\n    half1 = string[0:length\/\/2]\n    half2 = string[length-length\/\/2:length]\n    L = ''\n    if length == 1:\n#         print(\"code1\")\n        return num\n    if length % 2 != 0:\n        L = string[length\/\/2]\n    if half1 == half2[::-1]:\n#         print(\"code2\")\n        return num\n    elif int(half2) > int(half1[::-1]):\n#         print(\"code3\")\n        return int(half1 + L + half1[::-1])\n    else:\n        # everything here is not a palindrome and half 2 is less than half 1 reverse\n        # so half 1 will have to decrease by 1\n        if int(half1) == 10**(length\/\/2-1):\n            for i in range(0,length-1):\n                L = L + '9'\n#             print(\"code4\")\n            return int(L)\n        else:\n            a = str(int(half1)-1)\n            A = a + L + a[::-1]\n#             print(\"code5\")\n            return int(A)\n\n\nlastpal(4893745387955748857458)\nlastpal(10002)","618bb4a6":"# takes two arguments of numbers and finds the number of palindromes between them, as well as the number instance\n# of that palindrome in a list of all palindromes\ndef numpal(smallnum,bignum):\n    '''returns the instance number of two palindromes and the number \\n of palindromes between them'''\n    input1 = [smallnum,bignum]\n    output1 = []\n    for n in input1:\n        a = lastpal(n)\n        s = str(a)\n        l = len(s)\n        if l % 2 == 0:\n            output1.append(int(s[0:l\/\/2]))\n        elif l == 1:\n            output1.append(n)\n        else:\n            output1.append(int(s[0:l\/\/2-1]))\n    return [output1[0],output1[1],output1[1] - output1[0]]\nnumpal(10000,20000)","87b90d74":"%%time\n## first lets come up with an equation to find the smallest fraction out of any fraction - just because\n# we can do this efficiently by finding a set of smallest prime factors \n# let's begin by examining 12\/13 *32\n#so if we want to factor 384\/416 we begin by using a loop to look at 384 then 416 within this loop we loop through a list\n# containing 2 and each odd number after up to the sqrt of the number and checking each to see if it is a factor\nimport math as ma\n\ndef removesame(S,T):\n    '''removes common elements from two lists'''\n    T1 = tuple(T)\n    S1 = tuple(S)\n    for i in S1:\n        if i in T:\n            T.remove(i)\n            S.remove(i)\n    print(\"we started with S=\",S1,\"now S=\",S)\n    print(\"we started with T=\",T1,\"now T=\",T)\n    print(\"We have removed all commonalities from the two lists\")\n    return [S,T]\n    \ndef isprime(x):\n    '''returns true if a number is prime'''\n    this_num = x\n    sqrt_num = ma.sqrt(x)\n    intsqrtnum = int(x)\n    range3 =[2]\n    for num in range(3,intsqrtnum):\n        if num % 2 != 0:\n             range3.append(num)\n    v=0\n    for num in range3:\n        if this_num % num == 0:\n            v=v+1\n        else:\n            v=v\n    if v>0:\n        return False\n    elif v==0:\n        return True\n    else:\n        print(\"test failed\")\n\ndef lowfact(ele):\n    '''returns lowest factor of a number'''\n    H = []\n    for n in range(2,ele):\n        if ele%n==0:\n            H.append(n)\n    return min(H)\n\ndef Listoflowfacts(original):\n    '''returns a list of lowest factors for a number'''\n    V=[]\n    original2 = original\n    for num in range(0,20):\n        if isprime(original) == True:\n            V.append(original)\n            return V\n        else:\n            if sum(V) == original2:\n                return V\n            else:\n                factor = lowfact(original)\n                V.append(factor)\n                original = int(original\/factor)\n                \n                \nnum = Listoflowfacts(44783)\nden = Listoflowfacts(203993)\nprint(num)\nprint(den)\nremovesame(num,den)\n\ndef smallfrac(num,den):\n    '''returns the smallest fraction'''\n    num = Listoflowfacts(num)\n    den = Listoflowfacts(den)\n    removesame(num,den)\n    L = 1\n    for n in num:\n        L = L * n\n    S = 1\n    for i in den:\n        S = S * i\n    return [L,S]\nsmallfrac(679770,794430)","a3b84e10":"%%time\nimport math as ma\ndef leastfraction(num,den):\n    '''returns the smallest fraction'''\n    nsign = 1\n    dsign = 1\n    if num < 0:\n        nsign = -1\n    if den < 0:\n        dsign = -1\n    num = num * nsign\n    den = den * dsign\n    short = max(num,den)\n    end = int(ma.sqrt(short))\n    for n in range(2,end):    \n        if num % n == 0 and den % n == 0:\n            for s in range(0,round(ma.log(short,2))):\n                if  num % n == 0 and den % n == 0:\n                    short = short \/\/ n\n                    end = int(ma.sqrt(short))\n                    num = num \/\/ n\n                    den = den \/\/ n\n    if num == den:\n        if nsign < 0 and dsign < 0:\n            return [1,1]\n        else:\n            return [nsign,dsign]\n    elif num % den == 0:\n        factor = num \/\/ den\n        num = factor\n        den = 1\n    elif den % num == 0:\n        factor = den \/\/ num\n        num = 1\n        den = factor\n    if (nsign < 0 and dsign < 0) or (nsign > 0 and dsign > 0):\n        return [num,den]\n    else:\n        return [-1*num,den]\n\n# print(leastfraction(679770,794430))\n# print(leastfraction(-100,-1000))\n# print(leastfraction(10,100))\n# print(leastfraction(-4657,-4657*2))","a2f2da9e":"# if a number is divisible by every number between 1 and 20 it is factorable by \n# the product of all of the prime numbers between 1 and 20\nfactor = 1 * 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19\nprint(factor)\n# we can check the first 100 multiples of our factor to see if there is a solution\ndef func():\n    for num in range(1,101):\n        number = factor * num\n        v = 0\n        for i in range(1,21):\n            if number % i == 0:\n                v = v + 1\n            if v == 20:\n                return number\nprint(\"the lowest number divisible by all of the numbers from 1 to 20 is:\",func())","925176e8":"Second Problem:\n2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\n\nWhat is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?","77ed0248":"Lets look at some other functions to evaluate palindromes:","f595bb22":"# Python Algorithms ","9acdbb9e":"We are going to create a new class called GCSandwich for Grilled Cheese Sandwiches, which accepts ingredients as parameters","16dc703e":"### Problem 1:  \nA palindromic number reads the same both ways. The largest palindrome made  \nfrom the product of two 2-digit numbers is 9009 = 91 \u00d7 99.  \n\nFind the largest palindrome made from the product of two 3-digit numbers."}}