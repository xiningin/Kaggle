{"cell_type":{"3cbbe6c5":"code","4ba9cd2a":"code","d2268a7b":"code","d5e82842":"code","4d97fc4d":"code","ff38b721":"code","b71fa887":"code","f406cb12":"code","a2c249e1":"markdown","0e89d1c5":"markdown","1585f1ae":"markdown","d0637ae4":"markdown","704c8cf9":"markdown","7f2e4e4b":"markdown","550665af":"markdown","978d43e3":"markdown"},"source":{"3cbbe6c5":"from collections import defaultdict\nimport csv\nimport os\nimport tarfile","4ba9cd2a":"target_dir = {\"0\": \"alt.atheism\",\n             \"1\": \"comp.graphics\",\n             \"2\": \"comp.os.ms-windows.misc\",\n             \"3\": \"comp.sys.ibm.pc.hardware\",\n             \"4\": \"comp.sys.mac.hardware\",\n             \"5\": \"comp.windows.x\",\n             \"6\": \"misc.forsale\",\n             \"7\": \"rec.autos\",\n             \"8\": \"rec.motorcycles\",\n             \"9\": \"rec.sport.baseball\",\n             \"10\": \"rec.sport.hockey\",\n             \"11\": \"sci.crypt\",\n             \"12\": \"sci.electronics\",\n             \"13\": \"sci.med\",\n             \"14\": \"sci.space\",\n             \"15\": \"soc.religion.christian\",\n             \"16\": \"talk.politics.guns\",\n             \"17\": \"talk.politics.mideast\",\n             \"18\": \"talk.politics.misc\",\n             \"19\": \"talk.religion.misc\"}\ndir_target = {v: k for k, v in target_dir.items()}","d2268a7b":"def str_to_pattern(s, spacechar):\n    frm = ''.join([chr(i) for i in range(256)]) + spacechar\n    to = '.' * 256 + ' '\n    transtab = str.maketrans(frm, to)\n    return s.translate(transtab)","d5e82842":"def fix_plaindata(data):\n    data = data.replace('\\r\\n', '\\n')\n    data = data.replace('\\r', '\\n')\n    data = data.replace('\\n', '\\n ')\n    if data.endswith('\\n '):\n        data = data[:-1]\n    return data","4d97fc4d":"def get_plain_block_patterns():\n    tar_fname = \"..\/input\/sklearn-20newsgroup\/20news-bydate\/20news-bydate.tar.gz\"\n    tar = tarfile.open(tar_fname, \"r:gz\")\n    plain_block_pattern = defaultdict(list)\n    for member in tar.getmembers():\n        if member.isdir():\n            continue\n            \n        # split filename and convert it to a target\n        head, tail = os.path.split(member.path)\n        _dir = os.path.split(head)[1] \n        target = dir_target[_dir]\n        \n        # read plaindata\n        fh=tar.extractfile(member)\n        plaindata = fh.read()\n        plaindata = plaindata.decode('latin-1')\n        plaindata = fix_plaindata(plaindata)\n        \n        # Split plaindata into chunks of length 300\n        # and convert it to block patterns\n        for pos in range(0, len(plaindata), 300):\n            block = plaindata[pos:pos+300]\n            pattern = str_to_pattern(block, ' ')\n            plain_block_pattern[pattern].append(target)\n    return plain_block_pattern\n    ","ff38b721":"def get_test_rows():\n    with open(\"..\/input\/20-newsgroups-ciphertext-challenge\/test.csv\", 'r') as fh:\n        reader = csv.reader(fh, delimiter=\",\")\n        rows = []\n        for i, row in enumerate(reader, 1):\n            rows.append(row)\n    return rows","b71fa887":"def classify_by_pattern():\n    print(\"Starting classification of difficulty 1,2 and 3\")\n    rows = get_test_rows()\n\n    cipher_block_pattern = {}\n    for _id, difficulty, ciphertext in rows:\n        if difficulty == \"1\":\n            s = str_to_pattern(ciphertext, \"1\")\n            cipher_block_pattern[_id] = s\n        elif difficulty in \"23\":\n            s = str_to_pattern(ciphertext, \"8\")\n            cipher_block_pattern[_id] = s\n\n    plain_block_patterns = get_plain_block_patterns()\n    correct, multiclass, noclass = 0, 0, 0\n    classified_id_to_target = {}\n    unclassified_id_to_target = {}\n    for _id, cipher_pattern in cipher_block_pattern.items():\n        if cipher_pattern in plain_block_patterns:\n            targets = plain_block_patterns[cipher_pattern]\n            target = targets[0]\n            if all(t == target for t in targets):\n                correct += 1\n                classified_id_to_target[_id] = target\n            else:\n                multiclass += 1\n                targets = set(int(t) for t in targets)\n                unclassified_id_to_target[_id] = [str(t) for t in sorted(targets)]\n        else:\n            noclass += 1\n    print(\"No class: %d   Correct: %d   Multi: %d\" % (noclass, correct, multiclass))\n    print(\"Success of classification %5.2f pct\" % (100*correct\/(correct+multiclass)))\n\n    return classified_id_to_target, unclassified_id_to_target","f406cb12":"classified_id_to_target, unclassified_id_to_target = classify_by_pattern()\n\nprint(\"Sample of 5 classified ids\")\nfor i, (_id, target) in enumerate(classified_id_to_target.items()):\n    print(_id, target)\n    if i > 5:\n        break\nprint()\n\nprint(\"Sample of 5 unclassified ids\")\nfor i, (_id, targets) in enumerate(unclassified_id_to_target.items()):\n    print(_id, targets)\n    if i > 5:\n        break","a2c249e1":"**A function to read a csv file**","0e89d1c5":"**A function that fixes the plaindata in almost the same way as I foound in a comment from RS Turley**","1585f1ae":"**Setting up a dictionary to convert directory for a file to a target**","d0637ae4":"**A function that translates all but one character to a dot and the spacechar to a space**","704c8cf9":"**This kernel shows how to get 98.85% ciphertexts matched with the plaintext without any decryption.\nThe only thing we need to know is which character for each difficulty corresponds to the plaintext space character.\nThe most frequent character for each of difficulty 1, 2 and 3 is easily found and used as space.\n \"1\" is space for difficulty 1 and \"8\" is space for difficulty 2 and 3.**","7f2e4e4b":"**Let's run our classification code and print some samples of the classified and unclassified ids.**","550665af":"**Here we read all the plaintexts and converts them into pattern blocks.**","978d43e3":"**The main function that classifies our ciphertexts**"}}