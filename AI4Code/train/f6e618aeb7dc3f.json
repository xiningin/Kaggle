{"cell_type":{"6139e6aa":"code","be670a75":"code","83729fc8":"code","43d57c9c":"code","6b173491":"code","6d0e086b":"code","3d94e4ad":"code","53821fdb":"code","d9ca5f4b":"code","48a8cc12":"code","c928d4ee":"code","1ca2babc":"code","ab7a9443":"code","9c4ad724":"code","f6e9d705":"code","6ac7f86a":"code","5c2a5c2a":"code","441d0981":"code","64a83219":"code","a35f9e4c":"code","a2882d32":"code","84080ff5":"code","5a260d4a":"markdown","ad7bf2d9":"markdown","60dfd5bd":"markdown","10aa560d":"markdown","e3336088":"markdown","0b07fcbf":"markdown","e4c032a8":"markdown","5a089e56":"markdown","805359c4":"markdown"},"source":{"6139e6aa":"!pip install pretrainedmodels\n!pip install albumentations","be670a75":"# for TPU\n!curl https:\/\/raw.githubusercontent.com\/pytorch\/xla\/master\/contrib\/scripts\/env-setup.py -o pytorch-xla-env-setup.py\n!python pytorch-xla-env-setup.py --apt-packages libomp5 libopenblas-dev","83729fc8":"import os\nimport numpy as np\nimport pandas as pd\n\nimport albumentations as A\nimport cv2\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\n\nimport pretrainedmodels\n\nfrom tqdm.notebook import tqdm\nfrom torch.utils.data import Dataset, DataLoader\nfrom albumentations.pytorch import ToTensorV2\nfrom albumentations import Rotate \n\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import StratifiedKFold\n\nimport warnings  \nwarnings.filterwarnings('ignore')","43d57c9c":"# for TPU\nimport torch_xla\nimport torch_xla.core.xla_model as xm","6b173491":"DIR_INPUT = '\/kaggle\/input\/plant-pathology-2020-fgvc7'\n\nSEED = 27\n\n# If you want to chane parameters, check this for settings.\nN_FOLDS = 5\nN_EPOCHS = 10\nBATCH_SIZE = 64\nSIZE = 512","6d0e086b":"# for GPU\n# device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n\n# for TPU\ndevice = xm.xla_device()\ntorch.set_default_tensor_type('torch.FloatTensor')","3d94e4ad":"class PlantDataset(Dataset):\n    \n    def __init__(self, df, transforms=None):\n        self.df = df\n        self.transforms=transforms\n        \n    def __len__(self):\n        return self.df.shape[0]\n    \n    def __getitem__(self, idx):\n        image_src = DIR_INPUT + '\/images\/' + self.df.loc[idx, 'image_id'] + '.jpg'\n        # print(image_src)\n        image = cv2.imread(image_src, cv2.IMREAD_COLOR)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        labels = self.df.loc[idx, ['healthy', 'multiple_diseases', 'rust', 'scab']].values\n        labels = torch.from_numpy(labels.astype(np.int8))\n        labels = labels.unsqueeze(-1)\n        \n        if self.transforms:\n            transformed = self.transforms(image=image)\n            image = transformed['image']\n\n        return image, labels","53821fdb":"transforms_train = A.Compose([\n        A.RandomResizedCrop(height=SIZE, width=SIZE, p=1.0),\n        A.Rotate(20),\n        A.Flip(),\n        A.Transpose(),\n    A.Resize(height=SIZE, width=SIZE, p=1.0),\n    A.Normalize(p=1.0),\n    ToTensorV2(p=1.0),\n    ], p=1.0)\n\ntransforms_valid = A.Compose([\n    A.Resize(height=SIZE, width=SIZE, p=1.0),\n    A.Normalize(p=1.0),\n    ToTensorV2(p=1.0),\n])","d9ca5f4b":"train_df = pd.read_csv(DIR_INPUT + '\/train.csv')\ntrain_labels = train_df.iloc[:, 1:].values\n\n# Need for the StratifiedKFold split\ntrain_y = train_labels[:, 2] + train_labels[:, 3] * 2 + train_labels[:, 1] * 3","48a8cc12":"train_df.head()","c928d4ee":"folds = StratifiedKFold(n_splits=N_FOLDS, shuffle=True, random_state=SEED)\noof_preds = np.zeros((train_df.shape[0], 4))","1ca2babc":"model_name = 'resnet34'\nmodel = pretrainedmodels.__dict__[model_name](pretrained='imagenet')\nin_features = model.last_linear.in_features\nmodel.last_linear = nn.Linear(in_features, 4)","ab7a9443":"class DenseCrossEntropy(nn.Module):\n\n    def __init__(self):\n        super(DenseCrossEntropy, self).__init__()\n        \n        \n    def forward(self, logits, labels):\n        logits = logits.float()\n        labels = labels.float()\n        \n        logprobs = F.log_softmax(logits, dim=-1)\n        \n        loss = -labels * logprobs\n        loss = loss.sum(-1)\n\n        return loss.mean()","9c4ad724":"def train_one_fold(i_fold, model, criterion, optimizer, lr_scheduler, dataloader_train, dataloader_valid):\n    \n    train_fold_results = []\n\n    for epoch in range(N_EPOCHS):\n\n        print('  Epoch {}\/{}'.format(epoch + 1, N_EPOCHS))\n        print('  ' + ('-' * 20))\n        os.system(f'echo \\\"  Epoch {epoch}\\\"')\n\n        model.train()\n        tr_loss = 0\n\n        for step, batch in enumerate(dataloader_train):\n\n            images = batch[0].to(device, dtype=torch.float)\n            labels = batch[1].to(device, dtype=torch.float)\n            \n            outputs = model(images)\n            loss = criterion(outputs, labels.squeeze(-1))                \n            loss.backward()\n\n            tr_loss += loss.item()\n            \n            # for TPU\n            #optimizer.step()\n            xm.optimizer_step(optimizer, barrier=True)\n            \n            optimizer.zero_grad()\n\n        # Validate\n        model.eval()\n        \n        val_loss = 0\n        val_preds = None\n        val_labels = None\n\n        for step, batch in enumerate(dataloader_valid):\n\n            images = batch[0].to(device, dtype=torch.float)\n            labels = batch[1].to(device, dtype=torch.float)\n\n            if val_labels is None:\n                val_labels = labels.clone().squeeze(-1)\n            else:\n                val_labels = torch.cat((val_labels, labels.squeeze(-1)), dim=0)\n\n            \n\n            with torch.no_grad():\n                outputs = model(batch[0].to(device))\n\n                loss = criterion(outputs, labels.squeeze(-1))\n                val_loss += loss.item()\n\n                preds = torch.softmax(outputs, dim=1).data.cpu()\n                #preds = torch.softmax(outputs, dim=1).detach().cpu().numpy()\n\n                \n                if val_preds is None:\n                    val_preds = preds\n                else:\n                    val_preds = torch.cat((val_preds, preds), dim=0)\n           \n        # if train mode\n        lr_scheduler.step(tr_loss)\n\n        train_fold_results.append({\n            'fold': i_fold,\n            'epoch': epoch,\n            'train_loss': tr_loss \/ len(dataloader_train),\n            'valid_loss': val_loss \/ len(dataloader_valid),\n            'valid_score': roc_auc_score(val_labels.view(-1).cpu(), val_preds.view(-1).cpu(), average='macro'),\n        })\n\n    return val_preds, train_fold_results","f6e9d705":"submission_df = pd.read_csv(DIR_INPUT + '\/sample_submission.csv')\nsubmission_df.iloc[:, 1:] = 0","6ac7f86a":"dataset_test = PlantDataset(df=submission_df, transforms=transforms_valid)\ndataloader_test = DataLoader(dataset_test, batch_size=BATCH_SIZE, num_workers=4, shuffle=False)","5c2a5c2a":"submissions = None\ntrain_results = []\n\ndevice = xm.xla_device()\n\nfor i_fold, (train_idx, valid_idx) in enumerate(folds.split(train_df, train_y)):\n    print(\"Fold {}\/{}\".format(i_fold + 1, N_FOLDS))\n\n    valid = train_df.iloc[valid_idx]\n    valid.reset_index(drop=True, inplace=True)\n\n    train = train_df.iloc[train_idx]\n    train.reset_index(drop=True, inplace=True)    \n\n    dataset_train = PlantDataset(df=train, transforms=transforms_train)\n    dataset_valid = PlantDataset(df=valid, transforms=transforms_valid)\n\n    dataloader_train = DataLoader(dataset_train, batch_size=BATCH_SIZE, num_workers=4, shuffle=True)\n    dataloader_valid = DataLoader(dataset_valid, batch_size=BATCH_SIZE, num_workers=4, shuffle=False)\n\n    # device = torch.device(\"cuda:0\")    \n    model = model.to(device)\n\n    criterion = DenseCrossEntropy()\n    optimizer = optim.Adam(model.parameters(), lr=0.001)\n    lr_scheduler = optim.lr_scheduler.MultiStepLR(optimizer=optimizer, milestones=[int(N_EPOCHS * 0.5), int(N_EPOCHS * 0.75)], gamma=0.1, last_epoch=-1)\n    \n    val_preds, train_fold_results = train_one_fold(i_fold, model, criterion, optimizer, lr_scheduler, dataloader_train, dataloader_valid)\n    oof_preds[valid_idx, :] = val_preds\n    \n    train_results = train_results + train_fold_results\n\n    model.eval()\n    test_preds = None\n\n    for step, batch in enumerate(dataloader_test):\n\n        images = batch[0].to(device, dtype=torch.float)\n\n        with torch.no_grad():\n            outputs = model(images)\n\n            if test_preds is None:\n                test_preds = outputs.data.cpu()\n            else:\n                test_preds = torch.cat((test_preds, outputs.data.cpu()), dim=0)\n    \n    \n    # Save predictions per fold\n    submission_df[['healthy', 'multiple_diseases', 'rust', 'scab']] = torch.softmax(test_preds, dim=1)\n    submission_df.to_csv('submission_fold_{}.csv'.format(i_fold), index=False)\n\n    # logits avg\n    if submissions is None:\n        submissions = test_preds \/ N_FOLDS\n    else:\n        submissions += test_preds \/ N_FOLDS\n\nprint(\"5-Folds CV score: {:.4f}\".format(roc_auc_score(train_labels, oof_preds, average='macro')))\n\ntorch.save(model.state_dict(), '5-folds_rnn34.pth')","441d0981":"import matplotlib.pyplot as plt","64a83219":"def show_training_loss(train_result):\n    plt.figure(figsize=(15,10))\n    plt.subplot(3,1,1)\n    train_loss = train_result['train_loss']\n    plt.plot(train_loss.index, train_loss, label = 'train_loss')\n    plt.legend()\n\n    val_loss = train_result['valid_loss']\n    plt.plot(val_loss.index, val_loss, label = 'val_loss')\n    plt.legend()","a35f9e4c":"def show_valid_score(train_result):\n    plt.figure(figsize=(15,10))\n    plt.subplot(3,1,1)\n    valid_score = train_result['valid_score']\n    plt.plot(valid_score.index, valid_score, label = 'valid_score')\n    plt.legend()","a2882d32":"train_results = pd.DataFrame(train_results)\ntrain_results.head(10)","84080ff5":"submission_df[['healthy', 'multiple_diseases', 'rust', 'scab']] = torch.softmax(submissions, dim=1)\nsubmission_df.to_csv('submission.csv', index=False)","5a260d4a":"# Settings","ad7bf2d9":"# PretrainedModels","60dfd5bd":"# Version - 0.3 for TPU","10aa560d":"# Agumentations","e3336088":"# Train for StratifiedKFold","0b07fcbf":"# Show Train History","e4c032a8":"# Define Dataset","5a089e56":"# Generate submission file","805359c4":"# StratifiedKFold"}}