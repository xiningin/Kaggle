{"cell_type":{"73124a03":"code","3125c568":"code","f3702f54":"code","fa711c22":"code","59c83088":"code","656ccaa4":"code","925f4c89":"code","fe079200":"code","2973e613":"code","acfb7ba5":"code","793e2a60":"code","0b7e7484":"code","512e2715":"code","acafc668":"code","b1c60ca8":"code","65bf49c9":"code","025e8283":"code","4eff19ba":"code","2a70dc42":"code","d1be33fb":"code","5c2ce75e":"code","9cf9a223":"code","8949859a":"code","25c24459":"code","a663c496":"code","282b3ad9":"code","1a3e6ae7":"code","25e79a13":"code","2433ac7f":"code","b16de0a2":"code","6a403ef2":"code","bd6e40f0":"code","f1f62b54":"code","b48d98b5":"code","fdf279b0":"code","297a9ea2":"code","010224ff":"code","5ec27301":"code","18b2f3c8":"code","c694f472":"code","701b9702":"code","201ac5d7":"code","e664a1e2":"code","d9b7a219":"code","fabb9ab0":"code","60f0b0cf":"code","1e015a85":"code","ba5aa1ea":"code","e780d397":"code","0bf9e6a3":"code","103119cf":"code","09569cf3":"markdown","3adb2452":"markdown","3777e7dc":"markdown","5774cc6c":"markdown","ff579630":"markdown","4cf7bc53":"markdown","32f38840":"markdown","3a58b2cc":"markdown","d3eb39d6":"markdown","a9b393c6":"markdown","42fc030f":"markdown","088a3beb":"markdown","975eda7e":"markdown","04782112":"markdown","1b43bef4":"markdown","fb1871ce":"markdown","08578620":"markdown","6d40df01":"markdown","f2249a0c":"markdown","fd8e6a66":"markdown","623a7324":"markdown","340b1791":"markdown","4468a727":"markdown","12f868d7":"markdown","206bb8f0":"markdown","831795c5":"markdown","6d0c9129":"markdown","0f1b4d3a":"markdown","082ac187":"markdown","325562a1":"markdown","b3a2fc54":"markdown","f0da3ada":"markdown","e28c82cb":"markdown","8ac3789c":"markdown","263602bc":"markdown","1dfeef0b":"markdown","2c76ac64":"markdown","75e4f433":"markdown","b28cfba4":"markdown","b41f0998":"markdown","ac4f156e":"markdown","d2acec42":"markdown","4be1db8c":"markdown","20df3439":"markdown","a6d7aed6":"markdown"},"source":{"73124a03":"import time\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nfrom sklearn.model_selection import train_test_split \n\n\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import LinearSVC\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom xgboost import XGBClassifier\nfrom xgboost import plot_importance\n\n\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import plot_confusion_matrix\nfrom sklearn.metrics import precision_recall_fscore_support as score\nfrom sklearn.metrics import roc_curve, auc, roc_auc_score","3125c568":"# load the dataset\ndata = pd.read_csv('\/kaggle\/input\/nasa-asteroids-classification\/nasa.csv')\ndata.head()","f3702f54":"print(data.shape)\nprint(data.info())","fa711c22":"# missing value percentage\nround((data.isnull().sum() * 100\/ len(data)),2).sort_values(ascending=False)","59c83088":"# find the unique values\ndata.nunique()","656ccaa4":"# drop the mentioned variables from the dataset\ndf = data.drop(['Orbiting Body','Equinox','Neo Reference ID', 'Name','Close Approach Date','Epoch Date Close Approach','Orbit ID','Orbit Determination Date','Epoch Osculation','Perihelion Time'], axis = 1)\ndf.shape","925f4c89":"sns.set(style='darkgrid')\nplt.figure(figsize=(10, 10))\nsns.heatmap(df.corr())\nplt.show()","fe079200":"# drop the mentioned variables from the dataset\ndf = df.drop(['Est Dia in KM(max)','Est Dia in M(min)','Est Dia in M(max)','Est Dia in Miles(min)','Est Dia in Miles(max)','Est Dia in Feet(min)','Est Dia in Feet(max)',\n             'Relative Velocity km per sec','Miles per hour',\n             'Miss Dist.(Astronomical)','Miss Dist.(lunar)','Miss Dist.(miles)'],axis = 1)\nprint(df.shape)\ndf.head()","2973e613":"df.info()","acfb7ba5":"plt.figure(figsize=(10, 10))\nsns.heatmap(df.corr())\nplt.show()","793e2a60":"# To get a more clear picture of the correlation with Hazardous Nature\ndf.corr()['Hazardous'][:-1].sort_values().plot(kind='bar')\nplt.show()","0b7e7484":"# get the values\nprint(df['Hazardous'].value_counts())\nprint('\\n')\n\n# plot\nlab = 'False','True'\nplt.pie(df['Hazardous'].value_counts(), labels = lab, colors = ['green','red'],\n        autopct='%1.1f%%')\nplt.title('Hazardous Nature')\nplt.show()","512e2715":"# get the values\nprint(df['Orbit Uncertainity'].value_counts())\nprint('\\n')\n\n# plot\ndf1 = df.groupby([\"Orbit Uncertainity\"]).count().reset_index()\n\nfig = px.bar(df1,\n             y=df.groupby([\"Orbit Uncertainity\"]).size()\/len(df)*100,\n             x=\"Orbit Uncertainity\")\nfig.update_layout(yaxis_title='percentage',\n                  title_text='Orbit Uncertainity')\nfig.show()","acafc668":"# plot\ndf.groupby('Orbit Uncertainity')['Hazardous'].value_counts(normalize=True).unstack('Hazardous').plot.bar(stacked=True, title='Orbit Uncertainity vs. Hazardous Nature')\nplt.show()","b1c60ca8":"# plot\nsns.histplot(data['Absolute Magnitude']).set_title('Absolute Magnitude')\nplt.show()","65bf49c9":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Absolute Magnitude\",data=df,palette=('green','red')).set_title('Absolute Magnitude vs. Hazardous Nature')\nplt.show()","025e8283":"# plot\nsns.histplot(data['Minimum Orbit Intersection']).set_title('Minimum Orbit Intersection')\nplt.show()","4eff19ba":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Minimum Orbit Intersection\",data=df,palette=('green','red')).set_title('Minimum Orbit Intersection vs. Hazardous Nature')\nplt.show()","2a70dc42":"# plot\nsns.histplot(data['Perihelion Distance']).set_title('Perihelion Distance')\nplt.show()","d1be33fb":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Perihelion Distance\",data=df,palette=('green','red')).set_title('Perihelion Distance vs. Hazardous Nature')\nplt.show()","5c2ce75e":"# plot\nsns.histplot(data['Est Dia in KM(min)']).set_title('Estimated diameter(min)')\nplt.show()","9cf9a223":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Est Dia in KM(min)\",data=df,palette=('green','red')).set_title('Estimated diameter(min) vs. Hazardous Nature')\nplt.show()","8949859a":"# plot\nsns.histplot(data['Eccentricity']).set_title('Eccentricity')\nplt.show()","25c24459":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Eccentricity\",data=df,palette=('green','red')).set_title('Eccentricity vs. Hazardous Nature')\nplt.show()","a663c496":"# plot\nsns.histplot(data['Relative Velocity km per hr']).set_title('Relative Velocity')\nplt.show()","282b3ad9":"# plot\nsns.boxplot(x=\"Hazardous\", y=\"Relative Velocity km per hr\",data=df,palette=('green','red')).set_title('Relative Velocity vs. Hazardous Nature')\nplt.show()","1a3e6ae7":"y=df[\"Hazardous\"]\nx=df.drop([\"Hazardous\"],axis=1)","25e79a13":"# split data set into train and test\ntrain_x,test_x,train_y,test_y=train_test_split(x,y,test_size=0.2,random_state=2)\nprint(train_x.shape)\nprint(test_x.shape)","2433ac7f":"# plot ROC curve\ndef plot_roc_curve(fpr, tpr):\n    '''\n    fpr: false positive rate\n    tpr: true positive rate\n    '''\n    plt.plot(fpr, tpr, color='red', label='ROC')\n    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic (ROC) Curve')\n    plt.legend()\n    plt.show()","b16de0a2":"# define a function to train and test the models\ndef train_test_model(model, train_x, test_x, train_y, test_y,labels):\n    ''' \n    Train and test the model using the training and test data sets. \n    Return the predictions, accuracy and metric reports. \n    '''\n    model.fit(train_x, train_y)\n    predictions = model.predict(test_x)\n    accuracy = model.score(test_x, test_y)\n    metrics_report = classification_report(test_y, predictions)\n    precision, recall, fscore, train_support = score(test_y, predictions, average='weighted')\n    return predictions, accuracy, metrics_report, (precision, recall, fscore)","6a403ef2":"# get the hazardous labels\nlabels = df.Hazardous.unique()\nprint(labels)","bd6e40f0":"# define the model\nlog_model = LogisticRegression(penalty='l2', max_iter=500)\n\n# fit & predict\nst_time = time.time()\npredictions, accuracy, metrics_report, log_prf = train_test_model(log_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(log_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","f1f62b54":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","b48d98b5":"# define the model\nrf_model = RandomForestClassifier(n_estimators=100, max_depth=100, min_samples_split=10, n_jobs=-1, verbose=0)\n\n# fit & predict\nst_time = time.time()\npredictions, accuracy, metrics_report, rf_prf = train_test_model(rf_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(rf_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","fdf279b0":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","297a9ea2":"feature_imp = pd.Series(rf_model.feature_importances_,index=x.columns.tolist()).sort_values(ascending=False)\nsns.barplot(x=feature_imp, y=feature_imp.index)\nplt.xlabel('Feature Importance Score')\nplt.ylabel('Features')\nplt.title(\"Visualizing Important Features\")\nplt.legend()\nplt.show()","010224ff":"# plot\nsns.scatterplot(x=df['Absolute Magnitude'],y=df['Minimum Orbit Intersection'],hue=df['Hazardous'],palette=['green','red']).set_title('Hazardous Nature vs. Minimum Orbit Intersection vs. Absolute Magnitude')\nplt.show()","5ec27301":"# drop the Absolute Magnitude and Minimum Orbit Intersection\ndf_new = df.drop(['Absolute Magnitude','Minimum Orbit Intersection'],axis = 1)\ndf_new.head()","18b2f3c8":"y=df_new[\"Hazardous\"]\nx=df_new.drop([\"Hazardous\"],axis=1)\n\n# split data set into train and test\ntrain_x,test_x,train_y,test_y=train_test_split(x,y,test_size=0.2,random_state=2)\nprint(train_x.shape)\nprint(test_x.shape)","c694f472":"labels = df_new.Hazardous.unique()\n\n# define the model\nrf_model = RandomForestClassifier(n_estimators=100, max_depth=100, min_samples_split=10, n_jobs=-1, verbose=0, random_state=2)\n\n# fit and predict\nst_time = time.time()\npredictions, accuracy, metrics_report, rf_prf = train_test_model(rf_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(rf_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","701b9702":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","201ac5d7":"# define the model\ngb_model = GradientBoostingClassifier(n_estimators=50, max_depth=10, random_state=2)\n\n# fit and predict\nst_time = time.time()\npredictions, accuracy, metrics_report, gb_prf = train_test_model(gb_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(gb_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","e664a1e2":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","d9b7a219":"# define the model\nxgb_model = XGBClassifier(n_estimators = 1000, learning_rate = 0.001, random_state=2)\n\n# fit and predict\nst_time = time.time()\npredictions, accuracy, metrics_report, xgb_prf = train_test_model(xgb_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(xgb_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","fabb9ab0":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","60f0b0cf":"# define the model\nnb_model = GaussianNB()\n\n# fit and predict\nst_time = time.time()\npredictions, accuracy, metrics_report, nb_prf = train_test_model(nb_model, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(nb_model, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","1e015a85":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","ba5aa1ea":"# define the model\nsvm = LinearSVC(class_weight='balanced', verbose=False, max_iter=10000, tol=1e-4, C=0.1, random_state=2)\n\n# fit and predict\nst_time = time.time()\npredictions, accuracy, metrics_report, svm_prf = train_test_model(svm, train_x, test_x, train_y, test_y, labels)\nen_time = time.time()\nprint('Total time: {:.2f}s'.format(en_time-st_time))\nprint('accuracy: {}'.format(accuracy))\nprint('='*100)\nprint(metrics_report)\nplot_confusion_matrix(svm, test_x, test_y, display_labels=labels, xticks_rotation='vertical', cmap=\"BuPu\")","e780d397":"fpr, tpr, thresholds = roc_curve(test_y, predictions)\nplot_roc_curve(fpr, tpr)\nroc_auc_score(test_y, predictions)","0bf9e6a3":"# classification matric indices\nxx = np.array([1,2,3])\nwidth = 0.15\ngb_prf = np.array([0.83, 0.83, 0.83])\nax = plt.subplot(111)\nax.bar( xx - width, height=np.array(nb_prf), width=width, color='b', align='center', label='NB', tick_label=['Precision', 'Recall', 'f1'])\nax.bar(xx ,height=np.array(xgb_prf), width=width, color='g', align='center', label='XGB')\nax.bar(xx + width, height=np.array(svm_prf), width=width, color='r', align='center', label='SVM')\nax.bar(xx + 2*width, height=np.array(rf_prf), width=width, color='y', align='center', label='Random Forest')\nax.bar(xx + 3*width, height=np.array(gb_prf), width=width, color='black', align='center', label='Gradient Boosting')\n\n\nplt.xlabel('Classification Metrics')\nplt.ylabel('Scores')\nplt.legend(loc='lower right')\nplt.show()","103119cf":"feature_imp = pd.Series(rf_model.feature_importances_,index=x.columns.tolist()).sort_values(ascending=False)\nsns.barplot(x=feature_imp, y=feature_imp.index)\nplt.xlabel('Feature Importance Score')\nplt.ylabel('Features')\nplt.title(\"Visualizing Important Features\")\nplt.legend()\nplt.show()","09569cf3":"## Logistic Regression","3adb2452":"Relative Velocity vs. Hazardous Nature","3777e7dc":"Eccentricity vs. Hazardous Nature","5774cc6c":"This clearly shows the seperation between hazadous and non-hazardous asteroids in terms of the _Minimum Orbit Intersection (MOI)_ and _Absolute Magnitude_.  According to NASA the asteroid having a **MOI <0.05**, and  **absolute magnitude < 22mag** is used as a criterion for classifying an asteroid as potentially hazardous object (PHO) in this dataset. (Study of astronomy online at Swinburne University).  \n  \nSo, let's drop these 2 critical variables to identify the classification power of the remaining features.","ff579630":"80% of the dataset is used to train the classification models and remaining 20% is used for the eveluations","4cf7bc53":"Confusion matrix and ROC curve is used as the model evaluation metrics.","32f38840":"NASA classified an asteroid as a Potentially Hazardous Asteroid based on 2 characteristics; **Minimum Orbit Intersection Distance with the Earth, and Absolute Magnitude**  \n\nThis notebook discusses the other factors that might be usefull to identify an asteroid as potentially hazardous or not. And explains the classification power of those remaining factors in the absence of absolute magnitude and minimum orbit intersection values.","3a58b2cc":"Absolute Magnitude  \nMeasure of the luminosity of an asteroid, on an inverse logarithmic astronomical magnitude scale.","d3eb39d6":"## XGBoost","a9b393c6":"# Advanced Analysis","42fc030f":"# Feature Engineering","088a3beb":"# Hazardous Nature of Near Earth Objects","975eda7e":"Relative Velocity  \nAsteroid's velocity relative to earth","04782112":"# Exploratory Data Analysis","1b43bef4":"This dataset not contain any missing values.","fb1871ce":"Hazardous Nature  \nIs the asteroid hazardous? (True or False)","08578620":"Orbit Uncertainity vs. Hazardous Nature","6d40df01":"Perihelion Distance  \nDistance of point in asteroid's orbit which is closest to the Sun","f2249a0c":"## Correlation among the variables","fd8e6a66":"The datset contains 16.1% of hazardous asteroids and 83.9% of non-hazardous asteroids.","623a7324":"Min and max estimated diameter have measured in several units like Km, m, Miles, and Feet. All the variables shows an perfect correlation to each other. We can keep one variable to measure the estimated diameter. So we are going to **keep _'Est Dia in KM(min)'_**.  \nRelative velocity has also measured in three different units they are perfectly correlated to each other. We are going to **keep _'Relative Velocity km per hr'_**  \n'Miss Dist.' also has shows same charecteristics as above two. So, we are going to **keep _'Miss Dist.(kilometers)'_**","340b1791":"Minimum Orbit Intersection  \nThe closest distance between Earth and the asteroid in their respective orbits (in astronomical units)","4468a727":"# Without Absolute Magnitude and Minimum Orbit Intersection","12f868d7":"# Pre-Processing","206bb8f0":"Minimum Orbit Intersection vs. Hazardous Nature","831795c5":"Est Dia in KM(min) vs. Hazardous Nature","6d0c9129":"Absolute Magnitude vs. Hazardous Nature","0f1b4d3a":"Est Dia in KM(min)  \nMinimum estimated diameter of the asteroid","082ac187":"## Support Vector Machine (SVM)","325562a1":"Dataset contains the informaion about 4687 asteroids with 40 features.","b3a2fc54":"'Orbiting Body' and 'Equinox' contain one value for all the data.  \n'Neo Reference ID', 'Name','Close Approach Date','Epoch Date Close Approach','Orbit ID','Orbit Determination Date','Epoch Osculation', and 'Perihelion Time' contain some level of unique data or text data that are less interest.  \nSo, we can drop all these variables.","f0da3ada":"Eccentricity  \nA value which specifies by how much the asteroid's orbit deviates from a perfect circle","e28c82cb":"## Naive Bayes Classifier","8ac3789c":"Perihelion Distance vs. Hazardous Nature","263602bc":"_Minimum Orbit Intersection_ and _Absolute Magnitude_ show the highest feature importance score among all the features.  \nThis make sense, cause NASA has classified this dataset based on these 2 factors.  \nLet's plot these factors with the Hazardous Nature and see the impact.","1dfeef0b":"### Summary of the Accuracy and AUC values\nRandom Forest | Accuracy: 92.75% | AUC: 0.8184  \nGradient Boost | Accuracy: 94.46% | AUC: 0.8729  \nXGBoost | Accuracy: 89.76% | AUC: 0.7405  \nNaive Bayes | Accuracy: 81.88% | AUC: 0.5080  \nSVM | Accuracy: 83.58% | AUC: 0.5","2c76ac64":"## Gradient Boosting","75e4f433":"Random forest model shows a perfect accuracy of 99.68%.  \nLet's find the feature importance based on the Random Forest model.","b28cfba4":"Orbit Uncertainity  \nA measure of the uncertainty ('measurement errors') in the calculated orbit","b41f0998":"## Random Forest","ac4f156e":"Let's consider the Random Forest to do a feature engineering to identify the feature importance of the relevant features.","d2acec42":"## Random Forest","4be1db8c":"Precision, Recall and f1 statistics suggest the Random Forest as the best model to predict the hazardous nature of an asteroid without _Absolute Magnitude_ and _Minimum Orbit Intersection_ with **92.75%** of accuracy","20df3439":"# Model Evaluation","a6d7aed6":"Let's separate the variable of interest as the response variable and all the other variables as the predictor variables."}}