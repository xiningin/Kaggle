{"cell_type":{"8838ea17":"code","8627d696":"code","d2254dc1":"code","fc15e8bf":"code","3ea5d427":"code","e57f1417":"code","e0153ed7":"code","95307409":"code","1264846d":"code","77593665":"code","815f7a74":"code","41eebfce":"code","26aa2560":"code","86261a2f":"code","3fc6b773":"code","f5a39c92":"code","92b40c94":"code","542ada54":"code","40d72d61":"markdown","b6d09e81":"markdown","98d02afb":"markdown","28ebee4f":"markdown","75849516":"markdown","cd19d3ec":"markdown","2a9135ae":"markdown"},"source":{"8838ea17":"# import required libraries for dataframe and visualization\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport datetime as dt\n\n# import required libraries for clustering\nimport sklearn\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\nfrom scipy.cluster.hierarchy import linkage\nfrom scipy.cluster.hierarchy import dendrogram\nfrom scipy.cluster.hierarchy import cut_tree\nfrom sklearn.neighbors import NearestCentroid\nimport scipy.cluster.hierarchy as sch\nfrom sklearn.cluster import AgglomerativeClustering","8627d696":"df = pd.read_csv('..\/input\/california-housing-prices\/housing.csv')","d2254dc1":"df.head()","fc15e8bf":"df.shape","3ea5d427":"df.info()","e57f1417":"df.describe().transpose()","e0153ed7":"features = ['longitude', 'latitude']\nselect_df = df[features]\nselect_df.columns","95307409":"select_df.head()","1264846d":"scaler = StandardScaler()\nX = scaler.fit_transform(select_df)","77593665":"X = pd.DataFrame(X)\nX.columns = features\nX.head()","815f7a74":"def clustering(df1, clusters):\n    X = df1.iloc[:].values\n\n    for n_clusters in clusters:\n        # Create a subplot with 1 row and 2 columns\n        clusterer = AgglomerativeClustering(n_clusters=n_clusters, linkage='ward')\n        y_predict = clusterer.fit_predict(X)\n        cluster_labels = clusterer.labels_\n\n        clf = NearestCentroid()\n        clf.fit(X, y_predict)\n        print(\"Centroids:\")\n        print(clf.centroids_)\n        print(type(clf.centroids_))\n        from scipy.cluster.vq import vq\n\n        partition, euc_distance_to_centroids = vq(X, clf.centroids_)\n\n        TSS = np.sum((X-X.mean(0))**2)\n        WSS = np.sum(euc_distance_to_centroids**2)\n        BSS = TSS - WSS\n        print(\"Within Cluster Sum of Squares = \", WSS)\n        print(\"Between Cluster Sum of Squares = \", BSS)\n        print(\"\")\n\n    return","41eebfce":"clustering(select_df, [5])","26aa2560":"silhouette_coefficients = []\n\nfor k in range(2, 11):\n    hc = AgglomerativeClustering(n_clusters = k, affinity = 'euclidean', linkage = 'ward')\n    hc.fit_predict(X)\n    score = silhouette_score(X, hc.labels_)\n    silhouette_coefficients.append(score)","86261a2f":"plt.style.use(\"fivethirtyeight\")\nplt.plot(range(2, 11), silhouette_coefficients)\nplt.xticks(range(2, 11))\nplt.xlabel(\"Number of Clusters\")\nplt.ylabel(\"Silhouette Coefficient\")\nplt.show()","3fc6b773":"dendrogram = sch.dendrogram(sch.linkage(X, method = 'ward'))","f5a39c92":"clustering(select_df, [2])","92b40c94":"hc = AgglomerativeClustering(n_clusters = 2, affinity = 'euclidean', linkage = 'ward')\ndf['clusters'] = hc.fit_predict(X)","542ada54":"df['clusters'] = df['clusters'].astype(\"category\")\nsns.set_style('whitegrid')\nsns.relplot(x='longitude', y='latitude', hue='clusters', data=df, kind='scatter')","40d72d61":"## Hierarchial Clustering with Agglomerative","b6d09e81":"## Silhouette Analysis","98d02afb":"## Displaying the Data","28ebee4f":"## Recheckign WSS and BSS values","75849516":"## Dendogram","cd19d3ec":"Goal is to minimize WSS and maximize BSS","2a9135ae":"## Within Cluster Sum of Squares, Between Cluster Sum of Squares, and Total Cluster Sum of Squares"}}