{"cell_type":{"65309f6a":"code","201b8759":"code","58ed3677":"code","dc622f72":"code","aa605845":"code","4b79cb03":"code","22bcf8f6":"code","ae2f824b":"code","34f8b150":"code","19f284b6":"code","78ae9330":"code","cbd38195":"code","48186cae":"code","679e439c":"code","504677c2":"code","17150711":"code","c60c81b8":"markdown","569f2a75":"markdown","a4592d8c":"markdown","652d0279":"markdown","ba5a38fa":"markdown","7b1b8784":"markdown","f6f71a28":"markdown","89f7e588":"markdown","03248ef7":"markdown","41bdbafa":"markdown","88d70f6a":"markdown","9e3e93bc":"markdown","a1493d4e":"markdown","c15ed1fe":"markdown","413054c7":"markdown"},"source":{"65309f6a":"%reload_ext autoreload\n%autoreload 2\n%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\nfrom fastai.vision import *\nfrom fastai.metrics import error_rate","201b8759":"SEED = 42\nVALIDATION_PCT = 0.1\nIMAGE_SIZE_64 = 64\nIMAGE_SIZE_224 = 224\nBATCH_SIZE_64 = 64\nBATCH_SIZE_224 = 224\nPATH = Path('..\/input')\nTRAIN_PATH = PATH\/'train'\nTEST_FOLDER_PATH = \"test\/test\"\nSAMPLE_SUBMISSION_PATH = PATH\/\"sample_submission.csv\"","58ed3677":"def load_data(path, image_size, batch_size, validation_pct = VALIDATION_PCT):\n    data = (ImageList.from_folder(path)\n                .split_by_rand_pct(validation_pct, seed = SEED) # Taking 10% of data for validation set\n                .label_from_folder() # Label the images according to the folder they are present in\n                .transform(get_transforms(), size = image_size) # Default transformations with the given image size \n                .databunch(bs = batch_size) # Using the given batch size\n                .normalize(imagenet_stats)) # Normalizing the images to improve data integrity\n    return data","dc622f72":"data_64 = load_data(TRAIN_PATH, IMAGE_SIZE_64, BATCH_SIZE_224, VALIDATION_PCT)\ndata_64","aa605845":"learn = cnn_learner(data_64, # training data with low resolution\n                    models.resnet152, # Model which is pretrained on the ImageNet dataset \n                    metrics = [error_rate, accuracy], # Validation metrics\n                    model_dir = '\/tmp\/model\/') # Specifying a write location on the machine where the lr_find() can write ","4b79cb03":"learn.lr_find()\nlearn.recorder.plot()","22bcf8f6":"learn.fit_one_cycle(1, 1e-2)","ae2f824b":"test_df = pd.read_csv(SAMPLE_SUBMISSION_PATH)\ntest_df.head()\n","34f8b150":"test_images = ImageList.from_df(test_df, PATH\/\"\", folder = TEST_FOLDER_PATH)","19f284b6":"test_images[1]\n","78ae9330":"test_images[192]","cbd38195":"data_256 = load_data(TRAIN_PATH, IMAGE_SIZE_224, BATCH_SIZE_64, VALIDATION_PCT)\ndata_256.add_test(test_images)","48186cae":"learn.data = data_256\nlearn.lr_find()\nlearn.recorder.plot()","679e439c":"learn.unfreeze()\nlearn.fit_one_cycle(30, max_lr = slice(1.0e-4, 1.0e-3))","504677c2":"test_probabalities, _ = learn.get_preds(ds_type=DatasetType.Test)\ntest_predictions = [data_256.classes[pred] for pred in np.argmax(test_probabalities.numpy(), axis=-1)]","17150711":"test_df.predicted_class = test_predictions\ntest_df.to_csv(\"submission.csv\", index=False)\ntest_df.head()","c60c81b8":"**Finding the best range for the Learning Rate. The aim is to find a steep range where our model can converge faster. \n**","569f2a75":"**Fetching the sample submission file which contains the name of the images and a sample prediction class**","a4592d8c":"**Initializing our CNN model with the required parameters. **","652d0279":"**Function using which you can load the data. It uses fastai's data_block api which helps in fetching the files from the folder structure.**","ba5a38fa":"**Fitting the low resolution dataset into the model.**","7b1b8784":"**Variables initialization**","f6f71a28":"**Creating a predictions dataframe which consists of the imageId and the class.**","89f7e588":"**Extracting the test images from the data frame**","03248ef7":"**Unfreezing the layers of the Neural Net so that their weights can be updated with respect to our high resolution dataset. **","41bdbafa":"**Finding the probabality of all the classes for the given Test Dataset. Finding the predictions for the dataset by choosing the class with the highest probability.**","88d70f6a":"**Loading the data with high resolution and adding the test images to it.**","9e3e93bc":"**Importing necessary libraries**","a1493d4e":"**Loading the data with low resolution.**","c15ed1fe":"**Putting the high resolution data as the training data for the model.\nFinding the best LR range so that our model converges fasters.**","413054c7":"**Implementation of Resnet152 to achieve accuracy of 0.99 in the public leaderboard**"}}