{"cell_type":{"69a6cfe3":"code","d728c680":"code","4a515319":"code","a9417bad":"code","ebc3543a":"code","f08231a6":"code","9855022b":"code","78fe78cc":"code","3aee4ec6":"code","962999d5":"code","62783851":"code","2e3ca393":"code","63049db5":"code","a79c2b96":"code","2db4d2c2":"code","ea34ee96":"markdown","6ed86bdb":"markdown","6fc799b5":"markdown","42900417":"markdown","aa8150b1":"markdown","38d13cc2":"markdown","f6e274c9":"markdown","d12df214":"markdown","b9738877":"markdown","4f90fa44":"markdown","73a52220":"markdown","6b8d6f1f":"markdown","4bfd111c":"markdown"},"source":{"69a6cfe3":"# Install\n\n!mkdir \"..\/working\/firefox\"\n!cp -a \"..\/input\/firefox-63.0.3.tar.bz2\/firefox\/.\" \"..\/working\/firefox\"\n!chmod -R 777 \"..\/working\/firefox\"\n!pip install webdriverdownloader\nfrom webdriverdownloader import GeckoDriverDownloader\ngdd = GeckoDriverDownloader()\ngdd.download_and_install(\"v0.23.0\")\n!pip install selenium\n!apt-get install -y libgtk-3-0 libdbus-glib-1-2 xvfb\n!export DISPLAY=:99","d728c680":"# Setup for browser\nfrom selenium import webdriver as selenium_webdriver\nfrom selenium.webdriver.firefox.options import Options as selenium_options\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities as selenium_DesiredCapabilities\nbrowser_options = selenium_options()\nbrowser_options.add_argument(\"--headless\")\nbrowser_options.add_argument(\"--window-size=1920,1080\")\n# browser_options.add_argument(\"user-agent=whatever you want\")\ncapabilities_argument = selenium_DesiredCapabilities().FIREFOX\ncapabilities_argument[\"marionette\"] = True\nbrowser = selenium_webdriver.Firefox(\n    options=browser_options,\n    firefox_binary=\"..\/working\/firefox\/firefox\",\n    capabilities=capabilities_argument\n)","4a515319":"# Get the screenshot from google for a given location\nlat = 43.640722\nlng = -79.3811892\nz = 17 # Height\nimport numpy","a9417bad":"url = 'https:\/\/www.google.com\/maps\/@' + str(lat) + ',' + str(lng) + ',' + str(z) + 'z'\nprint(url)\nbrowser.set_window_size(1024,512)\nbrowser.get(url)\nbrowser.save_screenshot(\"before.png\")\n","ebc3543a":"# Get the scaling in meters and pixels\nfoot2meter = 0.3048;\nscale_in_feet = float(browser.find_element_by_id('widget-scale-label').text.replace(' ft',''))\nscale_in_meters = scale_in_feet*foot2meter\n\npixel_length = float(browser.find_element_by_class_name('widget-scale-ruler').value_of_css_property(\"width\").replace('px',''))\nprint(pixel_length)\n\nMetersPerPixel = scale_in_meters\/pixel_length\nprint(MetersPerPixel)\n\njs_string = \"var element = document.getElementById(\\\"omnibox-container\\\");element.remove();\"\nbrowser.execute_script(js_string)\njs_string = \"var element = document.getElementById(\\\"vasquette\\\");element.remove();\"\nbrowser.execute_script(js_string)\n\njs_string = \"var element = document.getElementsByClassName(\\\"app-viewcard-strip\\\");element[0].remove();\"\nbrowser.execute_script(js_string)\njs_string = \"var element = document.getElementsByClassName(\\\"scene-footer-container\\\");element[0].remove();\"\nbrowser.execute_script(js_string)\n","f08231a6":"browser.save_screenshot(\"waterfront.png\")\n","9855022b":"from PIL import Image,ImageDraw,ImageFont\n\nimport matplotlib.pyplot as plt\n\nimg = Image.open('\/kaggle\/working\/waterfront.png')\n# Convert to RGBA\nimg = img.convert('RGBA')\n# Load the pixels\npixels = img.load()\n!mkdir \"\/kaggle\/working\/frames\"","78fe78cc":"\n#define the find pixels that calculates number of pixels with that selection\ndef find_pixels(img,pixels,colour_set,slack, size):\n    num_px = []\n    # Set the value you want for these variables\n    r_min = colour_set[0]-slack\n    r_max = colour_set[0]+slack\n    g_min = colour_set[1]-slack\n    g_max = colour_set[1]+slack\n    b_min = colour_set[2]-slack\n    b_max = colour_set[2]+slack\n    for x in range(size[0][0]):\n        num_px_col_count = 0\n        for y in range(size[0][1]):\n            r, g, b,a = pixels[x,y]\n            pixels[x,y]=(int(255), int(255), int(255),int(0))\n\n            if r >= r_min and r <= r_max and b >= b_min and b <= b_max and g >= g_min and g <= g_max:\n                num_px_col_count = num_px_col_count + 1;\n                pixels[x,y]=(colour_set[0], colour_set[1], colour_set[2],int(255))\n#         print(x)\n        num_px.append(num_px_col_count)\n        if x % 5 == 0:\n            img.save('\/kaggle\/working\/frames\/' + str(x)+ '.png')\n\n    return num_px\n","3aee4ec6":"# Set the park colour\npark_colour = [197,232,197];park_slack = 2;\n\nnum_park = find_pixels(img,pixels,park_colour,park_slack,[img.size])\n","962999d5":"!mkdir \"\/kaggle\/working\/matplot\/\"\nfig=plt.figure(figsize=(1024\/100,438\/100))\nax = fig.add_subplot(111)\nax.set_facecolor(\"white\")\nfig.patch.set_facecolor(\"white\")\nfig.patch.set_alpha(0.0)\nax.set_xticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\nax.set_yticklabels(labels = [''], fontsize = 18,alpha = .7,minor=False)\n\n\nax.set_xlim([-10,1024])\nax.set_ylim([-10,438])\n\n\nfor spine in ax.spines.values():\n    spine.set_edgecolor('white')\nplt.grid(False)\nplt.axis('off')\n\nfor i in range(0,1024,10):\n#     print(i)\n    ax.plot(num_park[:i],color='#377e4d',linewidth=3,antialiased=True)\n    plt.savefig('\/kaggle\/working\/matplot\/'+str(i)+'.png', transparent=True,dpi=130)","62783851":"print(img.size)\ntotal_area = img.size[0]*img.size[1]*MetersPerPixel\/(1000*1000)\nprint(total_area)","2e3ca393":"# Make a gif by combning the matplot and images to form a nice graphic!\ntitle_font = ImageFont.truetype(\"\/kaggle\/input\/antonfont\/Anton-Regular.ttf\", 30)\nsmall_font = ImageFont.truetype(\"\/kaggle\/input\/antonfont\/Anton-Regular.ttf\", 10)\n\n# Loop over the frames in 10s\nframes = []\nfor i in range(0,1024,10):\n    # Load the other images we will overlay\n    googlemap = Image.open('\/kaggle\/working\/frames\/'+ str(i)+ \".png\")\n    matplot = Image.open('\/kaggle\/working\/matplot\/'+str(i)+'.png')\n    \n    # Create a new image to start\n    final = Image.new(mode='RGBA',size=(googlemap.size[0],googlemap.size[1]),color=(255,255,255,0))\n    # Create the total composite image\n    googlemap.paste(matplot, (-175, -52),matplot)\n    final.paste(googlemap, (0,0),googlemap)\n\n    # Do resampling to get the smoothing effect\n    final = final.resize(final.size, resample=Image.ANTIALIAS)\n\n    \n    frames.append(final)\n\n\n\n\nframes[0].save('t.gif', format='GIF', append_images=frames[1::], save_all=True, duration=1, loop=0)","63049db5":"# # SEE WHAT'S UNDER THE HOOD HERE\n# !cat \/etc\/os-release","a79c2b96":"# # WHERE ARE WE RIGHT NOW?\n# !ls -l .","2db4d2c2":"# # BUT, WHERE, REALLY, ARE WE RIGHT NOW? (p.s. IT LOOKS LIKE WE'RE INSIDE \/kaggle\/working FOLDER, INSIDE AN ISOLATE DOCKER CONTAINER\/IMAGE)\n# !echo \"ls -l \/kaggle\"\n# !ls -l \/kaggle\n\n# !echo \"\\nls -l \/kaggle\/working\"\n# !ls -l \/kaggle\/working","ea34ee96":"I was curious if I could make web scraping via a headless Firefox browser and selenium work in a Kaggle kernel. While this curiosity led to much frustration and hair tugging, I learned alot and am happy to report it works!","6ed86bdb":"### **Pre-requisite steps:**\n\n1) First, manually download firefox for linux locally somewhere:\n\nhttp:\/\/ftp.mozilla.org\/pub\/firefox\/releases\/63.0.3\/linux-x86_64\/en-US\/firefox-63.0.3.tar.bz2\n\n2) then upload as new private \"dataset\" to kaggle account, making it selectable across kernels\n\n*note: when uploading, make sure to choose \"Keep tabular files in original format\" *","6fc799b5":"## This notebook shows how to use headless Firefox browser + selenium library in Python to scrape data live in real-time from within a Kaggle notebook","42900417":"I am a running and wanted to find the best route in my area.  I my mind the best route is the most beautiful.  This means lots of greenspace and water. The issue is that there is not real map data that will let me quantify if an area is nice or not.  I could go to Google Maps and determine if a route might look ok, but again this is just a visual check.  To solve this I decided to extract features from Google Maps using Python, Selenium and Pillow (image lib).\n\nAs a part one I just want to see if I can automatically get a snapshot of Google Maps and extract feature information.  Feature information in this case is a rough approximation of proximity to parks and water. (More on this later)\n\nThe heavy lifting is done by Selenium which is a package that can mimic someone actually browsing a website.  \n\nFirst we need to install a browser (Firefox) and required drivers needed for using Selenium.  That in addition to some packages we need.","aa8150b1":"Now that everything is installed we can set up an instance of the browser which will live as a background process.","38d13cc2":"Yay! We have an image of the waterfront.  Now we will use Pillow to load the image and extract the pixels","f6e274c9":"### **Part 1: ** installing portable Firefox binary, geckodriver, and selenium library","d12df214":"Next  I will set up my URL to google maps and \"browse\"","b9738877":"As my first step lets set up the location I would like to work on.  How about the Toronto Waterfront?\n\n","4f90fa44":"I noticed that there is an element called the omnibox which overlays the map.  So lets get rid of that!","73a52220":"1) Manually \"+Add data | Your Datasets | firefox-63.0.3.tar.bz2\"\n\nnote: referencing uploaded binary files as \"datasets\" automatically places them into \"..\/input\" folder\n\n2) Under Settings section, set Internet = \"Internet Conneted\"","6b8d6f1f":"Calculate the percentage and total area of parkland","4bfd111c":"Now we can save the image!"}}