{"cell_type":{"c8845533":"code","e993ba45":"code","71034d05":"code","e1220991":"code","38123fb2":"code","9add4c63":"code","cb832e7f":"code","6206e85f":"code","bcfa6c7e":"code","39cad21c":"code","d47e080f":"code","bf5bf673":"code","f3034aa3":"code","f68cbb96":"code","4e4de382":"code","41c91abb":"code","70a5cb1e":"code","734cb838":"markdown"},"source":{"c8845533":"!pip install -q efficientnet","e993ba45":"%matplotlib inline\n%config InlineBackend.figure_format = 'svg'\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport cv2\nimport time\nimport itertools\n\nfrom keras.callbacks import ReduceLROnPlateau\nfrom keras.utils import np_utils\nimport efficientnet.tfkeras as efn\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten\nfrom keras.models import Model\nimport tensorflow as tf\nfrom tensorflow.keras.utils import plot_model\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix\n\ntrain = pd.read_csv('..\/input\/digit-recognizer\/train.csv')\ntest = pd.read_csv('..\/input\/digit-recognizer\/test.csv')\n\nY_train = train['label']\nX_train = train.drop(['label'], axis=1)\n\nX_train = X_train.astype('float32')\ntest = test.astype('float32')\n\nX_train \/= 255\ntest \/= 255\n\nX_train = X_train.values.reshape(-1,28,28,1)\ntest = test.values.reshape(-1,28,28,1)\n\nprint(X_train.shape)\nprint(test.shape)","71034d05":"plt.subplots(facecolor='white',figsize=(10,20))\nplt.subplot(131)\nplt.imshow(X_train[338,:,:,0], cmap=plt.cm.binary)\nplt.subplot(132)\nplt.imshow(X_train[342,:,:,0], cmap=plt.cm.binary)\nplt.subplot(133)\nplt.imshow(X_train[125,:,:,0], cmap=plt.cm.binary)\nplt.title('images before resize')","e1220991":"IMG_WIDTH = 32\nIMG_HEIGHT = 32\n# train\nx_train = np.full((42000, 32, 32, 3), 0.0)\nfor i, s in enumerate(X_train):\n    s = cv2.resize(s,(IMG_WIDTH, IMG_HEIGHT), interpolation=cv2.INTER_CUBIC) # resize image to 32 * 32 format\n    x_train[i] = cv2.cvtColor(s, cv2.COLOR_GRAY2RGB)\n    \n# test \nx_test = np.full((28000, 32, 32, 3), 0.0)\nfor i, s in enumerate(test):\n    s = cv2.resize(s,(IMG_WIDTH, IMG_HEIGHT), interpolation=cv2.INTER_CUBIC)\n    x_test[i] = cv2.cvtColor(s, cv2.COLOR_GRAY2RGB)\n    \ny_train = np_utils.to_categorical(Y_train, 10)","38123fb2":"plt.subplots(facecolor='white',figsize=(10,20))\nplt.subplot(131)\nplt.imshow(x_train[338,:,:,0], cmap=plt.cm.binary)\nplt.subplot(132)\nplt.imshow(x_train[342,:,:,0], cmap=plt.cm.binary)\nplt.subplot(133)\nplt.imshow(x_train[125,:,:,0], cmap=plt.cm.binary)\nplt.title('images after resize')","9add4c63":"model = Sequential()\nefnModel = efn.EfficientNetB7(weights='imagenet', \n                       input_shape = (32,32,3), \n                       include_top=False)\nmodel.add(efnModel)\nmodel.add(Flatten())\nmodel.add(Dense(1024, activation=\"relu\"))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(units=10, activation=\"softmax\"))\nmodel.summary()","cb832e7f":"plot_model(model, show_shapes=True, show_layer_names=True)","6206e85f":"model.compile(optimizer=tf.keras.optimizers.RMSprop(lr=0.001, decay=1e-6), \n              loss='categorical_crossentropy', \n              metrics=['accuracy'])\n\nBATCH_SIZE = 256\nhistory = model.fit(x_train, y_train,\n              epochs= 15,\n              batch_size = BATCH_SIZE,\n              validation_split=0.2,\n              shuffle=True)","bcfa6c7e":"plt.rcParams['figure.facecolor'] = 'white'\nhistory_dict = history.history\nacc = history_dict['accuracy']\nval_acc = history_dict['val_accuracy']\nepochs = range(1, len(acc) + 1)\nplt.plot(epochs, acc, 'bo', label='Training acc')\nplt.plot(epochs, val_acc, 'b', label='Validation acc')\nplt.title('Training Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\nplt.show()","39cad21c":"test_predictions = model.predict(x_test)\n# select the index with the maximum probability\nresults = np.argmax(test_predictions,axis = 1)\nsubmission = pd.DataFrame({'ImageId': range(1,28001), 'Label': results})\nsubmission.head(10)\nsubmission.to_csv(\"submission.csv\",index=False)","d47e080f":"x_train, x_val, y_train, y_val = train_test_split(x_train, y_train, test_size=0.2, random_state=2017)","bf5bf673":"learning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', \n                                            patience=3, \n                                            verbose=1, \n                                            factor=0.6, \n                                            min_lr=0.00001)","f3034aa3":"BATCH_SIZE = 256\nhistory = model.fit(\n            x_train, y_train,\n            validation_data = (x_val, y_val),\n            batch_size = BATCH_SIZE,\n            steps_per_epoch = x_train.shape[0] \/\/ BATCH_SIZE,\n            epochs = 15,\n            verbose = 1,\n            callbacks=[learning_rate_reduction]\n            )","f68cbb96":"acc = history.history['accuracy']\nval_acc = history.history['val_accuracy']\nloss = history.history['loss']\nval_loss = history.history['val_loss']\n\nplt.figure()\nplt.plot(acc,color = 'green',label = 'Training Acuracy')\nplt.plot(val_acc,color = 'red',label = 'Validation Accuracy')\nplt.legend()","4e4de382":"def plot_confusion_matrix(cm, classes, normalize=False, title='Confusion matrix',cmap=plt.cm.Reds):\n    '''This function prints and plots the confusion matrix.\n       Normalization can be applied by setting `normalize=True`.\n    '''\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        print(\"Normalized confusion matrix\")\n    else:\n        print('Confusion matrix, without normalization')\n\n    print(cm)\n\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","41c91abb":"y_val_pred = model.predict(x_val)\ny_val_pred = np.argmax(y_val_pred,axis = 1)\ny_val1 = np.argmax(y_val,axis = 1)\n#val_preds_class = np.where(val_preds.ravel()>0.5,1,0) \nprint('Out of Fold Accuracy is {:.5}'.format(accuracy_score(y_val1, y_val_pred)))","70a5cb1e":"plt.rcParams['figure.facecolor'] = 'white'\nclass_names = [i for i in range(1,11)]\nplot_confusion_matrix(confusion_matrix(y_val1, y_val_pred),\n                      classes=class_names, \n                      title='MINST confusion_matrix')","734cb838":"reference:\n\nhttps:\/\/www.kaggle.com\/rikdifos\/dogs-vs-cats-densenet201\/\n\nhttps:\/\/www.kaggle.com\/artemkostrikin\/flower-classification-on-tpu"}}