{"cell_type":{"cd891a07":"code","d3990aff":"code","c0447194":"code","50e3c961":"code","369944fb":"code","f0d22e93":"code","abde8727":"code","a3bf8baf":"code","9167b89a":"code","8b14b96c":"code","96f3d91f":"code","d5c6d07f":"code","f235402b":"code","6961f66d":"code","dc4fe14b":"code","83bb57e8":"code","a115c6c8":"code","165e0396":"code","a68481f6":"markdown","cdddcf2f":"markdown","9fe0d5d4":"markdown","75dd9133":"markdown","15ae1b30":"markdown","effa8dee":"markdown","13bb038d":"markdown","ace7757e":"markdown"},"source":{"cd891a07":"import pandas as pd\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras.utils import to_categorical\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OneHotEncoder","d3990aff":"import os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","c0447194":"train = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\")\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\")","50e3c961":"y = train['label'].values.reshape((-1, 1))\nX = train.drop('label', axis = 1).values\ny_oh = to_categorical(y)\nprint(y.shape)\nprint(y_oh.shape)","369944fb":"X_train, X_vali, y_train, y_vali = train_test_split(X, y_oh, test_size = 0.2, random_state = 42)\nprint(X_train.shape, X_vali.shape, y_train.shape, y_vali.shape)","f0d22e93":"tf.reset_default_graph()","abde8727":"def next_batch(num, data, labels):\n    idx = np.arange(0, len(data))\n    np.random.shuffle(idx)\n    idx = idx[:num]\n    data_shuffle = [data[i] for i in idx]\n    labels_shuffle = [labels[i] for i in idx]\n    \n    return np.asarray(data_shuffle), np.asarray(labels_shuffle)","a3bf8baf":"# parameters\ntime_steps = 784\nbatch_size = 280\nnum_classes = 10\nhidden_layer_size = 16","9167b89a":"_inputs = tf.placeholder(tf.float32, shape = [batch_size, time_steps, 1])\n_labels = tf.placeholder(tf.float32, shape = [batch_size, num_classes])","8b14b96c":"validation_data = X_vali[:batch_size].reshape((-1, time_steps, 1))\nvalidation_label = y_vali[:batch_size]","96f3d91f":"print(validation_data.shape)\nprint(validation_label.shape)","d5c6d07f":"with tf.name_scope(\"biGRU\"):\n    with tf.variable_scope('forward'):\n        gru_fw_cell = tf.contrib.rnn.GRUCell(hidden_layer_size)\n        gru_fw_cell = tf.contrib.rnn.DropoutWrapper(gru_fw_cell)\n\n    with tf.variable_scope('backward'):\n        gru_bw_cell = tf.contrib.rnn.GRUCell(hidden_layer_size)\n        gru_bw_cell = tf.contrib.rnn.DropoutWrapper(gru_bw_cell)\n\n    outputs, states = tf.nn.bidirectional_dynamic_rnn(cell_fw = gru_fw_cell,\n                                                      cell_bw = gru_bw_cell,\n                                                      inputs = _inputs,\n                                                      dtype = tf.float32,\n                                                      scope = \"BiGRU\")\n\nstates = tf.concat(values = states, axis = 1)","f235402b":"weights = {'linear_layer': tf.Variable(tf.truncated_normal([2 * hidden_layer_size, num_classes], mean = 0, stddev = 0.01))}\nbiases = {'linear_layer': tf.Variable(tf.truncated_normal([num_classes], mean = 0, stddev = 0.01))}\n\nfinal_output = tf.matmul(states, weights[\"linear_layer\"]) + biases[\"linear_layer\"]\nsoftmax = tf.nn.softmax_cross_entropy_with_logits(logits = final_output, labels = _labels)\ncross_entropy = tf.reduce_mean(softmax)\n\ntrain_step = tf.train.RMSPropOptimizer(0.001, 0.9).minimize(cross_entropy)\ncorrect_prediction = tf.equal(tf.argmax(_labels, 1), tf.argmax(final_output, 1))\naccuracy = (tf.reduce_mean(tf.cast(correct_prediction, tf.float32))) * 100","6961f66d":"sess = tf.InteractiveSession()\nsess.run(tf.global_variables_initializer())\n\nfor i in range(100):\n    batch_x, batch_y = next_batch(batch_size, X_train, y_train)\n    batch_x = batch_x.reshape((batch_size, time_steps, 1))\n    sess.run(train_step, feed_dict = {_inputs: batch_x,\n                                      _labels: batch_y})\n    \n    if i % 10 == 0:\n        acc, loss = sess.run([accuracy, cross_entropy], feed_dict = {_inputs: batch_x,\n                                                                     _labels: batch_y})\n        val_acc = sess.run(accuracy, feed_dict = {_inputs: validation_data,\n                                                  _labels: validation_label})\n        print(\"Iter = \" + str(i) + \" Loss = {:.6f}\".format(loss) + \" Accuracy = {:.5f}\".format(acc) + \n              \" Validation accuracy = {:.5f}\".format(val_acc))","dc4fe14b":"X_test = test.values.reshape((-1, time_steps, 1))\nprint(test.shape)\nprint(X_test.shape)","83bb57e8":"y_pred_list = []\n\nfor i in range(X_test.shape[0]\/\/batch_size):\n    X_test_iter = X_test[(i*batch_size):((i+1)*batch_size)]\n    y_pred = sess.run(tf.argmax(final_output, 1), feed_dict = {_inputs: X_test_iter})\n    \n    y_pred_list.append(y_pred)\n    \ny_pred_list = [item for sublist in y_pred_list for item in sublist]","a115c6c8":"test_id = np.arange(1, X_test.shape[0] + 1, 1)\nprint(test_id.shape)\nprint(len(y_pred_list))","165e0396":"sub = pd.DataFrame(data = {'ImageId': test_id,\n                           'Label': y_pred_list})\nsub.head()","a68481f6":"# Bidirectional RNN and GRU Cells for Digit Recognizer","cdddcf2f":"## Data","9fe0d5d4":"## Submission","75dd9133":"## Setup","15ae1b30":"## Test data prediction","effa8dee":"## One hot encoding","13bb038d":"## Bidirectional RNN with GRU cells","ace7757e":"## Validation data"}}