{"cell_type":{"dee9bdf2":"code","54331c42":"code","5d2269c0":"code","61376b8d":"code","a4c03d09":"code","55ec4043":"code","245c4a41":"code","c9baaa5c":"code","033f1e5e":"code","353f71c3":"code","f8c553d0":"code","0e68664d":"code","478215dd":"code","2e3ca4cc":"markdown"},"source":{"dee9bdf2":"import numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom functools import partial\nimport re, math\nimport matplotlib.pyplot as plt\nfrom kaggle_datasets import KaggleDatasets","54331c42":"try:\n    tpu = tf.distribute.cluster_resolver.TPUClusterResolver()\n    print(\"Device:\", tpu.master())\n    tf.config.experimental_connect_to_cluster(tpu)\n    tf.tpu.experimental.initialize_tpu_system(tpu)\n    strategy = tf.distribute.experimental.TPUStrategy(tpu)\n    \n    print('working on TPU...')\nexcept:\n    strategy = tf.distribute.get_strategy()\n    \n    print('working on CPU\/GPU...')\n    \nprint(\"Number of replicas:\", strategy.num_replicas_in_sync)","5d2269c0":"AUTOTUNE = tf.data.experimental.AUTOTUNE\n\n# this way works even with TPU (where you can't refer local FS)\nGCS_PATH = KaggleDatasets().get_gcs_path('cxr-tfrec256-may2020')\n\nBATCH_SIZE = 64\n\nIMAGE_SIZE = [256, 256]","61376b8d":"TRAINING_FILENAMES = tf.io.gfile.glob(GCS_PATH + \"\/train*.tfrec\")\nVALID_FILENAMES = tf.io.gfile.glob(GCS_PATH + \"\/valid*.tfrec\")\nTEST_FILENAMES = tf.io.gfile.glob(GCS_PATH + \"\/test*.tfrec\")\n\nprint(\"Train TFRecord Files:\", len(TRAINING_FILENAMES))\nprint(\"Validation TFRecord Files:\", len(VALID_FILENAMES))\nprint(\"Test TFRecord Files:\", len(TEST_FILENAMES))","a4c03d09":"def count_data_items(filenames):\n    n = [int(re.compile(r\"-([0-9]*)\\.\").search(filename).group(1)) \n         for filename in filenames]\n    return np.sum(n)\n\nn_train = count_data_items(TRAINING_FILENAMES)\nn_valid = count_data_items(VALID_FILENAMES)\nn_test = count_data_items(TEST_FILENAMES)\n\nprint('Number of train images:', n_train)\nprint('Number of validation images:', n_valid)\nprint('Number of test images:', n_test)","55ec4043":"# we assume here that in TFRecords file images are JPEG, 256x256, 3 channel\n\ndef decode_image(image):\n    image = tf.image.decode_jpeg(image, channels=3)\n    image = tf.cast(image, tf.float32)\n    # normalize pixels\n    image = image\/255.\n    image = tf.reshape(image, [*IMAGE_SIZE, 3])\n    return image","245c4a41":"def read_tfrecord(example, labeled):\n    tfrecord_format = (\n        {\n            \"image\": tf.io.FixedLenFeature([], tf.string),\n            \"label\": tf.io.FixedLenFeature([], tf.int64),\n        }\n        if labeled\n        else {\"image\": tf.io.FixedLenFeature([], tf.string),}\n    )\n    example = tf.io.parse_single_example(example, tfrecord_format)\n    \n    image = decode_image(example[\"image\"])\n    \n    if labeled:\n        label = tf.cast(example[\"label\"], tf.int32)\n        return image, label\n    return image","c9baaa5c":"def load_dataset(filenames, labeled=True):\n    ignore_order = tf.data.Options()\n    ignore_order.experimental_deterministic = False  # disable order, increase speed\n    dataset = tf.data.TFRecordDataset(\n        filenames\n    )  # automatically interleaves reads from multiple files\n    dataset = dataset.with_options(\n        ignore_order\n    )  # uses data as soon as it streams in, rather than in its original order\n    dataset = dataset.map(\n        partial(read_tfrecord, labeled=labeled), num_parallel_calls=AUTOTUNE\n    )\n    # returns a dataset of (image, label) pairs if labeled=True or just images if labeled=False\n    return dataset","033f1e5e":"def get_dataset(filenames, labeled=True):\n    dataset = load_dataset(filenames, labeled=labeled)\n    dataset = dataset.shuffle(2048)\n    dataset = dataset.prefetch(buffer_size=AUTOTUNE)\n    dataset = dataset.batch(BATCH_SIZE)\n    return dataset","353f71c3":"train_dataset = get_dataset(TRAINING_FILENAMES)\nvalid_dataset = get_dataset(VALID_FILENAMES)\ntest_dataset = get_dataset(TEST_FILENAMES)","f8c553d0":"image_batch, label_batch = next(iter(test_dataset))","0e68664d":"def show_batch(image_batch, label_batch):\n    plt.figure(figsize=(16, 16))\n    \n    for n in range(25):\n        ax = plt.subplot(5, 5, n + 1)\n        plt.imshow(image_batch[n])\n        \n        if label_batch[n]:\n            plt.title(\"Abnormal\")\n        else:\n            plt.title(\"Normal\")\n        plt.axis(\"off\")","478215dd":"show_batch(image_batch.numpy(), label_batch.numpy())","2e3ca4cc":"## TFRecord files Explorer\n\nReads a set of images packed in TFRecord files and displays them\n\nThis code has been largely inspired by the example at: https:\/\/keras.io\/examples\/keras_recipes\/tfrecord\/"}}