{"cell_type":{"71df4baf":"code","ab6f8bfe":"code","1a5f49e1":"code","fbae9b73":"code","408aeb98":"code","c0abab2a":"code","1cbed7bd":"code","cc709f80":"code","7542a415":"code","e38ba1eb":"code","2ffffbb3":"code","870269ad":"code","c67b243e":"code","9c5325eb":"code","9fca5081":"code","60b43a60":"code","ad636065":"code","a2127dd2":"code","946f09f8":"code","143e5c57":"code","ddf0f62f":"code","8388d368":"code","ef8a7f73":"code","4648516a":"code","c3961da7":"code","421017eb":"code","c36c452a":"code","e36c8c2b":"markdown","82564fa4":"markdown","ceab0b93":"markdown","6809e015":"markdown","2b4c88cf":"markdown","270226f4":"markdown","31e241a5":"markdown","97250be0":"markdown","c7ea200a":"markdown","e996e2c5":"markdown","25bca106":"markdown","2f403437":"markdown","c55407d8":"markdown"},"source":{"71df4baf":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sklearn as skl\n\nimport warnings\n\nwarnings.simplefilter(\"ignore\")\npd.set_option(\"display.max_columns\", None)","ab6f8bfe":"data = pd.read_csv('\/kaggle\/input\/waddata\/data.csv')","1a5f49e1":"# data cleaning, removing nans, reshaping the table etc\n\ndata.columns = ['country_name', 'country_code', 'features', 'unk', 'values']\ndata = data[['country_code', 'features', 'values']]\ndata['values'] = data['values'].map(lambda x: float(x) if x != '..' else np.nan)\ndata = data.dropna()\ndata = data.pivot_table(index='country_code', columns=['features'],values=['values'])\ndata = data.dropna(axis=1)\n\ndata.columns = data.columns.droplevel(0)\ndata.columns.name = None\ndf = data     ","fbae9b73":"df.head()","408aeb98":"df.columns","c0abab2a":"# raname columns to more friendly names\ndf.columns = [\n    'electricity_access',\n    'adj_income_per_cap',\n    'adj_savings',\n    'age_dependency_ratio',\n    'birth_rate_per_1000',\n    'consumer_price_index',\n    'death_rate_per_1000',\n    'employers_ratio_to_employment',\n    'forest_area_in_percent',\n    'gpd',\n    'gpd_growth_in_usd',\n    'gpd_per_capita',\n    'gpd_per_capita_ppp',\n    'percentage_using_internet',\n    'inflation',\n    'land_area_squared_km',\n    'life_expectency',\n    'population_growth',\n    'self_employment_ratio',\n    'alcohol_consumption',\n    'unemployment_1',\n    'unemployment_2',\n    'urban_population_percentage'\n]\n\ncols_to_use = ['adj_income_per_cap', 'age_dependency_ratio', 'birth_rate_per_1000', 'consumer_price_index', 'forest_area_in_percent', 'inflation', 'life_expectency' , 'alcohol_consumption', 'unemployment_1', 'gpd_growth_in_usd', 'gpd_per_capita_ppp', 'population_growth', 'urban_population_percentage']\n\ndf = df[cols_to_use]","1cbed7bd":"df.describe()","cc709f80":"plt.figure(figsize=(10,10))\n_ = plt.boxplot((df - df.mean())\/ df.std())\n_ = plt.xticks(range(13), labels=list(df.columns), rotation=45)","7542a415":"plt.figure(figsize=(20,20))\n\nsns.heatmap(df.corr(), annot=True)","e38ba1eb":"from sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\n\ndf_scaled = StandardScaler().fit_transform(df)\n\npca = PCA()\ntransformed = pca.fit_transform(df_scaled)","2ffffbb3":"plt.figure(figsize=(20,10))\nplt.plot(range(1,14), pd.Series(pca.explained_variance_ratio_).cumsum())\nplt.xlabel('Czynnik')\nplt.ylabel('Wariancja wytlumaczona przez czynniki')\npd.Series(pca.explained_variance_ratio_).cumsum()","870269ad":"x = pd.DataFrame(pca.components_.T)\nx.columns = [f'skladowa{i}' for i in range(1,14)]\nx.index = df.columns\nx","c67b243e":"def kolo_czynnikow(pc_infos, labels):\n\tplt.figure(figsize=(20,20))\n\tplt.Circle((0,0),radius=10, color='g', fill=False)\n\tcircle1=plt.Circle((0,0),radius=1, color='g', fill=False)\n\tfig = plt.gcf()\n\tfig.gca().add_artist(circle1)\n\n\tplt.plot([0.0,1.2],[0.0,0],'r')\n\tplt.plot([0.0,-1.2],[0.0,0],'r')\n\tplt.plot([0.0,0],[0.0,1.2],'r')\n\tplt.plot([0.0,0],[0.0,-1.2],'r')\n\tfor idx, idx2 in enumerate(pc_infos[\"PC-0\"]):\n\t\tx = pc_infos[\"PC-0\"][idx]\n\t\ty = pc_infos[\"PC-1\"][idx]\n\t\tplt.plot([0.0,x],[0.0,y],'k-')\n\t\tplt.plot(x, y, 'rx')\n\t\tplt.annotate(labels[idx], xy=(x,y))\n\tplt.xlabel(\"Czynnik 1\")\n\tplt.ylabel(\"Czynnik 2\")\n\tplt.xlim((-1.2,1.2))\n\tplt.ylim((-1.2,1.2))\n\tplt.title(\"Projekcja czynnikow\")\n\npca = PCA(n_components=2)\ntransformed = pca.fit_transform(df_scaled) \nx = pd.DataFrame(pca.components_.T)\nx.columns = ['PC-0', 'PC-1']\nkolo_czynnikow(x, df.columns)","9c5325eb":"plt.figure(figsize=(20,20))\ntransformed = pd.DataFrame(transformed)\ntransformed.columns=['partial_1', 'partial_2']\ntransformed.index = df.index\nplt.scatter(transformed.partial_1, transformed.partial_2)\n\nfor i, index in enumerate(transformed.index):\n    plt.annotate(index, (transformed.loc[index,'partial_1'], transformed.loc[index,'partial_2']))\n\nplt.plot([0.0,5],[0.0,0],'r')\nplt.plot([0.0,-5],[0.0,0],'r')\nplt.plot([0.0,0],[0.0,5],'r')\nplt.plot([0.0,0],[0.0,-5],'r')\n\nplt.title('Wykres kraj\u00f3w na podstawie 2 sk\u0142adowych')\n    \nplt.grid()","9fca5081":"import plotly.express as px\n\npca = PCA(n_components=3)\ntransformed = pca.fit_transform(df_scaled)\ntransformed = pd.DataFrame(transformed)\ntransformed.index = df.index\ntransformed = transformed.reset_index()\n\n\ntransformed.columns=['country', 'partial_1', 'partial_2', 'partial_3']\n\nfig = px.scatter_3d(transformed, x='partial_1', y='partial_2', z='partial_3',\n              color='country')\nfig.update_layout(width=1000, height=800)              \nfig.show()","60b43a60":"import plotly.figure_factory as ff\nfrom scipy.cluster.hierarchy import linkage, ward, fcluster, is_valid_linkage,cophenet\n\nfun = lambda x: linkage(x, \"ward\")\nfun = lambda x: ward(x)\n\nfig = ff.create_dendrogram(df_scaled, labels=df.index, linkagefun=fun)\nfig.update_layout(width=1000, height=800)\nfig.show()","ad636065":"z = ward(df_scaled)\nclusters = fcluster(z, 7, criterion='distance')\n\nis_valid_linkage(z)\n\ndf_scaled = pd.DataFrame(df_scaled, index =df.index)\ndf_scaled['clusters'] =  clusters\ndf_scaled['clusters']","a2127dd2":"agg = df_scaled.groupby(['clusters']).mean()\n\nplt.figure(figsize=(20,10))\nfor index in agg.index:\n    row = agg.loc[index, :]\n    plt.plot(row, label=index)\n    plt.xticks(range(13), labels=list(df.columns), rotation=45)\n\nplt.legend()","946f09f8":"import geopandas\n\nworld = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))\n\nshape = world[world['name'] == 'France']['geometry'].all()\n\nfr_df = pd.Series(['France', 'France'], name='country')\nfr_df = geopandas.GeoDataFrame(fr_df, geometry=[shape[1], shape[2]])\nfr_df = fr_df.dissolve(by='country')\nworld.at[world['name'] == 'France', 'geometry'] = fr_df['geometry'].values   \n\neurope = world[(world.continent=='Europe') & (~world.iso_a3.isin(['RUS', ]))]\neurope.loc[europe.name==\"Norway\", 'iso_a3'] = 'NOR'\neurope.loc[europe.name==\"France\", 'iso_a3'] = 'FRA'\ndf_scaled = df_scaled.reset_index()","143e5c57":"ax = europe.plot(figsize=(20,20), color='white', linestyle='-', edgecolor='gray')\n\ncolors = ['limegreen', 'yellowgreen', 'royalblue', 'darkcyan', 'blue']\n\nfor i in df_scaled.clusters.unique():\n    tmp = df_scaled[df_scaled.clusters==i].country_code\n    europe[europe.iso_a3.isin(tmp)].plot(figsize=(20,20), color=colors[i-1], edgecolor='gray', ax=ax, legend=True)\n\n_ = plt.legend()\n","ddf0f62f":"df","8388d368":"wsp_zmienn = df.std() \/ df.mean()\nwsp_zmienn = wsp_zmienn[wsp_zmienn > 0.1]\n\n#usuwamy cechy z zbyt ma\u0142\u0105 zmienno\u015bci\u0105\ndf = df[wsp_zmienn.index]","ef8a7f73":"wsp_zmienn = df.std() \/ df.mean()\nsum_wsp_zmienn = wsp_zmienn.sum()\n\nweights = wsp_zmienn * sum_wsp_zmienn\ndf_scaled = (df - df.mean()) \/ df.std()\n\nwzorzec = df_scaled.max()\nantywzorzec = df_scaled.min()\n\nis_s = np.array([True, True, False, True, False, False, False, True, True, True, False])\n\nwzorzec_2 = np.where(is_s, wzorzec, 0) + np.where(~is_s, antywzorzec, 0)\nd0 = np.sqrt(((wzorzec - antywzorzec)**2).sum())\ny = (df_scaled - wzorzec_2)**2\nd0s = y.sum(axis=1)**(1\/2)\nmi = 1 - (d0s \/ d0)\nhelwig = mi.sort_values(ascending=False)","4648516a":"# plt.figure(figsize=(3,10))\n\n# _ = sns.heatmap(pd.DataFrame(helwig), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1))\n# plt.title('Metoda Helwiga')\n# plt.legend()","c3961da7":"wsp_zmienn = df.std() \/ df.mean()\nsum_wsp_zmienn = wsp_zmienn.sum()\n\nweights = wsp_zmienn \/ sum_wsp_zmienn\ndf_scaled = (df - df.mean()) \/ df.std() * weights\n\ndf_scaled\n\nwzorzec = df_scaled.max()\nantywzorzec = df_scaled.min()\n\nis_s = np.array([True, True, False, True, False, False, False, True, True, True, False])\n\nwzorzec_2 = np.where(is_s, wzorzec, 0) + np.where(~is_s, antywzorzec, 0)\nd0 = np.sqrt(((wzorzec - antywzorzec)**2).sum())\n\ny = (df_scaled - wzorzec_2)**2\nd0s = y.sum(axis=1)**(1\/2)\nmi = 1 - (d0s \/ d0)\nwzorzec_plt = mi.sort_values(ascending=False)\n\n\n# plt.figure(figsize=(3,10))\n\n# _ = sns.heatmap(pd.DataFrame(wzorzec_plt), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1))\n# plt.title('Metoda wzorca')\n# plt.legend()\n","421017eb":"df_scaled = ((df**2) \/ (df**2).sum())**0.5\n\ndf_scaled\n\nwzorzec = df_scaled.max()\nantywzorzec = df_scaled.min()\n\nis_s = np.array([True, True, False, True, False, False, False, True, True, True, False])\n\nwzorzec_2 = np.where(is_s, wzorzec, 0) + np.where(~is_s, antywzorzec, 0)\nanywzorzec_2 = np.where(~is_s, wzorzec, 0) + np.where(is_s, antywzorzec, 0)\n\ndf_pos = df_scaled.copy()\ndf_neg = df_scaled.copy()\n\ndf_pos = (df_pos - wzorzec_2)**2\n\ndf_neg = (df_pos - anywzorzec_2)**2\n\nd0_pos = df_pos.sum(axis=1)**0.5\nd0_neg = df_neg.sum(axis=1)**0.5\n\nqi = d0_neg \/ (d0_neg + d0_pos)\n\ntopsis = qi.sort_values(ascending=False)\n\nplt.figure(figsize=(3,10))\n\n# _ = sns.heatmap(pd.DataFrame(topsis), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1))\n# plt.title('Metoda wzorca')\n# plt.legend()\n","c36c452a":"fig = plt.figure(figsize=(12,10))\nax = fig.subplots(1,3)\n\nsns.heatmap(pd.DataFrame(topsis), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1), ax=ax[0], cbar=False)\nsns.heatmap(pd.DataFrame(helwig), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1), ax=ax[1], cbar=False)\nsns.heatmap(pd.DataFrame(wzorzec_plt), cmap='Spectral', annot=np.array(range(1, 28)).reshape(27,1), ax=ax[2], cbar=False)\nax[0].set_title('Topsis')\nax[1].set_title('Hellwig')\nax[2].set_title('Wzorzec')","e36c8c2b":"# Analiza skupie\u0144\n\n## Poni\u017cej prezentuje Dendogram przy u\u017cyciu metody Warda","82564fa4":"## Mapa prezentuj\u0105ca geograficzne rozmieszczenie klastr\u00f3w","ceab0b93":"## \u015arednie warto\u015bci ustandaryzowanych cech w klastrach","6809e015":"# ANALIZA WIELOWYMIAROWA\n\n### Celem tej pracy jest ocena czynnikow mog\u0105cych wp\u0142ywa\u0107 na poczucie szcz\u0119\u015bcia w danym kraju.\n### W tym celu przeporwadze 3 analizy\n- Analize PCA\n- Analize skupie\u0144\n- Porz\u0105dkowanie liniowe\n\n### Dane kt\u00f3re mi do tego pos\u0142u\u017c\u0105 pochodz\u0105 z roku 2018 i zawieraja poni\u017csze informacje:\n\n- Adjusted net national income per capita (current USD)\n- Adjusted savings: gross savings (% of GNI)\n- Age dependency ratio (% of working-age population)\n- Birth rate, crude (per 1,000 people)\n- Consumer price index (2010 = 100)\n- Death rate, crude (per 1,000 people)\n- Employers, total (% of total employment) (modeled ILO estimate)\n- Forest area (% of land area)\n- GDP (current US$)\n- GDP growth (annual %)\n- GDP per capita (current US$)',\n- GDP per capita, PPP (current international $)\n- Individuals using the Internet (% of population)\n- Inflation, consumer prices (annual %)\n- Land area (sq. km)\n- Life expectancy at birth, total (years)\n- Population growth (annual %)\n- Self-employed, total (% of total employment) (modeled ILO estimate)\n- Total alcohol consumption per capita (liters of pure alcohol, projected estimates, 15+ years of age)\n- Unemployment, total (% of total labor force) (national estimate)\n- Urban population (% of total population)\n\n\n### Lista kraj\u00f3w: Albania, Austria, Belarus, Belgium, Bulgaria, Czech Republic, Croatia, Denmark, Estonia, Finland, France, Germany, Greece, Hungary, Iceland, Ireland, Italy, Latvia, Lithuania, Luxembourg, Norway, Poland, Slovenia, Slovak Republic, Switzerland, Ukraine, United Kingdom\n\n\n\n\n<p style='font-size:15px'>Wszytkie dane u\u017cyte w analizach pochodz\u0105 z <a>https:\/\/databank.worldbank.org\/source\/world-development-indicators<\/a> <\/p>","2b4c88cf":"## Poni\u017cej znajduje sie tabela z podstawownymi statystykami opisuj\u0105cymi cechy","270226f4":"## Z powy\u017cszego wykresu widzimy ze wyodr\u0119bnia si\u0119 4 lub 5 klastr\u00f3w.\n\n## Poni\u017cej prezentuje projekcje 3 czynnik\u00f3w w przestrzeni tr\u00f3jwymiarowej na interaktywnym wykresie","31e241a5":"## Poni\u017cej znajduje sie boxplot prezentuje ustandaryzowane cechy","97250be0":"## Na podstawie powy\u017cszych danych widzimy \u017ce 2 pierwsze sk\u0142adowe wyja\u015bnaiaj\u0105 52% zmienno\u015bci wszystkich cech\n\n## Poni\u017cej projekcja czynnik\u00f3w na ko\u0142o jednostkowe","c7ea200a":"## Macie\u017c korelacjicolumns","e996e2c5":"## Na podstawie wynik\u00f3w r\u00f3znych metod stwiedzamy \u017ce najszcz\u0119\u015bliwsi ludzie \u017cyj\u0105 w Irlandii, Luxemburgu oraz Islandi. Najmniejszcze\u015bliwi ludzie \u017cyj\u0105 w Ukrainie, Grecji oraz Bu\u0142garii","25bca106":"## Poni\u017cej prezentuje do jakich klastr\u00f3w zosta\u0142y przyporz\u0105dkowane kraje","2f403437":"# PCA","c55407d8":"# Porz\u0105dkowanie liniowe\n\n- adj_income_per_cap S\n- age_dependency_ratio D\n- birth_rate_per_1000 S\n- consumer_price_index D\n- forest_area_in_percent S\n- inflation D\n- life_expectency S\n- alcohol_consumption D\n- unemployment_1 D\n- gpd_growth_in_usd S\n- gpd_per_capita_ppp S\n- population_growth S\n- urban_population_percentage D"}}