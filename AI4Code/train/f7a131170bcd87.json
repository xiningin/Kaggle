{"cell_type":{"99c65f77":"code","50eb34b3":"code","1c005110":"code","346facee":"code","71f52c72":"code","3bc89f9c":"code","48592e88":"code","3a6d6490":"code","37a2e993":"code","b48c217d":"code","507650df":"code","1e53f49f":"code","23f42d9c":"code","b52fc532":"code","7b092ad5":"code","57a6e238":"code","6f020dfd":"code","8efcf33c":"code","3ff07cee":"code","a4091d44":"code","758799ee":"code","035975fd":"code","9b028049":"code","79e7e87d":"code","590d6f4d":"code","c8dee6d7":"code","6b6f7748":"code","d1b38840":"markdown","964bb800":"markdown","e85c97d5":"markdown","020fbcd6":"markdown","53aefd9f":"markdown","fbe1abc0":"markdown","40d81f7f":"markdown","88770c9f":"markdown","5cc59cfe":"markdown","a90a44b4":"markdown","5c1a9a17":"markdown","bb3d0300":"markdown","21d4e579":"markdown","0f9a071c":"markdown","8029046b":"markdown","1c0ef8bd":"markdown","7b41c9a1":"markdown","b7b861af":"markdown","2d24f514":"markdown","f14d31db":"markdown","e88fb55f":"markdown","31a5e7fd":"markdown","89931331":"markdown","adcd1ead":"markdown","e2aaeb6b":"markdown","7c4a4ca5":"markdown","277fc884":"markdown","24844970":"markdown"},"source":{"99c65f77":"import pandas as pd\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')\npd.set_option('max_columns',None)\nimport decimal\n\nimport plotly as py\nimport plotly.express as px\nimport plotly.graph_objs as go\nfrom plotly.offline import init_notebook_mode\ninit_notebook_mode(connected = True)\nimport matplotlib.lines as lines\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nPALETTE = ['#dd4124','#009473', '#b4b4b4', '#336b87']\n\n%matplotlib inline","50eb34b3":"df = pd.read_csv('..\/input\/customer-personality-analysis\/marketing_campaign.csv',sep='\\t')\n# df.set_index('ID',inplace=True,drop=True)\n# df.index.name = None\ndf.head(10).style.background_gradient(cmap=\"Wistia\",text_color_threshold=0.01)\n","1c005110":"# df.head()\n# df.shape #(2240,29)\n# df.info() #information about the dataframe\ncol = df.isnull().sum() #Income column having 24 missing values\ncol = col[col>0]\nprint(f'Column: {col.index[0]} having {col.values[0]} missing values')","346facee":"df.describe().T.style.bar(subset=['mean'], color='#606ff2')\\\n                            .background_gradient(subset=['std'], cmap='PuBu')\\\n                            .background_gradient(subset=['50%'], cmap='PuBu')","71f52c72":"df['Kids'] = df['Kidhome'] + df['Teenhome']\n\nre_marital = {\n    'Single': 'Not in relationship',\n    'Together': 'In relationship',\n    'Married': 'In relationship',\n    'Divorced': 'Not in relationship',\n    'Widow': 'Not in relationship',\n    'Alone': 'Not in relationship',\n    'Absurd': 'Not in relationship',\n    'YOLO': 'Not in relationship'\n}\n\ndf['Marital_Status'] = df['Marital_Status'].map(re_marital)\n\ndf['Family_size'] = 0\n\nfor i in range(len(df)):\n    \n    if df['Marital_Status'][i] == 'In relationship':\n        df['Family_size'][i] = 2 + df['Kids'][i]\n    else:\n        df['Family_size'][i] = 1 + df['Kids'][i]","3bc89f9c":"df['Dt_Customer'] = pd.to_datetime(df['Dt_Customer'])\ndf['Dt_Customer'].max(), df['Dt_Customer'].min()","48592e88":"df['Age'] = 2014 - df['Year_Birth']\ndf['Collected'] = '2014-12-07'\ndf['Collected'] = pd.to_datetime(df['Collected'])\ndf['Days_is_client'] = (df['Collected'] - df['Dt_Customer']).dt.days","3a6d6490":"df['MntTotal'] = df['MntWines']+df['MntFruits']+df['MntMeatProducts']+df['MntFishProducts']+df['MntSweetProducts']+df['MntGoldProds']\ndf['NumAllPurchases'] = df['NumWebPurchases']+df['NumCatalogPurchases']+df['NumStorePurchases']\ndf['AverageCheck'] = round((df['MntTotal'] \/ df['NumAllPurchases']), 1)\ndf['ShareDealsPurchases'] = round((df['NumDealsPurchases'] \/ df['NumAllPurchases']) * 100, 1)\ndf['TotalAcceptedCmp'] = df['AcceptedCmp1']+df['AcceptedCmp2']+df['AcceptedCmp3']+df['AcceptedCmp4']+df['AcceptedCmp5']+df['Response']","37a2e993":"df = df.query(\"NumAllPurchases != 0\")","b48c217d":"def setup_plot(w=1,h=1,rows=1,cols=1,X_label='',y_label='',dpi=600,PAL=PALETTE):\n    '''\n    w: width of the figsize parameter of matplotlib.pyplot\n    h: height of the figsize parameter of matplotlib.pyplot\n    rows: numbers of rows in gridspec\n    cols: numbers of cols in gridspec\n    X_label: Label of the x-axis\n    y_label: Label of the y-axis\n    dpi: to set dpi for the figure.dpi\n    PAL: color palette of seaborn\n    \n    design by @ankitkalauni\n    \n    Return axes (only single axes for now, still working on the multiple axes)\n    \n    \n    '''\n    #setting plot theme\n    plt.rcParams['figure.dpi'] = dpi\n\n    fig = plt.figure(figsize=(w,h), facecolor='#f6f5f5')\n    gs = fig.add_gridspec(rows, cols)\n    gs.update(wspace=1.5, hspace=0.05)\n\n    background_color = \"#f6f5f5\"\n    sns.set_palette(PAL)\n    \n    #making multiple ax\n    ax_dict = {}\n    for row in range(rows):\n        for col in range(cols):\n            ax_dict[\"ax%s%s\" %(row,col)] = fig.add_subplot(gs[row, col])\n\n    locals().update(ax_dict)\n\n    #setting theme for every ax in local()\n    for row in range(rows):\n        for col in range(cols):\n                    \n            for s in [\"right\", \"top\"]:\n                locals()['ax' + str(row) + str(col)].spines[s].set_visible(False)\n                \n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n\n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n            locals()['ax' + str(row) + str(col)].set_xlabel(X_label,fontsize=4, weight='bold',)\n            locals()['ax' + str(row) + str(col)].set_ylabel(y_label,fontsize=4, weight='bold')\n\n            locals()['ax' + str(row) + str(col)].tick_params(labelsize=3, width=0.5, length=1.5)\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='x', zorder=0, color='#EEEEEE', linewidth=0.4)\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='y', zorder=0, color='#EEEEEE', linewidth=0.4)\n\n    return locals()['ax' + str(row) + str(col)]\n\n\nplot1 = sns.kdeplot(df.Income,ax=setup_plot(w=3),zorder=2,fill=True,alpha=1,ec='black')\nplot1.ticklabel_format(useOffset=False,style='plain')\ny_label = np.arange(0, 0.18, 0.02)\nplot1.set_yticklabels(y_label)\n\nplot3 = sns.boxplot(df.Income,ax=setup_plot(w=2,dpi=600),zorder=2,linewidth=0.7)\nsns.swarmplot(x='Income',ax=plot3, data=df,size=0.7,linewidth=0.1,alpha=.5,zorder=3)\n\nplt.show()","507650df":"plot3 = sns.boxplot(df.AverageCheck,ax=setup_plot(w=2,dpi=600),zorder=2,linewidth=0.7)\nsns.swarmplot(x='AverageCheck',ax=plot3, data=df,size=0.7,linewidth=0.1,alpha=.6,zorder=3)\n\nplt.show()","1e53f49f":"median = df['Income'].median()\nmean = df['Income'].mean()\n\ndif = mean - median\nprint(f'Income Median: {round(median)}\\nIncome Mean: {round(mean)}\\ndifference: {round(dif)}')\n\ndf['Income'].fillna(median, inplace = True)","23f42d9c":"df.drop(['ID', 'Year_Birth', 'Kidhome', 'Teenhome', 'Dt_Customer', 'Z_CostContact', 'Z_Revenue', 'Collected'], axis = 1, inplace = True)","b52fc532":"df['Income'] = np.where(df['Income'] > 120000, 120000, df['Income'])\ndf['AverageCheck'] = np.where(df['AverageCheck'] > 200, 200, df['AverageCheck'])","7b092ad5":"plot3 = sns.boxplot(df.Income,ax=setup_plot(w=2,dpi=600),zorder=2,linewidth=0.7)\nsns.swarmplot(x='Income',ax=plot3, data=df,size=0.7,linewidth=0.1,alpha=.6,zorder=3)\n\nplt.show()","57a6e238":"plot3 = sns.boxplot(df.AverageCheck,ax=setup_plot(w=2,dpi=600),zorder=2,linewidth=0.7)\nsns.swarmplot(x='AverageCheck',ax=plot3, data=df,size=0.7,linewidth=0.1,alpha=.6,zorder=3)\n\nplt.show()","6f020dfd":"df['ActiveDays'] = df['Days_is_client'] - df['Recency']","8efcf33c":"df.head().style.background_gradient(cmap=\"Wistia\",text_color_threshold=0.01)","3ff07cee":"x = df['Education'].value_counts().values\ny = df['Education'].value_counts().index\n# PALETTE.pop()\nPALETTE.append('#A262A0')\nfirst = sns.barplot(x=x,y=y,ax=setup_plot(w=2,dpi=600,PAL=PALETTE,y_label='Education',X_label='No.of Customer\\'s'),zorder=2,ec='black',linewidth=0.5)\nfor p in first.patches:\n    if p.get_width() > 800:\n        value = f'{p.get_width():,.0f} | {(p.get_width()\/df.shape[0]):,.1%}'\n        x = p.get_x() + p.get_width() + 85\n        y = p.get_y() + p.get_height() \/ 2 \n        first.text(x, y, value, ha='center', va='center', fontsize=2, \n                bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n    else:\n        value = f'{p.get_width():,.0f} | {(p.get_width()\/df.shape[0]):,.1%}'\n        x = p.get_x() + p.get_width() + 80\n        y = p.get_y() + p.get_height() \/ 2 \n        first.text(x, y, value, ha='center', va='center', fontsize=2, \n        bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n\n        \nx = df['Marital_Status'].value_counts().values\ny = df['Marital_Status'].value_counts().index\n\nsec = sns.barplot(x=x,y=y,ax=setup_plot(w=2,dpi=600,PAL=PALETTE,y_label='Marital_Status',X_label='No.of Customer\\'s'),zorder=2,ec='black',linewidth=0.5)\nfor p in sec.patches:\n    if p.get_width() > 800:\n        value = f'{p.get_width():,.0f} | {(p.get_width()\/df.shape[0]):,.1%}'\n        x = p.get_x() + p.get_width() + 120\n        y = p.get_y() + p.get_height() \/ 2 \n        sec.text(x, y, value, ha='center', va='center', fontsize=2, \n                bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n    else:\n        value = f'{p.get_width():,.0f} | {(p.get_width()\/df.shape[0]):,.1%}'\n        x = p.get_x() + p.get_width() + 100\n        y = p.get_y() + p.get_height() \/ 2 \n        sec.text(x, y, value, ha='center', va='center', fontsize=2, \n        bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\nplt.show()","a4091d44":"cols = df.columns.values.tolist()\ncols.remove('Income')\n\nbar = []\nkde = []\n\nfor col in cols:\n    if len(df[col].value_counts().to_list()) > 9:\n        kde.append(col)\n    else:\n        bar.append(col)\n        \n        \ndef setup_multiple_plot(data,X,y=None,w=4,h=6,rows=3,dpi=600,HSPACE=2.5,WSPACE=0.2):\n    '''\n    data: DataFrame\n    X: List of the columns to pairplot\n    \n    design by @ankitkalauni\n    still working on making this function better my all work will be posted\n    on kaggle @ankitkalauni follow there to get update\n    '''\n\n\n\n#     from itertools import combinations\n#     import math\n\n#     plot = list(combinations(X, 2))\n\n#     cols = int(math.ceil(len(plot)\/rows))\n    cols = 2\n    #setting plot theme\n    plt.rcParams['figure.dpi'] = dpi\n\n    fig = plt.figure(figsize=(w,h), facecolor='#f6f5f5')\n    gs = fig.add_gridspec(rows, cols)\n    gs.update(wspace=WSPACE, hspace=HSPACE)\n\n    background_color = \"#f6f5f5\"\n    sns.set_palette(PALETTE)\n    \n    #making multiple ax\n    ax_dict = {}\n    for row in range(rows):\n        for col in range(cols):\n            ax_dict[\"ax%s%s\" %(row,col)] = fig.add_subplot(gs[row, col])\n\n    locals().update(ax_dict)\n    count = 0\n    \n    #setting theme for every ax in local()\n    for indx,row in enumerate(range(rows)):\n        for col in range(cols):\n            x = df[X[count]].value_counts().values\n            y = df[X[count]].value_counts().index\n\n            \n            locals()['ax' + str(row) + str(col)].tick_params(labelsize=3, width=0.5, length=1.5)\n\n            #comment below 2 lines if you are using regplot\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='x', zorder=0, color='#EEEEEE', linewidth=0.4)\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='y', zorder=0, color='#EEEEEE', linewidth=0.4)\n       \n            for s in [\"right\", \"top\"]:\n                locals()['ax' + str(row) + str(col)].spines[s].set_visible(False)\n\n            \n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n\n            # ax_sns = sns.regplot(x=df[x],y=df[y],ax=locals()['ax' + str(row) + str(col)]\n            #                      ,line_kws={'color': '#ff355d','alpha':1})\n            \n            ax_sns = sns.barplot(x=y,y=x,ax=locals()['ax' + str(row) + str(col)],zorder=2,linewidth=0.5,ec='black')\n\n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n            locals()['ax' + str(row) + str(col)].set_xlabel(str(X[count]),fontsize=4, weight='bold')\n#             locals()['ax' + str(row) + str(col)].set_ylabel(str(y),fontsize=4, weight='bold')\n            \n            for p in ax_sns.patches:\n                if p.get_height() > 1500: \n                    value = f'{p.get_height():,.0f}'\n                    x = p.get_x() + p.get_width() \/2\n                    y = p.get_y() + p.get_height() + 600 \n                    ax_sns.text(x, y, value, ha='center', va='center', fontsize=4, \n                    bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n                elif p.get_height() < 1500 and p.get_height() > 500:\n                    value = f'{p.get_height():,.0f}'\n                    x = p.get_x() + p.get_width() \/2\n                    y = p.get_y() + p.get_height() + 400 \n                    ax_sns.text(x, y, value, ha='center', va='center', fontsize=4, \n                    bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n                else:\n                    value = f'{p.get_height():,.0f}'\n                    x = p.get_x() + p.get_width() \/2\n                    y = p.get_y() + p.get_height() + 300 \n                    ax_sns.text(x, y, value, ha='center', va='center', fontsize=4, \n                    bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n\n\n            \n            count+=1\n            \nsetup_multiple_plot(df,X=bar,rows=6)\n\nplt.show()","758799ee":"def setup_multiple_plot(data,X,y=None,w=5,h=5,rows=3,dpi=600,HSPACE=1,WSPACE=0.2):\n    '''\n    data: DataFrame\n    X: List of the columns to pairplot\n    \n    design by @ankitkalauni\n    still working on making this function better my all work will be posted\n    on kaggle @ankitkalauni follow there to get update\n    '''\n\n\n\n#     from itertools import combinations\n#     import math\n\n#     plot = list(combinations(X, 2))\n\n#     cols = int(math.ceil(len(plot)\/rows))\n    cols = 2\n    #setting plot theme\n    plt.rcParams['figure.dpi'] = dpi\n\n    fig = plt.figure(figsize=(w,h), facecolor='#f6f5f5')\n    gs = fig.add_gridspec(rows, cols)\n    gs.update(wspace=WSPACE, hspace=HSPACE)\n\n    background_color = \"#f6f5f5\"\n    sns.set_palette(PALETTE)\n    \n    #making multiple ax\n    ax_dict = {}\n    for row in range(rows):\n        for col in range(cols):\n            ax_dict[\"ax%s%s\" %(row,col)] = fig.add_subplot(gs[row, col])\n\n    locals().update(ax_dict)\n    count = 0\n    \n    #setting theme for every ax in local()\n    for indx,row in enumerate(range(rows)):\n        for col in range(cols):\n            x = df[X[count]].value_counts().values\n            y = df[X[count]].value_counts().index\n\n            \n            locals()['ax' + str(row) + str(col)].tick_params(labelsize=3, width=0.5, length=1.5)\n\n            #comment below 2 lines if you are using regplot\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='x', zorder=0, color='#EEEEEE', linewidth=0.4)\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='y', zorder=0, color='#EEEEEE', linewidth=0.4)\n       \n            for s in [\"right\", \"top\"]:\n                locals()['ax' + str(row) + str(col)].spines[s].set_visible(False)\n\n            \n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n\n            # ax_sns = sns.regplot(x=df[x],y=df[y],ax=locals()['ax' + str(row) + str(col)]\n            #                      ,line_kws={'color': '#ff355d','alpha':1})\n            \n            ax_sns = sns.kdeplot(x=x,ax=locals()['ax' + str(row) + str(col)],zorder=2,fill=True,alpha=0.5,linewidth=0.5,ec='black')\n\n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n            locals()['ax' + str(row) + str(col)].set_xlabel(str(X[count]),fontsize=3, weight='bold')\n            locals()['ax' + str(row) + str(col)].set_ylabel('',fontsize=4, weight='bold')\n            count+=1\n            \nsetup_multiple_plot(df,X=kde,rows=6)\n\nplt.show()","035975fd":"\n\ndef setup_multiple_plot(data,X,y=None,w=20,h=150,rows=3,dpi=300,HSPACE=1,WSPACE=0.2):\n    '''\n    data: DataFrame\n    X: List of the columns to pairplot\n    \n    design by @ankitkalauni\n    still working on making this function better my all work will be posted\n    on kaggle @ankitkalauni follow there to get update\n    '''\n\n\n\n    from itertools import combinations\n    import math\n\n    plot = list(combinations(X, 2))\n\n    cols = int(math.ceil(len(plot)\/rows))\n#     cols = 2\n    #setting plot theme\n    plt.rcParams['figure.dpi'] = dpi\n\n    fig = plt.figure(figsize=(w,h), facecolor='#f6f5f5')\n    gs = fig.add_gridspec(rows, cols)\n    gs.update(wspace=WSPACE, hspace=HSPACE)\n\n    background_color = \"#f6f5f5\"\n    sns.set_palette(PALETTE)\n    \n    #making multiple ax\n    ax_dict = {}\n    for row in range(rows):\n        for col in range(cols):\n            ax_dict[\"ax%s%s\" %(row,col)] = fig.add_subplot(gs[row, col])\n\n    locals().update(ax_dict)\n    count = 0\n    \n    #setting theme for every ax in local()\n    for indx,row in enumerate(range(rows)):\n        for col in range(cols):\n            x = plot[count][0]\n            y = plot[count][1]\n\n            \n            locals()['ax' + str(row) + str(col)].tick_params(labelsize=3, width=0.5, length=1.5)\n\n            #comment below 2 lines if you are using regplot\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='x', zorder=0, color='#EEEEEE', linewidth=0.4)\n            locals()['ax' + str(row) + str(col)].grid(which='major', axis='y', zorder=0, color='#EEEEEE', linewidth=0.4)\n       \n            for s in [\"right\", \"top\"]:\n                locals()['ax' + str(row) + str(col)].spines[s].set_visible(False)\n\n            \n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n\n            # ax_sns = sns.regplot(x=df[x],y=df[y],ax=locals()['ax' + str(row) + str(col)]\n            #                      ,line_kws={'color': '#ff355d','alpha':1})\n            \n            ax_sns = sns.scatterplot(x=df[x],y=df[y],ax=locals()['ax' + str(row) + str(col)],zorder=2,alpha=0.5)\n\n            locals()['ax' + str(row) + str(col)].set_facecolor(background_color)\n            locals()['ax' + str(row) + str(col)].set_xlabel(x,fontsize=8, weight='bold')\n            locals()['ax' + str(row) + str(col)].set_ylabel(y,fontsize=8, weight='bold')\n            \n            count+=1\n            if count == 172:\n                return\n%time           \nsetup_multiple_plot(df,X=kde,rows=57)\n\nplt.show()","9b028049":"from sklearn.preprocessing import StandardScaler \nfrom sklearn.cluster import KMeans\n\ndf_clust = df[['AverageCheck', 'Days_is_client', 'NumAllPurchases']].copy()\n\nfor i in df_clust.columns:\n    df_clust[i] = StandardScaler().fit_transform(np.array(df_clust[[i]]))","79e7e87d":"wcss = []\nfor i in range(1, 10):\n    km = KMeans(n_clusters = i, random_state = 69)\n    km.fit(df_clust)\n    wcss.append(km.inertia_)\n\na = sns.lineplot(x = range(1, 10), y = wcss,ax= setup_plot(X_label='No.of Cluster',y_label='WCSS',w=4,h=2), linewidth = 3)\nb = sns.scatterplot(x = range(1, 10), y = wcss,ax=a ,s = 60, edgecolor = 'black', zorder = 5)\n\n\n\nplt.show()","590d6f4d":"# Number of clusters\nk = 4\nkmeans = KMeans(n_clusters = 4, init = 'k-means++', random_state = 69)\n\n#Returns a label for each data point based on the number of clusters\ny = kmeans.fit_predict(df_clust)\n\ndf['Cluster'] = y\n\ndf['Cluster'].value_counts()\n\ncluster = sns.barplot(y=df['Cluster'].value_counts().values,x=df['Cluster'].value_counts().index,linewidth=0.5,ec='black',ax=setup_plot(w=2,X_label='Cluster no.',y_label='Counts'),zorder=2)\nfor p in cluster.patches:\n    value = f'{p.get_height():,.0f} | {(p.get_height()\/df.shape[0]):,.1%}'\n    x = p.get_x() + p.get_width() \/2\n    y = p.get_y() + p.get_height() + 40 \n    cluster.text(x, y, value, ha='center', va='center', fontsize=2.5, \n    bbox=dict(facecolor='none', edgecolor='black', boxstyle='round', linewidth=0.3))\n\nplt.show()","c8dee6d7":"# ['#dd4124','#009473', '#b4b4b4', '#336b87'] [orange,grey, green, blue]\n\n# Visualising the clusters\n#Scatter plotting for (x,y) with label 1 as Cluster 1 in color c = red and points in size s = 614\nX = df.loc[df['Cluster'] == 3, 'Income']\nY = df.loc[df['Cluster'] == 3, 'NumAllPurchases']\n\ncluster = sns.scatterplot(x=X,y=Y,ax=setup_plot(w=4,h=2,X_label='',y_label='',PAL=['#dd4124', '#b4b4b4', '#009473', '#336b87']),s=2,alpha=1, label = 'Cluster 3',zorder=2)\n\n#Scatter plotting for (x,y) with label 2 as Cluster 2 in color c = blue and points in size s = 588\nX = df.loc[df['Cluster'] == 2, 'Income']\nY = df.loc[df['Cluster'] == 2, 'NumAllPurchases']\n\nsns.scatterplot(x=X,y=Y,ax=cluster,alpha=1, label = 'Cluster 2',zorder=2,s=2)\n\n#Scatter plotting for (x,y) with label 3 as Cluster 3 in color c = green and points in size s = 552\nX = df.loc[df['Cluster'] == 1, 'Income']\nY = df.loc[df['Cluster'] == 1, 'NumAllPurchases']\n\nsns.scatterplot(x=X,y=Y,ax=cluster,alpha=1, label = 'Cluster 1',zorder=2,s=2)\n#Scatter plotting for (x,y) with label 3 as Cluster 3 in color c = green and points in size s = 480\n\nX = df.loc[df['Cluster'] == 0, 'Income']\nY = df.loc[df['Cluster'] == 0, 'NumAllPurchases']\n\nsns.scatterplot(x=X,y=Y,ax=cluster,alpha=1, label = 'Cluster 0',zorder=2,s=2)\n\n\ncluster.legend(['Cluster 0','Cluster 1','Cluster 2','Cluster 3'], ncol=2, facecolor='#D8D8D8', fontsize=3, bbox_to_anchor=(1, 1.1),edgecolor=\"#f6f5f5\")\n#Scatter plotting the centroids with label = 'Centroids' in color c = cyan and points in size s = 100\n# plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s = 100, c = 'cyan', label = 'Centroids')\n\n# plt.title('Iris Flower Clusters')\n# plt.xlabel('Sepal Length in cm')\n# plt.ylabel('Petal Length in cm')\n# # plt.legend()\nplt.show()","6b6f7748":"clust = {\n    0: 'Ordinary client',\n    1: 'Elite client',\n    2: 'Good client',\n    3: 'Potential good client'\n}\ndf['Cluster'] = df['Cluster'].map(clust)\n\n\nplot = go.Figure()\n\ncolors = ['#b4b4b4', '#dd4124', '#009473', '#336b87']\nnames = ['Ordinary client', 'Elite client', 'Good client', 'Potential good client']\n\nfor i in range(4):\n    cl = names[i]\n    plot.add_trace(go.Scatter3d(x = df.query(\"Cluster == @cl\")['NumAllPurchases'],\n                                y = df.query(\"Cluster == @cl\")['AverageCheck'],\n                                z = df.query(\"Cluster == @cl\")['Days_is_client'],\n                                mode = 'markers',\n                                name = names[i],\n                                marker = dict(\n                                    size = 2,\n                                    color = colors[i],  \n                                     opacity = 0.6)))\n\nplot.update_traces(hovertemplate = 'Purchases: %{x} <br>Average Check: %{y} <br>Days is client: %{z}')\n\nplot.update_layout(width = 800, height = 800, autosize = True, showlegend = False,\n                   scene = dict(xaxis = dict(title = 'Count of purchases', titlefont_color = 'black'),\n                                yaxis = dict(title = 'Average check', titlefont_color = 'black'),\n                                zaxis = dict(title = 'Days is client', titlefont_color = 'black')),\n                   font = dict(family = \"monospace\", color  = 'black', size = 12),\n                   title_text = 'Customers clusters', title_x = 0.5)","d1b38840":"# **4.2 K-Median Clustering**\n\n<div style=\"color:White; display:fill; border-radius:5px;background-color:#009473;font-size:110%;font-family:sans-serif;letter-spacing:0.5px\">K-Medians is another clustering algorithm related to K-Means, except instead of recomputing the group center points using the mean we use the median vector of the group. This method is less sensitive to outliers (because of using the Median) but is much slower for larger datasets as sorting is required on each iteration when computing the Median vector.<\/div>\n\n<a id='4.2'><\/a>\n* [**Back to top**](#0)","964bb800":"# **3. Data Visualisation**\n\n<a id='3'><\/a>\n* [**Back to top**](#0)","e85c97d5":"Filling missing values with median you can also use mean.","020fbcd6":"And some more information about purchases.","53aefd9f":"8 Outliers in Income where 7 Customer's `Income` is near 150000\nand there is 1 Customer having `Income` greater than 600000","fbe1abc0":"<div style=\"color:White; display:fill; border-radius:5px;background-color:#dd4124;font-size:110%;font-family:sans-serif;letter-spacing:0.5px\">For the above-given graph, the optimum value for K would be 4. As we can see that with an increase in the number of clusters the WCSS value decreases. We select the value for K on the basis of the rate of decrease in WCSS. For example, from cluster 1 to 2 to 3 in the above graph we see a sudden and huge drop in WCSS. After 4 the drop is minimal and hence we chose 4 to be the optimal value for K.<\/div>","40d81f7f":"Droping useless columns","88770c9f":"**3.2 KDE Plot**\n\n<a id='3.2'><\/a>\n* [**Back to top**](#0)","5cc59cfe":"# **Table of Contents**\n\n* [1. Context](#1)\n    * [1.1 Problem Statement](#1)\n    * [1.2 Attributes](#1.2)\n* [2. Preprocessing](#2)\n* [3. Data Visualisation](#3)\n    * [3.1 Bar Plot](#3.1)\n    * [3.2 KDE Plot](#3.2)\n* [4. Clustering](#4)\n    * [4.1 K-Mean Clustering](#4.1)\n    * [4.2 K-Median Clustering](#4.2)\n    * [4.3 K-Mean Cluster 2D Plot](#4.3)\n    * [4.4 K-Median Cluster 3D Plot](#4.4)\n* [5. Clustering](#5)\n<a id='0'><\/a>","a90a44b4":"# **4.3 K-Mean Cluster 2D Plot**\n\n<a id='4.3'><\/a>\n* [**Back to top**](#0)","5c1a9a17":"<div style=\"color:White; display:fill; border-radius:5px;background-color:#336b87;font-size:110%;font-family:sans-serif;letter-spacing:0.5px\">\nMost of the codes below are from from: <h3>Customers Clustering EDA by <a href=\"https:\/\/www.kaggle.com\/dmitryuarov\/customers-clustering-eda\">DMITRY UAROV<\/a>.<\/h3> Thanks to @DMITRY UAROV for sharing the awesome notebook for all beginners like us!. support him by upvoting his notebook. ","bb3d0300":"It is very interesting dataset from which we can get much information.\n\nFirst, we need to understand the family details","21d4e579":"There are some logic errors in data, so 6 clients spent money, but did not make a single order - I will delete them.","0f9a071c":"<div style=\"color:White; display:fill; border-radius:5px;background-color:#336b87;font-size:110%;font-family:sans-serif;letter-spacing:0.5px\">Clustering is a Machine Learning technique that involves the grouping of data points.Given a set of data points, we can use a clustering algorithm to classify each data point into a specific group. In theory, data points that are in the same group should have similar properties and\/or features, while data points in different groups should have highly dissimilar properties and\/or features. Clustering is a method of unsupervised learning and is a common technique for statistical data analysis used in many fields.<\/div>","8029046b":"# **2. Preprocessing**\n\n<a id='2'><\/a>\n* [**Back to top**](#0)","1c0ef8bd":"# 1.2 Attributes\n\n## People\n\n* ID: dfomer's unique identifier\n* Year_Birth: dfomer's birth year\n* Education: dfomer's education level\n* Marital_Status: dfomer's marital status\n* Income: dfomer's yearly household income\n* Kidhome: Number of children in dfomer's household\n* Teenhome: Number of teenagers in dfomer's household\n* Dt_dfomer: Date of dfomer's enrollment with the company\n* Recency: Number of days since dfomer's last purchase\n* Complain: 1 if dfomer complained in the last 2 years, 0 otherwise\n\n## Products\n\n* MntWines: Amount spent on wine in last 2 years\n* MntFruits: Amount spent on fruits in last 2 years\n* MntMeatProducts: Amount spent on meat in last 2 years\n* MntFishProducts: Amount spent on fish in last 2 years\n* MntSweetProducts: Amount spent on sweets in last 2 years\n* MntGoldProds: Amount spent on gold in last 2 years\n\n## Promotion\n* NumDealsPurchases: Number of purchases made with a discount\n* AcceptedCmp1: 1 if dfomer accepted the offer in the 1st campaign, 0 otherwise\n* AcceptedCmp2: 1 if dfomer accepted the offer in the 2nd campaign, 0 otherwise\n* AcceptedCmp3: 1 if dfomer accepted the offer in the 3rd campaign, 0 otherwise\n* AcceptedCmp4: 1 if dfomer accepted the offer in the 4th campaign, 0 otherwise\n* AcceptedCmp5: 1 if dfomer accepted the offer in the 5th campaign, 0 otherwise\n* Response: 1 if dfomer accepted the offer in the last campaign, 0 otherwise\n\n## Place\n* NumWebPurchases: Number of purchases made through the company\u2019s web site\n* NumCatalogPurchases: Number of purchases made using a catalogue\n* NumStorePurchases: Number of purchases made directly in stores\n* NumWebVisitsMonth: Number of visits to company\u2019s web site in the last month\n\n## Target\n* Need to perform clustering to summarize dfomer segments.\n\n\n<a id='2'><\/a>\n* [**Back to top**](#0)","7b41c9a1":"We will assume that the customer information was collected 2014-12-07.","b7b861af":"And finally, calculate the difference between how long a person has been a client and the count of days from the last purchase.","2d24f514":"# **5 Work in Progress..**\nIf you like the work please upvote (\u1557 \u0361\ud83d\udc41\u202f\u035c\u0296 \u0361\ud83d\udc41)\u1557\n<a id='5'><\/a>\n* [**Back to top**](#0)","f14d31db":"# **4.4 K-Mean Cluster 3D Plot**\n\n<a id='4.4'><\/a>\n* [**Back to top**](#0)","e88fb55f":"# **4.1 K-Means Clustering**\n\nK-Means is probably the most well-known clustering algorithm. It\u2019s taught in a lot of introductory data science and machine learning classes. It\u2019s easy to understand and implement in code! Check out the graphic below for an illustration.\n\n![K-mean Clustering image](https:\/\/miro.medium.com\/max\/600\/1*KrcZK0xYgTa4qFrVr0fO2w.gif)\n\n> **1.** To begin, we first select a number of classes\/groups to use and randomly initialize their respective center points. To figure out the number of classes to use, it\u2019s good to take a quick look at the data and try to identify any distinct groupings. The center points are vectors of the same length as each data point vector and are the \u201cX\u2019s\u201d in the graphic above.\n\n> **2.** Each data point is classified by computing the distance between that point and each group center, and then classifying the point to be in the group whose center is closest to it.\n\n> **3.** Based on these classified points, we recompute the group center by taking the mean of all the vectors in the group.\n\n> **4.** Repeat these steps for a set number of iterations or until the group centers don\u2019t change much between iterations. You can also opt to randomly initialize the group centers a few times, and then select the run that looks like it provided the best results.\n\n\n\n**Advantages:**\nK-Means has the advantage that it\u2019s pretty fast, as all we\u2019re really doing is computing the distances between points and group centers; very few computations! It thus has a linear complexity O(n).\n\n**Disadvantages:**\nOn the other hand, K-Means has a couple of disadvantages. Firstly, you have to select how many groups\/classes there are. This isn\u2019t always trivial and ideally with a clustering algorithm we\u2019d want it to figure those out for us because the point of it is to gain some insight from the data. K-means also starts with a random choice of cluster centers and therefore it may yield different clustering results on different runs of the algorithm. Thus, the results may not be repeatable and lack consistency. Other cluster methods are more consistent.\n\n<a id='4.1'><\/a>\n* [**Back to top**](#0)","31a5e7fd":"# **4 Clustering**\n\nAs I am a beginner I have not done any unsupervised learning task before, let's learn the basics of clustering together and apply them in this task.\nI will be going to read this medium post on [**The 5 Clustering Algorithms Data Scientists Need to Know**](https:\/\/towardsdatascience.com\/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68)\n\n<a id='4'><\/a>\n* [**Back to top**](#0)","89931331":"# **Choosing The Right Number Of Clusters**\n\nThe number of clusters that we choose for a given dataset cannot be random. Each cluster is formed by calculating and comparing the distances of data points within a cluster to its centroid. An ideal way to figure out the right number of clusters would be to calculate the Within-Cluster-Sum-of-Squares (WCSS). \n\nWCSS is the sum of squares of the distances of each data point in all clusters to their respective centroids.\n\n![WCSS Formula image](https:\/\/www.analyticsindiamag.com\/wp-content\/uploads\/2019\/08\/4_wcss.png)\n\nThe idea is to minimise the sum. Suppose there are n observation in a given dataset and we specify n number of clusters (k = n) then WCSS will become zero since data points themselves will act as centroids and the distance will be zero and ideally this forms a perfect cluster, however this doesn\u2019t make any sense as we have as many clusters as the observations. Thus there exists a threshold value for K which we can find using the Elbow point graph.\n\n# **Elbow method**\nWe can find the optimum value for K using an Elbow point graph. We randomly initialise the K-Means algorithm for a range of K values and will plot it against the WCSS for each K value.","adcd1ead":"Let's highlight the age and time that a person is a client.","e2aaeb6b":"![customer](https:\/\/helprace.com\/wp-content\/uploads\/2017\/05\/customer-personality-types-1.png)","7c4a4ca5":"**3.1 Bar Plot**\n\n<a id='3.1'><\/a>\n* [**Back to top**](#0)","277fc884":"# 1. Context\n## 1.1 Problem Statement\n\nCustomer Personality Analysis is a detailed analysis of a company\u2019s ideal dfomers. It helps a business to better understand its dfomers and makes it easier for them to modify products according to the specific needs, behaviors and concerns of different types of dfomers.\n\nCustomer personality analysis helps a business to modify its product based on its target dfomers from different types of dfomer segments. For example, instead of spending money to market a new product to every dfomer in the company\u2019s database, a company can analyze which dfomer segment is most likely to buy the product and then market the product only on that particular segment.\n\n<a id='1'><\/a>\n* [**Back to top**](#0)","24844970":"**Converting outliers.**"}}