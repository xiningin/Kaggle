{"cell_type":{"edcf96ef":"code","049285a6":"code","e588385d":"code","d4342537":"code","73f1a72f":"markdown","16921e75":"markdown"},"source":{"edcf96ef":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","049285a6":"#define many functions here\n\nfrom copy import deepcopy\nimport random\nrandom.seed(108)\n\ndef print_board(board):\n    print()\n    print(' ', end='')\n    for x in range(1, len(board) + 1):\n        print(' %s  ' % x, end='')\n    print()\n\n    print('+---+' + ('---+' * (len(board) - 1)))\n\n    for y in range(len(board[0])):\n        print('|   |' + ('   |' * (len(board) - 1)))\n\n        print('|', end='')\n        for x in range(len(board)):\n            print(' %s |' % board[x][y], end='')\n        print()\n\n        print('|   |' + ('   |' * (len(board) - 1)))\n\n        print('+---+' + ('---+' * (len(board) - 1)))\n\ndef select_space(board, column, player):\n    if not move_is_valid(board, column):\n        return False\n    if player != \"X\" and player != \"O\":\n        return False\n    for y in range(len(board[0])-1, -1, -1):\n        if board[column-1][y] == ' ':\n            board[column-1][y] = player\n            return True\n    return False\n\ndef board_is_full(board):\n    for x in range(len(board)):\n        for y in range(len(board[0])):\n            if board[x][y] == ' ':\n                return False\n    return True\n\ndef move_is_valid(board, move):\n    if move < 1 or move > (len(board)):\n        return False\n\n    if board[move-1][0] != ' ':\n        return False\n\n    return True\n\ndef available_moves(board):\n    moves = []\n    for i in range(1, len(board)+1):\n        if move_is_valid(board, i):\n            moves.append(i)\n    return moves\n\ndef has_won(board, symbol):\n    # check horizontal spaces\n    for y in range(len(board[0])):\n        for x in range(len(board) - 3):\n            if board[x][y] == symbol and board[x+1][y] == symbol and board[x+2][y] == symbol and board[x+3][y] == symbol:\n                return True\n\n    # check vertical spaces\n    for x in range(len(board)):\n        for y in range(len(board[0]) - 3):\n            if board[x][y] == symbol and board[x][y+1] == symbol and board[x][y+2] == symbol and board[x][y+3] == symbol:\n                return True\n\n    # check \/ diagonal spaces\n    for x in range(len(board) - 3):\n        for y in range(3, len(board[0])):\n            if board[x][y] == symbol and board[x+1][y-1] == symbol and board[x+2][y-2] == symbol and board[x+3][y-3] == symbol:\n                return True\n\n    # check \\ diagonal spaces\n    for x in range(len(board) - 3):\n        for y in range(len(board[0]) - 3):\n            if board[x][y] == symbol and board[x+1][y+1] == symbol and board[x+2][y+2] == symbol and board[x+3][y+3] == symbol:\n                return True\n\n    return False\n\n\ndef game_is_over(board):\n  return has_won(board, \"X\") or has_won(board, \"O\") or len(available_moves(board)) == 0\n\ndef better_evaluate_board(board):\n    if has_won(board, \"X\"):\n      return float(\"Inf\")\n    elif has_won(board, \"O\"):\n      return -float(\"Inf\")\n    else:\n      x_streaks = count_streaks(board, \"X\")\n      o_streaks = count_streaks(board, \"O\")\n      return x_streaks - o_streaks\n\ndef count_streaks(board, symbol):\n    count = 0\n    for col in range(len(board)):\n        for row in range(len(board[0])):\n            if board[col][row] != symbol:\n                continue\n            # right\n            if col < len(board) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #left\n            if col > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #up-right\n            if col < len(board) - 3 and row > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row - i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-right\n            if col < len(board) - 3 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-left\n            if col > 2 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #up-left\n            if col > 2 and row > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row - i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-left\n            if col > 2 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down\n            num_in_streak = 0\n            if row < len(board[0]) - 3:\n                for i in range(4):\n                    if row + i < len(board[0]):\n                        if board[col][row + i] == symbol:\n                            num_in_streak += 1\n                        else:\n                            break\n            for i in range(4):\n                if row - i > 0:\n                    if board[col][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col][row - i] == \" \":\n                        break\n                    else:\n                        num_in_streak == 0\n            if row < 3:\n                if num_in_streak + row < 4:\n                    num_in_streak = 0\n            count += num_in_streak\n    return count\n\ndef minimax(input_board, is_maximizing, depth, alpha, beta, eval_function):\n  if game_is_over(input_board) or depth == 0:\n        return [eval_function(input_board), \"\"]\n  if is_maximizing:\n    best_value = -float(\"Inf\")\n    moves = available_moves(input_board)\n    random.shuffle(moves)\n    best_move = moves[0]\n    for move in moves:\n      new_board = deepcopy(input_board)\n      select_space(new_board, move, \"X\")\n      hypothetical_value = minimax(new_board, False, depth - 1, alpha, beta, eval_function)[0]\n      if hypothetical_value > best_value:\n        best_value = hypothetical_value\n        best_move = move\n      alpha = max(alpha, best_value)\n      if alpha >= beta:\n        break\n    return [best_value, best_move]\n  else:\n    best_value = float(\"Inf\")\n    moves = available_moves(input_board)\n    random.shuffle(moves)\n    best_move = moves[0]\n    for move in moves:\n      new_board = deepcopy(input_board)\n      select_space(new_board, move, \"O\")\n      hypothetical_value = minimax(new_board, True, depth - 1, alpha, beta, eval_function)[0]\n      if hypothetical_value < best_value:\n        best_value = hypothetical_value\n        best_move = move\n      beta = min(beta, best_value)\n      if alpha >= beta:\n        break\n    return [best_value, best_move]\n\ndef play_game(ai):\n    BOARDWIDTH = 7\n    BOARDHEIGHT = 6\n    board = []\n    for x in range(BOARDWIDTH):\n      board.append([' '] * BOARDHEIGHT)\n    while not game_is_over(board):\n        print_board(board)\n        moves = available_moves(board)\n        print(\"Available moves: \" , moves)\n        choice = 100\n        good_move = False\n        while not good_move:\n            choice = input(\"Select a move:\\n\")\n            try:\n                move = int(choice)\n            except ValueError:\n                continue\n            if move in moves:\n                good_move = True\n        select_space(board, int(choice), \"X\")\n        if not game_is_over(board):\n          result = minimax(board, False, ai, -float(\"Inf\"), float(\"Inf\"))\n          print(\"Computer chose: \", result[1])\n          select_space(board, result[1], \"O\")\n\ndef make_board():\n    new_game = []\n    for x in range(7):\n        new_game.append([' '] * 6)\n    return new_game","e588385d":"def random_eval(board):\n  return random.randint(-100, 100)\n\n\ndef my_evaluate_board(board):\n  if has_won(board, \"X\"):\n    return float(\"Inf\")\n  elif has_won(board, \"O\"):\n    return -float(\"Inf\")\n  \n  x_two_streak = 0\n  o_two_streak = 0\n  for col in range(len(board)-1):\n    for row in range(len(board[0])):\n      if board[col][row]==\"X\" and board[col+1][row]==\"X\":\n        x_two_streak += 1\n      if board[col][row]==\"O\" and board[col+1][row]==\"O\":\n        o_two_streak += 1\n  return x_two_streak - o_two_streak\n  \n  \n\ndef two_ai_game():\n    my_board = make_board()\n    while not game_is_over(my_board):\n      #The \"X\" player finds their best move.\n      result = minimax(my_board, True, 4, -float(\"Inf\"), float(\"Inf\"), my_evaluate_board)\n      print( \"X Turn\\nX selected \", result[1])\n      print(result[1])\n      select_space(my_board, result[1], \"X\")\n      print_board(my_board)\n\n      if not game_is_over(my_board):\n        #The \"O\" player finds their best move\n        result = minimax(my_board, False, 4, -float(\"Inf\"), float(\"Inf\"), random_eval)\n        print( \"O Turn\\nO selected \", result[1])\n        print(result[1])\n        select_space(my_board, result[1], \"O\")\n        print_board(my_board)\n    if has_won(my_board, \"X\"):\n        print(\"X won!\")\n    elif has_won(my_board, \"O\"):\n        print(\"O won!\")\n    else:\n        print(\"It's a tie!\")\n\n\n\nnew_board = make_board()\nselect_space(new_board, 6, \"X\")\nselect_space(new_board, 7, \"X\")\nselect_space(new_board, 1, \"O\")\nselect_space(new_board, 2, \"O\")\nselect_space(new_board, 3, \"X\")\nselect_space(new_board, 5, \"O\")\nselect_space(new_board, 4, \"O\")\nprint_board(new_board)\nprint(my_evaluate_board(new_board))\n\n\ntwo_ai_game()\n\n\n","d4342537":"def evaluate_board(board):\n    if has_won(board, \"X\"):\n      return float(\"Inf\")\n    elif has_won(board, \"O\"):\n      return -float(\"Inf\")\n    else:\n      x_streaks = count_streaks(board, \"X\")\n      o_streaks = count_streaks(board, \"O\")\n      return x_streaks - o_streaks\n\ndef count_streaks(board, symbol):\n    count = 0\n    for col in range(len(board)):\n        for row in range(len(board[0])):\n            if board[col][row] != symbol:\n                continue\n            # right\n            if col < len(board) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #left\n            if col > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #up-right\n            if col < len(board) - 3 and row > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row - i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-right\n            if col < len(board) - 3 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col + i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col + i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-left\n            if col > 2 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #up-left\n            if col > 2 and row > 2:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row - i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down-left\n            if col > 2 and row < len(board[0]) - 3:\n                num_in_streak = 0\n                for i in range(4):\n                    if board[col - i][row + i] == symbol:\n                        num_in_streak += 1\n                    elif board[col - i][row + i] != \" \":\n                        num_in_streak = 0\n                        break\n                count += num_in_streak\n            #down\n            num_in_streak = 0\n            if row < len(board[0]) - 3:\n                for i in range(4):\n                    if row + i < len(board[0]):\n                        if board[col][row + i] == symbol:\n                            num_in_streak += 1\n                        else:\n                            break\n            for i in range(4):\n                if row - i > 0:\n                    if board[col][row - i] == symbol:\n                        num_in_streak += 1\n                    elif board[col][row - i] == \" \":\n                        break\n                    else:\n                        num_in_streak == 0\n            if row < 3:\n                if num_in_streak + row < 4:\n                    num_in_streak = 0\n            count += num_in_streak\n    return count","73f1a72f":"If you\u2019ve never played Connect Four before, the goal is to get a streak of four of your pieces in any direction \u2014 horizontally, vertically, or diagonally. You can place a piece by picking a column. The piece will fall to the lowest available row in that column.\n\nWe'll create a game playing AI that can play Connect Four.","16921e75":"Our current evaluation function idea (which is a little simple):\n\nIf the game isn\u2019t over, a good strategy would be to have more streaks of two or streaks of three than your opponent. Having these streaks means that you\u2019re closer to getting a streak of four and winning the game!\n\nOne of the trickiest part of counting streaks is that they can happen in eight different directions \u2014 up, up-right, right, down-right, down, down-left, left, and up-left.\n\nFor now, we are just keeping track of streaks to the right.\n\nHere are some ideas on how to expand your function:\n\nCheck for streaks in all eight directions.\nWeight streaks of three higher than streaks of two.\nOnly count streaks if your opponent hasn\u2019t blocked the possibility of a Connect Four. For example, if there\u2019s an \"X\" streak of two to the right, but the next column over has an \"O\", then that streak is useless.\nOnly count streaks if there\u2019s enough board space to make a Connect Four. For example, there\u2019s no need to check for left streaks of two in the second column from the left. Even if there is a streak of two, you can\u2019t make a Connect Four going to the left, so the streak is useless.\nTesting your evaluation function on test boards is critically important before plugging it into the two_ai_game() function. Make sure you know that your function is working how you expect it to.\n\nThe following is a better choice for the evaluation function. Most of the work is done in the helper function count_streaks().\n\ncount_streaks() loops through every square in the board. For every square, it looks 4 squares out in all eight directions. If none of those squares contain the opposite player\u2019s symbol, then we know it\u2019s possible to make a Connect Four in that direction.\n\nWe then add the number of times our symbol appears in those 4 squares. Essentially we\u2019re saying \u201cit\u2019s possible to make a Connect Four in this direction and we have 1, 2, or 3 out of the four necessary pieces already placed."}}