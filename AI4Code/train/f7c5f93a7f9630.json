{"cell_type":{"afe059e4":"code","466beaf8":"code","98ae3f33":"code","56959ad6":"code","5d78d3d7":"code","8a364c30":"code","3a1978fb":"code","ae25bafd":"code","92c3f4ec":"code","d3fa5f09":"code","2213cc16":"code","d673d249":"code","e94f1133":"code","0f746767":"code","7c212648":"code","21143050":"code","67ed95ee":"code","071e3bb5":"code","11b51d25":"code","e73ee6fd":"code","bc559751":"code","174adcc1":"code","e47fe39b":"code","023b0bd1":"code","ba4c2107":"code","1f244d81":"code","009d35e8":"code","14a38774":"code","5c45975f":"code","2d93b724":"code","209a7b5e":"code","61eb2d46":"code","f4009825":"markdown","bb1ca1bb":"markdown","9be60b4b":"markdown","4628e259":"markdown","6291526f":"markdown","fd7552b3":"markdown","02bf4c39":"markdown","eb01cffe":"markdown","6538c6cf":"markdown","a2b9b5cd":"markdown","c4a10d10":"markdown","929776f9":"markdown","a0d0a500":"markdown","19c71908":"markdown","cd627f4d":"markdown","0e04eb84":"markdown","6dd7cc81":"markdown","e86a238b":"markdown","fd23878b":"markdown","24936de1":"markdown","032c7f65":"markdown","f05d0925":"markdown","eebb2c91":"markdown","a65ab9bb":"markdown"},"source":{"afe059e4":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","466beaf8":"import matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\nimport seaborn as sns\n\nfrom sklearn.svm import SVR\nfrom sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.tree import DecisionTreeRegressor as DTRegressor\nfrom sklearn.ensemble import RandomForestRegressor as RFRegressor\nfrom sklearn.ensemble import AdaBoostRegressor as Ada\nfrom xgboost import XGBRegressor\nfrom scipy.optimize import curve_fit\nfrom calendar import monthrange\n\n%config InlineBackend.figure_format = 'retina'\nfrom datetime import datetime as dt\nimport sys\nfrom tabulate import tabulate","98ae3f33":"df = pd.read_csv('..\/input\/wind-turbine-scada-dataset\/T1.csv')\ndf.columns = ['date', 'active_power', 'wind_speed', 'theor_power', 'wind_dir']\n\ndf","56959ad6":"# Convert to datetime format\ndf['date'] = pd.to_datetime(df['date'])\n\n# Set date column as index\ndf.set_index('date', inplace=True)\n\ndf","5d78d3d7":"plt.plot(df.wind_speed, df.theor_power, 'o', markersize= 1)\nplt.title('Theorectical Power vs Wind Speed')\nplt.grid('both')\nplt.xlabel('Wind Speed (m\/s)')\nplt.ylabel('Theoretical Power (kW)')\nplt.show()","8a364c30":"plt.title('Actual Power vs Theoretical Power')\nplt.plot(df.theor_power, df.active_power, 'o', markersize= 1)\nplt.grid('both')\nplt.xlabel('Theoretcial Power (kW)')\nplt.ylabel('Actual Power (kW)')\nplt.plot([0,3650], [0,3650], '-', c= 'k')\nplt.show()","3a1978fb":"x = np.array(df.wind_speed.tolist())\nfigure(figsize=(10, 8))\nplt.title('Actual Power vs Wind Speed')\nplt.plot(df.wind_speed, df.active_power, 'o', markersize= 1)\nplt.grid('both')\nplt.xlabel('Wind Speed (m\/s)')\nplt.ylabel('Actual Power (kW)')\nplt.show()","ae25bafd":"# Fitting Logistic Curves to Data\ndef logistic_curve(xi, a, b, c, d, trunc):\n    \"\"\"\n    Logistic function with parameters a, b, c, d, trunc\n    a is the curve's maximum value (ignoring truncation)\n    b is an offset value\n    c is the logistic growth rate or steepness of the curve\n    d is the x value of the sigmoid's midpoint\n    trunc is an upper truncation\n    \"\"\"\n    sigmoid = (a \/ (1 + np.exp(-c*(xi-d)))) + b\n    return np.clip(sigmoid, 0, trunc)","92c3f4ec":"max_df = pd.read_csv('..\/input\/turbineanalyticsworkingfiles\/power_envelope_max.csv')\nmin_df = pd.read_csv('..\/input\/turbineanalyticsworkingfiles\/power_envelope_min.csv')\n\np0 = [4000, -5, 1, 7, 3600] # Initial guess of fit parameters\nmax_logistic_params, covariance = curve_fit(logistic_curve, max_df.Speed, max_df.Power, p0 = p0)\nmin_logistic_params, covariance = curve_fit(logistic_curve, min_df.Speed, min_df.Power, p0 = p0)","d3fa5f09":"x = np.array(df.wind_speed.tolist())\n\na, b, c, d, trunc = max_logistic_params\nmax_power = logistic_curve(x, a, b, c, d, trunc)\n\na, b, c, d, trunc = min_logistic_params\nmin_power = logistic_curve(x, a, b, c, d, trunc)\n\nfigure(figsize=(10, 8))\nplt.title('Actual Power vs Wind Speed, with Upper & Lower Operational Bounds')\nplt.plot(df.wind_speed, df.active_power, 'o', markersize= 1)\nplt.plot(x, max_power, 'o', c = 'r', markersize= 1)\nplt.plot(x, min_power, 'o', c = 'r', markersize= 1)\nplt.grid('both')\nplt.xlabel('Wind Speed (m\/s)')\nplt.ylabel('Actual Power (kW)')\nplt.show()","2213cc16":"include_mask = []\npower_ratio = []\nspeed_data = df.wind_speed.tolist()\npower_data = df.active_power.tolist()\nfor p, power in enumerate(power_data):\n    power_range = max_power[p] - min_power[p]\n    if power_range > 0:\n        power_ratio.append((power - min_power[p]) \/ power_range)\n    else:\n        power_ratio.append(0)\n    if power >= min_power[p] and power <= max_power[p]:\n        include_mask.append(True)\n    else:\n        include_mask.append(False)\n        \ndf['Ratio'] = power_ratio\ndf['Mask'] = include_mask\nfitted_df = df[df['Mask']] # Data within the operating envelope\nnoise_df =  df[~df['Mask']] # Data outside the operating envelope\nzero_df = df[df['active_power']<=0]\n\nprint('Total Data: ',len(df),'points')\nprint('Operating Envelope Data: ',len(fitted_df),'points (',round(len(fitted_df)*100\/len(df),1),'%)')","d673d249":"figure(figsize=(10, 8))\nplt.title('Actual Power vs Wind Speed, Split by Group')\nplt.plot(fitted_df.wind_speed, fitted_df.active_power, 'o', markersize= 2, label='In Operating Envelope')\nplt.plot(noise_df.wind_speed, noise_df.active_power, 'o', markersize= 2, label='Non-Zero outside Operating Envelope')\nplt.plot(zero_df.wind_speed, zero_df.active_power, 'o', markersize= 2, label='Zero Power')\nplt.grid('both')\nplt.xlabel('Wind Speed (m\/s)')\nplt.ylabel('Actual Power (kW)')\nplt.legend()\nplt.show()","e94f1133":"figure(figsize=(10, 8))\nplt.plot(fitted_df.index, fitted_df['Ratio'], 'o', markersize= 1)\nplt.title('Power Ratio vs Date for data within operating window')\nplt.xlabel('Date')\nplt.ylabel('Power Ratio')\nplt.show()","0f746767":"dates = fitted_df.index.tolist()\nnoise_dates = noise_df.index.tolist()\ndays = np.array([d.timetuple().tm_yday for d in dates])\nnoise_days = np.array([d.timetuple().tm_yday for d in noise_dates])\nfitted_df['AnnualCycle'] = 0.15*np.sin((days\/365.25)*2*3.14159+1.2)+0.45\nnoise_df['AnnualCycle'] = 0.15*np.sin((noise_days\/365.25)*2*3.14159+1.2)+0.45\n\nfigure(figsize=(10, 8))\nplt.plot(dates, fitted_df['Ratio'], 'o', markersize= 1)\nplt.plot(dates, fitted_df['AnnualCycle'], 'o', markersize= 2, c = 'r')\nplt.title('Power Ratio vs Date for data within operating window, with Annual Sinusoid')\nplt.xlabel('Date')\nplt.ylabel('Power Ratio')\nplt.show()","7c212648":"hour = np.array([d.hour + d.minute\/60 for d in dates])\nnoise_hour = np.array([d.hour + d.minute\/60 for d in noise_dates])\nfigure(figsize=(10, 8))\nplt.plot(hour, fitted_df['Ratio'], 'o', markersize= 1)","21143050":"fitted_df['DailyCycle'] = 0.10*np.sin((hour-3.5)*2*3.142\/24)+0.35\nnoise_df['DailyCycle'] = 0.10*np.sin((noise_hour-3.5)*2*3.142\/24)+0.35\nfigure(figsize=(10, 8))\nplt.plot(hour, fitted_df['Ratio'], 'o', markersize= 1)\nplt.plot(hour, fitted_df['DailyCycle'], 'o', markersize= 2, c = 'r')","67ed95ee":"figure(figsize=(10, 8))\nplt.title('Power Ratio vs Wind Speed')\nplt.plot(fitted_df['wind_speed'],fitted_df['Ratio'], 'o', markersize= 1)\nplt.xlabel('Wind Speed (m\/s)')\nplt.ylabel('Power Ratio')\nplt.show()","071e3bb5":"# Rate of rotation of wind direction\nnoise_df['Rotation Rate'] = noise_df['wind_dir'].diff() \/ noise_df.index.to_series().diff().dt.total_seconds()\n# Rate of change in Wind Speed\nnoise_df['Acceleration'] = noise_df['wind_speed'].diff() \/ noise_df.index.to_series().diff().dt.total_seconds()","11b51d25":"figure(figsize=(10, 8))\nplt.plot(noise_df['Rotation Rate'],noise_df['active_power'], 'o', markersize= 1)\nplt.xlim([-0.05, 0.05])\nplt.title('Active Power vs Rate of change in Wind Direction')\nplt.xlabel('Rate of change in Wind Direction (deg\/sec)')\nplt.ylabel('Active Power (kW)')","e73ee6fd":"figure(figsize=(10, 8))\nplt.plot(noise_df['Acceleration'],noise_df['active_power'], 'o', markersize= 1)\n#plt.xlim([-0.05, 0.05])\nplt.title('Active Power vs Rate of change in Wind Speed')\nplt.xlabel('Rate of change in Wind Speed (m\/sec\/sec)')\nplt.ylabel('Active Power (kW)')","bc559751":"fitted_df['SinAngle'] = np.sin(fitted_df['wind_dir']\/360*2*3.14159)\nnoise_df['SinAngle'] = np.sin(noise_df['wind_dir']\/360*2*3.14159)","174adcc1":"sns.pairplot(fitted_df[['active_power', 'wind_speed', 'SinAngle', 'Ratio', 'DailyCycle', 'AnnualCycle']])","e47fe39b":"def corr_heatmap(df):    \n    plt.figure(figsize=(8,8))\n\n    mask = np.triu(np.ones_like(df.corr(), dtype=np.bool))\n    sns.heatmap(df.corr(), mask=mask, vmin=-1, vmax=1)\n\ncorr_heatmap(fitted_df[['active_power', 'wind_speed', 'SinAngle', 'Ratio', 'DailyCycle', 'AnnualCycle']])","023b0bd1":"# Features and target\nX = fitted_df[['wind_speed', 'SinAngle', 'DailyCycle', 'AnnualCycle']]\ny = fitted_df[['Ratio', 'active_power']] # Note, including active power, so we can compare predictions later\n\n# Train test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)\n\n# Split out Ratio (Regression target) from Active Power\nactive_power_test = np.array(y_test['active_power'].tolist())\nactive_power_train = np.array(y_train['active_power'].tolist())\ny_test = np.array(y_test['Ratio'].tolist())\ny_train = np.array(y_train['Ratio'].tolist())\n\n# Scale using Robust Scaler\nfrom sklearn.preprocessing import RobustScaler\nrscaler = RobustScaler()\nrscaler.fit(X_train)\n# Transform the train dataset to standardized data\nx_train_scaled = rscaler.transform(X_train)\nx_test_scaled  = rscaler.transform(X_test)","ba4c2107":"pd.DataFrame(X,columns=['wind_speed', 'SinAngle', 'DailyCycle', 'AnnualCycle']).hist()\nplt.show()","1f244d81":"check = input('Why not just load pickle? This will take a long time. Do you really wish to rerun? (y\/n): ')\nif check.upper() != 'Y':\n    sys.exit()\n    \nfrom xgboost import XGBRegressor\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import GridSearchCV \n\nxgb = XGBRegressor()\n\nparameters = {'tree_method': ['gpu_hist'], #'nthread':[4], #when use hyperthread, xgboost may become slower\n              'learning_rate': [0.05, 0.1, 0.2], # 'eta' value\n              'max_depth': [5, 10, 20],\n              'min_child_weight': [1],\n              'subsample': [1.0],\n              'colsample_bytree': [1.0],\n              'n_estimators': [100, 500, 1000], #number of trees\n              'seed': [1],\n              'eval_metric': ['mlogloss']}\n\ngrid = GridSearchCV(xgb, parameters, verbose=2, refit=True)\ngrid.fit(x_train_scaled, y_train)\n\n# Save results into a pickle file so that we dont need to repeat next time notebook started.\nimport pickle\npickle.dump( [xgb, parameters, grid], open( \"xgb_grid.pkl\", \"wb\" ) )","009d35e8":"# Load grid from pickle file\nfrom xgboost import XGBRegressor\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.model_selection import GridSearchCV \n\nimport pickle\nxgb, parameters, grid = pickle.load(open( '..\/input\/turbineanalyticsworkingfiles\/xgb_grid.pkl', \"rb\" ) )","14a38774":"print(grid.best_params_)\nprint('\\nmemorization performance: ', grid.score(x_train_scaled,y_train))\nprint('generalization performance: ', grid.score(x_test_scaled,y_test))\ny_pred_xg = grid.predict(x_train_scaled)\ny_test_pred_xg = grid.predict(x_test_scaled)","5c45975f":"figure(figsize=(10, 8))\nplt.plot(y_train, y_pred_xg, 'o', markersize= 2, label= 'Training Data')\nplt.plot(y_test, y_test_pred_xg, 'o', markersize= 2, label = 'Test Data')\nplt.plot([0,1], [0,1], '-', c= 'k')\nplt.xlim([0, 1])\nplt.ylim([0, 1])\nplt.title('Predicted vs Calculated Power Ratio')\nplt.xlabel('Calculated Power Ratio')\nplt.ylabel('Predicted Power Ratio')\nplt.grid('both')\nplt.legend()\nplt.show()","2d93b724":"# Function to return predicted Active Power given (1) Wind Speed and (2) Power Ratio\ndef pred_pwr(min_logistic_params, max_logistic_params, wind_speed, ratios):\n    a, b, c, d, trunc = max_logistic_params\n    max_power = logistic_curve(wind_speed, a, b, c, d, trunc)\n    a, b, c, d, trunc = min_logistic_params\n    min_power = logistic_curve(wind_speed, a, b, c, d, trunc)\n    span = (max_power - min_power)\n    power = min_power + span * ratios\n    return power","209a7b5e":"# Calculate power ratio predictions over operating envelope dataset\ntest_power = pred_pwr(min_logistic_params, max_logistic_params, X_test['wind_speed'], 0.5)\ntrain_power = pred_pwr(min_logistic_params, max_logistic_params, X_train['wind_speed'], 0.5)\n\n# Predict power ratios over 'noise' dataset and calculate matching Power predictions\nX_noise = noise_df[['wind_speed', 'SinAngle', 'DailyCycle', 'AnnualCycle']]\nx_noise_scaled = rscaler.transform(X_noise)\nnoise_ratio_pred = grid.predict(x_noise_scaled)\nnoise_power = pred_pwr(min_logistic_params, max_logistic_params, X_noise['wind_speed'], 0.5)\n\nfigure(figsize=(10, 8))\nplt.plot(active_power_train, train_power, 'o', markersize= 2, label= 'Training Data')\nplt.plot(active_power_test, test_power, 'o', markersize= 2, label = 'Test Data')\nplt.plot(noise_power, noise_df['active_power'], 'o', markersize= 2, label = 'Noise (unfitted) Data')\nplt.plot([0,3650], [0,3650], '-', c= 'k')\nplt.xlim([0, 3650])\nplt.ylim([0, 3650])\nplt.title('Predicted (using fixed 0.5 power ratio) vs Calculated Active Power')\nplt.xlabel('Reported Active Power (kW)')\nplt.ylabel('Predicted Active Power (kW)')\nplt.grid('both')\nplt.legend()\nplt.show()\n\noperating_pred = np.concatenate((train_power,test_power))\noperating_reported = np.concatenate((active_power_train,active_power_test))\n\nnon_zero_pred = np.concatenate((operating_pred,noise_power))\nnon_zero_reported = np.concatenate((operating_reported,np.array(noise_df['active_power'])))\n\nheaders = ['Dataset', 'Mean Absolute Error', 'Mean Squared Error', 'r2']\ntable = []\ntable.append(['Training Data', mean_absolute_error(active_power_train, train_power), mean_squared_error(active_power_train, train_power), r2_score(active_power_train, train_power)])\ntable.append(['Test Data', mean_absolute_error(active_power_test, test_power), mean_squared_error(active_power_test, test_power), r2_score(active_power_test, test_power)])\ntable.append(['All Operating Envelope', mean_absolute_error(operating_pred, operating_reported), mean_squared_error(operating_pred, operating_reported), r2_score(operating_pred, operating_reported)])\ntable.append(['All Non Zero Data', mean_absolute_error(non_zero_pred, non_zero_reported), mean_squared_error(non_zero_pred, non_zero_reported), r2_score(non_zero_pred, non_zero_reported)])\n\nprint(tabulate(table, headers = headers))","61eb2d46":"# Calculate power ratio predictions over operating envelope dataset\ntest_power = pred_pwr(min_logistic_params, max_logistic_params, X_test['wind_speed'], y_test_pred_xg)\ntrain_power = pred_pwr(min_logistic_params, max_logistic_params, X_train['wind_speed'], y_pred_xg)\n\n# Predict power ratios over 'noise' dataset and calculate matching Power predictions\nX_noise = noise_df[['wind_speed', 'SinAngle', 'DailyCycle', 'AnnualCycle']]\nx_noise_scaled = rscaler.transform(X_noise)\nnoise_ratio_pred = grid.predict(x_noise_scaled)\nnoise_power = pred_pwr(min_logistic_params, max_logistic_params, X_noise['wind_speed'], noise_ratio_pred)\n\nfigure(figsize=(10, 8))\nplt.plot(active_power_train, train_power, 'o', markersize= 2, label= 'Training Data')\nplt.plot(active_power_test, test_power, 'o', markersize= 2, label = 'Test Data')\nplt.plot(noise_power, noise_df['active_power'], 'o', markersize= 2, label = 'Noise (unfitted) Data')\nplt.plot([0,3650], [0,3650], '-', c= 'k')\nplt.xlim([0, 3650])\nplt.ylim([0, 3650])\nplt.title('Predicted vs Calculated Active Power with XGB Refinement')\nplt.xlabel('Reported Active Power (kW)')\nplt.ylabel('Predicted Active Power (kW)')\nplt.grid('both')\nplt.legend()\nplt.show()\n\noperating_pred = np.concatenate((train_power,test_power))\noperating_reported = np.concatenate((active_power_train,active_power_test))\n\nnon_zero_pred = np.concatenate((operating_pred,noise_power))\nnon_zero_reported = np.concatenate((operating_reported,np.array(noise_df['active_power'])))\n\nheaders = ['Dataset', 'Mean Absolute Error', 'Mean Squared Error', 'r2']\ntable = []\ntable.append(['Training Data', mean_absolute_error(active_power_train, train_power), mean_squared_error(active_power_train, train_power), r2_score(active_power_train, train_power)])\ntable.append(['Test Data', mean_absolute_error(active_power_test, test_power), mean_squared_error(active_power_test, test_power), r2_score(active_power_test, test_power)])\ntable.append(['All Operating Envelope', mean_absolute_error(operating_pred, operating_reported), mean_squared_error(operating_pred, operating_reported), r2_score(operating_pred, operating_reported)])\ntable.append(['All Non Zero Data', mean_absolute_error(non_zero_pred, non_zero_reported), mean_squared_error(non_zero_pred, non_zero_reported), r2_score(non_zero_pred, non_zero_reported)])\n\nprint(tabulate(table, headers = headers))","f4009825":"## And compare all corresponding (non-zero) Actual Power data","bb1ca1bb":"# Wind Turbine SCADA Data Analytics and Prediction of Turbine Power ","9be60b4b":"## Fit data within operating window with XGB Regression\nEnable GPU usage and use GridSearchCV to tune hyperparameters. Note: Dont actually run this unless you have a spare 1-2 hours to wait. You can skip to the next Pickle Load step instead if you just want the results.","4628e259":"## Investigate possibility that (a) Wind gusts and\/or (b) Changing wind direction can explain the noise\nCalculate Wind speed acceleration, and rate of change in wind angle over successive timestepsWe would like to investigate Mean Power Curve plot for all directions. ","6291526f":"## We will go ahead and describe a 'normal' operating envelope between two truncated Logistic curves, so that we can frame operating power in terms of the fraction between low and high curves.","fd7552b3":"## While very noisy, it does appear that an annual sinosoidal signal exists.\nWe will create a sinosoidal function that matches the frequency. The amplitude is irrelevant, given it will be rescaled for regression","02bf4c39":"## Similarly, while very noisy, it does appear that a daily sinosoidal signal exists.\nWe will create a sinosoidal function that matches the frequency. The amplitude is irrelevant, given it will be rescaled for regression","eb01cffe":"## Plotting actual power vs windspeed\nObservations:\n\n1. There is a clear 'normal' operating range that the majority data exists in, that appears to follow a truncated Logistic curve form\n2. There appears to be two separate upper power limits, one at around ~3,600 kW, and the other around ~3,450 kW.\n3. There exists many data points at zero power even at high wind speeds. I will assume this is due to operational decisions, and will ignore these\n4. There is a smaller population of data with power generation significantly below 'normal' operating range. I will look for possible explanations (other than operational decisions) before I ignore these data.","6538c6cf":"## The regression using the mid-point of the simple curve-fit power window envelope is actually pretty good.\nFrom a statistics point of view, there is barely any improvement by implementing XGB regression to fine-tune, but visually it does appear to materially help","a2b9b5cd":"## Split and Scale the data","c4a10d10":"## Crossplotting Actual vs Theoretic power, it's also clear that the theoretical power function does not accurately reflect actual power potential, with many data points above the unit slope line\nIt also appears that the vast majority of data points exist in a narrow bound around the diagonal. The question is whether or not much of the data that exist significantly off the diagonal are for operational reasons \/ decisions, or can be attributed to other features in the data set.","929776f9":"There doesnt appear to be any persuasive explanation for power generation values outside of the operating window.\n\nI will go ahead and fit values within the power operating envelope window. First, we will take Sin of the wind direction to use in place of the degrees feature. Doing this should permit the regression model to understand that 359 degress is almost the same as 1 degree","a0d0a500":"# 1. Read data","19c71908":"## Calculate operating power fraction (0 = Lower Limit, 1 = Upper Limit), and exclude all data less than min power envelope for fitting","cd627f4d":"## Firstly, with simply assuming 0.5 power ratio throughout","0e04eb84":"## Look for feature signals that are related to the Power Ratio. First, on a yearly basisSevere power loss on many days in January, at the end of February, one day in May, and at the end of December. This can be due to maintainance. ","6dd7cc81":"## Ploting the theoretical power vs wind speed, shows that this is clearly only a function of windspeed - with no other noise","e86a238b":"## Manually digitizing the upper and lower power bounds of the plot above, we can fit to truncated logistic functions. The digitized data can be found in 'power_envelope_max.csv' and 'power_envelope_min.csv'","fd23878b":"![image](https:\/\/user-images.githubusercontent.com\/51282928\/142767727-dab61a3e-bb06-4fad-925e-aca9319fe870.png)","24936de1":"## Refining, using XGB predictions to determine Power Ratio","032c7f65":"## Load XGB regression object from Pickle if you didnt want to rerun XGB GridSearchCV","f05d0925":"# Conclusions\n\n1. More than 93% of all the data points operates within a relatively narrow operating window.\n\n2. The generated power efficiency within the operating window is influenced strongly by wind speed, with weak influence from angle as well as annual \/ daily cycles.\n\n3. A simple curve fit approach to characterize the operating window does a reasonable job of predicting power generation\n\n4. The prediction can be slightly improved with regression, with final r2 of >99% of all non-zero power data","eebb2c91":"## And now look for daily frequency relationship","a65ab9bb":"## Look at Power Ratio vs Wind Speed\nWind speed appears to be a significant feature in determining power ratio"}}