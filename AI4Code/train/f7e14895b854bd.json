{"cell_type":{"a9153ad6":"code","69c9b7e2":"code","b3401b03":"code","076afe8d":"code","0432421b":"code","21e4d767":"code","7c6a595e":"code","d27f37a5":"code","4c53b58b":"code","491b447b":"code","a82b9ef8":"code","8a234baa":"code","b12f56cb":"code","5ba24e7a":"code","bc528d5d":"code","36d8cb29":"code","6ef5fe7c":"code","5bde46cc":"code","ff4816e3":"code","c11d5abf":"code","3feaff5a":"code","fffc2511":"code","5fe6aece":"code","c560792a":"code","c00f5102":"code","5fe4e084":"code","af21540d":"code","531303e6":"code","b86b2637":"code","fa4c287b":"code","ca8946ac":"code","9b0386a6":"code","254b8bc3":"code","65004b8a":"code","c076d5f0":"code","63a4ac2f":"code","0f3354cc":"code","2b2e8ee4":"code","9ae125f5":"code","cdc076f7":"code","be47a3d4":"code","0eb97224":"code","c156ff47":"code","21d134a0":"markdown","8f7a6ae5":"markdown","06ea1124":"markdown","35accebc":"markdown","6105a117":"markdown","777d5826":"markdown","42f252d9":"markdown","01536601":"markdown","b186b15f":"markdown","dbe477ce":"markdown","747093bd":"markdown","8b675d05":"markdown","11c5fb20":"markdown","b8524727":"markdown","2c4c08c3":"markdown","9120bf46":"markdown"},"source":{"a9153ad6":"import random\nimport os\nfrom datetime import datetime\nfrom collections import OrderedDict\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pandas.plotting import register_matplotlib_converters\nregister_matplotlib_converters()\nfrom tqdm.notebook import tqdm, trange","69c9b7e2":"data_path = '..\/input\/price-volume-data-for-all-us-stocks-etfs\/Data\/Stocks\/'\nfile_names = [name for name in os.listdir(data_path) if os.stat(data_path + name).st_size > 0]\nprint(random.sample(file_names, 4))","b3401b03":"file_suffix = '.us.txt'\ntickers = [file_name.replace(file_suffix, '') for file_name in file_names]\nprint(random.sample(tickers, 4))","076afe8d":"example_ticker = 'wafd'\nexample_stock = pd.read_csv(data_path + example_ticker + file_suffix)\nexample_stock.head()","0432421b":"class Stock:\n    def __init__(self, dates, prices):\n        self.dates = dates\n        self.prices = prices\n\n    def __getitem__(self, idx):\n        return type(self)(self.dates[idx], self.prices[idx])\n    \n    def __len__(self):\n        return len(self.dates)\n\n    @classmethod\n    def read(cls, ticker):\n        original = pd.read_csv(data_path + ticker + file_suffix)\n        dates = original['Date'].map(lambda t: datetime.strptime(t, '%Y-%m-%d')).to_numpy()\n        prices = original['Open'].to_numpy()\n        return cls(dates, prices)","21e4d767":"stocks = OrderedDict((ticker, Stock.read(ticker)) for ticker in tqdm(tickers))","7c6a595e":"def plot(contents, ticker, *args, **kwargs):\n    plt.figure(figsize=(12, 8))\n    plt.title(f'{ticker.upper()} price')\n    contents(ticker, *args, **kwargs)\n    plt.legend()\n    plt.xlabel('date')\n    plt.ylabel('price [$]')\n    plt.show()","d27f37a5":"def plot_price(ticker, **kwargs):\n    plt.plot(stocks[ticker].dates, stocks[ticker].prices,\n             label='price', c='dodgerblue', zorder=0)","4c53b58b":"plot(plot_price, example_ticker)","491b447b":"def moving_average(signal, period):\n    cumsum = np.cumsum(signal)\n    result = (cumsum[period:] - cumsum[:-period]) \/ period\n    filler = np.full(period, np.nan)\n    return np.concatenate((filler, result))","a82b9ef8":"def plot_moving_average(ticker, period):\n    plot_price(ticker)\n    plt.plot(stocks[ticker].dates, moving_average(stocks[ticker].prices, period),\n             label=f'{period}-day moving average', c='indigo', zorder=1)","8a234baa":"plot(plot_moving_average, example_ticker, 30)","b12f56cb":"def bands(signal, period, power=2, interval=2, log=False):\n    if log:\n        signal = np.log(signal)\n    average = moving_average(signal, period)\n    deviation = np.abs(signal - average) ** power\n    band_width = moving_average(deviation[period:], period) ** (1\/power) * interval\n    filler = np.full(period, np.nan)\n    filled_width = np.concatenate((filler, band_width))\n    low, high = average - filled_width, average + filled_width\n    return (np.exp(low), np.exp(high)) if log else (low, high)","5ba24e7a":"def plot_bands(ticker, period, **bands_kwargs):\n    plot_moving_average(ticker, period)\n    low_band, high_band = bands(stocks[ticker].prices, period, **bands_kwargs)\n    plt.fill_between(stocks[ticker].dates, low_band, high_band,\n                     label=f'{period}-day band', color='pink', zorder=-1)","bc528d5d":"plot(plot_bands, example_ticker, period=30)","36d8cb29":"def keep_strategy(prices):\n    '''A baseline trading strategy: buy at the beginning and sell at the end.'''\n    return np.array([0]), np.array([len(prices) - 1]) # buys, sells","6ef5fe7c":"def band_strategy(prices, **bands_kwargs):\n    '''A trading strategy based on bands: when price falls below bands, buy, when price rises above bands, sell.'''\n    low_band, high_band = bands(prices, **bands_kwargs)\n    buys = []\n    sells = []\n    for idx, (price, low, high) in enumerate(zip(prices, low_band, high_band)):\n        if price < low and len(buys) <= len(sells):\n            buys.append(idx)\n        elif price > high and len(buys) > len(sells):\n            sells.append(idx)\n    return np.array(buys, dtype=int), np.array(sells, dtype=int)","5bde46cc":"def gain_strategy(prices, buy_ratio=0.9, sell_ratio=1.1):\n    '''\n    Start by buying stock.\n    Sell when it is worth more than sell_ratio times the buy price.\n    Buy again when it is worth less than buy_ratio times the sell price.\n    '''\n    buys = [0]\n    sells = []\n    action_price = prices[0] * sell_ratio\n    for idx, price in enumerate(prices):\n        if len(sells) < len(buys):\n            if price >= action_price:\n                sells.append(idx)\n                action_price = price * buy_ratio\n        else:\n            if price <= action_price:\n                buys.append(idx)\n                action_price = price * sell_ratio\n    return np.array(buys, dtype=int), np.array(sells, dtype=int)","ff4816e3":"def roi(prices, buys, sells):\n    if len(sells) < len(buys):\n        sells = np.append(sells, -1) # simulate selling at the last price\n    return np.prod(prices[sells] \/ prices[buys]) - 1","c11d5abf":"def plot_trades(ticker, background, strategy, **kwargs):\n    background(ticker, **kwargs)\n    buys, sells = strategy(stocks[ticker].prices, **kwargs)\n    roi_value = roi(stocks[ticker].prices, buys, sells)\n    plt.title(f'{ticker.upper()} trades using {strategy.__name__}, ROI: {roi_value}')\n    plt.scatter(stocks[ticker].dates[buys], stocks[ticker].prices[buys],\n                label='buys', marker='x', c='red', s=256, zorder=2)\n    plt.scatter(stocks[ticker].dates[sells], stocks[ticker].prices[sells],\n                label='sells', marker='x', c='lime', s=256, zorder=2)","3feaff5a":"plot(plot_trades, example_ticker, background=plot_price, strategy=keep_strategy)","fffc2511":"plot(plot_trades, example_ticker, background=plot_bands, strategy=band_strategy, period=30)","5fe6aece":"plot(plot_trades, example_ticker, background=plot_price, strategy=gain_strategy)","c560792a":"def jumps_ok(prices, max_jump):\n    jumps = prices[1:] \/ prices[:-1]\n    return np.max(jumps) <= max_jump and np.max(1\/jumps) <= max_jump\n\ndef filter_stocks(stocks, start_date=None, end_date=None, min_length=256, min_price=0.01, max_jump=8):\n    masks = {ticker: np.full(len(stocks[ticker]), True) for ticker in stocks}\n    if start_date is not None:\n        masks = {ticker: np.logical_and(masks[ticker], start_date <= stocks[ticker].dates) for ticker in stocks}\n    if end_date is not None:\n        masks = {ticker: np.logical_and(masks[ticker], stocks[ticker].dates < end_date) for ticker in stocks}\n    filtered = {ticker: stocks[ticker][masks[ticker]] for ticker in stocks}\n    filtered = {ticker: filtered[ticker] for ticker in filtered if len(filtered[ticker]) >= min_length}\n    filtered = {ticker: filtered[ticker] for ticker in filtered if min(filtered[ticker].prices) >= min_price}\n    filtered = {ticker: filtered[ticker] for ticker in filtered if jumps_ok(filtered[ticker].prices, max_jump)}\n    return OrderedDict(filtered)","c00f5102":"training = filter_stocks(stocks, end_date=np.datetime64('2015-01-01'))\nvalidation = filter_stocks(stocks, start_date=np.datetime64('2016-01-01'))\nprint(f'{len(training)} companies in training, {len(validation)} in validation')","5fe4e084":"def strategy_rois(stocks, strategy, **kwargs):\n    result = []\n    for ticker in stocks:\n        buys, sells = strategy(stocks[ticker].prices, **kwargs)\n        result.append(roi(stocks[ticker].prices, buys, sells))\n    return np.array(result)\n\ndef performance(rois, bias=2):\n    '''De facto weighted average of ROIs, which gives less weight to very high ones.'''\n    return np.exp(np.mean(np.log(rois + bias))) - bias","af21540d":"def search_params(strategy, num_epochs, param_generator):\n    results = []\n    for epoch in trange(num_epochs):\n        params = param_generator()\n        rois = strategy_rois(training, strategy, **params)\n        perf = performance(rois)\n        results.append({'params': params, 'rois': rois, 'perf': perf})\n    return results","531303e6":"def band_params():\n    return {\n        'period': int(2 ** np.random.uniform(2, 6)),\n        'power': 2 ** np.random.uniform(-2, 2),\n        'interval': 2 ** np.random.uniform(0, 1),\n        'log': random.choice([True, False])\n    }\n\nband_results = search_params(band_strategy, 256, band_params)","b86b2637":"def gain_params():\n    return {\n        'buy_ratio': 1 - 2 ** np.random.uniform(-8, -1),\n        'sell_ratio': 1 + 2 ** np.random.uniform(-8, -1)\n    }\n\ngain_results = search_params(gain_strategy, 256, gain_params)","fa4c287b":"def span_years(dates):\n    timespan = dates[-1] - dates[0]\n    return timespan \/ np.timedelta64(1, 'Y').astype(timespan.dtype)","ca8946ac":"def roi_hist(strategy, stocks, **kwargs):\n    rois = strategy_rois(stocks, strategy, **kwargs)\n    spans = [span_years(stocks[ticker].dates) for ticker in stocks]\n    yearly = [(roi + 1) ** (1\/span) - 1 for roi, span in zip(rois, spans)]\n    plt.figure(figsize=(12, 8))\n    plt.title(f'yearly ROI histogram for {strategy.__name__}')\n    plt.hist(yearly, bins=np.linspace(np.quantile(yearly, .01), np.quantile(yearly, .99), 256))\n    plt.axvline(np.median(yearly), color='orange', label=f'median: {np.median(yearly)}')\n    plt.axvline(np.mean(yearly), color='violet', label=f'mean: {np.mean(yearly)}')\n    plt.xlabel('yearly ROI')\n    plt.ylabel('number of companies')\n    plt.legend()\n    plt.show()","9b0386a6":"roi_hist(keep_strategy, validation)","254b8bc3":"def evaluate_results(search_results, strategy, background_plot):\n    best_result = max(search_results, key=lambda result: result['perf'])\n    print(f'best params for {strategy.__name__}: {best_result[\"params\"]}')\n    roi_hist(strategy, validation, **best_result['params'])\n    plot(plot_trades, example_ticker, background=background_plot, strategy=strategy, **best_result['params'])\n    return best_result","65004b8a":"best_band = evaluate_results(band_results, band_strategy, plot_bands)","c076d5f0":"best_gain = evaluate_results(gain_results, gain_strategy, plot_price)","63a4ac2f":"plt.figure(figsize=(12, 8))\nplt.title('performance histogram of band strategies')\nplt.xlabel('performance')\nplt.ylabel('number of strategies')\nplt.hist([result['perf'] for result in band_results], bins=64)\nplt.legend()\nplt.show()","0f3354cc":"for param_name in ['period', 'power', 'interval']:\n    fig, axes = plt.subplots(1, 2, figsize=(12, 6))\n    for idx, ax in enumerate(axes):\n        log = bool(idx)\n        ax.set_title(f'performance vs {param_name}, log={log}')\n        ax.set_xlabel(f'{param_name}')\n        ax.set_ylabel('performance')\n        ax.set_yscale('symlog')\n        fitting_log = [result for result in band_results if result['params']['log'] == log]\n        ax.scatter(\n            [result['params'][param_name] for result in fitting_log],\n            [result['perf'] for result in fitting_log]\n        )\n    plt.show()","2b2e8ee4":"def trade_count(strategy, stocks, **kwargs):\n    return sum(len(np.concatenate(strategy(stocks[ticker].prices, **kwargs))) for ticker in stocks)\n\nplt.figure(figsize=(12, 8))\nplt.title('number of trades vs. performance, by strategy')\nplt.xlabel('number of trades')\nplt.ylabel('performance')\nplt.yscale('symlog')\nplt.scatter(\n    [trade_count(band_strategy, validation, **result['params']) for result in tqdm(band_results)],\n    [result['perf'] for result in band_results]\n)\nplt.show()","9ae125f5":"best_band_trades = {ticker: band_strategy(validation[ticker].prices, **best_band['params']) for ticker in validation}\n\nplt.figure(figsize=(12, 8))\nplt.title('best strategy ROI, by company')\nplt.xlabel('number of trades')\nplt.ylabel('ROI')\nplt.yscale('symlog')\nplt.scatter(\n    [len(np.concatenate(best_band_trades[ticker])) for ticker in validation],\n    [roi(validation[ticker].prices, *best_band_trades[ticker]) for ticker in validation]\n)\nplt.show()","cdc076f7":"validation_2016 = filter_stocks(\n    stocks,\n    start_date=np.datetime64('2016-01-01'),\n    end_date=np.datetime64('2017-01-01'),\n    min_length=best_band['params']['period'] * 2\n)\nvalidation_2017 = filter_stocks(\n    stocks,\n    start_date=np.datetime64('2017-01-01'),\n    end_date=np.datetime64('2018-01-01'),\n    min_length=best_band['params']['period'] * 2\n)\n# filter so that only companies in both are kept, arrange in the same order\nvalidation_2016 = OrderedDict((ticker, validation_2016[ticker]) for ticker in validation_2016 if ticker in validation_2017)\nvalidation_2017 = OrderedDict((ticker, validation_2017[ticker]) for ticker in validation_2016 if ticker in validation_2016)\n\nrois_2016 = strategy_rois(validation_2016, band_strategy, **best_band['params'])\nrois_2017 = strategy_rois(validation_2017, band_strategy, **best_band['params'])\n\nplt.figure(figsize=(12, 8))\nplt.title('predictive power of performance in prevous year')\nplt.xlabel('ROI in 2016')\nplt.xscale('symlog')\nplt.ylabel('ROI in 2017')\nplt.yscale('symlog')\nplt.scatter(rois_2016, rois_2017)\nplt.show()","be47a3d4":"def roi_by_step(prices, strategy, **kwargs):\n    buys, sells = strategy(prices, **kwargs)\n    buy_mask = np.full(len(prices), False)\n    buy_mask[buys] = True\n    sell_mask = np.full(len(prices), False)\n    sell_mask[sells] = True\n    last_sell_ratio = 1.0\n    owned = False\n    ratios = []\n    for price, is_buy, is_sell in zip(prices, buy_mask, sell_mask):\n        if is_buy:\n            owned = True\n            buy_price = price\n        elif is_sell:\n            owned = False\n            last_sell_ratio = price \/ buy_price * last_sell_ratio\n        if owned:\n            ratios.append(price \/ buy_price * last_sell_ratio)\n        else:\n            ratios.append(last_sell_ratio)\n    return np.array(ratios) - 1","0eb97224":"plt.figure(figsize=(12, 8))\nplt.title(f'sanity check: ROI over time when trading {example_ticker.upper()}')\nplt.plot(\n    stocks[example_ticker].dates,\n    roi_by_step(stocks[example_ticker].prices, band_strategy, **best_band['params'])\n)\nplt.show()","c156ff47":"def mean_roi_by_date(stocks, strategy, **kwargs):\n    min_date = min(np.min(stocks[ticker].dates) for ticker in stocks)\n    max_date = max(np.max(stocks[ticker].dates) for ticker in stocks)\n    span_days = int((max_date - min_date).astype('timedelta64[D]').astype(int))\n    all_dates = [min_date + np.timedelta64(i, 'D') for i in range(span_days + 1)]\n    \n    aggregator = OrderedDict((date, {}) for date in all_dates)\n    for ticker in tqdm(stocks):\n        rois = roi_by_step(stocks[ticker].prices, strategy, **kwargs)\n        for date, roi in zip(stocks[ticker].dates, rois):\n            aggregator[date][ticker] = roi\n    \n    # fill missing values with last available value\n    last_value = {ticker: 0.0 for ticker in stocks}\n    for date in aggregator:\n        for ticker in stocks:\n            if ticker not in aggregator[date]:\n                aggregator[date][ticker] = last_value[ticker]\n            else:\n                last_value[ticker] = aggregator[date][ticker]\n    \n    return all_dates, [np.mean([aggregator[date][ticker] for ticker in stocks]) for date in aggregator]\n\n\nplt.figure(figsize=(12, 8))\nplt.title('mean ROI over time, by strategy')\nplt.xlabel('date')\nplt.ylabel('mean ROI over all stocks')\nplt.yscale('symlog')\nplt.plot(*mean_roi_by_date(validation, keep_strategy), label='keep')\nplt.plot(*mean_roi_by_date(validation, band_strategy, **best_band['params']), label='band')\nplt.plot(*mean_roi_by_date(validation, gain_strategy, **best_gain['params']), label='gain')\nplt.legend()\nplt.show()","21d134a0":"No, performance in the previous year is not a good indicator of performance in the next. But let's still see if our strategy is stable over time.","8f7a6ae5":"## Setup\nLoading data, imports, exploring formats etc.","06ea1124":"Yes, this seems okay. Let's do a full-scale test!","35accebc":"We'll use a logarithmic ROI-based metric to evaluate performance, so that single cases in which the algorithm got extremely lucky don't sway our results too much.","6105a117":"First, we need to filter our data. We'll remove suspicious-looking entries which are likely due to manual error (zero price, prices jumping more than 8x during a day etc).","777d5826":"Not really. But maybe there's another, more useful predictor of when our strategy will do good: its performance for a given company's stock in the provious year. Let's investigate.","42f252d9":"Yes! Let's see if our best strategy is also better when its trades are higher in frequency.","01536601":"To evaluate our strategies, we'll be using the return on investments: the ratio of the net gain (negative if there was a loss) to the initial value invested.","b186b15f":"## Validation","dbe477ce":"## Insight\nLet's see if the best of these strategies - the band-based one - consistently produces good results, and what defines a good band-based strategy's parameters.","747093bd":"## Let's devise some strategies\nWe'll be simulating trading using a few simple strategies: a baseline (buy stock and hold onto it no matter what), one based on the bollinger-like bands, and one which guarantees that stock will be sold for more than it was bought for (but doesn't guarantee that it will be sold at all). All of these are all-or-nothing strategies: whenever they make a buy\/sell decision, they go all-in.","8b675d05":"Our strategies are fairly stable, and the band-based one clearly works well. Yay! In a new investigation, we should take a look at fees, taxes, and slippage costs, but for now - we're done here.","11c5fb20":"# Algotrading!\nLet's devise a stock trading strategy, optimize its parameters & see if it makes sense.","b8524727":"## Optimization time!\nWe'll be optimizing our strategies - finding the parameters which give the best performance in a trading simulation.","2c4c08c3":"## Let's explore some indicators!\nWe'll be looking at moving averages and Bollinger-like bands.","9120bf46":"Looks like our strategies are best when they do relatively high-frequency trades (the tendency to improve with lower period, power and interval would suggest this). Let's check!"}}