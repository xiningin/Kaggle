{"cell_type":{"803a4f4d":"code","c4c1653e":"code","13d72ba6":"code","86f9b6f3":"code","5a4498aa":"code","4ff1dd57":"code","d5907219":"code","af09d57e":"code","a3b7f539":"code","9b605efe":"code","4ae89798":"code","cb08ed15":"code","03ca19aa":"code","b8c27426":"code","23c1ca10":"code","76e74a41":"code","c2dd9116":"markdown","3d135305":"markdown","5cd877c4":"markdown","d84894cb":"markdown","331765d9":"markdown","85232f87":"markdown","c2869ce3":"markdown","939c894c":"markdown","61d635ce":"markdown","5bda2001":"markdown","373e07ea":"markdown"},"source":{"803a4f4d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.spatial.distance import cdist, pdist\nfrom sklearn.cluster import KMeans\nfrom mpl_toolkits.mplot3d import Axes3D\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c4c1653e":"data = pd.read_csv('..\/input\/unsupervised-learning-on-country-data\/Country-data.csv')\ndata_dict = pd.read_csv('..\/input\/unsupervised-learning-on-country-data\/data-dictionary.csv')\nprint(data.dtypes)\nprint(data.head(3))\nprint(data_dict)","13d72ba6":"# Detect number of NaN values in the table\nNAN = [(col,data[col].isna().sum()) for col in data]\nNAN = pd.DataFrame(NAN, columns=['Column_Name', 'Num_of_NaN'])\nNAN","86f9b6f3":"# Check if there is replication in the data\nprint('The dataset contains repeated country:', data.duplicated().any())\n# General discription of the table\ndata.describe()","5a4498aa":"# separate country column and the rest variables\ndata.index=data.iloc[:,0]\ndata_1=data.drop([\"country\"], axis=1)","4ff1dd57":"# find the correlation between variables\ncorr = data_1.corr()\nax = sns.heatmap(\n    corr, \n    vmin=-1, vmax=1, center=0,\n    cmap=sns.diverging_palette(10, 220, n=20),\n    square=True)\nax.set_xticklabels(\n    ax.get_xticklabels(),\n    rotation=45,\n    horizontalalignment='right')","d5907219":"# plot the pair scatter plots of all factors\nsns.pairplot(data_1)","af09d57e":"# find the outliers\nprint(data.query('child_mort>100 & income>20000')) #outlier in income\/gdpp plot\n# data.query('child_mort>100 & gdpp>17000')\nprint(data.query('inflation>100')) #outlier in inflation plot\nprint(data.query('child_mort>200')) #outlier in total_fer plot","a3b7f539":"# clustering the samples based on health factors(child_mort, life_expec, total_fer)\ndata_clustering_1=data[['child_mort', 'life_expec', 'total_fer']]\n\n# plot sum of squared distances (elbow method)\nK = range(1,10)\ndata_km = [KMeans(n_clusters=k).fit(data_clustering_1) for k in K]\nssd = [data_km[k].inertia_ for k in range(len(data_km))]\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.plot(K, ssd, 'b*-')\nplt.grid(True)\nplt.xlabel('Number of clusters')\nplt.ylabel('Sum of squared distances')\nplt.title('Elbow for KMeans clustering')\nplt.show()","9b605efe":"kmeans = KMeans(n_clusters=3)\nmodel = kmeans.fit(data_clustering_1)\npred = model.labels_\ndata_1['cluster_km'] = pred\ndata_1.head()","4ae89798":"fig = plt.figure()\nax = fig.add_subplot(111,projection='3d')\ncluster_0 = data_1.query('cluster_km==0')\ncluster_1 = data_1.query('cluster_km==1')\ncluster_2 = data_1.query('cluster_km==2')\nplt_0 = ax.scatter(cluster_0['child_mort'], cluster_0['life_expec'], cluster_0['total_fer'], c='c', s=10)\nplt_1 = ax.scatter(cluster_1['child_mort'], cluster_1['life_expec'], cluster_1['total_fer'], c='r', s=10)\nplt_2 = ax.scatter(cluster_2['child_mort'], cluster_2['life_expec'], cluster_2['total_fer'], c='g', s=10)\nax.set_xlabel('child_mort')\nax.set_ylabel('life_expec')\nax.set_zlabel('total_fer')\nplt.tight_layout()\nplt.show()","cb08ed15":"# Find out the number data points in cluster 2\nprint(cluster_2.count())","03ca19aa":"# clustering the samples based on economic factors(child_mort, life_expec, total_fer)\ndata_clustering_2=cluster_2[['income', 'gdpp', 'health']]\n\n# plot sum of squared distances (elbow method)\nK = range(1,10)\ndata_km = [KMeans(n_clusters=k).fit(data_clustering_2) for k in K]\nssd = [data_km[k].inertia_ for k in range(len(data_km))]\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.plot(K, ssd, 'b*-')\nplt.grid(True)\nplt.xlabel('Number of clusters')\nplt.ylabel('Sum of squared distances')\nplt.title('Elbow for KMeans clustering')\nplt.show()","b8c27426":"kmeans = KMeans(n_clusters=3)\nmodel = kmeans.fit(data_clustering_2)\npred = model.labels_\ncluster_2['cluster_km'] = pred\ncluster_2.head()","23c1ca10":"fig = plt.figure()\nax = fig.add_subplot(111,projection='3d')\ncluster_2_0 = cluster_2.query('cluster_km==0')\ncluster_2_1 = cluster_2.query('cluster_km==1')\ncluster_2_2 = cluster_2.query('cluster_km==2')\nplt_0 = ax.scatter(cluster_2_0['income'], cluster_2_0['gdpp'], cluster_2_0['health'], c='c', s=10, label='cluster0')\nplt_1 = ax.scatter(cluster_2_1['income'], cluster_2_1['gdpp'], cluster_2_1['health'], c='r', s=10, label='cluster1')\nplt_2 = ax.scatter(cluster_2_2['income'], cluster_2_2['gdpp'], cluster_2_2['health'], c='g', s=10, label='cluster2')\nax.set_xlabel('income')\nax.set_ylabel('gdpp')\nax.set_zlabel('health')\nax.legend()\nplt.tight_layout()\nplt.show()","76e74a41":"# sort cluster0 by gdpp, income, health ascendingly\nprint(cluster_2_0.sort_values(['income','gdpp','health'],ascending=True))","c2dd9116":"- It's also noticed that there are obvious outliers in the income, gdpp, total_fert scatter plots.","3d135305":"Take k=3","5cd877c4":"From the correlation map we see that \n- **child_mort** has a strong inverse correlation with **income**(net income per person), **life_expect**(expected years of living) and **gdpp**(the GDP per capita), a moderate correlation with **inflation**(annual growth rate of the total GDP) and **total_fert**(fertility rate). \n- **income** is correlated with **exports** and **gdpp**.\n- **exports** is correlated with **imports**\n- **life_expec** is correlated with **income** and **gdpp**, inversly correlated with **total_fert**","d84894cb":"From the plot we see that cluster 0 of the second k-means contains countries with low income and low gdpp. The health expenses vary. ","331765d9":"# Visualize k-means clustering results","85232f87":"# Data cleaning and exploration","c2869ce3":"The variables can be didived into economic metrics(exports, imports, income, inflation, gdpp, health), health metrics(child_mort, life_expec, total_fer).\n","939c894c":"The unsupervised learning results suggest that the aid should be provided to the countries at the top of the list(Congo, Niger, Central African Republic, etc.).","61d635ce":"We can see from the plot that cluster 2 are high child_mort, high total_fer and low life_expec, indicating poor social health, so we want to further cluster these data points based on their economic conditions.","5bda2001":"Take k=3","373e07ea":"# Clustering the countries"}}