{"cell_type":{"77e6215e":"code","8cd9b077":"code","48b9bf83":"code","65102d5e":"code","9ee62cc8":"code","df51f36d":"code","7b84295e":"code","3d5175cd":"code","e4379f3d":"code","e95e8199":"code","af524208":"markdown","06cc1445":"markdown"},"source":{"77e6215e":"# Import libraries\nimport lightgbm as lgb\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport platform\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom sklearn.metrics import roc_auc_score\n\n# Define global variables\nDATA_ROOT = '..\/input\/data-fraud'\n\n!dir \"..\/input\/ieee-fraud-detection\"\n\nif platform.system() == \"Windows\":\n    local = True\nelse:\n    local = False\n\nif local:\n    DATA_ROOT = '..\/input\/ieee-fraud-detection'\n","8cd9b077":"# Splitting training data function\ndef split_data(data, sample: float = 1.0, fraction: float = 0.8):\n    # Shuffle data\n    data = data.sample(frac=sample, random_state=0)\n\n    # Split data into train and test\n    train_data = data.sample(frac=fraction, random_state=0)\n    test_data = data.drop(train_data.index)\n\n    return train_data, test_data\n","48b9bf83":"def get_predictions(traindatafile, testdatafile, label, id):\n    # Read data\n    train = pd.read_csv(traindatafile)\n    test = pd.read_csv(testdatafile)\n\n    y = train[label].to_numpy()\n    predictions = np.zeros(len(test))\n    predictions_id = test[id].to_numpy()\n\n    # Drop id column and label column\n    train = train.drop(columns=[id, label])\n    test = test.drop(columns=[id])\n\n    # Init kfold\n    N_FOLD = 5\n    folds = StratifiedKFold(n_splits=N_FOLD, shuffle=True, random_state=0)\n\n    oof = np.zeros(len(train))\n    X = train.to_numpy()\n    X_test = test.to_numpy()\n\n    for train_idx, valid_idx in folds.split(X, y):\n        X_train, X_valid = X[train_idx, :], X[valid_idx, :]\n        y_train, y_valid = y[train_idx], y[valid_idx]\n        \n        model = lgb.LGBMClassifier(n_estimators=10000, metric='auc')\n        model.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_valid, y_valid)], verbose=200,\n                        early_stopping_rounds=250)\n        val_preds = model.predict(X_valid)\n        predictions += model.predict(X_test)\/N_FOLD\n        oof[valid_idx] = val_preds\n\n        lgb.plot_metric(model.evals_result_, metric='auc')\n        plt.show()\n        lgb.plot_importance(model, max_num_features=50)\n        plt.show()\n\n    AUC_OOF = round(roc_auc_score(y, oof), 4)\n    print('Model ensemble OOF AUC score: {}'.format(AUC_OOF))\n\n    result = pd.DataFrame({'TransactionID': predictions_id, 'isFraud': predictions})\n\n    return result","65102d5e":"# For testing\n# get_predictions(\n#     f'{DATA_ROOT}\/final_train_transaction.csv',\n#     f'{DATA_ROOT}\/final_test_transaction.csv',\n#     'isFraud',\n#     'TransactionID'\n# )","9ee62cc8":"def group_by_card(datafile):\n    # Read data\n    df = pd.read_csv(datafile)\n\n    tempdf = df.copy()\n    # Create new column named cardID where it equals to card1, card2, addr1 and addr2 combination as string\n    tempdf['cardID'] = tempdf['card1'].astype(str) + '_' + tempdf['card2'].astype(\n        str) + '_' + tempdf['addr1'].astype(str) + '_' + tempdf['addr2'].astype(str)\n\n    # Group TransactionIDs by cardID\n    groups = {}\n    for _, row in tempdf.iterrows():\n        if row['cardID'] not in groups:\n            groups[row['cardID']] = [row['TransactionID']]\n        else:\n            groups[row['cardID']].append(row['TransactionID'])\n\n    return groups\n\n\nprint(len(group_by_card(f'{DATA_ROOT}\/final_test_transaction.csv')))\n","df51f36d":"def get_group_avg(df, group, label, id):\n    # Get the average of the values of the group\n    return round(df.loc[df[id].isin(group), label].mean())","7b84295e":"# Export prediction function\ndef export_prediction(traindatafile, testdatafile, label, id):\n    # Group test data by cardID\n    groups = group_by_card(testdatafile)\n\n    # Predict\n    result = get_predictions(traindatafile, testdatafile, label, id)\n\n    result.to_csv(f'.\/raw_result.csv', index=False)\n\n    # Post-processing with group average\n    for _, group in groups.items():\n        result.loc[result[id].isin(group), label] = get_group_avg(\n            result, group, label, id)\n\n    # Export result\n    result.to_csv(f'.\/result.csv', index=False)\n\n    return result\n","3d5175cd":"# Check output file function\ndef check_output(filepath, label):\n    # Read data\n    data = pd.read_csv(filepath)\n\n    # Check data\n    print(f'{data.info()}\\n{\"---\"*10}')\n    print(f'{data.head()}\\n{\"---\"*10}')\n\n    # Value counts of label column\n    print(f'{data[label].value_counts()}\\n{\"---\"*10}')\n","e4379f3d":"export_prediction(\n    f'{DATA_ROOT}\/final_train_transaction.csv',\n    f'{DATA_ROOT}\/final_test_transaction.csv',\n    'isFraud',\n    'TransactionID'\n)\n","e95e8199":"check_output(f'.\/result.csv', 'isFraud')","af524208":"# Predicting\n\n## Training","06cc1445":"## Data post-processing\nNote that we are not predicting if a transaction is fraudulent or not but rather predicting if a card used for those transactions is fraudulent as the competition host mentioned [here](https:\/\/www.kaggle.com\/c\/ieee-fraud-detection\/discussion\/101203#589276).\n\nSo we are going to group those predictions together as cards and then take average then if a group is fraudulent then the whole group is going to be fraudulent. We will be grouping them by using card and addr columns."}}