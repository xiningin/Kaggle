{"cell_type":{"046ed431":"code","960d47c2":"code","acedf679":"code","4885945f":"code","6ccf689e":"code","4c7dd729":"code","b9d914c3":"code","7b002e7b":"code","13c7319b":"code","bdaa738a":"code","4a7e2c10":"code","16ca0794":"code","ed26c948":"code","ed99fca6":"code","c07bea3b":"code","10213988":"code","a3f6321a":"code","6008d855":"code","64891707":"code","3a4d58b6":"code","7dcc612f":"code","a6c36fc6":"code","1d73b6dc":"code","c95572b8":"code","cc7139a7":"code","e02cc5dd":"code","c3ee8be4":"code","50af8b9a":"code","349ef19c":"code","fdc65199":"code","a3153113":"code","1b395170":"code","a5a70ad3":"code","949549fe":"code","04b78982":"code","b0aee981":"code","c767d197":"code","9ceb812d":"code","67d45f77":"code","db0d9fd6":"code","e7eddeeb":"code","bac0f666":"code","3cd82855":"code","be3ba052":"code","dcfe9c53":"code","b5cfd84f":"code","89bb0d08":"code","6ade9fb8":"markdown","dd6f8986":"markdown","cabb7a50":"markdown","a44f1e9d":"markdown","c3ab3f28":"markdown","3eff54ee":"markdown","58ad42be":"markdown","d1dc2ac8":"markdown","d0c1726d":"markdown","8b7a1adc":"markdown","6276c14c":"markdown","e206312e":"markdown","4d1443b4":"markdown","62a98686":"markdown","b0c363f9":"markdown","5691badc":"markdown","2595be56":"markdown","2232c0a0":"markdown"},"source":{"046ed431":"# Imports\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.decomposition import PCA\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import KFold, StratifiedKFold\nfrom sklearn.metrics import accuracy_score, confusion_matrix\n\nimport tensorflow as tf","960d47c2":"# Reading in the data\n\ntrain = pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/train.csv')\ntest = pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/test.csv')","acedf679":"# Function to reduce memory\n\ndef reduce_mem_usage(df):\n    \"\"\" iterate through all the columns of a dataframe and modify the data type\n        to reduce memory usage.\n    \"\"\"\n    start_mem = df.memory_usage().sum() \/ 1024**2\n    \n    for col in df.columns:\n        col_type = df[col].dtype\n        \n        if col_type != object:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == 'int':\n                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)  \n            else:\n                #if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:\n                #    df[col] = df[col].astype(np.float16)\n                #el\n                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n        else:\n            df[col] = df[col].astype('category')\n\n    end_mem = df.memory_usage().sum() \/ 1024**2\n    print('Memory usage of dataframe is {:.2f} MB --> {:.2f} MB (Decreased by {:.1f}%)'.format(\n        start_mem, end_mem, 100 * (start_mem - end_mem) \/ start_mem))\n    return df","4885945f":"# Reducing memory usage\n\ntrain = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)","6ccf689e":"# Viewing the number of observations per category in target variable\n\ntrain['Cover_Type'].value_counts()","4c7dd729":"# Getting the all the soil column names\nsoil_columns = [col for col in train.columns if 'Soil_' in col]\n\n# Extracting winderness columns\nwild_columns = [col for col in train.columns if 'Wild' in col]\n\n# Categorical columns\ncat_cols = soil_columns + wild_columns","b9d914c3":"# Checking if an observation has more than one soil_type\n\ntrain[soil_columns].sum(axis=1).value_counts()","7b002e7b":"# Adding the number of soil_types as an additional feature\n\ntrain['sum_soil_types'] = train[soil_columns].sum(axis=1)\ntest['sum_soil_types'] = test[soil_columns].sum(axis=1)","13c7319b":"from sklearn.cluster import KMeans\n\nkmeans = KMeans(n_clusters=7)\ntrain['cluster'] = kmeans.fit_predict(train[soil_columns])\ntest['cluster'] = kmeans.predict(test[soil_columns])","bdaa738a":"# Remove columns 'Soil_Type7', 'Soil_Type15'\n\ntrain.drop(['Soil_Type7', 'Soil_Type15'], inplace=True, axis=1)\ntest.drop(['Soil_Type7', 'Soil_Type15'], inplace=True, axis=1)","4a7e2c10":"# Clipping the hillshade columns between 0 and 255\n\nhillshade_columns = [col for col in train.columns if 'Hillshade' in col]\n\nfor col in hillshade_columns:\n    train[col] = train[col].clip(0,255)\n    test[col] = test[col].clip(0,255)","16ca0794":"# Changing the range of Aspect to fall between 0 and 359\n\ntrain['Aspect'] = train['Aspect'].apply(lambda row: row%360)\ntest['Aspect'] = test['Aspect'].apply(lambda row: row%360)","ed26c948":"# Getting the features and target variables\n\nfeatures = [col for col in train.columns if col not in ['Id', 'Cover_Type']]\ntarget = 'Cover_Type'","ed99fca6":"# Label encoding the target variable\n\nfrom sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\ntrain[target] = le.fit_transform(train[target])","c07bea3b":"# Removing that single observation that has tree type '5' (or '4' after LabelEncoding)\n\ntrain = train.loc[train['Cover_Type'] != 4,].reset_index(drop=True)\n# train = train.loc[train['Cover_Type'] != 3,].reset_index(drop=True)","10213988":"# Getting the all the soil column names\nsoil_columns = [col for col in train.columns if 'Soil_' in col]\n\n# Extracting winderness columns\nwild_columns = [col for col in train.columns if 'Wild' in col]\n\n# Categorical columns\ncat_cols = soil_columns + wild_columns","a3f6321a":"# Getting the numerical features\n\nnum_columns = [col for col in train.columns if col not in cat_cols+['Id', 'Cover_Type']]","6008d855":"# Scaling the data before applying PCA\n\nscaler = StandardScaler()\npca_train = scaler.fit_transform(train[num_columns])\npca_test = scaler.transform(test[num_columns])","64891707":"# Checking to see how many components are needed to explain the most variance\n\npca = PCA()\npca.fit(pca_train)\nprint(pca.explained_variance_ratio_)","3a4d58b6":"# Plotting scree plots\n\nPC_values = np.arange(pca.n_components_) + 1\nplt.plot(PC_values, pca.explained_variance_ratio_, 'o-', linewidth=2, color='blue')\nplt.title('Scree Plot')\nplt.xlabel('Principal Component')\nplt.ylabel('Variance Explained')\nplt.show()","7dcc612f":"# Fitting a PCA \n\npca = PCA(n_components=4)\npca_train = pca.fit_transform(pca_train)\npca_test = pca.transform(pca_test)","a6c36fc6":"# Adding 4 components to the data\n\ntrain = pd.concat([train, pd.DataFrame(pca_train,columns=['comp1', 'comp2', 'comp3', 'comp4'])], axis=1)\ntest = pd.concat([test, pd.DataFrame(pca_test,columns=['comp1', 'comp2', 'comp3', 'comp4'])], axis=1)","1d73b6dc":"# # Getting the all the soil column names\n# soil_columns = [col for col in train.columns if 'Soil_' in col]\n\n# # Undummying the Soil_types\n# train['soil_type'] = train[soil_columns].idxmax(axis=1)\n# test['soil_type'] = test[soil_columns].idxmax(axis=1)\n\n# # Calculating the fequency encoding\n# soil_map = pd.Series(train['soil_type'].value_counts()\/train.shape[0]).to_dict()\n\n# # Applying the frequency encoding\n# train['soil_type'] = train['soil_type'].map(soil_map)\n# test['soil_type'] = test['soil_type'].map(soil_map)\n\n# # Dropping all the 'Soil-Type' columns\n# train = train.drop(soil_columns, axis=1)\n# test = test.drop(soil_columns, axis=1)","c95572b8":"# Checking if an observation has more than one soil_type\n\ntrain[wild_columns].sum(axis=1).value_counts()","cc7139a7":"wild_means = KMeans(n_clusters=7)\ntrain['wild_cluster'] = wild_means.fit_predict(train[wild_columns])\ntest['wild_cluster'] = wild_means.predict(test[wild_columns])","e02cc5dd":"total_means = KMeans(n_clusters=7)\ntrain['total_cluster'] = total_means.fit_predict(train[cat_cols])\ntest['total_cluster'] = total_means.predict(test[cat_cols])","c3ee8be4":"# Adding the number of wild_types as an additional feature\n\ntrain['sum_wild_types'] = train[wild_columns].sum(axis=1)\ntest['sum_wild_types'] = test[wild_columns].sum(axis=1)","50af8b9a":"# Function finding the Euclidean distance\n\ndef combine_components(row):\n    return np.sqrt(np.square(row['Horizontal_Distance_To_Hydrology']) + np.square(row['Vertical_Distance_To_Hydrology']))","349ef19c":"# Applying the function\n\ntrain['distance_to_hydrology'] = train.apply(combine_components, axis=1)\ntest['distance_to_hydrology'] = test.apply(combine_components, axis=1)","fdc65199":"# # Extracting winderness columns\n# wild_columns = [col for col in train.columns if 'Wild' in col]\n\n# # Undummying the wilderness_types\n# train['wild_type'] = train[wild_columns].idxmax(axis=1)\n# test['wild_type'] = test[wild_columns].idxmax(axis=1)\n\n# # Calculating the fequency encoding\n# wild_map = pd.Series(train['wild_type'].value_counts()\/train.shape[0]).to_dict()\n\n# # Applying the frequency encoding\n# train['wild_type'] = train['wild_type'].map(wild_map)\n# test['wild_type'] = test['wild_type'].map(wild_map)\n\n# # Dropping all the 'Soil-Type' columns\n# train = train.drop(wild_columns, axis=1)\n# test = test.drop(wild_columns, axis=1)","a3153113":"train = reduce_mem_usage(train)\ntest = reduce_mem_usage(test)","1b395170":"# Getting the features and target variables\n\ncolumns = soil_columns + ['Id', 'Cover_Type', 'Horizontal_Distance_To_Hydrology', 'Vertical_Distance_To_Hydrology'] + wild_columns\n\nfeatures = [col for col in train.columns if col not in columns]\ntarget = 'Cover_Type'","a5a70ad3":"# # Splitting the data into train and test splot\n\n# X_train, X_valid, y_train, y_valid = train_test_split(\n#     train[features], \n#     train[target],\n#     stratify=train[target],\n#     test_size=0.1, \n#     random_state=0\n# )\n# print(f'Shape of X_train: {X_train.shape}')\n# print(f'Shape of y_train: {y_train.shape}')\n# print(f'Shape of X_valid: {X_valid.shape}')\n# print(f'Shape of y_valid: {y_valid.shape}')","949549fe":"# # Scaling the data by fitting on X_train and scaling the rest\n\n# scaler = StandardScaler()\n\n# X_train = scaler.fit_transform(X_train)\n# X_valid = scaler.transform(X_valid)\n# # t = scaler.transform(test[features])","04b78982":"# Creating the model and compiling\n\ndef get_model(inputs):\n    \n    tf.keras.backend.clear_session()\n    \n    ## Setting the Inputs\n    inputs = tf.keras.Input(shape=(inputs))\n    x = inputs\n    \n    ## Dense Layers\n    \n    ### First layer\n    x = tf.keras.layers.Dense(256, activation='relu')(x)\n    x = tf.keras.layers.BatchNormalization()(x)\n    \n    ### Second layer\n    x = tf.keras.layers.Dense(128, activation='relu')(x)\n    x = tf.keras.layers.BatchNormalization()(x)\n    \n    ### Creating a skip conection\n    conn1 = tf.keras.layers.Concatenate()([inputs,x])\n    \n    ### Third Layer\n    x2 = tf.keras.layers.Dense(256, activation='relu')(conn1)\n    x2 = tf.keras.layers.BatchNormalization()(x2)\n    \n    ### Fourth layer\n    x2 = tf.keras.layers.Dense(128, activation='relu')(x2)\n    x2 = tf.keras.layers.BatchNormalization()(x2)\n    \n    ### Creating a skip conection\n    conn2 = tf.keras.layers.Concatenate()([x,x2])\n    \n    ### Fourth layer\n    x3 = tf.keras.layers.Dense(256, activation='relu')(conn2)\n    x3 = tf.keras.layers.BatchNormalization()(x3)\n    \n    ### Fifth layer\n    x3 = tf.keras.layers.Dense(128, activation='relu')(x3)\n    x3 = tf.keras.layers.BatchNormalization()(x3)\n    \n#     ### Sixth layer\n#     x3 = tf.keras.layers.Dense(64, activation='relu')(x3)\n#     x3 = tf.keras.layers.BatchNormalization()(x3)\n    \n    ## Output layer\n    output = tf.keras.layers.Dense(7, activation='softmax')(x3)\n\n    model = tf.keras.Model(inputs=inputs, outputs=output)\n    \n    model.compile(\n        optimizer=tf.keras.optimizers.Adam(learning_rate=1e-2),\n        loss=\"sparse_categorical_crossentropy\",\n        metrics=['acc']        \n    )\n    \n    ## Returning the model\n    return model","b0aee981":"# # Function that creates a TF sequential model\n\n# def get_model(inputs):\n#     tf.keras.backend.clear_session()\n\n#     ## Creating a Sequential Model\n#     model = tf.keras.Sequential([\n#         tf.keras.layers.Dense(512, input_shape=(None,inputs), activation='relu'),\n#         tf.keras.layers.Dense(256, activation='relu'),\n#         tf.keras.layers.Dense(128, activation='relu'),\n#         tf.keras.layers.Dense(64, activation='relu'),\n#         tf.keras.layers.Dense(7, activation = 'softmax')\n#     ])\n    \n#     ## Compile \n#     model.compile(\n#         optimizer=\"adam\",\n#         loss=\"sparse_categorical_crossentropy\",\n#         metrics=['acc']\n#     )\n    \n#     return model","c767d197":"# Neural Network parameters\n\nEPOCHS = 50\nBATCH_SIZE = 2048\n\nplateau = tf.keras.callbacks.ReduceLROnPlateau(\n    monitor='val_acc',\n    factor = 0.5,\n    patience = 3,\n    verbose = 0,\n    mode = 'max'\n)\n    \nearly_stopping = tf.keras.callbacks.EarlyStopping(\n    monitor = 'val_acc', \n    min_delta = 1e-06, \n    patience = 6, \n    verbose = 0,\n    mode = 'max', \n    baseline = None,\n    restore_best_weights = True\n)","9ceb812d":"# # K-fold Cross Validation model evaluation\n\n# X = X_train\n# y = y_train.values\n\n# FOLDS = 5\n# cv = StratifiedKFold(n_splits=FOLDS, shuffle=True, random_state=0)\n\n# test_preds = np.zeros((1, 1))\n# scores = []\n# for fold, (train_idx, val_idx) in enumerate(cv.split(X, y)):\n    \n#     ## Extracting the training and validation set from a fold\n#     X_t, X_v = X[train_idx], X[val_idx]\n#     y_t, y_v = y[train_idx], y[val_idx]\n    \n#     print('------------------------------------------------------------------------')\n#     print(f'Training for fold {fold} ...')\n    \n#     ## Creating a model\n#     model = get_model(X_train.shape[1])\n\n#     ## Fit data to model\n#     model.fit(\n#         X_t,\n#         y_t,\n#         validation_data=(X_v, y_v),\n#         epochs=EPOCHS,\n#         batch_size=BATCH_SIZE,\n#         verbose=2,\n#         callbacks=[plateau, early_stopping]\n#     )\n    \n#     ## Predicting using the model\n#     y_pred = np.argmax(model.predict(X_v), axis=1)\n#     score = accuracy_score(y_v, y_pred)\n#     scores.append(score)\n#     print(f'>Fold: {fold} --> Accuracy: {score}')","67d45f77":"# # Printing the results from K-Fold\n\n# print(f'Accuracy for each fold: {scores}')\n# print(f'Mean of all the folds: {np.mean(scores):.4f}')\n# print(f'Standard Deviation of the folds: {np.std(scores):.4f}')","db0d9fd6":"# # Creating a model\n\n# model = get_model(train[features].shape[1])\n\n# # Fit data to model\n# model.fit(\n#     X_train,\n#     y_train,\n#     validation_data=(X_valid, y_valid),\n#     epochs=EPOCHS,\n#     batch_size=BATCH_SIZE,\n#     verbose=2,\n#     callbacks=[plateau, early_stopping]\n# )","e7eddeeb":"# y_preds = model.predict(X_valid)\n# y_preds = y_preds.argmax(axis=1)\n# cm = confusion_matrix(y_preds, y_valid)","bac0f666":"# ## Get Class Labels\n# labels = le.classes_\n# class_names = labels\n\n# # Plot confusion matrix in a beautiful manner\n# fig = plt.figure(figsize=(12, 12))\n# ax= plt.subplot()\n# sns.heatmap(cm, annot=True, ax = ax, fmt = 'g'); #annot=True to annotate cells\n# # labels, title and ticks\n# ax.set_xlabel('Predicted', fontsize=20)\n# ax.xaxis.set_label_position('bottom')\n# plt.xticks(rotation=90)\n# ax.xaxis.set_ticklabels(class_names, fontsize = 10)\n# ax.xaxis.tick_bottom()\n\n# ax.set_ylabel('True', fontsize=20)\n# ax.yaxis.set_ticklabels(class_names, fontsize = 10)\n# plt.yticks(rotation=0)\n\n# plt.title('Refined Confusion Matrix', fontsize=20)","3cd82855":"# Scaling the train\n\nscaler = StandardScaler()\n\ntrain_scaled = scaler.fit_transform(train[features])\ntest_scaled = scaler.transform(test[features])","be3ba052":"# Creating a model\n\nmodel = get_model(train[features].shape[1])\n\n# Fit data to model\nmodel.fit(\n    train_scaled,\n    train[target],\n    epochs=EPOCHS,\n    batch_size=BATCH_SIZE,\n    verbose=2,\n    callbacks=[plateau, early_stopping]\n)","dcfe9c53":"# Predicting on the test set\n\npreds = model.predict(test_scaled)","b5cfd84f":"# Reversing the label encoder\n\nfinal_preds = le.inverse_transform(preds.argmax(axis=1))","89bb0d08":"# Creating a submission file\n\nsubmission = pd.DataFrame({'Id': test['Id'], 'Cover_Type': final_preds })\nsubmission.to_csv('submission.csv', index=False)","6ade9fb8":"After running K-Fold cross validation, the mean was .9485 with a 0.0002 standard deviation. It seems like the model is fitting well. We will rerun the model but with all the data instead of splitting it into train and validation set.","dd6f8986":"This is my continuation of our base line model: https:\/\/www.kaggle.com\/tqrahman\/baseline-with-tf-and-feature-engineering\n\nIn this notebook, we will focus on the neural network architecture\n* Version 4\n    * implemented PCA to add first five components as additional features\n* Version 6\n    * increased the network size\n    * added Batch Normalization\n    * added Skip Connections\n* Version 8\n    * applied clustering\n    * removed frequncy encoding\n    * feature engineered distance-to-hydrology","cabb7a50":"### Distance to Hydrology\nThere is a vertical and horizontal distance. It might be good to combine it to combine the components into one","a44f1e9d":"### Aspect\nAspect is in degress. It seems that it should be between 0-360 degrees. However some are below this range and exceeds this range. ","c3ab3f28":"## Model Analysis\n### Confusion Matrix","3eff54ee":"#### Frequency Encoding for 'Soil' columns\nThere are a lot of 'Soil_' types. It may add a lot of noise for the model. A possiblity is to use a frequency encoding instead of dummying the variable.","58ad42be":"## Processing for the Model","d1dc2ac8":"There are many dummy variables for 'soil_type'. We should check to see if each observation has one type or multiple types of soil. ","d0c1726d":"## Data Processing using PCA ","8b7a1adc":"Based on this value count, there are some observations that have multiple soil_types. This might be important for the model to know.","6276c14c":"## Feature Engineering","e206312e":"### Tensorflow Model","4d1443b4":"## Predictions","62a98686":"### Clustering data based on soil_types","b0c363f9":"### Hillshade\n\nHillshade is an \"image\" that ranges from 0-255. However some of the hillshade values are less than 0 or greater than 255. We will make an assumption that those were data entry errors and will clip them. If it is less than 0, we will set it to sero. If it is greater than 255, set it to 255.\n\nSome additional thoughts:\n* Set values under 0 to 0 and values greater than 255 to 255 for all Hillshade variables\n* Is clipping the best way to procede? Try just scaling instead of clipping\n* Remove the hillshade data that are NOT within the range between 0, 255","5691badc":"## Data Processing for Neural Network","2595be56":"### Wilderness Variables\n#### Frequency Encoding the 'Wilderness' column too","2232c0a0":"### Soil Variables\nIt will be a good idea to remove 'Soil_Type7' and 'Soil_Type15'because it is 0's for all observations. Therefore it is not informative and might add noise to the model."}}