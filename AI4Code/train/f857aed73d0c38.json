{"cell_type":{"c3877a7c":"code","b7d27fb2":"code","04b6986a":"code","aa2fd9f2":"code","0f635452":"code","6a7fc2a7":"code","ec778c6a":"code","07ae9233":"code","3786d99e":"code","1990b0b3":"code","002435ff":"code","d5a2fb89":"code","d3577134":"code","b4f25842":"code","ea209299":"code","369a94b8":"code","35aad59f":"code","3ddd30af":"code","556d5cf2":"code","17a2fa12":"code","1b4f5168":"code","8a09b12e":"code","598a9ba9":"code","62a71106":"code","d118404a":"code","054bfa2a":"code","aa6f0518":"code","9526891d":"code","4295c285":"code","18fa0428":"code","7650b40f":"code","b66ee105":"code","432abef3":"code","7cb3204b":"code","786a6c73":"code","5abec92a":"code","f0a6637c":"code","9a5631f0":"code","2b6cbd3d":"code","dab5cd91":"code","a445d5f8":"code","2d865b9a":"code","cdc6dbb7":"code","6abef007":"code","ed6a9e09":"code","f456dfb2":"markdown","feffdedc":"markdown","2d224453":"markdown","4f565121":"markdown","3160d8ea":"markdown","c019994c":"markdown","75186aae":"markdown","45cf6b0c":"markdown","2eb8a3e7":"markdown","1472bd14":"markdown","c6b16a7e":"markdown","dd17c3cd":"markdown","5259c5bc":"markdown","e187968b":"markdown","ee7012ef":"markdown","813ce557":"markdown","dab43567":"markdown","54ca65e3":"markdown"},"source":{"c3877a7c":"import torch\nimport torchvision\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision.datasets import MNIST\nfrom torchvision.transforms import ToTensor\nfrom torchvision.utils import make_grid\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.data import random_split\nimport pandas as pd\n%matplotlib inline","b7d27fb2":"train = pd.read_csv(\"..\/input\/digit-recognizer\/train.csv\",dtype = np.float32)\ntest = pd.read_csv(\"..\/input\/digit-recognizer\/test.csv\",dtype = np.float32)","04b6986a":"print(train.shape)\nprint(test.shape)","aa2fd9f2":"train.head()","0f635452":"test.head()","6a7fc2a7":"targets = train.label.values # 1st column that is values\nfeatures = train.drop(labels = [\"label\"],axis = 1).values \/ 255 #normalize","ec778c6a":"targetsTrain = torch.from_numpy(targets).type(torch.LongTensor)\nfeaturesTrain = torch.from_numpy(features)","07ae9233":"trn = torch.utils.data.TensorDataset(featuresTrain,targetsTrain)","3786d99e":"val_size = 4200\ntrain_size = len(trn) - val_size\n\ntrain_ds, val_ds = random_split(trn, [train_size, val_size])\nlen(train_ds), len(val_ds)","1990b0b3":"batch_size = 256","002435ff":"train_loader = DataLoader(train_ds, batch_size, shuffle=True, num_workers=4, pin_memory=True)\nval_loader = DataLoader(val_ds, batch_size*2, num_workers=4, pin_memory=True)","d5a2fb89":"for images,labels in train_loader:\n    plt.imshow(images[28].reshape(28,28))\n    plt.axis(\"off\")\n    plt.title(str(labels[28]))\n    plt.show()\n    break","d3577134":"for images, _ in train_loader:\n    imgs = []\n    print('images.shape:', images.shape)\n    plt.figure(figsize=(16,8))\n    for img in images:\n        im = img.reshape(28,28)\n        im = im.view(-1,im.size(0),im.size(1))\n        imgs.append(im)\n        plt.axis('off')\n    plt.imshow(make_grid(imgs, nrow=16).permute((1,2,0)))\n    break","b4f25842":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))","ea209299":"class Mnistnn(nn.Module):\n    def __init__(self,in_size,hidden_size1,hidden_size2,hidden_size3,out_size):\n        super().__init__()\n        self.linear1 = nn.Linear(in_size, hidden_size1)\n        self.linear2 = nn.Linear(hidden_size1, hidden_size2)\n        self.linear3 = nn.Linear(hidden_size2,hidden_size3)\n        self.linear4 = nn.Linear(hidden_size3,out_size)\n    \n    def forward(self,xb):\n        #xb.size(0) will be the batch size(change dynamically)\n        # -1 ths will be calculate by pytorch itself..\n        xb = xb.view(-1,xb.size(1))\n        out = self.linear1(xb)\n        out = F.relu(out)\n        out = self.linear2(out)\n        out = F.relu(out)\n        out = self.linear3(out)\n        out = F.relu(out)\n        out = self.linear4(out)\n        out = F.relu(out)\n        return out\n    \n    def training_step(self,batch):\n        images, labels = batch\n        out = self(images)\n        loss = F.cross_entropy(out,labels)\n        return loss\n    \n    def validation_step(self,batch):\n        images,labels = batch\n        out = self(images)\n        loss = F.cross_entropy(out,labels)\n        acc = accuracy(out,labels)\n        return {'val_loss': loss, 'val_acc': acc}\n\n    def validation_epoch_end(self,outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n\n    def epoch_end(self,epoch,result):\n        print(\"Epoch [{}], val_loss: {:.4f}, val_acc: {:.4f}\".format(epoch, result['val_loss'], result['val_acc']))","369a94b8":"input_size = 784\nhidden_size1 = 512\nhidden_size2 = 256\nhidden_size3 = 64\nnum_classes = 10","35aad59f":"model = Mnistnn(input_size, hidden_size1=hidden_size1, hidden_size2= hidden_size2,hidden_size3 = hidden_size3, out_size=num_classes)","3ddd30af":"for t in model.parameters():\n    print(t.shape)","556d5cf2":"for images, labels in train_loader:\n    outputs = model(images)\n    print(labels.shape)\n    loss = F.cross_entropy(outputs, labels)\n    print('Loss:', loss.item())\n    break\n\nprint('outputs.shape : ', outputs.shape)\nprint('Sample outputs :\\n', outputs[:2].data)","17a2fa12":"torch.cuda.is_available()","1b4f5168":"def get_default_device():\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')","8a09b12e":"device = get_default_device()\ndevice","598a9ba9":"# Moving PyTorch Tensors to GPU\ndef to_device(data, device):\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)","62a71106":"for images, labels in train_loader:\n    print(images.shape)\n    images = to_device(images, device)\n    print(images.device)\n    break","d118404a":"class DeviceDataLoader():\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        return len(self.dl)","054bfa2a":"train_loader = DeviceDataLoader(train_loader, device)\nval_loader = DeviceDataLoader(val_loader, device)","aa6f0518":"for xb, yb in val_loader:\n    print('xb.device:', xb.device)\n    print('yb:', yb)\n    break","9526891d":"def evaluate(model, val_loader):\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    time = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        for batch in train_loader:\n            loss = model.training_step(batch)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        model.epoch_end(epoch, result)\n        time.append(result)\n    return time","4295c285":"model = Mnistnn(input_size, hidden_size1=hidden_size1, hidden_size2= hidden_size2, hidden_size3= hidden_size3, out_size=num_classes)\nto_device(model, device)","18fa0428":"time = [evaluate(model, val_loader)]\ntime","7650b40f":"time += fit(10, 0.5, model, train_loader, val_loader) #Learning Rate = 0.5","b66ee105":"time += fit(16, 0.2, model, train_loader, val_loader)","432abef3":"time += fit(16, 0.0001, model, train_loader, val_loader)","7cb3204b":"time += fit(100, 0.00001, model, train_loader, val_loader)","786a6c73":"losses = [x['val_loss'] for x in time]\nplt.plot(losses, '-b')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.title('Loss vs. No. of epochs');","5abec92a":"accuracies = [x['val_acc'] for x in time]\nplt.plot(accuracies, 'r-')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('Accuracy vs. No. of epochs');","f0a6637c":"features_test = test.values \/ 255\nfeatures_tensor = torch.from_numpy(features_test)\ntest_loader = DataLoader(features_tensor, batch_size*2, num_workers=4, pin_memory=True)","9a5631f0":"# Prediction Function\ndef predict(tl, model):\n    preds = torch.cuda.LongTensor()\n    for img in tl:\n        y = model(img)\n        _, pred  = torch.max(y, dim=1)\n        preds = torch.cat((preds, pred), dim=0)\n    return preds","2b6cbd3d":"for images in test_loader:\n    imgs = []\n    print('images.shape:', images.shape)\n    plt.figure(figsize=(16,9))\n    for img in images:\n        im = img.reshape(28,28)\n        im = im.view(-1,im.size(0),im.size(1))\n        imgs.append(im)\n        plt.axis('off')\n    plt.imshow(make_grid(imgs, nrow=32).permute((1,2,0)))\n    break","dab5cd91":"test_loader_gpu = DeviceDataLoader(test_loader, device)","a445d5f8":"test_preds = predict(test_loader_gpu,model)","2d865b9a":"test_predictions = test_preds.cpu()","cdc6dbb7":"test_df = pd.DataFrame(np.c_[np.arange(1, len(test)+1), test_predictions.numpy()], \n                      columns=['ImageId', 'Label'])","6abef007":"test_df.to_csv('submission.csv', index=False)","ed6a9e09":"test_df.head()","f456dfb2":"# Viewing some training images \ud83e\udd33","feffdedc":"### Converting the pandas dataframe to numpy array to later covert into pytorch tensors \u2699\ufe0f\ud83d\udee0\ufe0f","2d224453":"# Using GPU for Training \u2764\ufe0f\ud83d\udd25 ","4f565121":"### Create model on GPU","3160d8ea":"## Intial loss with random weights \ud83d\udcc9","c019994c":"# Importing libraries\ud83d\udcda","75186aae":"# Getting data \ud83d\udcbd","45cf6b0c":"# Now we predict the Test Set \ud83d\udcbe","2eb8a3e7":"Defining function to calculate model accuracy for user. This won't help in training as it is not a differentiable function ","1472bd14":"# Submission \ud83d\udcdd","c6b16a7e":"## Visualizing Test Set \ud83c\udff7\ufe0f","dd17c3cd":"Defining Evaluate function and training loop for our model","5259c5bc":"# Creating a Simple PyTorch Model  \ud83e\udde9\ud83e\udde9\n### Defining a model with 1 input + 2 hidden layers ","e187968b":"# Now we view a batch of training images \ud83d\udcc8\ud83e\udd33","ee7012ef":"## Viewing accuracies increase over epochs \ud83d\udcc8\n### we see accuracy of our model rise as it trains","813ce557":"#### We only get around 9-15% accuracy. Which is okay considering random initailization of weights... But now we train the model","dab43567":"## Viewing loss over epochs \ud83d\udcc9\n### we see it drops quickly at first.. then it slows down","54ca65e3":"### There are 42,000 images in training set. We'll use 90% of the training set for training and 10% data for validation"}}