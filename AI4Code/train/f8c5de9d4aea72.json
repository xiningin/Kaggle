{"cell_type":{"c0a83991":"code","c04ba455":"code","5d02ba7c":"code","d052d368":"code","7f9c6949":"code","89ae34b8":"code","2f17122a":"code","34a066dd":"code","8215cd54":"code","1c73d203":"code","93569914":"code","c643e1b3":"code","a80a7bfc":"code","b32cefa4":"markdown","8129b6d9":"markdown","b907540f":"markdown"},"source":{"c0a83991":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c04ba455":"import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom astropy.coordinates import SkyCoord\nfrom astropy import units\nimport seaborn as sns","5d02ba7c":"bh_prop_df = pd.read_csv(\"\/kaggle\/input\/halo-sims\/final.csv\", index_col=0)\nbh_radec_df = bh_prop_df[['ra', 'dec', 'z']]","d052d368":"z = list(range(3,8))\n\ndef add_column( df, col = \"z\", vmin = 3.0, vmax = 4.0 ):\n    zid = \"{} < z < {}\".format(vmin, vmax)\n    flag = df[col].between( vmin, vmax )\n    df.loc[ flag, \"z_range\"] = zid\n\nfor zmin, zmax in zip( z[:-1], z[1:] ):\n    add_column(bh_radec_df, col=\"z\", vmin=zmin, vmax = zmax)","7f9c6949":"k = bh_radec_df[\"z_range\"].unique()\ncolormap = ['#d7191c','#fdae61', '#abd9e9','#2c7bb6']\n\nfig = plt.figure(figsize=(12, 8))\nfig.add_subplot(111, projection='mollweide')\nax = fig.get_axes()\n\nfor i, r in enumerate(k[:-1]):\n\n    flag = bh_radec_df[\"z_range\"] == r\n    r_ra = bh_radec_df[\"ra\"][flag]\n    r_dec = bh_radec_df[\"dec\"][flag]\n\n    coords = SkyCoord(ra=r_ra, dec=r_dec, unit='degree')\n    r_ra = coords.ra.wrap_at(180 * units.deg).radian\n    r_dec = coords.dec.radian\n\n    ax[0].scatter(r_ra, r_dec, alpha = 0.8, label = r, s = 70, color = colormap[i])\n    ax[0].set_xlabel('R.A.')\n    ax[0].set_ylabel('Decl.')\n    plt.grid(True)\n\nplt.legend()\nplt.show()","89ae34b8":"data_eddington = bh_prop_df[['log_edd_ratio', 'z', 'log_lbol', 'log_bh']]","2f17122a":"bins = [3,3.5,4.5,5.5,6.5,8]\nind = np.digitize(data_eddington['z'],bins)\ndata_eddington.loc[:,'z_range'] = ind","34a066dd":"val_data = data_eddington[(data_eddington['log_bh'] > 0)]","8215cd54":"import matplotlib.pyplot as plt\n\nf, ax = plt.subplots(2, len(np.unique(ind)), sharex=True, figsize=(20,8))\n\nfor i in np.unique(ind):\n    z_range_data = val_data[val_data['z_range']==i].dropna()\n    sns.kdeplot(z_range_data['log_lbol'],\n                z_range_data['log_edd_ratio'],\n                ax=ax[0][i-1], \n                cmap='Blues', \n                shade=True,\n                shade_lowest=False,\n                levels=8,\n                alpha=0.8\n               )\n\n    sns.kdeplot(z_range_data['log_lbol'], \n                z_range_data['log_bh'],\n                ax=ax[1][i-1], \n                cmap='Reds',\n                shade=True,\n                shade_lowest=False,\n                levels=8,\n                alpha=0.8\n               )\n    if i > 1:\n        ax[0][i-1].xaxis.set_visible(False)\n        ax[0][i-1].yaxis.set_visible(False)\n        ax[1][i-1].yaxis.set_visible(False)\n    ax[0][0].xaxis.set_visible(False)\n    ax[0][i-1].set_title(f'z = {i+2} ({len(z_range_data)})', fontsize=24)\n\n\n\nfor i in range(5):\n    ax[1][i].set_xticks([46,47,48])\n    ax[1][i].tick_params(axis='x', labelsize=24)\n    ax[1][i].xaxis.label.set_size(24)\n    \n    ax[1][i].set_xlabel('$\\mathrm{Log( L_{bol})}$')\nax[0][0].tick_params(axis='y', labelsize=24)\nax[1][0].tick_params(axis='y', labelsize=24)\nax[0][0].yaxis.label.set_size(24)\nax[1][0].yaxis.label.set_size(24)\n\nax[0][0].set_ylabel('$\\mathrm{Log( L_{bol} \/ L_{Edd} )}$')\nax[1][0].set_ylabel('$\\mathrm{Log( M_{BH} \/ M_{\\odot} )}$')\n\n\nf.subplots_adjust(wspace=0)\nf.subplots_adjust(hspace=0)\n\nplt.tight_layout()","1c73d203":"def columns_criteria(c):\n    crit1 = c.startswith('log_bh')\n    crit2 = c.startswith('fwhm_civ') and not c.endswith('_err')\n    crit3 = c.startswith('fwhm_mgii') and not c.endswith('_err')\n    return crit1 or crit2 or crit3","93569914":"bh_mass_cols = [c for c in bh_prop_df.columns if columns_criteria(c)]\nprop_cols = ['z', 'log_lbol', 'log_edd_ratio', ]\ncol = prop_cols + bh_mass_cols + ['refcode']","c643e1b3":"df = bh_prop_df.copy()\n# assign a redshift range to each Quasar\n# so that we can color the plot later according to the redshift\ndef obtain_redshift_range( df, col = \"z\", vmin = 3.0, vmax = 4.0 ):\n    zid = \"{} < z < {}\".format(vmin, vmax)\n    flag = df[col].between( vmin, vmax )\n    df.loc[ flag, \"z_range\"] = zid\n\nz = list(range(3,8))\nfor zmin, zmax in zip( z[:-1], z[1:] ):\n    obtain_redshift_range(df, col=\"z\", vmin=zmin, vmax = zmax)\n    \n############################################################################\n# Things that need to be fixed before shipping it\n############################################################################\n\n# this should also be fixed directly on GCP\n# by unifying the number for missing values!\nfor c in col:\n    if c in [\"log_edd_ratio\",'refcode']: continue\n    flag = df[c] <= 0.0\n    df.loc[flag, c] = np.nan\n\n# this will be removed in the later revision\nc = \"log_edd_ratio\"\nflag = df[c] <= -9.9\ndf.loc[flag, c] = np.nan","a80a7bfc":"# A demonstration of Figure 5 on our paper\n\n# we use the colorblind\n# https:\/\/gist.github.com\/mwaskom\/b35f6ebc2d4b340b4f64a4e28e778486\n\ndef hide_current_axis(*args, **kwds):\n    plt.gca().set_visible(False)\n\npalette = [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"]\n\n# color_palette = tol_cset('bright')\n\ndf[''] = df['z_range']\n    \ng = sns.pairplot(df, vars= ['log_lbol', 'log_edd_ratio', \n                            'log_bh_mgii', 'log_bh_civ', \n                            'fwhm_mgii', 'fwhm_civ'], \n                 hue = \"\", \n                 hue_order=[ \"3 < z < 4\", \"4 < z < 5\", \"5 < z < 6\", \"6 < z < 7\" ], \n                 dropna= True, \n                 plot_kws =  {\"alpha\": 0.8, \"s\": 50.0})#sns.color_palette('bright'))\ng.map_upper(hide_current_axis)\n\nplt.setp(list(g._legend.get_texts()), fontsize=20)\n\n# g.fig.legend(fontsize=20)\n\n# handles = g._legend_data.values()\n# labels = g._legend_data.keys()\n# g.fig.legend(handles=handles, labels=labels, loc='upper center', ncol=1)\n# g.fig.legend(handles=handles, labels=labels, loc='lower center', ncol=3)\n# g.fig.legend(handles=handles, labels=labels, loc='upper left', ncol=3)\n# g.fig.subplots_adjust(top=0.92, bottom=0.08)\n\n\nplt.tight_layout()\n\nxlabels = [\"log_lbol\", \"log_edd_ratio\", \"log_bh_mgii\", \"log_bh_civ\", \"fwhm_mgii ($10^3 \\mathrm{km\/s}$)\", \"fwhm_civ ($10^3 \\mathrm{km\/s}$)\"]\nylabels = [\"log_lbol\", \"log_edd_ratio\", \"log_bh_mgii\", \"log_bh_civ\", \"fwhm_mgii ($10^3 \\mathrm{km\/s}$)\", \"fwhm_civ ($10^3 \\mathrm{km\/s}$)\"]\n\nxlabels = ['$ \\mathrm{Log}( \\mathrm{L_{bol}}) $', \n           '$ \\mathrm{Log}( \\mathrm{L_{bol}} \/ \\mathrm{L}_{edd} ) $',\n           '$ \\mathrm{Log}( \\mathrm{M_{MgII} \/ M_{\\odot}} ) $',\n           '$ \\mathrm{Log}( \\mathrm{M_{CIV} \/ M_{\\odot}} ) $',\n           '$ \\mathrm{FWHM_{MgII} ~(10^3 km\/s) } $',\n           '$ \\mathrm{FWHM_{CIV}  ~(10^3  km\/s)} $']\nylabels = xlabels\n\nfor i in range(len(xlabels)):\n    for j in range(len(ylabels)):\n        g.axes[j,i].patch.set_edgecolor('black')  \n        g.axes[j,i].patch.set_linewidth('1')  \n        \n        t = g.axes[j,i].get_xticks()\n        if t[-1] > 1e3:\n            t = np.array(t)\/1e3\n        g.axes[j,i].xaxis.set_ticklabels(t, fontsize=16)\n        \n        t = g.axes[j,i].get_yticks()\n        if t[-1] > 1e3:\n            t = np.array(t)\/1e3\n        g.axes[j,i].yaxis.set_ticklabels(t, fontsize=16)\n        \n        if i == j and i > 0 and j <5: continue\n            \n        if not(i == j and i == 0):\n            g.axes[j,i].xaxis.set_label_text(xlabels[i], fontsize = 16)\n        if not(i == j and j == 5):\n            g.axes[j,i].yaxis.set_label_text(ylabels[j], fontsize = 16)\n            ","b32cefa4":"# Eddington Ratios Distributions\n","8129b6d9":"# Sky-Distribution Plot\n- RA and DEC with Mollweide Projection","b907540f":"# Joint Distribution Between Observed Properties"}}