{"cell_type":{"e58b69f0":"code","81b86543":"code","e5425489":"code","ff9ea478":"code","9963bb8f":"code","fc1c1449":"code","7cc45bb3":"code","5f3539fe":"code","6a6b5f23":"code","76582450":"code","d57f08bd":"code","5d175ffc":"code","28685af4":"code","75a07ef2":"code","8575e732":"code","debc2d1f":"code","0b67cbf9":"code","384901e9":"code","bf012797":"markdown","23d3aa61":"markdown","b1338fd1":"markdown","3c34e3a7":"markdown"},"source":{"e58b69f0":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline","81b86543":"human_data = pd.read_table('..\/input\/human-genes-dataset\/datasets\/human_data.txt')\nhuman_data.head()","e5425489":"# just as a placeholder datasets\nchimp_data = pd.read_table('..\/input\/human-genes-dataset\/datasets\/chimp_data.txt')\ndog_data = pd.read_table('..\/input\/human-genes-dataset\/datasets\/dog_data.txt')\nchimp_data.head()\ndog_data.head()","ff9ea478":"from IPython.display import Image\nImage(\"..\/input\/human-genes-dataset\/datasets\/genefamily.png\")","9963bb8f":"# def getKmers(seq, k=6):\n#     # kmers = []\n#     # for i in range(len(seq) - k + 1):\n#     #     kmers.append(seq[i:i+k])\n#     # return kmers\n#     return [seq[i:i+k].lower() for i in range(len(seq) - k + 1)]\n\n# function to convert sequence strings into k-mer words, default size = 6 (hexamer words)\ndef getKmers(sequence, size=6):\n    return [sequence[x:x+size].lower() for x in range(len(sequence) - size + 1)]","fc1c1449":"human_data['words'] = human_data.apply(lambda x: getKmers(x['sequence']), axis=1)\nhuman_data = human_data.drop('sequence', axis=1)","7cc45bb3":"# human_data['words'] = human_data.apply(lambda x: getKmers(x), axis=1)\nhuman_data.head()","5f3539fe":"human_texts = list(human_data['words'])\nfor item in range(len(human_texts)):\n    human_texts[item] = ' '.join(human_texts[item])\n\ny_data=human_data.iloc[:, 0].values","6a6b5f23":"# print(human_texts[0])\n# print(human_texts[1])\nprint(human_texts[2])\n","76582450":"from sklearn.feature_extraction.text import CountVectorizer\n\ncv = CountVectorizer(ngram_range=(4,4))\nx = cv.fit_transform(human_texts)","d57f08bd":"print(x.shape)","5d175ffc":"human_data['class'].value_counts().sort_index().plot.bar()","28685af4":"from  sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(x, y_data, test_size=0.2, random_state=42)","75a07ef2":"print(X_train.shape)","8575e732":"print(X_test.shape)","debc2d1f":"from sklearn.naive_bayes import MultinomialNB\n\nclassifier = MultinomialNB(alpha=0.01)\nclassifier.fit(X_train, y_train)","0b67cbf9":"y_pred = classifier.predict(X_test)","384901e9":"from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score\n\nprint(\"confusion matrix\\n\")\nprint(pd.crosstab(pd.Series(y_test, name = 'Actual'), pd.Series(y_pred, name = 'Predicted')))\n\ndef get_metrics(y_test, y_pred):\n    accuracy = accuracy_score(y_test, y_pred)\n    precision = precision_score(y_test, y_pred, average='weighted')\n    recall = recall_score(y_test, y_pred, average = 'weighted')\n    f1 =  f1_score(y_test, y_pred, average = 'weighted')\n    return accuracy, precision, recall, f1\n\naccuracy, precision, recall, f1 = get_metrics(y_test, y_pred)\n\nprint(\"accuracy = %.3f \\nprecision = %.3f \\nrecall = %.3f \\n f1 = %.3f\" % (accuracy, precision, recall, f1))","bf012797":"<a href=\"https:\/\/colab.research.google.com\/github\/VivanVatsa\/DNA-sequencing-NLP-machinelearning-project\/blob\/main\/DNA_sequencing_NLP.ipynb\" target=\"_parent\"><img src=\"https:\/\/colab.research.google.com\/assets\/colab-badge.svg\" alt=\"Open In Colab\"\/><\/a>","23d3aa61":"**BAG of WORDS using CountVectorizer using NLP**","b1338fd1":"**k-mer counting**\n- counting the occurances of each possible k-mer sequence\n- need to convert the available data in vectors of uniform length\n- suitable for classification or regression problem","3c34e3a7":"# DNA sequencing using NLP \n\n*- classification*\n*- CountVectorizer*\n*- Naive Bayes*"}}