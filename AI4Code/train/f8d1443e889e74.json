{"cell_type":{"7bbebf4b":"code","55203e5b":"code","2bddbdda":"code","6cc250bf":"code","fad3e61e":"code","9fe70f0f":"code","9a420590":"code","7877a30c":"code","fc202646":"code","93e60a18":"code","67c9d1ce":"code","dae38f1d":"code","0bff2edb":"code","457127ee":"code","fc92c13a":"code","e2c18534":"code","8d8d2d2d":"code","f62cd478":"code","801bd467":"code","1122553a":"code","083fa752":"code","1b335bdd":"code","283489f2":"code","9c2c6736":"code","4833b6f3":"code","f01e2adf":"code","6da5df97":"code","ea51446b":"code","16d432cd":"code","0e5860a2":"code","523399da":"code","a9ec4ab8":"code","2e3356b6":"code","7ab4351c":"code","39f4d7c2":"code","c143dbff":"code","0b109de4":"code","c411eb00":"code","8d51ef64":"code","d278dac9":"code","fa65fb40":"code","ae35b975":"code","d480cc9e":"code","b784bfe8":"code","254851d2":"code","30300d30":"code","2f240e1e":"code","a7c473be":"code","3fbfb654":"code","979c17c7":"code","1edc7432":"code","94c834e4":"code","baf15d2e":"code","387285b1":"code","ee1cd567":"code","e6d50b75":"code","c0969e62":"code","5b688b0d":"code","7956df6f":"code","9460bed2":"code","e470158b":"markdown","0e356126":"markdown","789d99f6":"markdown","163d7608":"markdown","558cccf1":"markdown","5d9083e3":"markdown","e1b5015c":"markdown","c5cae0da":"markdown","6ca5bab4":"markdown","fb508494":"markdown","55ea921f":"markdown","8aebe3b1":"markdown","3dc1697d":"markdown","011821d8":"markdown","cd7dc866":"markdown","e260ede2":"markdown","032ab84d":"markdown","e0c72296":"markdown","577b50c5":"markdown","f5bdf0c2":"markdown","1bd520ec":"markdown","eda85dde":"markdown","2d1d59b6":"markdown","0ed7e8dd":"markdown","c939deb7":"markdown","fb7db0c2":"markdown","b0c00a09":"markdown"},"source":{"7bbebf4b":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns ","55203e5b":"train = pd.read_csv('..\/input\/factelyticts-siom-2021\/Train data.csv')\ntest = pd.read_csv('..\/input\/factelyticts-siom-2021\/Test data.csv')\ntrain.drop('id', axis=1, inplace=True)\ntest.drop('id', axis=1, inplace=True)","2bddbdda":"print('Total records in train is', train.shape[0], ', and in test is '+ str(test.shape[0])+ '.')","6cc250bf":"train.isnull().sum()","fad3e61e":"from sklearn.ensemble import RandomForestClassifier\nX = train.copy()\n\n\ny = train.term_deposit_subscribed\nX = X.drop('term_deposit_subscribed', axis=1)\n\n\nX = X.fillna(-999)\n\n\nfor c in train.columns[train.dtypes == 'object']:\n    X[c] = X[c].factorize()[0]\n    \nrf = RandomForestClassifier()\nrf.fit(X,y)\n\nplt.plot(rf.feature_importances_)\nplt.ylabel('Importance of Feature')\nplt.xticks(np.arange(X.shape[1]), X.columns.tolist(), rotation=90);","9fe70f0f":"corr=abs(train.corr())\ncore = corr.term_deposit_subscribed.sort_values(ascending=False)\ncore","9a420590":"train.groupby('prev_campaign_outcome')['term_deposit_subscribed'].value_counts()","7877a30c":"train.groupby('marital')['term_deposit_subscribed'].value_counts()","fc202646":"train.groupby('job_type')['term_deposit_subscribed'].value_counts()","93e60a18":"(train.balance<0).value_counts()","67c9d1ce":"print(\"Subsctiption breakdown of poeple with negative balance\\n\", \n      train.loc[train.balance<0, 'term_deposit_subscribed'].value_counts(), '\\n')\n\nprint(\"Subsctiption breakdown of poeple with positive balance\\n\", \n      train.loc[train.balance>0, 'term_deposit_subscribed'].value_counts())","dae38f1d":"print(\"Subsctiption breakdown of poeple with balancemore than 1000\\n\", \n      train.loc[train.balance>1000, 'term_deposit_subscribed'].value_counts())\n\nprint(\"Subsctiption breakdown of poeple with balancemore than 2000\\n\", \n      train.loc[train.balance>2000, 'term_deposit_subscribed'].value_counts())","0bff2edb":"months = train.month.unique().tolist()\nfor m in months:\n    print(m,'\\t')\n    print(train.loc[train.month==m, 'term_deposit_subscribed'].value_counts(), '\\t')","457127ee":"train.groupby('communication_type').term_deposit_subscribed.value_counts()","fc92c13a":"train.groupby('month').communication_type.value_counts()","e2c18534":"plt.figure(figsize=(10,5))\nsns.kdeplot(data=train, x=train.loc[train.last_contact_duration<1200, 'last_contact_duration'], hue='term_deposit_subscribed', multiple = 'fill')\nplt.xlabel('Time in seconds')","8d8d2d2d":"plt.figure(figsize=(15,4))\nplt.tight_layout()\n\nplt.subplot(1,3,1)\nplt.hist((train.balance, test.balance), range=(-10000,30000), bins = 10, log = 1)\nplt.title('Balance Distribution')\nplt.xlabel('Balance')\n\nplt.subplot(1,3,2)\nplt.hist((train.customer_age, test.customer_age), bins = 10)\nplt.title('Age Distribution')\nplt.xlabel('Age')\n\nplt.subplot(1,3,3)\nplt.hist((train.month, test.month), bins = 10)\nplt.title('Month Distribution')\nplt.xlabel('Month')\n\nplt.show()","f62cd478":"plt.figure(figsize=(13,4))\nplt.tight_layout()\n\nplt.subplot(1,3,1)\nplt.hist((train.days_since_prev_campaign_contact, test.days_since_prev_campaign_contact), bins = 10)\nplt.title('Days since previous contact distribution')\nplt.xlabel('Days')\n\nplt.subplot(1,3,2)\nplt.hist((train.num_contacts_prev_campaign, test.num_contacts_prev_campaign), bins = 15, log=1)\nplt.title('Number of contacts distribution')\nplt.xlabel('Count')\n\nplt.subplot(1,3,3)\nplt.hist((train.last_contact_duration, test.last_contact_duration), bins = 10, log=1)\nplt.title('Call Duration distribution')\nplt.xlabel('Time in Seconds')\n\nplt.tight_layout()\n\nplt.show()","801bd467":"#Checking the distribution between train and test data. This will help us tune the model to get highest possible F1 score\ncolumns = test.columns.to_list()\ncolumns.remove('day_of_month')\ncolumns.remove('month')\ncolumns.remove('balance')\ncolumns.remove('customer_age')\ncolumns.remove('days_since_prev_campaign_contact')\ncolumns.remove('num_contacts_prev_campaign')\ncolumns.remove('last_contact_duration')\nfor c in columns:\n    print(train[c].value_counts().sort_index(),\"\\n\", test[c].value_counts().sort_index(), \"\\n\") ","1122553a":"corr = abs(train.corr())\ncore = corr.balance.sort_values(ascending = False)\ncore","083fa752":"print(\"Rows where both customer age and account balance are not avaiable in : \",len(train.loc[(train.balance.isnull()==True) & (train.customer_age.isnull()==True)]), \"\\nWe will drop these rows.\")\n#Dropping specified rows \ntrain = train.loc[(train.balance.isnull()!=True) | (train.customer_age.isnull()!=True)]\ntrain.reset_index(drop=True, inplace =True)\nprint('')","1b335bdd":"balances = [-5000, 0, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 60000, 70000, 80000, 90000, 100000, 110000]\nfor b in balances : \n    m1 = train.customer_age.isnull() == True\n    m2 = (train.balance<(b+7500))\n    m3 = (train.balance>(b-7500)) \n    value = round(train.loc[m2 & m3, 'customer_age'].mean(),0) \n    i = train.loc[m1 & m2 & m3,'customer_age'].index\n    train.loc[i,'customer_age'] = value\ndel m1, m2, m3, i \n\n\nfor b in balances : \n    m1 = test.customer_age.isnull() == True\n    m2 = (test.balance<(b+7500))\n    m3 = (test.balance>(b-7500))\n    value = round(test.loc[m2 & m3, 'customer_age'].mean(),0) \n    i = test.loc[m1 & m2 & m3,'customer_age'].index\n    test.loc[i,'customer_age'] = value\ndel m1, m2, m3, i, balances, b","283489f2":"ages = train.customer_age.unique().tolist()\nfor age in ages:\n    value = train.loc[(train.customer_age == age), ['balance']].mean().get('balance')\n    m1 =  train.customer_age == age\n    m2 = train.balance.isnull()==True\n    i = train.loc[m2 & m1, 'balance'].index\n    train.loc[i, 'balance'] = value\ndel ages, m1, m2, i\n\n\n\nages = test.customer_age.unique().tolist()\nfor age in ages:\n    value = test.loc[(test.customer_age == age), ['balance']].mean().get('balance')\n    m1 =  test.customer_age == age\n    m2 = test.balance.isnull()==True\n    i = test.loc[m2 & m1, 'balance'].index\n    test.loc[i, 'balance'] = value\ndel ages, m1, m2, i","9c2c6736":"i = test.loc[(test.balance.isnull()==True) & test.customer_age.isnull()==True].index\nmean_balance = test.balance.mean()\nmean_age = round(test.customer_age.mean(), 0)\ntest.loc[i, ['balance', 'customer_age']] = mean_balance, mean_age","4833b6f3":"train['personal_loan'] = train['personal_loan'].replace({'no':0, 'yes':1})\ntest['personal_loan'] = test['personal_loan'].replace({'no':0, 'yes':1})\n\nfrom sklearn.impute import KNNImputer\nknn = KNNImputer(n_neighbors=10)\n\ncol_pl = ['balance', 'personal_loan']\nknn.fit(train[col_pl])\n\nr = pd.DataFrame(np.round(knn.transform(train[col_pl]), 0), columns=col_pl)\ntrain['personal_loan'] = r['personal_loan'].astype('int64')\n\nr = pd.DataFrame(np.round(knn.transform(test[col_pl]), 0), columns=col_pl)\ntest['personal_loan'] = r['personal_loan'].astype('int64')","f01e2adf":"train['housing_loan'] = train['housing_loan'].replace({'no':0, 'yes':1})\ntest['housing_loan'] = test['housing_loan'].replace({'no':0, 'yes':1})\n\ntrain['loan'] = (train.personal_loan | train.housing_loan)\ntrain['loan'] = train['loan'].astype('int64')\n\ntest['loan'] = (test.personal_loan | test.housing_loan)\ntest['loan'] = test['loan'].astype('int64')\n\n\ntrain.drop('personal_loan', axis=1, inplace=True)\ntest.drop('personal_loan', axis=1, inplace=True)\n\ntrain.drop('housing_loan', axis=1, inplace=True)\ntest.drop('housing_loan', axis=1, inplace=True)","6da5df97":"from sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import LabelEncoder","ea51446b":"train.last_contact_duration.fillna(value = train.last_contact_duration.mean(), inplace= True)\ntest.last_contact_duration.fillna(value = test.last_contact_duration.mean(), inplace=True)","16d432cd":"#Label encoding of education as the data is ordinal \ntrain['education'] = train['education'].replace({'unknown':0, 'primary':1, 'secondary':2, 'tertiary':3})\ntest['education'] = test['education'].replace({'unknown':0, 'primary':1, 'secondary':2, 'tertiary':3})","0e5860a2":"scaler = StandardScaler()\nscaler.fit(train.education.values.reshape(-1,1))\n\nnew_edu = scaler.transform(train.education.values.reshape(-1,1))\ntrain['education'] = new_edu\n\nnew_edu = scaler.transform(test.education.values.reshape(-1,1))\ntest['education'] = new_edu","523399da":"train['last_contact_duration'] = np.clip(train.last_contact_duration,a_min=None, a_max=3000) \ntest['last_contact_duration'] = np.clip(test.last_contact_duration,a_min=None, a_max=3000) \n\nscaler = StandardScaler()\nscaler.fit(train.last_contact_duration.values.reshape(-1,1))\n\nnew_con = scaler.transform(train.last_contact_duration.values.reshape(-1,1))\ntrain['last_contact_duration'] = new_con\n\nnew_con = scaler.transform(test.last_contact_duration.values.reshape(-1,1))\ntest['last_contact_duration'] = new_con","a9ec4ab8":"train['num_contacts_prev_campaign'] = np.clip(train.num_contacts_prev_campaign,a_min=None, a_max=26) \ntest['num_contacts_prev_campaign'] = np.clip(test.num_contacts_prev_campaign,a_min=None, a_max=26) \n\nscaler = StandardScaler()\nscaler.fit(train.num_contacts_prev_campaign.values.reshape(-1,1))\n\nnew_con = scaler.transform(train.num_contacts_prev_campaign.values.reshape(-1,1))\ntrain['num_contacts_prev_campaign'] = new_con\n\nnew_con = scaler.transform(test.num_contacts_prev_campaign.values.reshape(-1,1))\ntest['num_contacts_prev_campaign'] = new_con","2e3356b6":"train['balance'] = np.clip(train.balance,a_min=None, a_max=40000) \ntest['balance'] = np.clip(train.balance,a_min=None, a_max=40000) \n\nscaler = StandardScaler()\nscaler.fit(train.balance.values.reshape(-1,1))\n\nnew_balance = scaler.transform(train.balance.values.reshape(-1,1))\ntrain['balance'] = new_balance\n\nnew_balance = scaler.transform(test.balance.values.reshape(-1,1))\ntest['balance'] = new_balance","7ab4351c":"scaler = StandardScaler()\nscaler.fit(train.customer_age.values.reshape(-1,1))\n\nnew_age = scaler.transform(train.customer_age.values.reshape(-1,1))\ntrain['customer_age'] = new_age\n\nnew_age = scaler.transform(test.customer_age.values.reshape(-1,1))\ntest['customer_age'] = new_age","39f4d7c2":"le = LabelEncoder()\nle.fit(train.month)\nnew_m = le.transform(train.month)\ntrain['month'] = new_m\n\nnew_m = le.transform(test.month)\ntest['month'] = new_m\n\nscaler = StandardScaler()\nscaler.fit(train.month.values.reshape(-1,1))\n\nnew_month = scaler.transform(train.month.values.reshape(-1,1))\ntrain['month'] = new_month\n\nnew_month = scaler.transform(test.month.values.reshape(-1,1))\ntest['month'] = new_month","c143dbff":"le = LabelEncoder()\nle.fit(train.job_type)\nnew_m = le.transform(train.job_type)\ntrain['job_type'] = new_m\n\nnew_m = le.transform(test.job_type)\ntest['job_type'] = new_m\n\nscaler = StandardScaler()\nscaler.fit(train.job_type.values.reshape(-1,1))\n\nnew_jt = scaler.transform(train.job_type.values.reshape(-1,1))\ntrain['job_type'] = new_jt\n\nnew_jt = scaler.transform(test.job_type.values.reshape(-1,1))\ntest['job_type'] = new_jt","0b109de4":"scaler = StandardScaler()\nscaler.fit(train.day_of_month.values.reshape(-1,1))\n\nnew_day = scaler.transform(train.day_of_month.values.reshape(-1,1))\ntrain['day_of_month'] = new_day\n\nnew_day = scaler.transform(test.day_of_month.values.reshape(-1,1))\ntest['day_of_month'] = new_day","c411eb00":"train['marital'] = train['marital'].replace({'single':3, 'married':1, 'divorced':2})\ntest['marital'] = test['marital'].replace({'single':3, 'married':1, 'divorced':2})","8d51ef64":"knn = KNNImputer(n_neighbors=10)\n\ncol_marital = ['customer_age', 'education', 'marital']\nknn.fit(train[col_marital])\n\nr = pd.DataFrame(np.round(knn.transform(train[col_marital]), 0), columns=col_marital)\ntrain['marital'] = r['marital']\n\nr = pd.DataFrame(np.round(knn.transform(test[col_marital]), 0), columns=col_marital)\ntest['marital'] = r['marital']","d278dac9":"train = train.join(pd.get_dummies(train.marital, prefix = 'marital'))\ntrain.drop('marital', axis=1, inplace = True)\n\ntest = test.join(pd.get_dummies(test.marital, prefix='marital'))\ntest.drop('marital', axis=1, inplace = True)","fa65fb40":"train = train.join(np.round(pd.get_dummies(train.default, prefix='default'), 0))\ntrain.drop('default', axis=1, inplace = True)\n\ntest = test.join(pd.get_dummies(test.default, prefix = 'default'))\ntest.drop('default', axis=1, inplace = True)","ae35b975":"train = train.join(pd.get_dummies(train.communication_type, prefix='communication_type'))\ntrain.drop('communication_type', axis=1, inplace = True)\n\ntest = test.join(pd.get_dummies(test.communication_type, prefix = 'communication_type'))\ntest.drop('communication_type', axis=1, inplace = True)","d480cc9e":"train = train.join(pd.get_dummies(train.prev_campaign_outcome, prefix='prev_campaign_outcome'))\ntrain.drop('prev_campaign_outcome', axis=1, inplace = True)\n\ntest = test.join(pd.get_dummies(test.prev_campaign_outcome, prefix = 'prev_campaign_outcome'))\ntest.drop('prev_campaign_outcome', axis=1, inplace = True)","b784bfe8":"knn = KNNImputer(n_neighbors=10)\n\ncol_days = ['month', 'balance', 'customer_age', 'education', 'days_since_prev_campaign_contact']\nknn.fit(train[col_days])\n\nr = pd.DataFrame(knn.transform(train[col_days]), columns=col_days)\ntrain['days_since_prev_campaign_contact'] = r['days_since_prev_campaign_contact']\n\nr =  pd.DataFrame(knn.transform(test[col_days]), columns=col_days)\ntest['days_since_prev_campaign_contact'] = r['days_since_prev_campaign_contact']","254851d2":"knn = KNNImputer(n_neighbors=10)\ncol_nums = ['day_of_month', 'num_contacts_in_campaign']\nknn.fit(train[col_nums])\nr =  pd.DataFrame(knn.transform(train[col_nums]), columns=col_nums)\ntrain['num_contacts_in_campaign'] = r['num_contacts_in_campaign']\n\n\nr =  pd.DataFrame(knn.transform(test[col_nums]), columns=col_nums)\ntest['num_contacts_in_campaign'] = r['num_contacts_in_campaign']","30300d30":"train['num_contacts_in_campaign'] = np.clip(train.num_contacts_in_campaign,a_min=None, a_max=30) \ntest['num_contacts_in_campaign'] = np.clip(test.num_contacts_in_campaign,a_min=None, a_max=30) \n\nscaler = StandardScaler()\nscaler.fit(train.num_contacts_in_campaign.values.reshape(-1,1))\n\nnew_con = scaler.transform(train.num_contacts_in_campaign.values.reshape(-1,1))\ntrain['num_contacts_in_campaign'] = new_con\n\nnew_con = scaler.transform(test.num_contacts_in_campaign.values.reshape(-1,1))\ntest['num_contacts_in_campaign'] = new_con","2f240e1e":"train['days_since_prev_campaign_contact'] = np.clip(train.days_since_prev_campaign_contact,a_min=None, a_max=600) \ntest['days_since_prev_campaign_contact'] = np.clip(test.days_since_prev_campaign_contact,a_min=None, a_max=600) \n\nscaler = StandardScaler()\nscaler.fit(train.days_since_prev_campaign_contact.values.reshape(-1,1))\n\nnew_con = scaler.transform(train.days_since_prev_campaign_contact.values.reshape(-1,1))\ntrain['days_since_prev_campaign_contact'] = new_con\n\nnew_con = scaler.transform(test.days_since_prev_campaign_contact.values.reshape(-1,1))\ntest['days_since_prev_campaign_contact'] = new_con","a7c473be":"print(train.isnull().sum(axis=0).sum(), test.isnull().sum(axis=0).sum())","3fbfb654":"y = train['term_deposit_subscribed'].values\nX = train.drop('term_deposit_subscribed', axis=1)\nx = X.values\nx.shape","979c17c7":"print(train.term_deposit_subscribed.value_counts().to_list())\nprint(\"Ration of No to Yes is \" ,train.term_deposit_subscribed.value_counts()[1]\/train.term_deposit_subscribed.value_counts()[0])","1edc7432":"from sklearn.model_selection import StratifiedShuffleSplit\n\nsss = StratifiedShuffleSplit(n_splits=5, test_size=0.2, random_state=14)\n\nfor train_index, test_index in sss.split(x, y):\n    xtrain, xval = x[train_index], x[test_index]\n    ytrain, yval = y[train_index], y[test_index]","94c834e4":"import tensorflow as tf ","baf15d2e":"model = tf.keras.models.Sequential([\n    tf.keras.layers.Dense(256, activation='relu', input_shape=(23,)),\n    tf.keras.layers.Dropout(0.4),\n    tf.keras.layers.Dense(64, activation='relu'),\n    tf.keras.layers.Dropout(0.4),\n    tf.keras.layers.Dense(32, activation='relu'),\n    tf.keras.layers.Dropout(0.4),\n    tf.keras.layers.Dense(16, activation='relu'),\n    tf.keras.layers.Dropout(0.4),\n    tf.keras.layers.Dense(8, activation='relu'),\n    #tf.keras.layers.Dropout(0.4),\n    tf.keras.layers.Dense(4, activation='relu'),\n    #tf.keras.layers.Dropout(0.4), \n    tf.keras.layers.Dense(1, activation='sigmoid')\n])","387285b1":"model.summary()","ee1cd567":"from keras import backend as K\n\ndef f1(y_true, y_pred):\n    \n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    recall = true_positives \/ (possible_positives + K.epsilon())\n    precision = true_positives \/ (predicted_positives + K.epsilon())\n    f1 = 2*(precision*recall)\/(precision+recall+K.epsilon())\n    return f1\n\n\nmodel.compile(loss='binary_crossentropy', optimizer= \"adam\", metrics=[f1,'AUC'])","e6d50b75":"annealer = tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=3, verbose=1, min_lr=1e-3)","c0969e62":"model.fit(xtrain, ytrain, epochs=200, validation_data=(xval, yval), shuffle=True, callbacks=[annealer])","5b688b0d":"xtest = pd.read_csv('..\/input\/factelyticts-siom-2021\/Test data.csv')\nsample = xtest['id']\nsample = pd.DataFrame(sample)","7956df6f":"p_y = model.predict(test)\np_y = p_y.flatten()\nprint(p_y)\np_y=np.round(p_y,0)\nprint(p_y)\nsample['term_deposit_subscribed'] = p_y","9460bed2":"sample.to_csv('Predictions.csv', index=False)","e470158b":"## Customers with job types as management, student and unemployed have a higher chance of taking the subscription. ","0e356126":"## Dataset provided in \u201cFactElytics\u201d organized by Drishti, the Annual fest of SIOM Nashik. \n### From a total of 330 participants, 87 teams were shortlisted after a quiz round held on Dare2Compete. Making it to the top 8 Teams, being the only individual participant, based on F1 score on a model for a banking institution\u2019s campaigning dataset.\n#### If this notebook helps you, an upvote would be huge!","789d99f6":"## Converting dataset to feed into Neural Network","163d7608":"## If the last contact duration was high, the chances of the customer subscribing is high, as longer duration implies interest of the customer in services offered by the bank. ","558cccf1":"## Only about 5 percent customers with negative bank balance tend to not shy away from subscribing for term deposit, , whereas for customers with positive balances have a subscription percentage of 11%. ","5d9083e3":"## Because of the skewed dataset (ratio of term deposit not subscribed to term deposit  subscribed is around 0.1), we will use Stratified shuffle split so the distribution of target values are the same in train and validation set. This is a  very significant when working with skewed data.","e1b5015c":"## Month has a significant impact on the **reach** as well as the success of the campaign.\n","c5cae0da":"### This dataset is very similar to the Portuguese Bank Marketing dataset. You can check it out here - https:\/\/www.kaggle.com\/yufengsui\/portuguese-bank-marketing-data-set","6ca5bab4":"## In-depth visualisations, analysis, insights and strong predictive models. ","fb508494":"# Comparing the distribution of test and training set.\n### If the distribution is different, improving our model in training set will not result in any imporvement in test set. ","55ea921f":"### For a Neural Network architecture, One-Hot encoding is more effective in recognizing patterns than Label\/Frequency Encoding. \n### Features are scaled about mean=0 and unit variance. Gradients in Neural Networks tend to explode or vanish on unscaled features.\n### Normalising help Neural Networks converge faster to the \"Saddle point\"","8aebe3b1":"## A very peculiar insight here is that \"unknown\" is very prominent on the month of May and June. For the remaning months, it has negligible contribution in terms of campaign reach.\n","3dc1697d":"## Single customers are more inclined towards taking up term deposit subscription.","011821d8":"## Building Neural Network model.","cd7dc866":"## Cellular and telephone communication types are the most efficient with 13% success rate. \"Unknown\" has an efficiency of only 3.5%","e260ede2":"# Feature generation\n## Combining \"personal_loan\" and \"housing_loan\" to generate a new feature \"loan\"","032ab84d":"## Customers who subscribed in the previous campaign are most likely to subscribe again. ","e0c72296":"## The distribution of train and test appears to be the same. Thus, working on training set will eventually improve the test set. ","577b50c5":"## Few features are very dominant in the model, namely, Last contact duration, month, previous campaign outcome, day of month, balance and customer age. ","f5bdf0c2":"# -----------------------------------------------------------------------------------------------------------","1bd520ec":"# -----------------------------------------------------------------------------------------------------------","eda85dde":"## Balance and customer age have highest correlation. We will use either of these to fill NaN values of the other. This is more effective and gives higher accuracy than filling the NaN values of any feature with its Mean or Median. \n\n### NOTE : We are not considering the feature \"days_since_prev_campaign_contact\" as 80% NaN values in the dataset, hence the correlation value is not an accurate representation for this particular feature. ","2d1d59b6":"## Further, subscription percentage rate gradually increases with increase in balance.\n","0ed7e8dd":"## Data scaling and imputing ","c939deb7":"__________________________________________________________________________________________________________________________","fb7db0c2":"## Around 3900 bank accounts with balances less than 0, implying customers tried to make payments larger than the amount of money in thier account.","b0c00a09":"# Data preprocessing \n## Working with Nan values"}}