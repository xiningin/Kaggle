{"cell_type":{"909628bc":"code","727694ec":"code","cfc7410f":"code","6592ba93":"code","642dc871":"code","cb5d6931":"code","01dac860":"code","bc299246":"code","b3c5ef8d":"markdown","b6cdb864":"markdown","04bb8351":"markdown","ae7ec915":"markdown"},"source":{"909628bc":"AUGMENTATION_DATADIR = '..\/input\/stanford-covid-vaccine-new-sequences-augmentation'\nAUGMENTATION_PACKAGES = ['vienna_2', 'contrafold', 'rnasoft']\nOUTDIR = 'output'","727694ec":"BATCHSIZE = 2\nKF_MODELDIR = '..\/input\/stanford-covid-vaccine-kf-models'\nKF_MODELS = [\n    '2200_v2_sw_conv_gru_h512',\n    '2201_v3_sw_bpp_conv_gru_h512',\n    '2201_v3_sw_bpp_conv_gru_h512l3',\n    '2302_conv2d_emb_gru_aug-vc',\n    '2302_conv2d_emb_lstm_aug-vc',\n    '2304_conv2d_emb_gru_aug-cr',\n    '2304_conv2d_emb_gru_aug-cr_sig0.5',\n    '2304_conv2d_emb_gru_aug-vcr',\n    '2304_conv2d_emb_gru_aug-vcr-10f',\n    '2304_conv2d_emb_lstm_aug-cr',\n    '2304_conv2d_emb_lstm_aug-cr_sig0.5',\n    '2304_conv2d_emb_lstm_aug-vcr',\n    '2304_conv2d_emb_lstm_aug-vcr-10f',\n    '2304_conv2d_emb_lstm_aug-vcr_signal0.5',\n    '2306_conv2d_emb_gru_aug-vcr-lw',\n    '2306_conv2d_emb_gru_aug-vcr-lw0.1',\n    '2306_conv2d_emb_lstm_aug-vcr-lw',\n    '2306_conv2d_emb_lstm_aug-vcr-lw0.1',\n    '2307_conv2d_emb_gru_aug-vcr-lw-nosw',\n    '2307_conv2d_emb_lstm_aug-vcr-lw-nosw',\n    '2308_conv2d_emb_gru_aug-vcr-lw-light',\n    '2308_conv2d_emb_lstm_aug-vcr-lw-light',\n]","cfc7410f":"%%capture\n!pip install -q forgi\n!pip install -q ..\/input\/stanford-covid-vaccine-kf-packages\/*","6592ba93":"import gc\nimport os\nimport yaml\nfrom pathlib import Path\n\nimport numpy as np\nimport pandas as pd\nimport torch\nfrom tqdm.auto import tqdm\n\nimport covid_vaccine.preprocessing as P\nimport nncomp.registry as R\nfrom nncomp.datasets import SequenceDataset\n\nDEVICE = 0 if torch.cuda.is_available() else 'cpu'","642dc871":"AUG_COLUMNS = [\n    'id',\n    'structure_ids',\n    'predicted_loop_type_ids',\n    'bpp',\n]\npreprocessor = P.CovidVaccineSequencePreprocessorV1(\n    out_columns=[\n        'sequence_ids',\n        'structure_ids',\n        'predicted_loop_type_ids',\n        'mask',\n    ]\n)\n\ntarget_df = pd.read_json(f\"{AUGMENTATION_DATADIR}\/original\/dataset.json\", lines=True)\ntarget_df['bpp'] = [\n    np.load(f\"{AUGMENTATION_DATADIR}\/original\/bpps\/{id}.npy\").astype('float16')\n    for id in target_df.id\n]\ntarget_df = preprocessor(target_df)\nsample_submission_df = pd.read_csv('..\/input\/stanford-covid-vaccine\/post_deadline_files\/new_sequences_submission.csv')\n\nfor pkg in AUGMENTATION_PACKAGES:\n    datapath = Path(f\"{AUGMENTATION_DATADIR}\/{pkg}\/dataset.json\")\n    if datapath.exists():\n        df = pd.read_json(f\"{AUGMENTATION_DATADIR}\/{pkg}\/dataset.json\", lines=True)\n    else:\n        df = pd.read_csv(f\"{AUGMENTATION_DATADIR}\/{pkg}\/dataset.csv\")\n        \n    df['bpp'] = [\n        np.load(f\"{AUGMENTATION_DATADIR}\/{pkg}\/bpps\/{id}.npy\").astype('float16')\n        for id in df.id\n    ]\n    df = preprocessor(df)\n    target_df = target_df.merge(\n        df[AUG_COLUMNS],\n        on='id',\n        suffixes=['', f\"_{pkg}\"]\n    )\n    del df\n    gc.collect()\n\ntarget_df.head()","cb5d6931":"dataloader = torch.utils.data.DataLoader(\n    SequenceDataset(\n        target_df.reset_index(drop=True),\n        padding_columns=dict(\n            mask=0,\n            sequence_ids=0,\n            structure_ids=0,\n            predicted_loop_type_ids=0,\n            bpp=0,\n\n            structure_ids_vienna_2=0,\n            predicted_loop_type_ids_vienna_2=0,\n            bpp_vienna_2=0,\n\n            structure_ids_contrafold=0,\n            predicted_loop_type_ids_contrafold=0,\n            bpp_contrafold=0,\n\n            structure_ids_rnasoft=0,\n            predicted_loop_type_ids_rnasoft=0,\n            bpp_rnasoft=0,\n        ),\n        non_padding_columns=[\n            'id',\n            'seq_length',\n            'seq_scored',\n        ],\n        maxlen=target_df.seq_length.max(),\n    ),\n    drop_last=False, shuffle=False,\n    batch_size=BATCHSIZE,\n    num_workers= os.cpu_count(),    \n)","01dac860":"Path(OUTDIR).mkdir(exist_ok=True, parents=True)\n\nfor name in tqdm(KF_MODELS):\n    print(name)\n    modeldir = Path(KF_MODELDIR) \/ name\n    outputs = pd.DataFrame()\n    for folddir in tqdm(list(modeldir.glob('fold=*'))):\n        with open(list(folddir.glob('*.yml'))[0]) as f:\n            config = yaml.safe_load(f)['params']['model']\n        config['params'].pop('pretrained_model', None)\n        model = R.ModelRegistry.get_instance(\n            config['class'],\n            **config['params']\n        )\n        ckpt = torch.load(list(folddir.glob('*.pth'))[0], map_location='cpu')\n        model.load_state_dict(ckpt['model_state_dict'])\n        model.eval()\n        model.to(DEVICE)\n        \n        for batch in tqdm(dataloader):\n            maxlen = int(batch['mask'].sum(dim=1).max())\n            for key, value in batch.items():\n                if torch.is_tensor(value):\n                    if len(value.shape) == 1:\n                        value = value[:maxlen]\n                    elif len(value.shape) == 2:\n                        value = value[range(len(value)), :maxlen]\n                    elif len(value.shape) == 3:\n                        value = value[range(len(value)), :maxlen, :maxlen]\n                    else:\n                        raise NotImplementedError()\n                    batch[key] = value.to(DEVICE)\n            with torch.no_grad():\n                ys = model(**batch)\n            output = pd.DataFrame({\n                key.split('y_')[-1]: {\n                    f\"{id}_{i}\": float(y_sample)\n                    for id, y_sequence in zip(batch['id'], y_batch)\n                    for i, y_sample in enumerate(y_sequence)\n                }\n                for key, y_batch in ys.items()\n            })\n            output.index.name = 'id_seqpos'\n            outputs = outputs.append(output)\n            \n        model.to('cpu')\n        torch.cuda.empty_cache()\n        del model, ckpt\n        gc.collect()\n        \n    outputs = outputs.groupby('id_seqpos').mean()\n    outputs = outputs.loc[sample_submission_df.id_seqpos]\n    outputs.to_csv(f\"{OUTDIR}\/{name}.csv.gz\")","bc299246":"!ls -l $OUTDIR\npd.read_csv(list(Path(OUTDIR).iterdir())[0])","b3c5ef8d":"## Inference","b6cdb864":"# KF side","04bb8351":"## Preprocess","ae7ec915":"## Setup"}}