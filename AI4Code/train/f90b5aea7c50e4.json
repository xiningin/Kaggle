{"cell_type":{"f85e5142":"code","999bd96e":"code","dba3b2ad":"code","0154bd00":"code","918c3609":"code","54c5c896":"code","548564d1":"code","fec775a2":"code","8a441f76":"code","7ffc4b42":"code","ad30cbe3":"code","6cad10bc":"code","05c66123":"code","178f5b78":"code","a9c834a9":"code","42cece0b":"code","c8bf119a":"code","20024ebe":"code","8bfd563f":"code","47d8d280":"code","68d459be":"code","a9abc00f":"code","cd0f2830":"code","71b37c98":"code","7275f8c4":"code","6632ce35":"code","04a73726":"code","87e9469f":"markdown","0de10943":"markdown","fdcb79e7":"markdown"},"source":{"f85e5142":"import numpy as np \nimport pandas as pd \n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))","999bd96e":"!pip install jcopdl","dba3b2ad":"import matplotlib.pyplot as plt\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report","0154bd00":"df = pd.read_csv('\/kaggle\/input\/digit-recognizer\/train.csv')\ndf.rename(columns=lambda x: x.lower().replace(' ', '_'), inplace=True)\ndf.head()","918c3609":"x = df.drop(columns='label').values\ny = df.label.values\n\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, stratify = y, random_state = 1)\nx_train.shape, x_test.shape, y_train.shape, y_test.shape","54c5c896":"N = len(x_train)\nindex = np.random.choice(N)\nimg, label = x_train[index], y_train[index]\n\nplt.imshow(img.reshape(28, 28), cmap = 'gray')\nplt.title(label)\nplt.axis('off');","548564d1":"import torch\nfrom torch import nn, optim\nfrom jcopdl.callback import Callback, set_config\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\ndevice","fec775a2":"x_train = x_train.reshape(len(x_train), 1, 28, 28)\nx_test = x_test.reshape(len(x_test), 1, 28, 28)\n\nx_train.shape, x_test.shape","8a441f76":"from torch.utils.data import DataLoader, TensorDataset","7ffc4b42":"x_train = torch.FloatTensor(x_train).to(device)\nx_test = torch.FloatTensor(x_test).to(device)\n\ny_train = torch.LongTensor(y_train).to(device)\ny_test = torch.LongTensor(y_test).to(device)","ad30cbe3":"train_set = TensorDataset(x_train, y_train)\ntrainloader = DataLoader(train_set, batch_size = 64, shuffle=True)\n\ntest_set = TensorDataset(x_test, y_test)\ntestloader = DataLoader(test_set, batch_size = 64)","6cad10bc":"label_cat = torch.unique(y_test)\nlabel_cat","05c66123":"from jcopdl.layers import linear_block","178f5b78":"class CNN(nn.Module):\n    def __init__(self):\n        super().__init__()\n\n        self.conv = nn.Sequential(\n            nn.Conv2d(1, 64, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n            \n            nn.Conv2d(64, 32, kernel_size=3, stride=1, padding=1),\n            nn.ReLU(),\n            nn.MaxPool2d(2),\n\n            nn.Flatten()\n        )\n\n        self.fc = nn.Sequential( \n            # input, output\n            linear_block(7*7*32, 512, dropout = 0.2),\n            linear_block(512, 256, dropout = 0.2),\n            # log softmax\n            linear_block(256, len(label_cat), activation='lsoftmax')\n        )\n        \n    def forward(self, x):\n        x = self.conv(x)\n        x = self.fc(x)\n        return x","a9c834a9":"model = CNN().to(device)\ncriterion = nn.NLLLoss()\noptimizer = optim.AdamW(model.parameters(), lr = 0.001)\ncallback = Callback(model, outdir = 'Model', early_stop_patience=5)","42cece0b":"from tqdm.auto import tqdm\n\ndef loop_fn(mode, dataset, dataloader, model, criterion, optimizer, device):\n    if mode == \"train\":\n        model.train()\n    elif mode == \"test\":\n        model.eval()  \n        \n    cost = correct = 0\n    for feature, target in tqdm(dataloader, desc = mode.title()): \n        feature, target = feature.to(device), target.to(device)\n        output = model(feature)\n        loss = criterion(output, target)\n                         \n        if mode == \"train\":\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n            \n        cost += loss.item() * feature.shape[0]\n        correct += (output.argmax(1) == target).sum().item()\n        \n    cost = cost \/ len(dataset)\n    acc = correct \/ len(dataset)\n                         \n    return cost, acc","c8bf119a":"while True:\n    train_cost, train_score = loop_fn('train', train_set, trainloader, model, criterion, optimizer, device)\n    with torch.no_grad():\n        test_cost, test_score = loop_fn('test', test_set, testloader, model, criterion, optimizer, device)\n\n    # logging    \n    callback.log(train_cost, test_cost, train_score, test_score)\n    # Checkpoint\n    callback.save_checkpoint()\n    # Runtime plotting\n    callback.cost_runtime_plotting()\n    callback.score_runtime_plotting()\n    \n    # early stopping\n    if callback.early_stopping(model, monitor='test_cost'):\n        callback.plot_cost()\n        callback.plot_score()\n        break","20024ebe":"feature, target = next(iter(testloader))\nfeature, target = feature.to(device), target.to(device)\nfeature.shape","8bfd563f":"with torch.no_grad():\n    model.eval()\n    output = model.forward(feature)\n    preds = output.argmax(1)\n\nprint('Predict', preds)\nprint('actual', target)","47d8d280":"fig, axes = plt.subplots(13, 5, figsize = (15, 42))\naxes[12, 4].set_visible(False)\n\nfor img, label, pred, ax in zip(feature.cpu(), target.cpu(), preds.cpu(), axes.flatten()):\n    font = {'color':'red'} if label != pred else {'color':'green'} \n    ax.imshow(img.reshape(28, 28), cmap = 'gray')\n    ax.set_title(f'Actual : {label_cat[label]} \\n Prediction :{label_cat[pred]}', fontdict = font)\n    ax.axis('off');","68d459be":"print(confusion_matrix(target.cpu(), preds.cpu()))\nprint(classification_report(target.cpu(), preds.cpu()))","a9abc00f":"test = pd.read_csv('\/kaggle\/input\/digit-recognizer\/test.csv')\ntest.rename(columns=lambda x: x.lower().replace(' ', '_'), inplace=True)\ntest.head()","cd0f2830":"test = test.values.reshape(len(test), 1, 28, 28)\ntest = torch.FloatTensor(test).to(device)\ntest.shape","71b37c98":"with torch.no_grad():\n    model.eval()\n    output = model.forward(test)\n    sub_preds = output.argmax(1)","7275f8c4":"sub_preds","6632ce35":"sub = pd.read_csv('\/kaggle\/input\/digit-recognizer\/sample_submission.csv')\nsub['Label'] = sub_preds.cpu()\nsub.head()","04a73726":"sub.to_csv('submission.csv', index=False)","87e9469f":"# CNN","0de10943":"# Submission","fdcb79e7":"# Predict 1 Batch"}}