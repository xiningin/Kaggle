{"cell_type":{"3d02d522":"code","a57e3452":"code","ecdbb091":"code","ebcf31d7":"code","a9575fb5":"code","b4cef0f9":"code","f83a32d0":"code","c1faae2f":"code","e75ba397":"code","4d13a9b8":"code","68ec3151":"markdown","8346ec24":"markdown","bae80b3e":"markdown","b8eded1a":"markdown","dfe23841":"markdown","de65a4f4":"markdown","75b0ce26":"markdown"},"source":{"3d02d522":"import numpy as np\nimport pandas as pd\nimport random\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import ModelCheckpoint, ReduceLROnPlateau, EarlyStopping","a57e3452":"SEED = 24\n\ndef set_seed(seed=SEED):\n    random.seed(seed)\n    np.random.seed(seed)\n    tf.random.set_seed(seed)\n    \nset_seed()","ecdbb091":"PATH = '..\/input\/face-mask-detection\/Dataset'\n\nIMAGE_SIZE = (224, 224)\nEPOCHS = 70\nBATCH_SIZE = 128\nNUM_CLASSES = 3","ebcf31d7":"train_gen = ImageDataGenerator(\n    horizontal_flip=True,\n    zoom_range=.3,\n    rotation_range=45,\n    validation_split=.2\n)\n\nval_gen = ImageDataGenerator(validation_split=.2)","a9575fb5":"train_data = train_gen.flow_from_directory(\n    PATH,\n    target_size=IMAGE_SIZE,\n    batch_size=BATCH_SIZE,\n    seed=SEED,\n    subset='training'\n)\n\nval_data = val_gen.flow_from_directory(\n    PATH,\n    target_size=IMAGE_SIZE,\n    batch_size=BATCH_SIZE,\n    seed=SEED,\n    shuffle=False,\n    subset='validation'\n)","b4cef0f9":"base_model = tf.keras.applications.EfficientNetB0(include_top=False)","f83a32d0":"model = tf.keras.Sequential([\n    base_model,\n    tf.keras.layers.GlobalAveragePooling2D(),\n    tf.keras.layers.Dense(NUM_CLASSES, activation='softmax')\n])","c1faae2f":"early_stopping = EarlyStopping(patience=5, verbose=1)\ncheckpoint = ModelCheckpoint('mask_model.h5', save_best_only=True, verbose=1)\nlr_reduce = ReduceLROnPlateau(patience=2, verbose=1)","e75ba397":"model.compile(\n    optimizer=tf.keras.optimizers.Adam(amsgrad=True),\n    loss='categorical_crossentropy',\n#     our data classes are perfectly balanced so I'm able to use simple accuracy metric\n    metrics=['acc']\n)\n\nhistory = model.fit(\n    train_data,\n    validation_data=val_data,\n    epochs=EPOCHS,\n    callbacks=[early_stopping, checkpoint, lr_reduce]\n)","4d13a9b8":"plt.plot(history.history['loss'])\nplt.plot(history.history['val_loss'])\nplt.title('model loss')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.legend(['train_loss', 'val_loss'], loc='upper right')\nplt.show()","68ec3151":"**EfficientNetB0** is pretty good model at image classification among the others pretrained models.","8346ec24":"# Load data","bae80b3e":"Feel free to write down any comments about this notebook. Thank you!","b8eded1a":"As we can see model has very high (**100%**!!!) validation accuracy. According to plots model isn't overfitted at all!","dfe23841":"# Import libs","de65a4f4":"These callbacks are very useful. I'm gonna stop model training when it tends to overfit. Also I will save model with best weights so I can use it later in other tasks.","75b0ce26":"# Define model"}}