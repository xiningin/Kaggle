{"cell_type":{"c679326f":"code","668ff4ec":"code","b0a085fd":"code","48ca27ea":"code","57b63e1c":"code","7c069ddc":"code","4a530b14":"code","2bf8f6f4":"code","67ce0997":"markdown"},"source":{"c679326f":"import tensorflow as tf\nimport os\nimport numpy as np\nimport pandas as pd\nfrom tensorflow import keras\n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg","668ff4ec":"class LoadData():\n    def __init__(self):\n        self.data_train = pd.read_csv(os.path.join('..','input','fashionmnist',\"fashion-mnist_train.csv\"))\n        self.data_test = pd.read_csv(os.path.join('..','input','fashionmnist',\"fashion-mnist_test.csv\"))\n        \n        self.x_train = np.array(self.data_train.iloc[:,1:])\n        self.y_train = np.array(self.data_train.iloc[:,0])\n        \n        self.x_test = np.array(self.data_test.iloc[:,1:])\n        self.y_test = np.array(self.data_test.iloc[:,0])\n        \n    def reshape_data(self):\n        img_rows, img_cols = 28, 28\n        print(\"Before: \")\n        print(self.x_train.shape,self.y_train.shape)\n        print(self.x_test.shape,self.y_test.shape)\n        \n        self.x_train = self.x_train.reshape(self.x_train.shape[0],img_rows,img_cols,1).astype('float32')\n        self.x_test = self.x_test.reshape(self.x_test.shape[0],img_rows,img_cols,1).astype('float32')\n        self.x_train \/= 255\n        self.x_test \/= 255\n        \n        print(\"After: \")\n        \n        \n        self.y_train = keras.utils.to_categorical(self.y_train)\n        self.y_test = keras.utils.to_categorical(self.y_test)\n        self.num_classes = self.y_test.shape[1]\n        print(self.x_train.shape,self.y_train.shape)\n        print(self.x_test.shape,self.y_test.shape)\n        print(\"total classes: \",self.num_classes)\n","b0a085fd":"ld_obj = LoadData()\nld_obj.reshape_data()","48ca27ea":"class DesignModel():\n    def __init__(self):\n        self.model = None\n        self.history = None\n        self.x_train = ld_obj.x_train\n        self.y_train = ld_obj.y_train\n        \n        self.x_test = ld_obj.x_test\n        self.y_test = ld_obj.y_test\n        self.num_classes = ld_obj.num_classes\n        print(self.num_classes)\n\n\n    def create_model(self):\n        self.model = keras.Sequential()\n        self.model.add(keras.layers.Conv2D(32, (3,3), activation='relu',input_shape=(28,28,1)))\n        #self.model.add(keras.layers.Conv2D(64, (3,3), activation='relu'))\n        #self.model.add(keras.layers.Conv2D(128, (3,3), activation='relu'))\n        self.model.add(keras.layers.MaxPool2D((2,2)))\n        self.model.add(keras.layers.Flatten())\n        #self.model.add(keras.layers.Dense(128, activation='relu'))\n        self.model.add(keras.layers.Dense(self.num_classes, activation='softmax'))\n        print(self.model.summary())\n    \n    def compile_model(self):\n        self.model.compile(loss=\"categorical_crossentropy\",optimizer=\"adam\",metrics=[\"accuracy\"])\n    \n    def train_model(self,batch_size,epochs):\n        self.history = self.model.fit(self.x_train,self.y_train,epochs=epochs,\n                                      batch_size=batch_size,verbose=2,\n                                      validation_data = (self.x_test,self.y_test),shuffle=True)","57b63e1c":"epochs = 20\nbatch_size = 512\n\nmodel_obj = DesignModel()\nmodel_obj.create_model()\nmodel_obj.compile_model()\nmodel_obj.train_model(batch_size,epochs)","7c069ddc":"class EvaluateModel():\n    def __init__(self,history):\n        self.history = history\n        \n    def plot_acc_loss(self):\n        epochs = self.history.epoch\n        acc = self.history.history.get('accuracy')\n        loss = self.history.history.get('loss')\n\n        print(epochs,loss,acc)\n        plt.plot(epochs, acc, 'b', label='Training accuracy')\n        plt.title('Training accuracy')\n\n        plt.figure()\n\n        plt.plot(epochs, loss, 'b', label='Training Loss')\n        plt.title('Training loss')\n        plt.legend()\n\n        plt.show()\n        ","4a530b14":"eval_obj = EvaluateModel(model_obj.history)\neval_obj.plot_acc_loss()","2bf8f6f4":"from PIL import Image\nfrom IPython.display import Image as IMG\n\n\nclass Prediction():\n    \n    def __init__(self,model):\n        self.model = model\n        labels = ['T-shirt\/top', 'Trouser', 'Pullover', 'Dress', 'Coat', \n               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']\n        self.labels = {k:labels[k] for k in range(len(labels))}\n    \n    def predict(self,image):\n        img = Image.open(image)\n        print(\"Image: \")\n        display(IMG(filename=image))\n        img = img.convert(\"L\")\n        img = img.resize((28,28))\n        im2arr = np.array(img)\n        im2arr = im2arr.reshape(1,28,28,1)\n        y_pred = self.model.predict(im2arr)\n        return y_pred\n        \npred_obj = Prediction(model_obj.model)\nfiles = None\n\nfor r,d,f in os.walk(os.path.join(cur_dir,\"Test_Data\")):\n    files = f\nfor item in files:\n    result = pred_obj.predict(os.path.join(cur_dir,\"Test_Data\",item))\n    print(\"Predition Label: \",pred_obj.labels[result.argmax()],'\\n')","67ce0997":"# Why reshape required??\nEach image (instance) in the dataset has 784 pixels (features) and value of each feature(pixel) ranges from 0 to 255, this range is too wide, hence we have performed Normalization on the training and test dataset, by dividing the pixels by 255, so that values of all features (pixels) are in a small range (0 to 1)."}}