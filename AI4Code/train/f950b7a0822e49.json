{"cell_type":{"4f27a82f":"code","a5e260d8":"code","4c0a9e21":"code","d74b3360":"code","80c6e6ca":"code","4bc65127":"code","de886602":"code","d8dfaf0f":"code","3b43b83a":"code","3a370a00":"code","86a7e5ea":"code","8681a106":"code","c7a5b03c":"code","9e7acb0b":"code","706a83f7":"code","758cd0e9":"code","6268ee19":"code","3b7706a7":"code","fed008d5":"code","7ce7499f":"code","58281b75":"code","5559c4af":"code","ce215dcf":"code","57275473":"code","09802ecd":"code","94b64424":"code","7e8bcd87":"code","ce22d0f4":"code","3b937368":"code","ef144143":"code","0be5dba3":"code","50381ffd":"code","00cb9881":"markdown","2da1592d":"markdown","b95d8077":"markdown","030f568a":"markdown","3504cee0":"markdown","b3af9063":"markdown","bfa5e4ca":"markdown","072df8ef":"markdown"},"source":{"4f27a82f":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","a5e260d8":"import pandas as pd \nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import linear_kernel\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom surprise import Reader, Dataset, SVD\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom surprise.model_selection import cross_validate\nfrom ast import literal_eval","4c0a9e21":"df=pd.read_csv('\/kaggle\/input\/the-movies-dataset\/movies_metadata.csv')\ndf.head()","d74b3360":"C= df['vote_average'].mean()\nprint('Average Vote: ', C)\nm= df['vote_count'].quantile(0.95)\nprint('Vote Count above 95% : ', m)","80c6e6ca":"qualified = df.copy().loc[df['vote_count'] >= m]\nqualified.shape","4bc65127":"def weighted_rating(x, m=m, C=C):\n    v = x['vote_count']\n    R = x['vote_average']\n    return (v\/(v+m) * R) + (m\/(m+v) * C)\n\nqualified['score'] = qualified.apply(weighted_rating, axis=1)\nqualified = qualified.sort_values('score', ascending=False).head(100)\nqualified[['title', 'vote_count', 'vote_average', 'score']].head(10)","de886602":"df['genres']","d8dfaf0f":"def genre_based(genre, percentile=0.85):\n    vote_counts = df[df['vote_count'].notnull()]['vote_count'].astype('int')\n    vote_averages = df[df['vote_average'].notnull()]['vote_average'].astype('int')\n    C = vote_averages.mean()\n    m = vote_counts.quantile(percentile)\n    \n    qualified = df[(df['vote_count'] >= m) ] [['title', 'vote_count', 'vote_average', 'popularity']]\n    qualified['vote_count'] = qualified['vote_count'].astype('int')\n    qualified['vote_average'] = qualified['vote_average'].astype('int')\n    qualified['score'] = qualified.apply(lambda x: (x['vote_count']\/(x['vote_count']+m) * x['vote_average'])  + (m\/(m+x['vote_count']) * C), axis=1)\n    qualified = qualified.sort_values('score', ascending=False).head(250)\n    \n    return qualified","3b43b83a":"genre_based('Romance').head(15)","3a370a00":"df_small =pd.read_csv('\/kaggle\/input\/the-movies-dataset\/links_small.csv')\ndf_small","86a7e5ea":"df_small = df_small[df_small['tmdbId'].notnull()]['tmdbId'].astype('int')\ndf = df.drop([19730, 29503, 35587])\ndf['id'] = df['id'].astype('int')\nsdf = df[df['id'].isin(df_small)]\nsdf.shape","8681a106":"sdf","c7a5b03c":"sdf['description'] = sdf['overview'] + sdf['tagline']\nsdf['description'] = sdf['description'].fillna('')\ntf = TfidfVectorizer(analyzer='word',ngram_range=(1, 2),min_df=0, stop_words='english')\ntfidf_matrix = tf.fit_transform(sdf['description'])\ntfidf_matrix.shape","9e7acb0b":"cos_sim = linear_kernel(tfidf_matrix, tfidf_matrix)\nsdf = sdf.reset_index()\nindices = pd.Series(sdf.index, index=sdf['title']).drop_duplicates()\n\ndef get_recommendations(title, cos_sim=cos_sim):\n    idx = indices[title]\n    sim_scores = list(enumerate(cos_sim[idx]))\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n    sim_scores = sim_scores[1:11]\n    movie_indices = [i[0] for i in sim_scores]\n    return sdf['title'].iloc[movie_indices]","706a83f7":"get_recommendations('The Baby-Sitters Club')","758cd0e9":"get_recommendations('The Godfather')","6268ee19":"credits = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/credits.csv')\nkeywords = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/keywords.csv')\nkeywords['id'] = keywords['id'].astype('int')\ncredits['id'] = credits['id'].astype('int')\ndf['id'] = df['id'].astype('int')\n\ndf.shape","3b7706a7":"df = df.merge(credits, on='id')\ndf = df.merge(keywords, on='id')\nsdf = df[df['id'].isin(df_small)]\nsdf.shape","fed008d5":"features = ['cast', 'crew', 'keywords']\nfor feature in features:\n    sdf[feature] = sdf[feature].apply(literal_eval)\n\nsdf['cast_size'] = sdf['cast'].apply(lambda x: len(x))\nsdf['crew_size'] = sdf['crew'].apply(lambda x: len(x))","7ce7499f":"def get_director(x):\n    for i in x:\n        if i['job'] == 'Director':\n            return i['name']\n    return np.nan\n\ndef get_list(x):\n    if isinstance(x, list):\n        names = [i['name'] for i in x]\n        if len(names) > 3:\n            names = names[:3]\n        return names\n    return []\n\nsdf['director'] = sdf['crew'].apply(get_director)\n\nfeatures = ['cast', 'keywords', 'genres']\nfor feature in features:\n    sdf[feature] = sdf[feature].apply(get_list)","58281b75":"sdf[['title', 'cast', 'director', 'keywords', 'genres']].head(3)","5559c4af":"s = sdf.apply(lambda x: pd.Series(x['keywords']),axis=1).stack().reset_index(level=1, drop=True)\ns.name = 'keyword'\ns = s.value_counts()\ns[:10]","ce215dcf":"def clean_data(x):\n    if isinstance(x, list):\n        return [str.lower(i.replace(\" \", \"\")) for i in x]\n    else: \n        if isinstance(x, str):\n            return str.lower(x.replace(\" \", \"\"))\n        else:\n            return ''\n        \nfeatures = ['cast', 'keywords', 'director', 'genres']\nfor feature in features:\n    sdf[feature] = sdf[feature].apply(clean_data)\n    \ndef create_soup(x):\n    return ' '.join(x['keywords']) + ' ' + ' '.join(x['cast']) + ' ' + x['director'] + ' ' + ' '.join(x['genres'])\nsdf['soup'] = sdf.apply(create_soup, axis=1)\ncount = CountVectorizer(stop_words='english')\ncount_matrix = count.fit_transform(sdf['soup'])\n\ncosine_sim2 = cosine_similarity(count_matrix, count_matrix)\n\nsdf = sdf.reset_index()\nindices = pd.Series(sdf.index, index=sdf['title'])","57275473":"get_recommendations('The Prestige', cosine_sim2)","09802ecd":"reader = Reader()\nratings = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/ratings_small.csv')\nratings.head()","94b64424":"data = Dataset.load_from_df(ratings[['userId', 'movieId', 'rating']], reader)\nprint(data.df.head())\n#.split(n_folds=5)","7e8bcd87":"svd = SVD()\ncross_validate(svd, data, measures=['RMSE', 'MAE'])","ce22d0f4":"trainset = data.build_full_trainset()\nsvd.fit(trainset)\n\nratings[ratings['userId'] == 1]","3b937368":"svd.predict(1, 302, 3)","ef144143":"def convert_int(x):\n    try:\n        return int(x)\n    except:\n        return np.nan\n    \nid_map = pd.read_csv('\/kaggle\/input\/the-movies-dataset\/links_small.csv')[['movieId', 'tmdbId']]\nid_map['tmdbId'] = id_map['tmdbId'].apply(convert_int)\nid_map.columns = ['movieId', 'id']\nid_map = id_map.merge(sdf[['title', 'id']], on='id').set_index('title')\n\nindices_map = id_map.set_index('id')\n\ndef hpred(userId, title):\n    index = indices[title]\n    Id = id_map.loc[title]['id']\n    movie_id = id_map.loc[title]['movieId']\n    \n    recc = list(enumerate(cos_sim[int(index)]))\n    recc = sorted(recc, key=lambda x: x[1], reverse=True)\n    recc = recc[1:25]\n    movie_indices = [i[0] for i in recc]\n    movies = sdf.iloc[movie_indices][['title', 'vote_count', 'vote_average', 'id']]\n    movies['est'] = movies['id'].apply(lambda x: svd.predict(userId, indices_map.loc[x]['movieId']).est)\n    movies = movies.sort_values('est', ascending=False)\n    return movies.head(10)","0be5dba3":"hpred(1, 'Bride Wars')","50381ffd":"hpred(500, 'Bride Wars')","00cb9881":"# **CONCLUSION**\n\nAn information filtering system used to predict the preference of movies that a user would watch was hence modelled.\n\n# **Reference\/ Acknowledgements**\n\n1.https:\/\/hackernoon.com\/introduction-to-recommender-system-part-1-collaborative-filtering-singular-value-decomposition-44c9659c5e75\n\n2.https:\/\/www.kaggle.com\/ibtesama\/getting-started-with-a-movie-recommendation-system\n\n","2da1592d":"# **Content Based Recommendation System**\n\nThis system computes similarity between movies such that it is used to suggest movies that are most similar to a particular movie that a user liked.\nA smaller dataset is used due to lack of computational power.","b95d8077":"# **Simple Recommender System**\n\nSort movies based on ratings,popularity and genre.Display the top movies of the list.","030f568a":"# **Credits and Keywords Based Recommender**","3504cee0":"Here, in hybrid recommender system, we get different recommendations for different users although the movie is the same.","b3af9063":"# **Hybrid Model**","bfa5e4ca":"# **Collabrative Filtering**","072df8ef":"# **The recommendation engines present in this model are:**\n\n**1. Simple Recommender System :**\nSorts movies based on ratings, genre and popularity .Displays the top movies of the list.\n\n**2. Movie Description based Recommender System :**\nComputes similarity between movies description and is used to suggest movies that are most similar to a particular movie that a user liked. Used TfidfVectorizer to transform text to feature vectors that can be used as input to estimator.\n\n**3. Credits and Keywords based Recommender :**\nRecommendations are given based on keywords.\n\n**4. Collaborative filtering based Recommender System :**\nRecords from various users provide recommendations based on user similarities.\n\n**5. Hybrid filtering based Recommender System :**\nThis filtering takes advantage of content-based and collaborative filtering.\nIt provides different recommendations for different users even though the movie title is the same."}}