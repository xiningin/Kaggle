{"cell_type":{"483a369c":"code","64fc63d0":"code","ea408438":"code","3167bb7a":"code","caf18d79":"code","19d69a16":"code","e406fb51":"code","ce99ec08":"code","7f3f7750":"code","e8309e21":"code","450f4c48":"code","0bf5133d":"code","8f196858":"code","e4bb11ba":"code","2a3abb5a":"code","0f2423ce":"code","72484136":"code","47a73470":"code","99cfd001":"code","c8cfd9cf":"code","f4c62db1":"code","ef145658":"code","8013ef99":"code","6e301743":"code","52dec76f":"code","fc30a4bd":"code","b27e406d":"code","ff93b197":"code","30e0577c":"code","c8028a9e":"markdown","9bd9b1d6":"markdown","610b0046":"markdown","d210a2f2":"markdown","f89d74f1":"markdown","768271bd":"markdown","038bb260":"markdown","6ab744a1":"markdown","a605d39c":"markdown","26181474":"markdown","472e0d5a":"markdown","43ceda77":"markdown","a3b39e78":"markdown","a724275c":"markdown","9c14492c":"markdown","79f6b803":"markdown","fea72f5a":"markdown","efe427b3":"markdown","b99a7bbd":"markdown","e9281179":"markdown","a714d21b":"markdown","2e8d4b80":"markdown"},"source":{"483a369c":"import numpy as np\nimport math\nimport random\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nunited_states_map = mpimg.imread(\"..\/input\/united_states_map.png\")\ndef show_cities(path, w=12, h=8):\n    \"\"\"Plot a TSP path overlaid on a map of the US States & their capitals.\"\"\"\n    if isinstance(path, dict):      path = list(path.values())\n    if isinstance(path[0][0], str): path = [ item[1] for item in path ]    \n    plt.imshow(united_states_map)    \n    for x0, y0 in path:\n        plt.plot(x0, y0, 'y*', markersize=15)  # y* = yellow star for starting point        \n    plt.axis(\"off\")\n    fig = plt.gcf()\n    fig.set_size_inches([w, h])\n\n    \ndef show_path(path, starting_city=None, w=12, h=8):\n    \"\"\"Plot a TSP path overlaid on a map of the US States & their capitals.\"\"\"\n    if isinstance(path, dict):      path = list(path.values())\n    if isinstance(path[0][0], str): path = [ item[1] for item in path ]\n    \n    starting_city = starting_city or path[0]\n    x, y = list(zip(*path))\n    #_, (x0, y0) = starting_city\n    (x0, y0) = starting_city\n    plt.imshow(united_states_map)\n    #plt.plot(x0, y0, 'y*', markersize=15)  # y* = yellow star for starting point\n    plt.plot(x + x[:1], y + y[:1])  # include the starting point at the end of path\n    plt.axis(\"off\")\n    fig = plt.gcf()\n    fig.set_size_inches([w, h])\n    \n    \ndef polyfit_plot(x,y,deg, **kwargs):\n    coefficients = np.polyfit(x,y,deg,**kwargs)\n    poly  = np.poly1d(coefficients)\n    new_x = np.linspace(x[0], x[-1])\n    new_y = poly(new_x)\n    plt.plot(x, y, \"o\", new_x, new_y)\n    plt.xlim([x[0]-1, x[-1] + 1 ])\n    \n    terms = []\n    for p, c in enumerate(reversed(coefficients)):\n        term = str(round(c,1))\n        if p == 1: term += 'x'\n        if p >= 2: term += 'x^'+str(p)\n        terms.append(term)        \n    plt.title(\" + \".join(reversed(terms)))    ","64fc63d0":"def distance(xy1, xy2) -> float:\n    if isinstance(xy1[0], str): xy1 = xy1[1]; xy2 = xy2[1];               # if xy1 == (\"Name\", (x,y))\n    return math.sqrt( (xy1[0]-xy2[0])**2 + (xy1[1]-xy2[1])**2 )\n\ndef path_distance(path) -> int:\n    if isinstance(path, dict):      path = list(path.values())            # if path == {\"Name\": (x,y)}\n    if isinstance(path[0][0], str): path = [ item[1] for item in path ]   # if path == (\"Name\", (x,y))\n    return int(sum(\n        [ distance(path[i],  path[i+1]) for i in range(len(path)-1) ]\n      + [ distance(path[-1], path[0]) ]                                   # include cost of return journey\n    ))","ea408438":"cities = { \"Oklahoma City\": (392.8, 356.4), \"Montgomery\": (559.6, 404.8), \"Saint Paul\": (451.6, 186.0), \"Trenton\": (698.8, 239.6), \"Salt Lake City\": (204.0, 243.2), \"Columbus\": (590.8, 263.2), \"Austin\": (389.2, 448.4), \"Phoenix\": (179.6, 371.2), \"Hartford\": (719.6, 205.2), \"Baton Rouge\": (489.6, 442.0), \"Salem\": (80.0, 139.2), \"Little Rock\": (469.2, 367.2), \"Richmond\": (673.2, 293.6), \"Jackson\": (501.6, 409.6), \"Des Moines\": (447.6, 246.0), \"Lansing\": (563.6, 216.4), \"Denver\": (293.6, 274.0), \"Boise\": (159.6, 182.8), \"Raleigh\": (662.0, 328.8), \"Atlanta\": (585.6, 376.8), \"Madison\": (500.8, 217.6), \"Indianapolis\": (548.0, 272.8), \"Nashville\": (546.4, 336.8), \"Columbia\": (632.4, 364.8), \"Providence\": (735.2, 201.2), \"Boston\": (738.4, 190.8), \"Tallahassee\": (594.8, 434.8), \"Sacramento\": (68.4, 254.0), \"Albany\": (702.0, 193.6), \"Harrisburg\": (670.8, 244.0) }\ncities = list(sorted(cities.items()))\nprint(len(cities))\nshow_cities(cities)","3167bb7a":"show_path(cities)\npath_distance(cities)","caf18d79":"import time\nfrom itertools import chain\nfrom typing import Any, Callable, List, Tuple, Union\n\nimport numpy as np\nimport random\n\n\n\nclass AntColonySolver:\n    def __init__(self,\n                 cost_fn:                 Callable[[Any,Any], Union[float,int]],                         \n                 \n                 time=0,                  # run for a fixed amount of time\n                 min_time=0,              # minimum runtime\n                 timeout=0,               # maximum time in seconds to run for\n                 stop_factor=2,           # how many times to redouble effort after new new best path\n                 min_round_trips=10,      # minimum number of round trips before stopping\n                 max_round_trips=0,       # maximum number of round trips before stopping                 \n                 min_ants=0,              # Total number of ants to use\n                 max_ants=0,              # Total number of ants to use\n                 \n                 ant_count=64,            # this is the bottom of the near-optimal range for numpy performance\n                 ant_speed=1,             # how many steps do ants travel per epoch\n\n                 distance_power=1,        # power to which distance affects pheromones                 \n                 pheromone_power=1.25,    # power to which differences in pheromones are noticed\n                 decay_power=0,           # how fast do pheromones decay\n                 reward_power=0,          # relative pheromone reward based on best_path_length\/path_length \n                 best_path_smell=2,       # queen multiplier for pheromones upon finding a new best path                  \n                 start_smell=0,           # amount of starting pheromones [0 defaults to `10**self.distance_power`]\n\n                 verbose=False,\n\n    ):\n        assert callable(cost_fn)        \n        self.cost_fn         = cost_fn\n        self.time            = int(time)\n        self.min_time        = int(min_time)\n        self.timeout         = int(timeout)\n        self.stop_factor     = float(stop_factor)\n        self.min_round_trips = int(min_round_trips)\n        self.max_round_trips = int(max_round_trips)\n        self.min_ants        = int(min_ants)\n        self.max_ants        = int(max_ants)\n    \n        self.ant_count       = int(ant_count)\n        self.ant_speed       = int(ant_speed)\n        \n        self.distance_power  = float(distance_power)     \n        self.pheromone_power = float(pheromone_power)\n        self.decay_power     = float(decay_power)\n        self.reward_power    = float(reward_power)\n        self.best_path_smell = float(best_path_smell)\n        self.start_smell     = float(start_smell or 10**self.distance_power)\n        \n        self.verbose         = int(verbose)\n        self._initalized     = False\n        \n        if self.min_round_trips and self.max_round_trips: self.min_round_trips = min(self.min_round_trips, self.max_round_trips)\n        if self.min_ants and self.max_ants:               self.min_ants        = min(self.min_ants, self.max_ants)\n\n\n    def solve_initialize(\n            self,\n            problem_path: List[Any],\n    ) -> None:\n        ### Cache of distances between nodes\n        self.distances = {\n            source: {\n                dest: self.cost_fn(source, dest)\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n\n        ### Cache of distance costs between nodes - division in a tight loop is expensive\n        self.distance_cost = {\n            source: {\n                dest: 1 \/ (1 + self.distances[source][dest]) ** self.distance_power\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n\n        ### This stores the pheromone trail that slowly builds up\n        self.pheromones = {\n            source: {\n                # Encourage the ants to start exploring in all directions and furthest nodes\n                dest: self.start_smell\n                for dest in problem_path\n            }\n            for source in problem_path\n        }\n        \n        ### Sanitise input parameters\n        if self.ant_count <= 0:\n            self.ant_count = len(problem_path)\n        if self.ant_speed <= 0:\n            self.ant_speed = np.median(list(chain(*[ d.values() for d in self.distances.values() ]))) \/\/ 5\n        self.ant_speed = int(max(1,self.ant_speed))\n        \n        ### Heuristic Exports\n        self.ants_used   = 0\n        self.epochs_used = 0\n        self.round_trips = 0\n        self._initalized = True        \n\n\n    def solve(self,\n              problem_path: List[Any],\n              restart=False,\n    ) -> List[Tuple[int,int]]:\n        if restart or not self._initalized:\n            self.solve_initialize(problem_path)\n\n        ### Here come the ants!\n        ants = {\n            \"distance\":    np.zeros((self.ant_count,)).astype('int32'),\n            \"path\":        [ [ problem_path[0] ]   for n in range(self.ant_count) ],\n            \"remaining\":   [ set(problem_path[1:]) for n in range(self.ant_count) ],\n            \"path_cost\":   np.zeros((self.ant_count,)).astype('int32'),\n            \"round_trips\": np.zeros((self.ant_count,)).astype('int32'),\n        }\n\n        best_path       = None\n        best_path_cost  = np.inf\n        best_epochs     = []\n        epoch           = 0\n        time_start      = time.perf_counter()\n        while True:\n            epoch += 1\n\n            ### Vectorized walking of ants\n            # Small optimization here, testing against `> self.ant_speed` rather than `> 0` \n            #       avoids computing ants_arriving in the main part of this tight loop\n            ants_travelling = (ants['distance'] > self.ant_speed)\n            ants['distance'][ ants_travelling ] -= self.ant_speed\n            if all(ants_travelling):\n                continue  # skip termination checks until the next ant arrives\n            \n            ### Vectorized checking of ants arriving\n            ants_arriving       = np.invert(ants_travelling)\n            ants_arriving_index = np.where(ants_arriving)[0]\n            for i in ants_arriving_index:\n\n                ### ant has arrived at next_node\n                this_node = ants['path'][i][-1]\n                next_node = self.next_node(ants, i)\n                ants['distance'][i]  = self.distances[ this_node ][ next_node ]\n                ants['remaining'][i] = ants['remaining'][i] - {this_node}\n                ants['path_cost'][i] = ants['path_cost'][i] + ants['distance'][i]\n                ants['path'][i].append( next_node )\n\n                ### ant has returned home to the colony\n                if not ants['remaining'][i] and ants['path'][i][0] == ants['path'][i][-1]:\n                    self.ants_used  += 1\n                    self.round_trips = max(self.round_trips, ants[\"round_trips\"][i] + 1)\n\n                    ### We have found a new best path - inform the Queen\n                    was_best_path = False\n                    if ants['path_cost'][i] < best_path_cost:\n                        was_best_path  = True\n                        best_path_cost = ants['path_cost'][i]\n                        best_path      = ants['path'][i]\n                        best_epochs   += [ epoch ]\n                        if self.verbose:\n                            print({\n                                \"path_cost\":   int(ants['path_cost'][i]),\n                                \"ants_used\":   self.ants_used,\n                                \"epoch\":       epoch,\n                                \"round_trips\": ants['round_trips'][i] + 1,\n                                \"clock\":       int(time.perf_counter() - time_start),\n                            })\n\n                    ### leave pheromone trail\n                    # doing this only after ants arrive home improves initial exploration\n                    #  * self.round_trips has the effect of decaying old pheromone trails\n                    # ** self.reward_power = -3 has the effect of encouraging ants to explore longer routes\n                    #                           in combination with doubling pheromone for best_path\n                    reward = 1\n                    if self.reward_power: reward *= ((best_path_cost \/ ants['path_cost'][i]) ** self.reward_power)\n                    if self.decay_power:  reward *= (self.round_trips ** self.decay_power)\n                    for path_index in range( len(ants['path'][i]) - 1 ):\n                        this_node = ants['path'][i][path_index]\n                        next_node = ants['path'][i][path_index+1]\n                        self.pheromones[this_node][next_node] += reward\n                        self.pheromones[next_node][this_node] += reward\n                        if was_best_path:\n                            # Queen orders to double the number of ants following this new best path                            \n                            self.pheromones[this_node][next_node] *= self.best_path_smell\n                            self.pheromones[next_node][this_node] *= self.best_path_smell\n\n\n                    ### reset ant\n                    ants[\"distance\"][i]     = 0\n                    ants[\"path\"][i]         = [ problem_path[0] ]\n                    ants[\"remaining\"][i]    = set(problem_path[1:])\n                    ants[\"path_cost\"][i]    = 0\n                    ants[\"round_trips\"][i] += 1\n\n\n            ### Do we terminate?\n            \n            # Always wait for at least 1 solutions (note: 2+ solutions are not guaranteed)\n            if not len(best_epochs): continue \n            \n            # Timer takes priority over other constraints\n            if self.time or self.min_time or self.timeout:\n                clock = time.perf_counter() - time_start\n                if self.time:\n                    if clock > self.time: break\n                    else:                 continue\n                if self.min_time and clock < self.min_time: continue\n                if self.timeout  and clock > self.timeout:  break\n            \n            # First epoch only has start smell - question: how many epochs are required for a reasonable result?\n            if self.min_round_trips and self.round_trips <  self.min_round_trips: continue        \n            if self.max_round_trips and self.round_trips >= self.max_round_trips: break\n\n            # This factor is most closely tied to computational power                \n            if self.min_ants and self.ants_used <  self.min_ants: continue        \n            if self.max_ants and self.ants_used >= self.max_ants: break            \n            \n            # Lets keep redoubling our efforts until we can't find anything more\n            if self.stop_factor and epoch > (best_epochs[-1] * self.stop_factor): break\n                                \n            # Nothing else is stopping us: Queen orders the ants to continue!      \n            if True: continue\n            \n            \n            \n        ### We have (hopefully) found a near-optimal path, report back to the Queen\n        self.epochs_used = epoch\n        self.round_trips = np.max(ants[\"round_trips\"])\n        return best_path\n\n\n    def next_node(self, ants, index):\n        this_node   = ants['path'][index][-1]\n\n        weights     = []\n        weights_sum = 0\n        if not ants['remaining'][index]: return ants['path'][index][0]  # return home\n        for next_node in ants['remaining'][index]:\n            if next_node == this_node: continue\n            reward = (\n                    self.pheromones[this_node][next_node] ** self.pheromone_power\n                    * self.distance_cost[this_node][next_node]  # Prefer shorter paths\n            )\n            weights.append( (reward, next_node) )\n            weights_sum   += reward\n\n        # Pick a random path in proportion to the weight of the pheromone\n        rand = random.random() * weights_sum\n        for (weight, next_node) in weights:\n            if rand > weight: rand -= weight\n            else:             break\n        return next_node\n            \n        \ndef AntColonyRunner(cities, verbose=False, plot=False, label={}, algorithm=AntColonySolver, **kwargs):\n    solver     = algorithm(cost_fn=distance, verbose=verbose, **kwargs)\n    start_time = time.perf_counter()\n    result     = solver.solve(cities)\n    stop_time  = time.perf_counter()\n    if label: kwargs = { **label, **kwargs }\n        \n    for key in ['verbose', 'plot', 'animate', 'label', 'min_time', 'max_time']:\n        if key in kwargs: del kwargs[key]\n    print(\"N={:<3d} | {:5.0f} -> {:4.0f} | {:4.0f}s | ants: {:5d} | trips: {:4d} | \"\n          .format(len(cities), path_distance(cities), path_distance(result), (stop_time - start_time), solver.ants_used, solver.round_trips)\n          + \" \".join([ f\"{k}={v}\" for k,v in kwargs.items() ])\n    )\n    if plot:\n        show_path(result)\n    return result","19d69a16":"results = AntColonyRunner(cities, distance_power=1, verbose=True, plot=True)","e406fb51":"results = AntColonyRunner(cities, distance_power=0, stop_factor=1.25, verbose=True, plot=True)","ce99ec08":"results = AntColonyRunner(cities, distance_power=0, min_time=30, verbose=True, plot=True)","7f3f7750":"results_converged = [ AntColonyRunner(cities) for i in range(10) ]","e8309e21":"results_timed = [ AntColonyRunner(cities, time=10) for i in range(10) ]","450f4c48":"import pandas as pd\nresults_converged_stats = pd.Series([ path_distance(path) for path in results_converged ]).describe()\nresults_timed_stats     = pd.Series([ path_distance(path) for path in results_timed     ]).describe()\npd.DataFrame({\n    \"results_converged\": results_converged_stats,\n    \"results_timed\":     results_timed_stats,\n    \"difference\":        results_converged_stats - results_timed_stats,\n}).T.round(1)","0bf5133d":"for ant_count in range(0,16+1):\n    AntColonyRunner(cities, ant_count=2**ant_count, time=60)","8f196858":"for N in range(8,30+1):\n    best = { \"ant_count\": 0, \"min_ants\": 0, \"path\": None, \"count\": 0 }\n    for ant_count in [8,16,32,64,128,256,512,1024,2048]:\n        for min_ants in [64,128,256,512,1024,2048,4096,8192]:\n            result = AntColonySolver(ant_count=ant_count, min_ants=min_ants, cost_fn=distance).solve(cities[:N])\n            if not best['path'] or best['path'] > path_distance(result):\n                best = { \"ant_count\": ant_count, \"min_ants\": min_ants, \"path\": path_distance(result), \"count\": best['count']+1 }\n                continue\n            if best['count'] >= 3: \n                best['count'] = 0\n                break\n    AntColonyRunner(cities[:N], ant_count=best['ant_count'], min_ants=best['min_ants'])","e4bb11ba":"for ant_speed in list(range(0,10+1)):\n    result = AntColonyRunner(cities, ant_speed=2**ant_speed, time=10)\nresult = AntColonyRunner(cities, ant_speed=0, time=10)    ","2a3abb5a":"for distance_power in [-2.0, -1.0, 0.0, 0.5, 1.0, 1.25, 1.5, 1.75, 2.0, 3.0, 5.0, 10.0]:\n    result = AntColonyRunner(cities, distance_power=distance_power, timeout=60)","0f2423ce":"for distance_power in [0,1,2]:\n    for pheromone_power in [-2.0, -1.0, 0.0, 0.5, 1.0, 1.25, 1.5, 1.75, 2.0, 3.0, 5.0, 10.0]:\n        result = AntColonyRunner(cities, distance_power=distance_power, pheromone_power=pheromone_power, time=0)\n    print()","72484136":"for distance_power in [0,1,2]:\n    for pheromone_power in [1.0, 1.1, 1.2, 1.3, 1.4]:\n        result = AntColonyRunner(cities, distance_power=distance_power, pheromone_power=pheromone_power, time=0)\n    print()","47a73470":"for pheromone_power in [1.0, 1.25]:\n    for distance_power in [0,1,2]:\n        for decay_power in [-1.0, 0.0, 1.0, 1.25, 1.5, 2.0, 3.0]:\n            result = AntColonyRunner(cities, pheromone_power=pheromone_power, distance_power=distance_power, decay_power=decay_power, time=15)\n        print()\n    print()","99cfd001":"for distance_power in [0,1,2]:\n    for decay_power in [-2.0, -1.0, 0.0, 0.5, 1.0, 1.25, 1.5, 2.0, 3.0, 5.0, 10.0]:\n        result = AntColonyRunner(cities, distance_power=distance_power, decay_power=decay_power, time=0)\n    print()","c8cfd9cf":"for decay_power in [-2.0, -1.0, 0.0, 0.5, 1.0, 1.25, 1.5, 2.0, 3.0, 5.0, 10.0]:\n    result = AntColonyRunner(cities, decay_power=decay_power, timeout=60)\n    print()","f4c62db1":"for decay_power in [-2.0, -1.0, 0.0, 0.5, 1.0, 1.25, 1.5, 2.0, 3.0, 5.0, 10.0]:\n    for reward_power in range(-5,5+1):\n        result = AntColonyRunner(cities, decay_power=decay_power, reward_power=reward_power, time=15)\n    print()","ef145658":"for distance_power in [0,1,2]:\n    for best_path_smell in [0.0, 0.5, 1.0, 1.25, 1.5, 2.0, 3.0, 5.0, 10.0]:\n        result = AntColonyRunner(cities, distance_power=distance_power, best_path_smell=best_path_smell, time=15)\n    print()","8013ef99":"for distance_power in [0,1,2]:\n    for best_path_smell in [0.0, 0.5, 1.0, 1.25, 1.5, 2.0, 3.0, 5.0, 10.0]:\n        result = AntColonyRunner(cities, distance_power=distance_power, best_path_smell=best_path_smell, min_round_trips=20, time=0)\n    print()","6e301743":"for distance_power in [0, 1, 2]:\n    for start_smell in list(range(0,8)):\n        result = AntColonyRunner(cities, distance_power=distance_power, start_smell=10**start_smell, time=15)\n    result = AntColonyRunner(cities, distance_power=distance_power, start_smell=0, time=15)\n    print()","52dec76f":"for distance_power in [0, 1, 2]:\n    for stop_factor in [1.25, 1.5, 1.75, 2, 5]:\n        result = AntColonyRunner(cities, distance_power=distance_power, stop_factor=stop_factor)\n    print()","fc30a4bd":"import string\ndef create_cities(size, max_x=1000, max_y=1000, image=None, color=1, border=30):\n    if (image is not None):\n        max_x = image.shape[0] - 1 - border*2\n        max_y = image.shape[1] - 1 - border*2\n    cities = {}\n    while len(cities) <= size:\n        name = ''.join(random.choices(string.ascii_lowercase, k=10))\n        x = round( border + random.random() * max_x,  1)\n        y = round( border + random.random() * max_y,  1)\n        if (image is not None) and not all( image[int(x)][int(y)] == color ): continue\n        cities[(int(x),int(y))] = ( name, (y,x) )               \n    return list(cities.values())\n\nnp_hard = create_cities(256, image=united_states_map)\nprint(np_hard[:5])\nshow_cities(np_hard)","b27e406d":"for N in [8,16,32,64,128,256]:\n    result = AntColonyRunner(np_hard[:N], label={ \"N\": N }, timeout=60*60)\n    plt.figure()\n    plt.title(f'N={N}')        \n    show_path(result)    \nprint()","ff93b197":"for N in [8,16,32,64,128,256]:\n    result = AntColonyRunner(np_hard[:N], label={ \"N\": N }, max_ants=N**2, timeout=60*60)\n    plt.figure()\n    plt.title(f'N={N}')    \n    show_path(result)        \nprint()","30e0577c":"for N in [8,16,32,64,128,256]:\n    result = AntColonyRunner(np_hard[:N], label={ \"N\": N }, distance_power=10, max_ants=N**2, timeout=60*60)\n    plt.figure()\n    plt.title(f'N={N}')\n    show_path(result)            \nprint()","c8028a9e":"# distance_power\n\nAs documented in the introduction, this affects the ability of ant to see distance when choosing a next node, rather than just blindly smelling the pheromone trail. This can have a big impact on performance and runtimes.\n\n- `-1` or negative distance powers encourage ants to travel to more distant nodes first. \n    - This finds is worse than random results\n    - Ants may or may not find a better solution than the first ant to return home\n- `0` this disables the distance metric and rely purely on the pheromones trail (like wild ants)\n    - this can be very slow to converge \n    - can occasionally run into early termination issues (not finding new best paths quick enough)\n- `1` this works perfectly well, but graphs can contain tangled loops around clusters of closely spaced nodes\n- `1.5 - 2.0` this converges much more quickly and produces cleaner, more circular graphs (default = 2)\n- `3+` this converges a little too quickly, with less exploration, and finds suboptimal routes\n- `10` this is a cheat solution, slightly suboptimal, but converges very quickly based on distance alone","9bd9b1d6":"# stop_factor\n\nThis controls how many times the ants will redouble their efforts after finding a new best path before giving up.\n\n- The tradeoff is the risk of early termination vs excessive runtimes with the law of diminishing returns for better paths\n- `1.5` is too small and often results in early termination \n- `2` seems to be about the right factor for reaching convergance\n- `5+` burns CPU cycles without generating any significantly better solutions","610b0046":"# ant_count\n\nThis really shows the performance impact of using vectorized numpy arrays vs python loops\n- observe the number of ants generated\n- operations on numpy arrays have a linear overhead\n- using very small arrays (4 or smaller) can be much slower than using python primitives\n- 256-4096 is the sweet spot for the optimal size of numpy arrays in a tight loop\n- 64-16384 still provides near optimal performance\n- 32768+ results in a dramatic drop in performance - as bad as using very small arrays ","d210a2f2":"# min_ants\n\nOne of the main unsolved problem is how to optimize the performance of the algorithm whilst also correctly detecting convergance \n\n- a low ant_count will mean more round trips per second\n    - this will make better use of the pheromone trail\n    - this also increases the risk of early termination \n- a too high ant count\n    - will avoid early termination\n    - but result is only a small number of round trips\n    - this also affects the relative strength of the start_smell\n- algorithm phases\n    - early on, there can be very large 4x-10x gaps before finding a new best path\n    - during the middle of the algorithm, new best paths will be regularly found withn 1.1x - 1.5x\n    - at the end of the algorithm, the ants will search for a long time without finding anything new\n    - but occasionally randomly find a slightly better new best path, which resets the 2x timer\n    - unsure exactly how to set a stop_factor that accounts for all of this\n- ant_count\n    - to few ants and the pheromone trail doesn't get built up fast enough, the ants \n- the current algorithm cheats quite a bit by using a distance heuristic, which is doing half the work","f89d74f1":"# pheromone_power\nThis affects the power to which relative differences in pheromones are noticed. \n\n- Negative numbers make the pheromones repulsive, yet the algorithm still finds (slightly) better than random results\n- The pheromone_power effect is most noticable when the distance heuristic is disabled.\n- When run without a timer, increasing a tiny bit above 1 resulted in a massive path_length improvement with a significantly extended runtime. \n    - The sweet spot seems to be around `1.25` (setting this to default)\n    - This shows an amplified sensitivity to pheromones and that the ants could continually find new paths\n    - This also seems to amplify the effect of other smell heuristic settings[[](http:\/\/)](http:\/\/)\n- Setting `pheromone_power` destroys the fine balance between optimization and exploration","768271bd":"# Statistical Random Variation\n\nWhilst the Ant Colony Optimization Algorithm is not \"complete\" in the sense that it does not gaurentee to find the optimal path, it is able to quickly converge on a near-optimal path which may be acceptable for many usecases.\n\nIt contains a stochastic\/random model, but a statistical analysis shows:\n\n\n- For converged results:\n  - standard deviation is 20.8 which is about 1% of the mean path length (2211.1) \n  - difference between maximum and minimum path length is 50 (2.5%)\n  - average time to convergance is 47.2s\n  \n  \n- Running on a fixed 10s timer:\n  - standard deviation is reduced slightly to 17.3\n  - average path length is only 20 (= 1%) higher than for converged results\n  \nThis shows the algorithm is reasonably consistant and can be still produce acceptable results with early-termination. The law of deminishing returns applies to running the algorithm for extended periods of time.","038bb260":"Lets limit time complexity to N^2","6ab744a1":"# Hyperparameter Optimization\n\nThere are a number of hyperparameters that can be tuned:\n```\n- ant_count=2048,          # this is close to the optimal number for performance\n- ant_speed=1,             # how many steps do ants travel per epoch\n- start_smell=0,           # amount of starting pheromones [0 defaults to `10**self.distance_power`]\n- best_path_smell=2,       # queen multiplier for pheromones upon finding a new best path \n- reward_power=-3,         # Counter intuatively -3 actually rewards longer paths, but leads to more exploration\n- distance_power=2,        # power to which distance affects pheromones\n- pheromone_power=1,       # power to which differences in pheromones are noticed\n- decay_power=1,           # how fast do pheromones decay\n```","a605d39c":"What if we enable cheat mode with `distance_power=10`\n- Thus works quicker and faster than relying on the pheromone trail\n- Even with an N^2 limitation on the ants, there is still an 14 minute runtime on N=256","26181474":"# NP Hard Scalability\n\nSo the Ant Colony Optimization Algorithm works fairly well on small maps of size 30 nodes, but how does it scale against larger problems?\n\nFirst let us create a new map with random coordinates","472e0d5a":"# reward_power\n```\nreward = (self.round_trips ** self.decay_power) * ((best_path_cost \/ ants['path_cost'][i]) ** self.reward_power)\n```\n\nThis is the pheromone reward given by each ant after it makes a round trip, and is relative to the path_cost of the route it took\n- Numbers are normalized to be very close to 1\n- Negative powers increase the relative reward for longer path lengths\n- Negative powers increase the relative reward for shorter path lengths\n\n\nIt doesn't have a effect much larger than the statistical noise (std = 20). \n\n- For `best_path_smell=1`: \n    - The effects of reward_power are more amplified when `best_path_smell` is disabled\n    - `-1` or `-2` produces a produces a small but noticable effect\n    - `-2` caused an exceptionally long runtime without a timeout (ants kept continually finding new best paths)\n    - `4+` results in a noticable deoptimization\n\n\n- For `best_path_smell=2`: \n    - Previous experiments (and current default) suggsted `-3` was the optimal setting, but I have been unable to reproduce this here\n    - disabling this feature and setting `reward_power=0` actually produces the best results here\n    \nUpdate: changing the default back to 0","43ceda77":"# decay_power\n\nhow fast do pheromones decay\n\n```\nreward = (self.round_trips ** self.decay_power) * ((best_path_cost \/ ants['path_cost'][i]) ** self.reward_power)\n```\n\n- with `pheromone_power=1.0` \n    - the effect seems almost indistingusable from noise\n    \n    \n- with `pheromone_power=1.25`\n    - There is still lots of variation when rerunning the results    \n    - with `distance_power=0`: `0` is the sweet spot\n    - with `distance_power=1`: `0`-`1.25` is the sweet spot\n    - with `distance_power=2`: \n         - previous sweet spots: `0`, `1.25`, `2`\n         - results now indistingusable from noise\n         \n Setting default to: `0`","a3b39e78":"First let look at some of the smaller problems\n- For the smallest problems `N<8` most of the time is spent just marching 1024 ants for a minimum of 4 round trips\n- Running to convergance takes exponentally longer for each doubling of the problem size\n- The ants can still find a reasonable path for N=64","a724275c":"# Solving with Wild Ants\n\nOf course these ants are cheating. They can see the distances and have been taught to strongly squared prefer to visit closer nodes. In the wild, ants would be blind to everything except the pheromone trail, so lets see how this affects the algorithm.\n\n- The ants slowly but methodically converge on better solutions\n- The final path found is 30% longer than the distance^2 ants (2843 vs 2203)\n- The first ant to return took a path almost double the length of the distance^2 ant (5906 vs 2987)\n- The algorithm was alot more computationally expensive, with 6x runtime (94s vs 16s)\n- The resultant graph contains more loops and sharp corners, as these represent the main paths found during early exploration \n- The path found, whilst not perfect, is still sufficently good to keep the wild ants from starving\n- occasionally this suffers from early termination, so another termination condition is required `min_ants` to prevent this","9c14492c":"# ant_speed\n\nIncreasing `ant_speed` affects the number of steps taken per epoch loop\n- This doesn't have much effect on the mechanics of the underlying algroythem\n- It provides a small performance optimization, as it reduces the number of epoch loops\n    - The effect of `ant_speed` is much more noticable when not using numpy vectorization\n    - The numpy implemention defaults to `1` for algorithm fidelity\n- If `ant_speed` is set too high, then the ants effectively jump from city to city without any travel time\n    - This slightly distorts the algorithm in theory, but the effect on path costs is within noise levels for statistical variation\n- Setting `ant_speed=0` attempts an auto-optimized value of: `median distance between nodes \/\/ 5`","79f6b803":"# Map\n\nFirst let us define a map of cities","fea72f5a":"# start_smell\n\nThis affects the amount of pheromones on the map at the start of the search. High values encourage more randomness in early exploration.\n- The effects of this are more noticable with a lower `self.distance_power`\n- If the `start_smell` is too low, the ants quickly converge on the first non-optimal path, then take longer to correct themselves\n- If the `start_smell` is too high, then it will take a long time for the pheromones left by the ants to overpower the `start_smell`\n    - This can also distort the pheromones trail left by randomly wandering ants, leading to suboptimal paths\n- If the `start_smell` is very high, then this completely overpowers the pheromone map, leaving the ants to rely on the distance metric alone\n- If the `start_smell` is just right, the ants will have a good balance between optimization and exploration and quickly converge\n- `start_smell=0` defaults to `10**self.distance_power`\n","efe427b3":"# best_path_smell\n\nThis is the reward given by the queen for finding a new best path and encourages more ants to explore around this new route\n\n- This has less effect on short runtimes\n- `best_path_smell == -1` \n    - with `pheromone_power=1`:     causes ants to go in random directions when then encounter negative pheromones\n    - with `pheromone_power=1.25`:  throws an exception due to comparing: float > complex \u221a-1 numbers \n- `best_path_smell < 1` effectively tells the ants to stop exploring the best path. This converges quickly on a poor score.\n- `best_path_smell == 1` removes this functionality, the ants still find a reasonable path\n- `best_path_smell > 1` improves the ability for ants to continually find better paths, and not give up so quickly\n    - it doesn't need to be much above 1 for it to work (the ants all follow each other, creating a feedback loop)\n    - higher values don't produce any additional effect\n    - setting it very high (5+) undoes this effect as prevents the ants from exploring neighbouring routes\n- `best_path_smell > 2` \n    - is required for this heuristic to be most effective at `distance_power=0` \n    - still works just as well for `distance_power=1` or `distance_power=2`  \n    - the default value is `2`","b99a7bbd":"Opps, we have suffered from early termination. Lets try to fix this:","e9281179":"# Meet the Ant Colony\n\n- For performance reasons, the ants are represented as a set of 2048 wide numpy arrays, which allows for fast vectorized operations\n- Many of the parameters are tunable, which will affect the internal logic of the ant colony, but have been set to sensible\/optimal defaults\n- The high-level logic of the algorithm is: \n    - we set the ants off on a random walk, each individually undertaking the quest of Travelling Saleman\n        - `ant_count` defines the number of ants in the numpy array\n        - `ant_speed` defines how many steps each ant travels per epoch\n    - ants individually keep track of: \n        - `path` list of the cities they have previously visited\n        - the set of `remaining` cities they still need to visit\n        - `distance` to their next destination\n        - `path_cost` of how many steps they have taken\n        - the number of `round_trips` they have made to colony       \n    - when the ants are travelling, there is a vectorized countdown of `distance`\n    - when an ant arrives at a node:\n        - it randomly selects a new destination on its remaining list\n        - its choice is weighted by the amount pheromones left by other ants\n        - `pheromone_power` affects the how strongly ants are affected by small differences in pheromones\n        - `distance_power`  affects the awareness the ants have of distance, ie a preference to visit closer nodes first\n        - `reward_power`    affects how `best_path\/current_path` is used when laying new pheromones \n            - `** -3` was counterintuitively discovered as optimal\n            - this encourages ants to explore longer paths around the strongest pheromones trail\n        - `decay_power`     affects how quickly old pheromone trails decay\n        - once an ant has visited all the nodes on its list, it returns home\n    - once an ant returns home:\n        - it updates the `self.pheromones` map for its completed path, telling the others that this way is popular\n        - the pheromone reward increases with `self.round_trips` which has the effect of slowly decaying older pheromone trails\n        - it updates the `self.ants_used` count    \n        - it updates its individual `self.round_trips` count            \n        - the ant resets and begins the Travelling Sales Problem again\n    - if the ant has found a new best-yet path:\n        - it informs the queen who keeps a record of the best path\n        - the queen doubles the pheromones along this new best path, which doubles probability of ants exploring this path\n        - `best_path_smell` controls the multipler the queen uses when a new best path is found \n    - Termination: there are several configurable options:\n        - `self.stop_factor`   ant logic: if a new best path was found, then redouble efforts in search of a new best path before quitting\n            - a factor of 2 will terminate in double the time required to find the last best path\n            - a factor of 4 is more reliable in preventing early termination in some cases (but can be very time consuming)\n        - `self.time`          run for a fixed number of seconds then stop\n        - `self.min_time`      run for a minimum number of seconds before terminating naturally \n        - `self.timeout`       run for a maximum number of seconds but may terminate naturally beforehand\n        - `self.round_trips`   wait for a minimum number of round_trips as a precondition to terminating (default 4)\n        ","a714d21b":"# Ant Colony Optimization Algorithm\n\nThis notebook explains the Ant Colony Optimization Algorithm as applied to the Travelling Salesman Problem. \n- https:\/\/en.wikipedia.org\/wiki\/Ant_colony_optimization_algorithms \n- https:\/\/en.wikipedia.org\/wiki\/Travelling_salesman_problem\n\n\nThe Travelling Salesman Problem is a classic NP-hard problem and defined as:\n> Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?\n\nOne possible solution is take inspiration from an Ant Colony and how it used decentralized intelligence to find food:\n- the colony as a whole can be considered a single decentralized organism\n  - evolutionarily speaking, the queen carries the genetic information for the entire colony\n  - individual ants performing the same role as individual cells in a human body\n- ants communicate using pheromones and leave a pheromone trail behind them as they walk\n- when no food is found, scouts will randomly wander around looking for food\n- when a scout finds food, it will carry it home and leave a pheromone trail signalling that there is food in this direction\n- the scout will encourage worker ants to follow it back to the food\n- the worker ants will generally follow the strongest pheromone trail, but sometimes randomly wander off it\n- the worker ants will also leave a pheromone trail behind them, and the more ants that follow a path, the stronger that pheromone trail will become\n- once a worker ant has found food, it will follow and strengthen the pheromone trail back home\n- if an ant accidentally finds a shorter path, it's round trip times will be shorter than on longer path, more round-trips mean more pheromones\n- as the pheromones along the shorter path build up faster than along the longer path, it will encourage more ants to explore this path, building up the pheromones even more quickly\n- eventually the network of pheromone trails will map out near-optimal solutions for the shortest paths between food locations\n- when the food runs out, the ants will disperse as scouts, and the old pheromone trails will fade away\n- however if the ants are not careful, they can all end up in a death spiral, all following each other in a circle but not going anywhere\n\n\nThe Ant Colony Optimization Algorithm can be extended using KMeans clustering, which provides an order of magnitude performance improvement for larger map sizes N=64 to N=512\n- https:\/\/www.kaggle.com\/jamesmcguigan\/kmeans-ant-colony-optimization","2e8d4b80":"# Solving the Traveling Salesman Problem\n\nThe first round of ants quickly find a reasonable path, then the colony quickly converges on a near-optimal path\n- There are 1024 ants travelling around at any one time\n- The ants follow and create pheromones trail, but they also use a `1\/distance` metric for determining the next city to go to\n- Originally the ants used a `1\/distance^2` heuristic, but after hyperparameter tuning, it was discovered that `1\/distance` could produce equlivant results (and is now the default)\n- The ants will keep redoubling their efforts until they can no longer find better best path "}}