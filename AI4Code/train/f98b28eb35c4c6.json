{"cell_type":{"5710ed41":"code","66b5f847":"code","22419593":"code","dd773d0a":"code","3560e6e6":"code","41aaed93":"code","c9c215b9":"code","e22469de":"code","48ce1ffc":"code","00b7d054":"code","87cc9220":"code","547777a6":"code","0a6579ae":"code","e811252d":"code","1f05bc70":"code","14a855e3":"code","f5a92d0f":"code","98e43064":"code","7f1f33b6":"code","af7dda35":"code","47096e0a":"code","494397d4":"code","60b3ce91":"code","83165b85":"code","78520a15":"code","2e5aa21d":"code","6cdf1c82":"markdown","328a67ef":"markdown","baa95c41":"markdown","9ed6fc6a":"markdown","f8806f67":"markdown","14b0bb93":"markdown","80e35a5a":"markdown","11f3921f":"markdown","d35e014f":"markdown","a3b8db89":"markdown","508691e8":"markdown"},"source":{"5710ed41":"%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport seaborn as sns\nplt.rcParams[\"figure.figsize\"] = (15, 10)\nplt.rcParams[\"figure.dpi\"] = 125\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams['font.family'] = ['sans-serif']\nplt.rcParams['font.sans-serif'] = ['DejaVu Sans']\nplt.style.use('ggplot')\nsns.set_style(\"whitegrid\", {'axes.grid': False})\nplt.rcParams['image.cmap'] = 'gray' # grayscale looks better\nfrom itertools import cycle\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']","66b5f847":"from pathlib import Path\nimport numpy as np\nimport doctest\nimport copy\nfrom skimage.io import imread as imread_raw\ndef imread(x, as_gray=True):\n    c_img = imread_raw(x, as_gray=as_gray)\n    if c_img.max()<10:\n        c_img = (c_img.astype('float32')*255).clip(0, 255).astype('uint8')\n    return c_img\nfrom skimage.util import montage as montage2d\nfrom skimage.color import label2rgb\n\n# tests help notebooks stay managable\ndef autotest(func):\n    globs = copy.copy(globals())\n    globs.update({func.__name__: func})\n    doctest.run_docstring_examples(\n        func, globs, verbose=True, name=func.__name__)\n    return func\n","22419593":"np.random.seed(2019)\nxx = np.stack([np.arange(5)]*5, -1)\nyy = xx.T\nbins_sample_8bit = np.linspace(0, 255, 8)\nsample_img = (25*(xx+yy)+np.random.uniform(-10, 10, size=(5, 5))).astype('uint8')\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6,3))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax2.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)","dd773d0a":"test_image_path = Path('..') \/ 'input' \/ 'test_images'\nall_images = sorted(list(test_image_path.glob('*.jpg')))\nprint('Found', len(all_images), 'images')","3560e6e6":"bins_8bit = np.linspace(0, 255, 26)\nfig, m_axs = plt.subplots(5, 2, figsize=(15, 10))\nfor (c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path, as_gray=True)\n    c_ax.imshow(c_img)\n    d_ax.hist(c_img.ravel(), bins_8bit)","41aaed93":"from skimage.exposure import rescale_intensity","c9c215b9":"\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = rescale_intensity(sample_img)\ntrans_name = 'Normalized'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","e22469de":"fig, m_axs = plt.subplots(5, 2, figsize=(15, 10))\nfor (c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path)\n    n_img = rescale_intensity(c_img)\n    c_ax.imshow(n_img)\n    c_ax.set_title('Old Range {}\\nNew Range {}'.format((c_img.min(), c_img.max()), \n                                                       (n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","48ce1ffc":"@autotest\nclass skl_image_wrapper():\n    \"\"\"Simple wrapper around SKLearn functions for images.\n    >>> from sklearn.preprocessing import Normalizer\n    >>> ski_norm = skl_image_wrapper(Normalizer())\n    >>> np.power(ski_norm.fit_transform(np.eye(2)), 2)\n    array([[0.5, 0. ],\n           [0. , 0.5]])\n    >>> ski_norm.fit_transform(np.ones((1,)))\n    Traceback (most recent call last):\n       ...\n    ValueError: Invalid Input Shape (1,)\n    \"\"\"\n    def __init__(self, parent):\n        self._parent = parent\n    def __getattr__(self, name):\n        attr = getattr(self._parent, name)\n        if callable(attr):\n            def _newfunc(X, *args, **kwargs):\n                X_shape = np.shape(X)\n                batch_size = X_shape[0]\n                fix_rgb = False\n                if len(X_shape)==2:\n                    # just one 2d image\n                    Xt = np.reshape(X, (-1, 1))\n                    batch_size = Xt.shape[0]\n                elif (len(X_shape)==3) and (X_shape[3]<=3):\n                    # rgb image (or hsv or greyscale)\n                    Xt = np.reshape(X.swapaxes(0, 2).swapaxes(1, 2), (X_shape[3], -1))\n                    fix_rgb = True\n                    batch_size = X_shape[3]\n                elif len(X_shape) in [3, 4]:\n                    # multiple multichannel images\n                    # or multiple images in 2D\n                    Xt = np.reshape(X, (X_shape[0], -1))\n                else:\n                    raise ValueError('Invalid Input Shape {}'.format(X_shape))\n                \n                result = attr(Xt, *args, **kwargs)\n                \n                if fix_rgb:\n                    result = result.swapaxes(0, 1)\n                \n                if np.prod(np.shape(result))==np.prod(X_shape):\n                    return np.reshape(result, X_shape)\n                else:\n                    return np.reshape(result, (batch_size, -1))\n            return _newfunc\n        else:\n            return attr","00b7d054":"from sklearn.preprocessing import Normalizer, MinMaxScaler, RobustScaler\nski_robust_norm = skl_image_wrapper(RobustScaler(quantile_range=(25, 75)))\ndef robust_norm_func(in_img):\n    out_img = ski_robust_norm.fit_transform(in_img)\n    return (out_img*127+127).clip(0, 255).astype('uint8')","87cc9220":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = robust_norm_func(sample_img)\ntrans_name = 'Robust Normalizer'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","547777a6":"fig, m_axs = plt.subplots(5, 2, figsize=(15, 10))\nfor (c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path)\n    n_img = robust_norm_func(c_img)\n    c_ax.imshow(n_img)\n    c_ax.set_title('Old Range {}\\nNew Range {}'.format((c_img.min(), c_img.max()), \n                                                       (n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","0a6579ae":"from skimage.exposure import equalize_hist\nequalize_hist_8bit = lambda in_img: (equalize_hist(in_img)*255).clip(0, 255).astype('uint8')","e811252d":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = equalize_hist_8bit(sample_img)\ntrans_name = 'Equalized'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","1f05bc70":"fig, m_axs = plt.subplots(4, 3, figsize=(15, 10))\nfor (b_ax, c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path, as_gray=True)\n    b_ax.imshow(c_img)\n    b_ax.axis('off')\n    b_ax.set_title('Old Range {}'.format((c_img.min(), c_img.max())))\n    n_img = equalize_hist_8bit(c_img)\n    c_ax.imshow(n_img)\n    c_ax.axis('off')\n    c_ax.set_title('New Range {}'.format((n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","14a855e3":"from scipy.signal import detrend\ndef detrend_img(in_img): \n    out_img = detrend(detrend(in_img.astype('float32'), axis=0), axis=1)\n    return (255.0*(out_img-out_img.min())\/(out_img.max()-out_img.min())).clip(0, 255).astype('uint8')\n","f5a92d0f":"# 1D example\ny = np.random.uniform(-1, 1, size=(30))+np.arange(30)*0.1\nfig, ax1 = plt.subplots(1,1, figsize=(8, 4))\nax1.plot(y, label='Raw Signal')\nax1.plot(detrend(y), label='Detrended Signal')\nax1.plot(y-detrend(y), label='Trend (subtracted from raw signal)')\nax1.legend()","98e43064":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = detrend_img(sample_img)\ntrans_name = 'Detrended'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","7f1f33b6":"fig, m_axs = plt.subplots(4, 3, figsize=(15, 10))\nfor (b_ax, c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path, as_gray=True)\n    b_ax.imshow(c_img)\n    b_ax.axis('off')\n    b_ax.set_title('Old Range {}'.format((c_img.min(), c_img.max())))\n    n_img = detrend_img(c_img)\n    c_ax.imshow(n_img)\n    c_ax.axis('off')\n    c_ax.set_title('New Range {}'.format((n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","af7dda35":"from cv2 import createCLAHE\nlittle_clahe_obj = createCLAHE(clipLimit=4, tileGridSize=(3, 3))\nclahe_obj = createCLAHE(clipLimit=4, tileGridSize=(16, 16))","47096e0a":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = little_clahe_obj.apply(sample_img)\ntrans_name = 'CLAHE'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","494397d4":"fig, m_axs = plt.subplots(4, 3, figsize=(15, 10))\nfor (b_ax, c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path, as_gray=True)\n    b_ax.imshow(c_img)\n    b_ax.axis('off')\n    b_ax.set_title('Old Range {}'.format((c_img.min(), c_img.max())))\n    n_img = clahe_obj.apply(c_img)\n    c_ax.imshow(n_img)\n    c_ax.axis('off')\n    c_ax.set_title('New Range {}'.format((n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","60b3ce91":"import math\nimport numpy\n\n\"\"\"\nOriginal Code at https:\/\/github.com\/nearlyfreeapps\/Rolling-Ball-Algorithm\/blob\/master\/rolling_ball.py\nPorted to Python from ImageJ's Background Subtractor.\nOnly works for 8-bit greyscale images currently.\nDoes not perform shrinking\/enlarging for larger radius sizes.\nBased on the concept of the rolling ball algorithm described\nin Stanley Sternberg's article,\n\"Biomedical Image Processing\", IEEE Computer, January 1983.\nImagine that the 2D grayscale image has a third (height) dimension by the image\nvalue at every point in the image, creating a surface. A ball of given radius\nis rolled over the bottom side of this surface; the hull of the volume\nreachable by the ball is the background.\nhttp:\/\/rsbweb.nih.gov\/ij\/developer\/source\/ij\/plugin\/filter\/BackgroundSubtracter.java.html\n\"\"\"\n\n\ndef smooth(array, window=3.0):\n    \"\"\"\n    Applies a 3x3 mean filter to specified array.\n    \"\"\"\n    dx, dy = array.shape\n    new_array = numpy.copy(array)\n    edgex = int(math.floor(window \/ 2.0))\n    edgey = int(math.floor(window \/ 2.0))\n\n    for i in range(dx):\n        for j in range(dy):\n            window_array = array[max(i - edgex, 0):min(i + edgex + 1, dx),\n                                 max(j - edgey, 0):min(j + edgey + 1, dy)]\n            new_array[i, j] = window_array.mean()\n    return new_array\n\n\ndef rolling_ball_float_background(float_array, radius, invert, smoothing,\n                                  ball):\n    \"\"\"\n    Create background for a float image by rolling a ball over the image\n    \"\"\"\n    pixels = float_array.flatten()\n    shrink = ball.shrink_factor > 1\n\n    if invert:\n        for i in range(len(pixels)):\n            pixels[i] = -pixels[i]\n\n    if smoothing:\n        smoothed_pixels = smooth(numpy.reshape(pixels, float_array.shape))\n        pixels = smoothed_pixels.flatten()\n\n    pixels = roll_ball(ball, numpy.reshape(pixels, float_array.shape))\n\n    if invert:\n        for i in range(len(pixels)):\n            pixels[i] = -pixels[i]\n    return numpy.reshape(pixels, float_array.shape)\n\n\ndef roll_ball(ball, array):\n    \"\"\"\n    Rolls a filtering object over an image in order to find the\n    image's smooth continuous background.  For the purpose of explaining this\n    algorithm, imagine that the 2D grayscale image has a third (height)\n    dimension defined by the intensity value at every point in the image.  The\n    center of the filtering object, a patch from the top of a sphere having\n    radius 'radius', is moved along each scan line of the image so that the\n    patch is tangent to the image at one or more points with every other point\n    on the patch below the corresponding (x,y) point of the image.  Any point\n    either on or below the patch during this process is considered part of the\n    background.\n    \"\"\"\n    height, width = array.shape\n    pixels = numpy.float32(array.flatten())\n    z_ball = ball.data\n    ball_width = ball.width\n    radius = ball_width \/\/ 2\n    cache = numpy.zeros(width * ball_width)\n\n    for y in range(-radius, height + radius):\n        next_line_to_write_in_cache = (y + radius) % ball_width\n        next_line_to_read = y + radius\n        if next_line_to_read < height:\n            src = next_line_to_read * width\n            dest = next_line_to_write_in_cache * width\n            cache[dest:dest + width] = pixels[src:src + width]\n            p = next_line_to_read * width\n            for x in range(width):\n                pixels[p] = -float('inf')\n                p += 1\n        y_0 = y - radius\n        if y_0 < 0:\n            y_0 = 0\n        y_ball_0 = y_0 - y + radius\n        y_end = y + radius\n        if y_end >= height:\n            y_end = height - 1\n        for x in range(-radius, width + radius):\n            z = float('inf')\n            x_0 = x - radius\n            if x_0 < 0:\n                x_0 = 0\n            x_ball_0 = x_0 - x + radius\n            x_end = x + radius\n            if x_end >= width:\n                x_end = width - 1\n            y_ball = y_ball_0\n            for yp in range(y_0, y_end + 1):\n                cache_pointer = (yp % ball_width) * width + x_0\n                bp = x_ball_0 + y_ball * ball_width\n                for xp in range(x_0, x_end + 1):\n                    z_reduced = cache[cache_pointer] - z_ball[bp]\n                    if z > z_reduced:\n                        z = z_reduced\n                    cache_pointer += 1\n                    bp += 1\n                y_ball += 1\n\n            y_ball = y_ball_0\n            for yp in range(y_0, y_end + 1):\n                p = x_0 + yp * width\n                bp = x_ball_0 + y_ball * ball_width\n                for xp in range(x_0, x_end + 1):\n                    z_min = z + z_ball[bp]\n                    if pixels[p] < z_min:\n                        pixels[p] = z_min\n                    p += 1\n                    bp += 1\n                y_ball += 1\n\n    return numpy.reshape(pixels, array.shape)\n\n\nclass RollingBall(object):\n    \"\"\"\n    A rolling ball (or actually a square part thereof).\n    \"\"\"\n    def __init__(self, radius):\n        if radius <= 10:\n            self.shrink_factor = 1\n            arc_trim_per = 24\n        elif radius <= 30:\n            self.shrink_factor = 2\n            arc_trim_per = 24\n        elif radius <= 100:\n            self.shrink_factor = 4\n            arc_trim_per = 32\n        else:\n            self.shrink_factor = 8\n            arc_trim_per = 40\n        self.build(radius, arc_trim_per)\n\n    def build(self, ball_radius, arc_trim_per):\n        small_ball_radius = ball_radius \/ self.shrink_factor\n        if small_ball_radius < 1:\n            small_ball_radius = 1\n        rsquare = small_ball_radius * small_ball_radius\n        xtrim = int(arc_trim_per * small_ball_radius) \/ 100\n        half_width = int(round(small_ball_radius - xtrim))\n        self.width = (2 * half_width) + 1\n        self.data = [0.0] * (self.width * self.width)\n\n        p = 0\n        for y in range(self.width):\n            for x in range(self.width):\n                xval = x - half_width\n                yval = y - half_width\n                temp = rsquare - (xval * xval) - (yval * yval)\n\n                if temp > 0:\n                    self.data[p] = float(math.sqrt(temp))\n                p += 1","83165b85":"@autotest\ndef rolling_ball_background(array, radius, light_background=True,\n                            smoothing=True):\n    \"\"\"\n    Calculates and subtracts background from array.\n    Arguments:\n    array - uint8 numpy array representing image\n    radius - radius of the rolling ball creating the background\n    light_background - Does image have light background\n    smoothing - Whether the image should be smoothed before creating the\n                background.\n    >>> in_image = 1-np.eye(4)\n    >>> rolling_ball_background(in_image, 2)\n    array([[0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0]], dtype=int8)\n    >>> rolling_ball_background(np.ones_like(in_image), 2)\n    array([[0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0]], dtype=int8)\n    \"\"\"\n    invert = False\n    if light_background:\n        invert = True\n\n    ball = RollingBall(radius)\n    float_array = array\n    float_array = rolling_ball_float_background(float_array, radius, invert,\n                                                smoothing, ball)\n    background_pixels = float_array.flatten()\n\n    if invert:\n        offset = 255.5\n    else:\n        offset = 0.5\n    pixels = numpy.int8(array.flatten())\n\n    for p in range(len(pixels)):\n        value = (pixels[p] & 0xff) - (background_pixels[p] + 255) + offset\n        if value < 0:\n            value = 0\n        if value > 255:\n            value = 255\n\n        pixels[p] = numpy.int8(value)\n\n    return numpy.reshape(pixels, array.shape)","78520a15":"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4))\nsns.heatmap(sample_img, annot=True,fmt='02d', ax=ax1, cmap='viridis')\nax1.set_title('Original')\nax1.axis('off')\ntrans_img = rolling_ball_background(sample_img, 2)\ntrans_name = 'Rolling Ball'\nsns.heatmap(trans_img, annot=True,fmt='02d', ax=ax2, cmap='viridis')\nax2.set_title(trans_name)\nax2.axis('off')\nax3.hist(sample_img.ravel(), bins_sample_8bit, label='Original', alpha=1)\nax3.hist(trans_img.ravel(), bins_sample_8bit, label=trans_name, alpha=0.5)\nax3.legend()","2e5aa21d":"fig, m_axs = plt.subplots(4, 3, figsize=(15, 10))\nfor (b_ax, c_ax, d_ax), c_image_path in zip(m_axs, all_images):\n    c_img = imread(c_image_path, as_gray=True)\n    b_ax.imshow(c_img)\n    b_ax.axis('off')\n    b_ax.set_title('Old Range {}'.format((c_img.min(), c_img.max())))\n    n_img = rolling_ball_background(c_img, 5)\n    c_ax.imshow(n_img)\n    c_ax.axis('off')\n    c_ax.set_title('New Range {}'.format((n_img.min(), n_img.max())))\n    d_ax.hist(n_img.ravel(), bins_8bit)","6cdf1c82":"## Setup Code\nJust the imports and setup we need to get started","328a67ef":"# Local Equalization\nWe can use a technique called contrast limited adaptive histogram equalization (CLAHE) which goes through tiles in the image and equalizes them individually and thus corrects illumination differences over the entire image","baa95c41":"# Rolling Ball Background Subtraction\nThis method (based on ImageJ\/FIJI) uses a rolling ball. It rolls a filtering object over an image in order to find the image's smooth continuous background The code here is a copy paste rip-off from https:\/\/github.com\/nearlyfreeapps\/Rolling-Ball-Algorithm\/blob\/master\/rolling_ball.py\n","9ed6fc6a":"# scikit-learn Normalizations\nScikit-Learn offers a number of more advanced normalizations that we can use as well. We just require a little wrapper to use them with images","f8806f67":"# Overview\nThis notebook shows a few different background correction techniques for dealing with uneven illumination as part of the [Quantitative Big Imaging course at ETH Zurich](https:\/\/kmader.github.io\/Quantitative-Big-Imaging-2019\/). While not actually part of the competition, the steel defect dataset\/competition is an excellent example of lots of different ways the illumination can be uneven and how making the images more consistent can help.\n","14b0bb93":"## Show a few examples\nHere we can see the problems that come up in the images","80e35a5a":"# Normalization\nThe simplist technique we can do is just normalize the histograms","11f3921f":"# Load Images","d35e014f":"# Equalization","a3b8db89":"# Detrending\nThe easiest background correction to do is detrending","508691e8":"## Sample Image\nA sample image to see what happens as we apply different techniques"}}