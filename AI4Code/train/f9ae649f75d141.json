{"cell_type":{"f5cbcd44":"code","90c45b26":"code","4f45a0da":"code","e37e510f":"code","a23381b3":"code","986ceea7":"code","2ef9d15b":"code","8ad798d2":"code","51dd019e":"code","85d45413":"code","16801f1d":"code","e4400b56":"code","06101165":"code","9c6df539":"code","413774e4":"code","e039c6e8":"code","100b55d3":"code","c2460784":"code","ab0f6161":"code","ed1661b3":"code","1c6d5203":"code","1fad192e":"code","e235f3ac":"code","25d1de46":"code","d78955da":"code","1935e1a5":"code","c2aec434":"markdown","a3dbbee1":"markdown"},"source":{"f5cbcd44":"## pip install numpy\nimport numpy as np\n\n## pip install matplotlib\nimport matplotlib.image as mpimg  # mpimg.imread(path)\nimport matplotlib.pyplot as plt  # plt.imshow(np.array)","90c45b26":"## Creating an image\nimg = np.zeros(shape=(8, 8))\n\nplt.imshow(img, cmap='gray')\nplt.show()","4f45a0da":"## Manually modifying an image\nimg = np.zeros(shape=(8, 8))\n\nimg[2:4, 1:3] = 1.\nimg[2:4, 5:7] = 1.\nimg[4:5, 3:5] = 1.\nimg[5:7, 2:6] = 1.\nimg[([7, 7], [2, 5])] = 1.\n\nplt.imshow(img, cmap='gray')  # cmap is color mapping ie func(number) -> color\nplt.show()","e37e510f":"## RGB Pixels as Numpy array\nimg = mpimg.imread('..\/input\/cat-images\/cat.jpg')\n\nprint(img[:2, : 2])\nplt.imshow(img[:2, :2], cmap='gray')\nplt.show()","a23381b3":"## Read in image\nimg = mpimg.imread('..\/input\/planet-images\/Venus-580x580.jpg')\n\n## Visualize image\nplt.imshow(img)\nplt.show()","986ceea7":"## Extracting color channels via indexing\nredchannel = img[:, :, 0]\n\nplt.imshow(redchannel, cmap='Reds')  ## Note change in color map\nplt.show()","2ef9d15b":"## Image Dimensions via Shape\n# height, width, channels=1\nprint('Shape of 3 Channel Image')\nprint(img.shape)\nprint()\nprint('Shape of Red Channel Image')\nprint(redchannel.shape)","8ad798d2":"## Cropping image via Slicing\nheight_split = img.shape[0] \/\/ 2\n\ncropped = img[height_split:]\n\nplt.imshow(cropped, cmap='gray')\nplt.show()","51dd019e":"## Grayscaling \/\/ Averaging\ngrayscale = np.mean(img, axis=2)\n\nplt.imshow(grayscale, cmap='gray')\nplt.show()","85d45413":"## The Numbers that make the Images\nprint('RGB Three Channel Image')\nprint(img[:2, :2])\nprint('-'*10)\nprint('Red Channel of Image')\nprint(redchannel[:2, :2])\nprint('-'*10)\nprint('Grayscaled 3 Channel Image')\nprint(grayscale[:2, :2])\nprint('')\nprint('Four channels exist in some images, ie the alpha channel in a .PNG or the depth channel from our realsense cameras')","16801f1d":"## Cat\nimg2 = mpimg.imread('..\/input\/cat-images\/cat2.jpg')\n\nplt.imshow(img2)\nplt.show()","e4400b56":"## You can use np.where to set image colors based on a conditional\nbinarize = np.where(img2 < 122, 255, 0)\n\nprint(binarize[14:16, :2])\n\nplt.imshow(binarize)\nplt.show()","06101165":"## Binarizing a grayscale image\ngrayscale2 = np.mean(img2, axis=2)\n\nbinarize2 = np.where(grayscale2 > 122, 255, 0)\n\nprint(binarize2[14:16, :2])\n\nplt.imshow(binarize2, cmap='gray')\nplt.show()","9c6df539":"## Read in Image\nwhole_qr = mpimg.imread('..\/input\/qr-codes\/qr_dataset\/1011-v4.png')\nplt.imshow(whole_qr)\nplt.show()","413774e4":"## Split an image with slicing and put it back together\nhorizontal_split = whole_qr.shape[1] \/\/ 2\nvertical_split = whole_qr.shape[0] \/\/ 2\n\nqr_q1 = whole_qr[:vertical_split, :horizontal_split]\nqr_q2 = whole_qr[:vertical_split, horizontal_split:]\nqr_q3 = whole_qr[vertical_split:, :horizontal_split]\nqr_q4 = whole_qr[vertical_split:, horizontal_split:]\n\n## Combine sections and show\ntop = np.concatenate((qr_q4, qr_q3), axis=1)\nbottom = np.concatenate((qr_q2, qr_q1), axis=1)\n\nnew_qr = np.concatenate((top, bottom), axis=0)\n\nplt.imshow(new_qr)\nplt.show()","e039c6e8":"## Rotate images in numpy\n# Note: cannot transpose 3 channel image because it will break the 3 channel system.\n\n# 180\nrotated = np.rot90(new_qr)\n\n# np.rot90(new_qr) also exists\n\nplt.imshow(rotated)\nplt.show()","100b55d3":"## Get a new planet\nplanet = mpimg.imread('..\/input\/planet-images\/True-colour_image_of_Mars_seen_by_OSIRIS-580x580.jpg')\n\nplt.imshow(planet)\nplt.show()","c2460784":"## Flip red and blue channels\nplanet2 = np.copy(planet)\n\nbuffer = planet2[:, :, 2]\nplanet2[:, :, 2] = planet2[:, :, 0]\nplanet2[:, :, 0] = buffer\n\nplt.imshow(planet2)\nplt.show()","ab0f6161":"## Remove red channel\nplanet3 = np.copy(planet)\n\nplanet3[:, :, 0] = 0\n\nplt.imshow(planet3)\nplt.show()","ed1661b3":"## Invert the image, replace the background w\/ black\nplanet4 = np.copy(planet)\n\nplanet4 = 255 - planet4\n\nplt.imshow(planet4)\nplt.show()","1c6d5203":"## Add two images\n# Example\na = np.arange(0, 255, 25)\ninverse_a = 255 - a\n\nprint(a + inverse_a)\n\n# Planet + (255 - Planet)\nplt.imshow(planet + planet4)\nplt.show()","1fad192e":"## The original image had a black background, so the goal here is to acheive that with planet4\nplanet4_better = np.copy(planet4)\n\n# this is called a mask, just like the one in a masked array\nwhite_spots = np.sum(planet4, axis=2) == 255 * 3\n\nprint('Mask, true if the given pixel is pure white')\nprint(white_spots)\n\n# the mask is then used to index the values in planet4_better that have white pixels\nplanet4_better[white_spots] = np.array([0, 0, 0])\n\nplt.imshow(planet4_better)\nplt.show()","e235f3ac":"## Images are not exact, you gotta work with the noise my dude\nplanet4_way_better = np.copy(planet4_better)\n\n# this is called a mask, just like the one in a masked array\nsomewhat_white_spots = np.mean(planet4, axis=2) >= 200\n\n# the mask is then used to index the values in planet4_better that have white pixels\nplanet4_way_better[somewhat_white_spots] = np.array([0, 0, 0])\n\nplt.imshow(planet4_way_better)\nplt.show()","25d1de46":"## Cat\ncat = mpimg.imread('..\/input\/cat-images\/cat.jpg')\n\nplt.imshow(cat)\nplt.show()","d78955da":"## Shrinking an Image\n# note: _ is because we dont care about the number of channels\ncat_height, cat_width, _ = cat.shape\n\nhalf_height_image = np.copy(cat)\n\n# Cut the height in half\nhalf_height_image = half_height_image[np.arange(0, cat_height, 2)]\n\nplt.imshow(half_height_image)\nplt.show()","1935e1a5":"# Cut the width in half\nhalf_size_image = np.copy(half_height_image)\n\nhalf_size_image = half_size_image[:, np.arange(0, cat_width, 2)]\n\nplt.imshow(half_size_image)\nplt.show()","c2aec434":"# Goal is to make the planet blue","a3dbbee1":"# Computer Vision 101 with Numpy\nIn Python, all of the popular image libraries use Numpy arrays to store images. This is because arrays in Numpy has an array structure that allows for contiguous memory in Python. Numpy has optimized various matrix and other general mathematical operations.\n\nNumpy is super fast and powerful.\n\nWhile OpenCV and similar libraries implement most of this functionality for you, it is important to know how they work at a lower level for debugging and writing your own functionality when necessary."}}