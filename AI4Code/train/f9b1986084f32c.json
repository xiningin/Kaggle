{"cell_type":{"1e9461eb":"code","7fc274b1":"code","590880f0":"code","4fbbbcf6":"code","6839cd41":"code","b1e53fa0":"code","12f3d75a":"code","7030a826":"code","2ceff2ac":"code","e359c191":"code","4da8b169":"markdown","604f884c":"markdown","ad43e72e":"markdown","27819004":"markdown","5fdceb48":"markdown","9ec77c34":"markdown"},"source":{"1e9461eb":"from mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n","7fc274b1":"print(os.listdir('..\/input'))","590880f0":"# Distribution graphs (histogram\/bar graph) of column data\ndef plotPerColumnDistribution(df, nGraphShown, nGraphPerRow):\n    nunique = df.nunique()\n    df = df[[col for col in df if nunique[col] > 1 and nunique[col] < 50]] # For displaying purposes, pick columns that have between 1 and 50 unique values\n    nRow, nCol = df.shape\n    columnNames = list(df)\n    nGraphRow = (nCol + nGraphPerRow - 1) \/ nGraphPerRow\n    plt.figure(num = None, figsize = (6 * nGraphPerRow, 8 * nGraphRow), dpi = 80, facecolor = 'w', edgecolor = 'k')\n    for i in range(min(nCol, nGraphShown)):\n        plt.subplot(nGraphRow, nGraphPerRow, i + 1)\n        columnDf = df.iloc[:, i]\n        if (not np.issubdtype(type(columnDf.iloc[0]), np.number)):\n            valueCounts = columnDf.value_counts()\n            valueCounts.plot.bar()\n        else:\n            columnDf.hist()\n        plt.ylabel('counts')\n        plt.xticks(rotation = 90)\n        plt.title(f'{columnNames[i]} (column {i})')\n    plt.tight_layout(pad = 1.0, w_pad = 1.0, h_pad = 1.0)\n    plt.show()\n","4fbbbcf6":"# Correlation matrix\ndef plotCorrelationMatrix(df, graphWidth):\n    filename = 'df'#df.dataframeName\n    df = df.dropna('columns') # drop columns with NaN\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    if df.shape[1] < 2:\n        print(f'No correlation plots shown: The number of non-NaN or constant columns ({df.shape[1]}) is less than 2')\n        return\n    corr = df.corr()\n    plt.figure(num=None, figsize=(graphWidth, graphWidth), dpi=80, facecolor='w', edgecolor='k')\n    corrMat = plt.matshow(corr, fignum = 1)\n    plt.xticks(range(len(corr.columns)), corr.columns, rotation=90)\n    plt.yticks(range(len(corr.columns)), corr.columns)\n    plt.gca().xaxis.tick_bottom()\n    plt.colorbar(corrMat)\n    plt.title(f'Correlation Matrix for {filename}', fontsize=15)\n    plt.show()\n","6839cd41":"# Scatter and density plots\ndef plotScatterMatrix(df, plotSize, textSize):\n    df = df.select_dtypes(include =[np.number]) # keep only numerical columns\n    # Remove rows and columns that would lead to df being singular\n    df = df.dropna('columns')\n    df = df[[col for col in df if df[col].nunique() > 1]] # keep columns where there are more than 1 unique values\n    columnNames = list(df)\n    if len(columnNames) > 10: # reduce the number of columns for matrix inversion of kernel density plots\n        columnNames = columnNames[:10]\n    df = df[columnNames]\n    ax = pd.plotting.scatter_matrix(df, alpha=0.75, figsize=[plotSize, plotSize], diagonal='kde')\n    corrs = df.corr().values\n    for i, j in zip(*plt.np.triu_indices_from(ax, k = 1)):\n        ax[i, j].annotate('Corr. coef = %.3f' % corrs[i, j], (0.8, 0.2), xycoords='axes fraction', ha='center', va='center', size=textSize)\n    plt.suptitle('Scatter and Density Plot')\n    plt.show()\n","b1e53fa0":"\"\"\"\nReading the data\nhttps:\/\/jon.oberheide.org\/blog\/2008\/10\/15\/dpkt-tutorial-2-parsing-a-pcap-file\/\nhttps:\/\/dpkt.readthedocs.io\/en\/latest\/_modules\/examples\/print_packets.html\n\"\"\"\n\nimport datetime\nimport socket\n\nimport dpkt\nimport numpy as np\nimport pandas as pd\nfrom dpkt.compat import compat_ord\n\n\ndef mac_addr(address):\n    \"\"\"Convert a MAC address to a readable\/printable string\n\n       Args:\n           address (str): a MAC address in hex form (e.g. '\\x01\\x02\\x03\\x04\\x05\\x06')\n       Returns:\n           str: Printable\/readable MAC address\n    \"\"\"\n    return ':'.join('%02x' % compat_ord(b) for b in address)\n\n\ndef inet_to_str(inet):\n    \"\"\"Convert inet object to a string\n\n        Args:\n            inet (inet struct): inet network address\n        Returns:\n            str: Printable\/readable IP address\n    \"\"\"\n    # First try ipv4 and then ipv6\n    try:\n        return socket.inet_ntop(socket.AF_INET, inet)\n    except ValueError:\n        return socket.inet_ntop(socket.AF_INET6, inet)\n\n\n##################################################################################\n\npackets_to_read = 10 ** 10\nf = open('..\/input\/ICMP.pcap', 'rb')\npcap = dpkt.pcapng.Reader(f)\ndpcap = {\n    'ts': [],\n    'eth_src': [],\n    'eth_dst': [],\n    'eth_type': [],\n    'ip_src': [],\n    'ip_dst': [],\n    'ip_len': [],\n    'ip_ttl': [],\n    'ip_df': [],\n    'ip_mf': [],\n    'ip_offset': [],\n    'type': [],\n    'tcp_dport': [],\n    'http_uri': [],\n    'http_method': [],\n    'http_version': [],\n    'http_headers_ua': [],\n}\nnon_ip_packets = dict()\nc = 0\n# For each packet in the pcap process the contents\nfor timestamp, buf in pcap:\n    \n    c += 1\n    if c > packets_to_read:\n        break\n\n    dpcap['ts'].append(str(datetime.datetime.utcfromtimestamp(timestamp)))  # timestamp in UTC\n\n    # Unpack the Ethernet frame (mac src\/dst, ethertype)\n    eth = dpkt.ethernet.Ethernet(buf)\n    dpcap['eth_src'].append(mac_addr(eth.src))\n    dpcap['eth_dst'].append(mac_addr(eth.dst))\n    dpcap['eth_type'].append(eth.type)\n\n    # Make sure the Ethernet frame contains an IP packet\n    if not isinstance(eth.data, dpkt.ip.IP):\n        #print('Non IP Packet type not supported %s\\n' % eth.data.__class__.__name__)\n        non_ip_packets[eth.data.__class__.__name__] = non_ip_packets.get(eth.data.__class__.__name__, 0) + 1\n        \n        dpcap['ts'].pop()\n        dpcap['eth_src'].pop()\n        dpcap['eth_dst'].pop()\n        dpcap['eth_type'].pop()\n        \n        continue\n\n    # Now unpack the data within the Ethernet frame (the IP packet)\n    # Pulling out src, dst, length, fragment info, TTL, and Protocol\n    ip = eth.data\n\n    # Pull out fragment information (flags and offset all packed into off field, so use bitmasks)\n    do_not_fragment = bool(ip.off & dpkt.ip.IP_DF)\n    more_fragments = bool(ip.off & dpkt.ip.IP_MF)\n    fragment_offset = ip.off & dpkt.ip.IP_OFFMASK\n\n    dpcap['ip_src'].append(inet_to_str(ip.src))\n    dpcap['ip_dst'].append(inet_to_str(ip.dst))\n    dpcap['ip_len'].append(ip.len)\n    dpcap['ip_ttl'].append(ip.ttl)\n    dpcap['ip_df'].append(do_not_fragment)\n    dpcap['ip_mf'].append(more_fragments)\n    dpcap['ip_offset'].append(fragment_offset)\n\n    dpcap['type'].append(ip.data.__class__.__name__)\n    \n    dpcap['tcp_dport'].append(np.nan)\n    dpcap['http_uri'].append(np.nan)\n    dpcap['http_method'].append(np.nan)\n    dpcap['http_version'].append(np.nan)\n    dpcap['http_headers_ua'].append(np.nan)\n    \n    if not isinstance(ip.data, dpkt.tcp.TCP):\n        continue\n    \n    tcp = ip.data\n    \n    dpcap['tcp_dport'].pop()\n    dpcap['tcp_dport'].append(tcp.dport)\n\n    if tcp.dport == 80 and len(tcp.data) > 2 or True:\n        #print(tcp.data)\n        try:\n            http = dpkt.http.Request(tcp.data)\n            dpcap['http_uri'].pop()\n            dpcap['http_uri'].append(http.uri)\n            #print http.uri\n            dpcap['http_method'][-1] = http.method\n            dpcap['http_version'][-1] = http.version\n            dpcap['http_headers_ua'][-1] = http.headers['user-agent']\n        except:\n            pass\n\ndf = pd.DataFrame.from_dict(dpcap)\nprint('non_ip_packets counter:', non_ip_packets)\ndf[df.http_uri.notnull()].head(20)","12f3d75a":"#df.astype('object').describe().transpose()\ndf.groupby(df.type).nunique()\n","7030a826":"#plotPerColumnDistribution(df, nGraphShown=50, nGraphPerRow=3)","2ceff2ac":"import collections\n\ncollections.Counter(df.http_uri)\n","e359c191":"df[['ip_src', 'ip_dst', 'http_headers_ua', 'http_uri', 'ts']].groupby(['ip_dst', 'ip_src', ]).agg(['count', 'min', 'max'])","4da8b169":"## Conclusion\nThis concludes your starter analysis! To go forward from here, click the blue \"Fork Notebook\" button at the top of this kernel. This will create a copy of the code and environment for you to edit. Delete, modify, and add code as you please. Happy Kaggling!","604f884c":"Oh, no! There are no automatic insights available for the file types used in this dataset. As your Kaggle kerneler bot, I'll keep working to fine-tune my hyper-parameters. In the meantime, please feel free to try a different dataset.","ad43e72e":"There is 0 csv file in the current version of the dataset:\n","27819004":"## Exploratory Analysis\nTo begin this exploratory analysis, first import libraries and define functions for plotting the data using `matplotlib`. Depending on the data, not all plots will be made. (Hey, I'm just a simple kerneling bot, not a Kaggle Competitions Grandmaster!)","5fdceb48":"## Introduction\nGreetings from the Kaggle bot! This is an automatically-generated kernel with starter code demonstrating how to read in the data and begin exploring. If you're inspired to dig deeper, click the blue \"Fork Notebook\" button at the top of this kernel to begin editing.","9ec77c34":"The next hidden code cells define functions for plotting data. Click on the \"Code\" button in the published kernel to reveal the hidden code."}}