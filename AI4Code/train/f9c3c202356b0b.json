{"cell_type":{"c9a4d139":"code","86856f16":"code","d32fb716":"code","0fdaaf88":"code","21f3927b":"code","648633e8":"code","0db6c530":"code","d44f5ff0":"code","ee1131a7":"code","318ea964":"code","751bde7b":"code","bcf352ed":"code","d4dc423a":"code","ff4eac8f":"code","d9900d99":"code","83a1deb4":"code","e1dd4828":"code","d445cc5f":"code","81f3f956":"code","9408fd1d":"code","1ac61ed4":"code","6ef3079e":"code","e21e35b5":"markdown","06f18501":"markdown","8cd2c80c":"markdown","b7ea1a33":"markdown","90d0ed94":"markdown","8d4085d3":"markdown","de92b3f2":"markdown","aceb9ab7":"markdown","e8e4fcc1":"markdown","ae4e68c7":"markdown","40a6fbb6":"markdown","7ce8019f":"markdown","8d5c31f4":"markdown","0367b796":"markdown","20d0fed5":"markdown","e6c5e8bd":"markdown","6fcb5cc7":"markdown","3c1fe711":"markdown","fab90ce7":"markdown","a2e222bf":"markdown","e599999f":"markdown","b2a94de4":"markdown","55f59fdb":"markdown","2f75d7b3":"markdown","b63c8c1f":"markdown","48fecf3a":"markdown"},"source":{"c9a4d139":"import pandas as pd\nimport numpy as np\nimport seaborn as sns #plotting\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport plotly.plotly as py\nimport plotly.graph_objs as go\nimport matplotlib.pyplot as plt\nfrom sklearn import preprocessing\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.tree import DecisionTreeClassifier\n%matplotlib inline\ninit_notebook_mode(connected=True)","86856f16":"df_reviews = pd.read_csv(\"..\/input\/googleplaystore_user_reviews.csv\")\ndf_reviews.head()","d32fb716":"df_apps = pd.read_csv(\"..\/input\/googleplaystore.csv\")\ndf_apps.head()","0fdaaf88":"categories = list(df_apps[\"Category\"].unique())\nprint(\"There are {0:.0f} categories! (Excluding\/Removing Category 1.9)\".format(len(categories)-1))\nprint(categories)\n#Remove Category 1.9\ncategories.remove('1.9')","21f3927b":"a = df_apps.loc[df_apps[\"Category\"] == \"1.9\"]\nprint(a.head())\nprint(\"This mislabeled app category affects {} app at index {}.\".format(len(a),int(a.index.values)))\ndf_apps = df_apps.drop(int(a.index.values),axis=0)","648633e8":"df_apps['Rating'].isnull().sum()","0db6c530":"df_apps = df_apps.drop(df_apps[df_apps['Rating'].isnull()].index, axis=0)","d44f5ff0":"df_apps.info()","ee1131a7":"df_apps[\"Rating\"].describe()","318ea964":"layout = go.Layout(\n    xaxis=dict(title='Ratings'),yaxis=dict(title='Number of Apps'))\ndata = [go.Histogram(x=df_apps[\"Rating\"])]\nfig = go.Figure(data=data, layout=layout)\niplot(fig, filename='basic histogram')\n","751bde7b":"#Show top 35 app genres\nplt.figure(figsize=(16, 9.5))\ngenres = df_apps[\"Genres\"].value_counts()[:35]\nax = sns.barplot(x=genres.values, y=genres.index, palette=\"PuBuGn_d\")","bcf352ed":"sns.set(rc={'figure.figsize':(20,10)}, font_scale=1.5, style='whitegrid')\nax = sns.boxplot(x=\"Category\",y=\"Rating\",data=df_apps)\nlabels = ax.set_xticklabels(ax.get_xticklabels(), rotation=45,ha='right')\n","d4dc423a":"#Cut away rows which have < 4.0 ratings\nhighRating = df_apps.copy()\nhighRating = highRating.loc[highRating[\"Rating\"] >= 4.0]\nhighRateNum = highRating.groupby('Category')['Rating'].nunique()\nhighRateNum","ff4eac8f":"df_apps.dtypes\ndf_apps[\"Type\"] = (df_apps[\"Type\"] == \"Paid\").astype(int)\ncorr = df_apps.apply(lambda x: x.factorize()[0]).corr()\nsns.heatmap(corr, xticklabels=corr.columns, yticklabels=corr.columns,annot=True)","d9900d99":"#Extract App, Installs, & Content Rating from df_apps\npopApps = df_apps.copy()\npopApps = popApps.drop_duplicates()\n#Remove characters preventing values from being floats and integers\npopApps[\"Installs\"] = popApps[\"Installs\"].str.replace(\"+\",\"\") \npopApps[\"Installs\"] = popApps[\"Installs\"].str.replace(\",\",\"\")\npopApps[\"Installs\"] = popApps[\"Installs\"].astype(\"int64\")\npopApps[\"Price\"] = popApps[\"Price\"].str.replace(\"$\",\"\")\npopApps[\"Price\"] = popApps[\"Price\"].astype(\"float64\")\npopApps[\"Size\"] = popApps[\"Size\"].str.replace(\"Varies with device\",\"0\")\npopApps[\"Size\"] = (popApps[\"Size\"].replace(r'[kM]+$', '', regex=True).astype(float) *\\\n        popApps[\"Size\"].str.extract(r'[\\d\\.]+([kM]+)', expand=False).fillna(1).replace(['k','M'], [10**3, 10**6]).astype(int))\npopApps[\"Reviews\"] = popApps[\"Reviews\"].astype(\"int64\")\n\npopApps = popApps.sort_values(by=\"Installs\",ascending=False)\npopApps.reset_index(inplace=True)\npopApps.drop([\"index\"],axis=1,inplace=True)\npopApps.loc[:40,['App','Installs','Content Rating']]","83a1deb4":"popAppsCopy = popApps.copy()\nlabel_encoder = preprocessing.LabelEncoder() \n  \n# Encode labels in column 'Category'. \npopAppsCopy['Category']= label_encoder.fit_transform(popAppsCopy['Category']) \npopAppsCopy['Content Rating']= label_encoder.fit_transform(popAppsCopy['Content Rating']) \npopAppsCopy['Genres']= label_encoder.fit_transform(popAppsCopy['Genres']) \npopAppsCopy.dtypes","e1dd4828":"popAppsCopy = popAppsCopy.drop([\"App\",\"Last Updated\",\"Current Ver\",\"Android Ver\"],axis=1)\nprint(\"There are {} total rows.\".format(popAppsCopy.shape[0]))\ncountPop = popAppsCopy[popAppsCopy[\"Installs\"] > 100000].count()\nprint(\"{} Apps are Popular!\".format(countPop[0]))\nprint(\"{} Apps are Unpopular!\\n\".format((popAppsCopy.shape[0]-countPop)[0]))\nprint(\"For an 80-20 training\/test split, we need about {} apps for testing\\n\".format(popAppsCopy.shape[0]*.20))\npopAppsCopy[\"Installs\"] = (popAppsCopy[\"Installs\"] > 100000)*1 #Installs Binarized\nprint(\"Cut {} apps off Popular df for a total of 3558 Popular training apps.\".format(int(4568*.22132)))\nprint(\"Cut {} apps off Unpopular df for a total of 3558 Unpopular training apps.\\n\".format(int(4324*.17738)))\n\ntestPop1 = popAppsCopy[popAppsCopy[\"Installs\"] == 1].sample(1010,random_state=0)\npopAppsCopy = popAppsCopy.drop(testPop1.index)\nprint(\"Values were not dropped from training dataframe.\",testPop1.index[0] in popAppsCopy.index)\n\ntestPop0 = popAppsCopy[popAppsCopy[\"Installs\"] == 0].sample(766,random_state=0)\npopAppsCopy = popAppsCopy.drop(testPop0.index)\nprint(\"Values were not dropped from training dataframe.\",testPop0.index[0] in popAppsCopy.index)\n\ntestDf = testPop1.append(testPop0)\ntrainDf = popAppsCopy\n\n#Shuffle rows in test & training data set\ntestDf = testDf.sample(frac=1,random_state=0).reset_index(drop=True)\ntrainDf = trainDf.sample(frac=1,random_state=0).reset_index(drop=True)\n\n#Form training and test data split\ny_train = trainDf.pop(\"Installs\")\nX_train = trainDf.copy()\ny_test = testDf.pop(\"Installs\")\nX_test = testDf.copy()\n\nX_train = X_train.drop(['Reviews', 'Rating'], axis=1) #REMOVE ROW TO INCLUDE REVIEWS & RATINGS IN ML MODEL ~93% accurate\nX_test = X_test.drop(['Reviews', 'Rating'], axis=1)   #REMOVE ROW TO INCLUDE REVIEWS & RATINGS IN ML MODEL ~93% accurate","d445cc5f":"print(\"{} Apps are used for Training.\".format(y_train.count()))\nprint(\"{} Apps are used for Testing.\".format(y_test.count()))\nX_test.head(3)","81f3f956":"popularity_classifier = DecisionTreeClassifier(max_leaf_nodes=29, random_state=0)\npopularity_classifier.fit(X_train, y_train)","9408fd1d":"predictions = popularity_classifier.predict(X_test)\nprint(\"Predicted: \",predictions[:30])\nprint(\"Actual:    \",np.array(y_test[:30]))","1ac61ed4":"accuracy_score(y_true = y_test, y_pred = predictions)","6ef3079e":"X_testCopy = X_test.copy()\nX_testCopy[\"Popular?\"] = y_test\nX_testCopy[X_test[\"Size\"] == 3600000].head(10)","e21e35b5":"<font color=\"navy\">Delete rows that don't have any ratings.<\/font>","06f18501":"### <font color=\"navy\"> Predict on Test Set <\/font>","8cd2c80c":"<font color='navy'> There are many categories of apps that are equal in terms of being the highest rated. This is great, however, the interest should lie within the app categories which have the lowest number of high ratings. These poorly rated apps deserve more attention because if a new sleek new app in that category were to be put on the app store, then the developers could satisfy the demand for innovation in this area. In this case,<\/font><font color='black'> **The Categories of Importance are \"AUTO_AND_VEHICLES\"and \"ENTERTAINMENT.\"**","b7ea1a33":"## Conclusion","90d0ed94":"<font color=\"navy\">Next, find the number of unique app categories.<\/font>","8d4085d3":"### Find out what caused higher popularity","de92b3f2":"<font color=\"navy\">If different apps with the same app sizes are compared, we can see that the Category and the Genres columns are the only parameters that differ when determining popularity. Shown below, the 1 in the \"Popular?\" column may be an outlier, so as a whole, given all columns below, we can predict with ~72% accuracy the success of an app.","aceb9ab7":"### <font color=\"navy\">Which categories have the best overall rating? Also, which category had the most installs? Let's find out!<\/font>","e8e4fcc1":"## Model Limitations\n* Better performance for predicting app success would come by using alternative ML models. Random Forests, Logistic Regression, and K Nearest-Neighbors would be great models to test against Decision Trees. More than likely, we could achieve up to 80% accuracy using one of these models rather than the current ML model. ","ae4e68c7":"### <font color=\"navy\"> Fit on Train Set <\/font>","40a6fbb6":"<font color=\"navy\">Load the datasets into pandas dataframes<\/font>","7ce8019f":"## The Model - (Decision Tree Classifier)","8d5c31f4":"## The Exploration","0367b796":"<font color='navy'> As seen above, there are not any null values.<\/font>","20d0fed5":"<font color=\"navy\"> When running the kernel, the Accuracy of this Decision Tree Classifier will be about 95% (IF INCLUDING REVIEWS & RATINGS). When not including the rating and reviews features, the Classifier has around 72% Accuracy. This shows that **given the Size, Type, Price, Content Rating, and Genre of an app, we can predict within 72% certainty if an app will have more than 100,000 installs and be a hit on the Google Play Store.** <\/font>","e6c5e8bd":"* **<font color=\"DE1212\"> For Innovation <\/font>** - **Developers** should focus in on apps with a category  of **Auto and Vehicles** and **Entertainment**, as there are not many highly rated apps in these categories.\n***\n* **<font color=\"DE1212\"> For Revenue <\/font>** - **Marketers** should advertise on the top 40 most installed apps list above, in order to reach the maximum viewing of their advertisements.\n***\n* **<font color=\"DE1212\"> For Popularity <\/font>** - **Everyone** building apps should consider that the Category and Genre of an app may strongly dictate if an app will be popular or not. However, the Size, Type, Price, Content Rating, and Genre features should all be used to most accurately determine if an app will gain maximum installs. ","6fcb5cc7":"### <font color=\"navy\">Now to analyze the apps which would produce the most ad revenue\nOne parameter that would affect ad revenue the most is the number of installs an app has. More installs means more people are opening the app and viewing the embedded ads, hence, there is more money being made. A free application may lead to more installs, however, other parameters may alter how many installs an app will have. **Let's see if there is a correlation between installs and other parameters!**","3c1fe711":"<font color=\"navy\">We will only be using the df_apps dataframe.<\/font>","fab90ce7":"### <font color=\"navy\"> Measure Accuracy of Classifier <\/font>","a2e222bf":"<font color=\"navy\">In order to predict if an app will be successful, we must first determine what shows success. In this case a popular app has a high install value. The way in which we will go about preprocessing the data is by binarizing the Installs column. Anything above 100,000 will be considered equal to 1, and everything below that threshold will be equal to 0. This data split is not symmetric and will cause the model to be biased when predicting popularity of an app. We will pop off the enough values of each group to make a 50-50 training set, and the rest will be used for our test set. Also, we will encode the object labels of desired features.<\/font>","e599999f":"<font color='navy'>All of the categories have close rating averages. In order to further define which categories are the highest rated, we will only look at the data for each category that has more than or equal to 4.0 in rating.<\/font>","b2a94de4":"<font color='navy'>Drop rows with Category \"1.9\" from dataframe. As seen below, this incorrectly labeled app category only affected one app. We can remove this row from the dataframe.","55f59fdb":"# <font color='blue'>G<\/font><font color='red'>o<\/font><font color='F2EA0D'>o<\/font><font color='blue'>g<\/font><font color='green'>l<\/font><font color='red'>e<\/font> Play Store Applications Analysis\n\n***\n# UPDATE - Fix These: \n## Issues found with the model\/process used in this Jupyter Notebook:\n* When preprocessing the model, OneHotEncoding should have been used rather than the LabelEncoder. This is because a bias may exist between numbers in 0-33 rather than a matrix of 0 and 1 for category, genre, and content rating. \n* A K-fold Cross Validation set should have been used to find tune the model before using the test set. \n* Other models could have been used during the cross validation process to determine the best binary classifier model to use. \n* ROC AUC or precision\/recall curves should have been created to determine the best decision threshold for the model.\n\n***\n## Contents\n1. <font color='DE1212'> Research Questions & Motivation <\/font>\n2. <font color='DE1212'> The Data <\/font>\n3. <font color='DE1212'> The Exploration <\/font>\n4. <font color='DE1212'> The Model - (Decision Tree Classifier) <\/font>\n5. <font color='DE1212'> Conclusion <\/font>\n\n### Research Questions: \n* <font color='DE1212'> Can you predict an app's popularity on the Google Play Store using a Decision Tree? <\/font>\n* <font color='DE1212'> If a developer were to create a new app, what qualities should this app have in order to generate the most ad revenue? <\/font>\n\n    \n### Motivation: \n* <font color='DE1212'> Gain edge over the industry competition for app success. <\/font>\n* <font color='DE1212'> Provide insight for advertisement companies on which apps would generate the most revenue if ads were added. <\/font>\n* <font color='DE1212'> Assist Android developers to develop state-of-the-art apps that the public deserve. <\/font>","2f75d7b3":"Above, we can see that Installs and Reviews has the strongest inverse correlation. This is reasonable because more reviews are conducted on apps that are the most popular. Since Installs was not correlated to Type, this disproves our intuition that free apps lead to more installs. Since the Installs parameter is independent and not correlated to any other parameters, we must only use Installs to show the popularity of an app. Apps with larger amounts of installs would generate the most revenue.\nLet's take a look at the **Top 40 Apps that businesses should consider signing advertising deals with! **","b63c8c1f":"<font color=\"navy\"> Since the important data is already preprocessed into floats and integers, we can drop the object features and build an 80\/20 training\/test split.<\/font>","48fecf3a":"## The Data"}}