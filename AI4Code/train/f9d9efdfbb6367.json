{"cell_type":{"6c303ec5":"code","ac0cdb62":"code","e42b50aa":"code","2bb3cba4":"code","0b319e80":"code","5155b44f":"code","f9594aff":"code","dc282a17":"code","fbd7b274":"code","6c129166":"code","866111ab":"code","d5195179":"code","38feba52":"code","e85f5730":"code","3f701a66":"code","a2e704c9":"code","606970b2":"code","d475b078":"code","0199190a":"code","d023bb3d":"code","f13410be":"code","1b795dd3":"code","3d6d1b75":"code","08296c26":"code","a21676bd":"code","4e5c0951":"code","9039d168":"code","d8b9a604":"code","55324a3a":"code","8cdb6e7a":"code","545f762a":"code","57cfa7af":"code","fa4233e0":"code","8448c338":"code","ce7d7039":"code","b5bf5d84":"code","bbd6feba":"code","86543b3d":"code","e0231be4":"code","c609c3d4":"code","6da7db14":"code","c8cf8d3b":"code","9b117ea4":"code","8b1b6078":"code","20bf3b9a":"code","8ff7a677":"markdown","64404077":"markdown","4a512e82":"markdown","32fd121e":"markdown","9d955030":"markdown","26a77aa0":"markdown","fb20c89b":"markdown","47a7bf59":"markdown","7d8c3ee7":"markdown","9ebae35a":"markdown","1bcfa55b":"markdown","c6d8b923":"markdown","8e3b6680":"markdown"},"source":{"6c303ec5":"import tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.preprocessing.text import Tokenizer\nfrom tensorflow.keras.preprocessing.sequence import pad_sequences\nimport keras\nimport csv\nimport pandas as pd\nimport random\nimport numpy as np\nfrom keras import regularizers\nimport re\nfrom tqdm import tqdm_notebook\nfrom nltk.corpus import stopwords\nfrom nltk import WordNetLemmatizer\nimport nltk\nnltk.download('wordnet')\nimport itertools\nfrom string import ascii_lowercase\nfrom functools import reduce\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split","ac0cdb62":"train_path='..\/input\/jigsaw-toxic-comment-classification-challenge\/train.csv'\ntrain=pd.read_csv(train_path)","e42b50aa":"train.head()","2bb3cba4":"train.isnull().sum()","0b319e80":"labels = ['toxic', 'severe_toxic', 'obscene', 'threat', 'insult', 'identity_hate']\ny = train[labels].values  \nprint(y[:5])","5155b44f":"lens=train['comment_text'].str.len()","f9594aff":"resize = np.arange(0, 1500,200)\nlens.hist(color='pink', figsize=(10, 6), bins=resize,width=200 )\nplt.title('Length Distribution')\nplt.xlabel('Length of the Comments')\nplt.ylabel('Number of Comments')","dc282a17":"class_cnt = {}\nfor label in labels:\n    class_cnt[label] = len(train[train[label] == 1])\n    \nclass_cnt = {k: v for k, v in sorted(class_cnt.items(), key = lambda item: item[1], reverse = True)}\nvalues=[*class_cnt.values()]\nplt.pie(values, labels=labels, radius=2.5,autopct='%1.1f%%')\nplt.show()","fbd7b274":"RE_PATTERNS = {\n    ' american ':\n        [\n            'amerikan'\n        ],\n\n    ' adolf ':\n        [\n            'adolf'\n        ],\n\n\n    ' hitler ':\n        [\n            'hitler'\n        ],\n\n    ' fuck':\n        [\n            '(f)(u|[^a-z0-9 ])(c|[^a-z0-9 ])(k|[^a-z0-9 ])([^ ])*',\n            '(f)([^a-z]*)(u)([^a-z]*)(c)([^a-z]*)(k)',\n            ' f[!@#\\$%\\^\\&\\*]*u[!@#\\$%\\^&\\*]*k', 'f u u c',\n            '(f)(c|[^a-z ])(u|[^a-z ])(k)', r'f\\*',\n            'feck ', ' fux ', 'f\\*\\*', \n            'f\\-ing', 'f\\.u\\.', 'f###', ' fu ', 'f@ck', 'f u c k', 'f uck', 'f ck','fuk', 'wtf','fucck','f cking'\n        ],\n\n    ' ass ':\n        [\n            '[^a-z]ass ', '[^a-z]azz ', 'arrse', ' arse ', '@\\$\\$'\n                                                           '[^a-z]anus', ' a\\*s\\*s', '[^a-z]ass[^a-z ]',\n            'a[@#\\$%\\^&\\*][@#\\$%\\^&\\*]', '[^a-z]anal ', 'a s s'\n        ],\n\n    ' asshole ':\n        [\n            ' a[s|z]*wipe', 'a[s|z]*[w]*h[o|0]+[l]*e', '@\\$\\$hole', 'ass hole'\n        ],\n\n    ' bitch ':\n        [\n            'b[w]*i[t]*ch', 'b!tch',\n            'bi\\+ch', 'b!\\+ch', '(b)([^a-z]*)(i)([^a-z]*)(t)([^a-z]*)(c)([^a-z]*)(h)',\n            'biatch', 'bi\\*\\*h', 'bytch', 'b i t c h','beetch'\n        ],\n\n    ' bastard ':\n        [\n            'ba[s|z]+t[e|a]+rd'\n        ],\n\n    ' transgender':\n        [\n            'transgender','trans gender'\n        ],\n\n    ' gay ':\n        [\n            'gay'\n        ],\n\n    ' cock ':\n        [\n            '[^a-z]cock', 'c0ck', '[^a-z]cok ', 'c0k', '[^a-z]cok[^aeiou]', ' cawk',\n            '(c)([^a-z ])(o)([^a-z ]*)(c)([^a-z ]*)(k)', 'c o c k'\n        ],\n\n    ' dick ':\n        [\n            ' dick[^aeiou]', 'deek', 'd i c k','diick '\n        ],\n\n    ' suck ':\n        [\n            'sucker', '(s)([^a-z ]*)(u)([^a-z ]*)(c)([^a-z ]*)(k)', 'sucks', '5uck', 's u c k'\n        ],\n\n    ' cunt ':\n        [\n            'cunt', 'c u n t'\n        ],\n\n    ' bullshit ':\n        [\n            'bullsh\\*t', 'bull\\$hit','bs'\n        ],\n\n    ' homosexual':\n        [\n            'homo sexual','homosex'\n        ],\n\n    ' jerk ':\n        [\n            'jerk'\n        ],\n\n    ' idiot ':\n        [\n            'i[d]+io[t]+', '(i)([^a-z ]*)(d)([^a-z ]*)(i)([^a-z ]*)(o)([^a-z ]*)(t)', 'idiots', 'i d i o t'\n        ],\n\n    ' dumb ':\n        [\n            '(d)([^a-z ]*)(u)([^a-z ]*)(m)([^a-z ]*)(b)'\n        ],\n\n    ' shit ':\n        [\n            'shitty', '(s)([^a-z ]*)(h)([^a-z ]*)(i)([^a-z ]*)(t)', 'shite', '\\$hit', 's h i t'\n        ],\n\n    ' shithole ':\n        [\n            'shythole','shit hole'\n        ],\n\n    ' retard ':\n        [\n            'returd', 'retad', 'retard', 'wiktard', 'wikitud'\n        ],\n\n    ' rape ':\n        [\n            ' raped'\n        ],\n\n    ' dumbass':\n        [\n            'dumb ass', 'dubass'\n        ],\n\n    ' asshead':\n        [\n            'butthead', 'ass head'\n        ],\n\n    ' sex ':\n        [\n            's3x', 'sexuality',\n        ],\n\n\n    ' nigger ':\n        [\n            'nigger', 'ni[g]+a', ' nigr ', 'negrito', 'niguh', 'n3gr', 'n i g g e r'\n        ],\n\n    ' shut the fuck up':\n        [\n            'stfu'\n        ],\n\n    ' pussy ':\n        [\n            'pussy[^c]', 'pusy', 'pussi[^l]', 'pusses'\n        ],\n\n    ' faggot ':\n        [\n            'faggot', ' fa[g]+[s]*[^a-z ]', 'fagot', 'f a g g o t', 'faggit',\n            '(f)([^a-z ]*)(a)([^a-z ]*)([g]+)([^a-z ]*)(o)([^a-z ]*)(t)', 'fau[g]+ot', 'fae[g]+ot',\n        ],\n\n    ' motherfucker':\n        [\n            ' motha ', ' motha f', ' mother f', 'motherucker', 'mother fucker'\n        ],\n\n    ' whore ':\n        [\n            'wh\\*\\*\\*', 'w h o r e'\n        ],\n}","6c129166":"##Text Normalization\n\ndef clean_text(text,remove_repeat_text=True, remove_patterns_text=True, is_lower=True):\n\n  if is_lower:\n    text=text.lower()\n    \n  if remove_patterns_text:\n    for target, patterns in RE_PATTERNS.items():\n      for pat in patterns:\n        text=str(text).replace(pat, target)\n\n  if remove_repeat_text:\n    text = re.sub(r'(.)\\1{2,}', r'\\1', text) \n\n  text = str(text).replace(\"\\n\", \" \")\n  text = re.sub(r'[^\\w\\s]',' ',text)\n  text = re.sub('[0-9]',\"\",text)\n  text = re.sub(\" +\", \" \", text)\n  text = re.sub(\"([^\\x00-\\x7F])+\",\" \",text)\n  return text ","866111ab":"train_texts = [] \nfor line in tqdm_notebook(train['comment_text'], total=159571): \n    train_texts.append(clean_text(line))","d5195179":"##Lemmatization\n\nlemmatizer= WordNetLemmatizer()\ndef lemma(text, lemmatization=True):\n  output=''\n  if lemmatization:\n    text=text.split(' ')\n    for word in text:\n      word1 = lemmatizer.lemmatize(word, pos = \"n\") #noun \n      word2 = lemmatizer.lemmatize(word1, pos = \"v\") #verb\n      word3 = lemmatizer.lemmatize(word2, pos = \"a\") #adjective\n      word4 = lemmatizer.lemmatize(word3, pos = \"r\") #adverb\n      output=output + \" \" + word4\n  else:\n    output=text\n  \n  return str(output.strip())","38feba52":"lema_train_text=[]\nfor line in train_texts:\n    lema_train_text.append(lemma(line))","e85f5730":"##Stopwords Removal\n\nstopword_list=[]\ndef iter_all_strings():\n    for size in itertools.count(1):\n        for s in itertools.product(ascii_lowercase, repeat=size):\n            yield \"\".join(s)\n\ndual_alpha_list=[]\nfor s in iter_all_strings():\n    dual_alpha_list.append(s)\n    if s == 'zz':\n        break\n\ndual_alpha_list.remove('i')\ndual_alpha_list.remove('a')\ndual_alpha_list.remove('am')\ndual_alpha_list.remove('an')\ndual_alpha_list.remove('as')\ndual_alpha_list.remove('at')\ndual_alpha_list.remove('be')\ndual_alpha_list.remove('by')\ndual_alpha_list.remove('do')\ndual_alpha_list.remove('go')\ndual_alpha_list.remove('he')\ndual_alpha_list.remove('hi')\ndual_alpha_list.remove('if')\ndual_alpha_list.remove('is')\ndual_alpha_list.remove('in')\ndual_alpha_list.remove('me')\ndual_alpha_list.remove('my')\ndual_alpha_list.remove('no')\ndual_alpha_list.remove('of')\ndual_alpha_list.remove('on')\ndual_alpha_list.remove('or')\ndual_alpha_list.remove('ok')\ndual_alpha_list.remove('so')\ndual_alpha_list.remove('to')\ndual_alpha_list.remove('up')\ndual_alpha_list.remove('us')\ndual_alpha_list.remove('we')\n\n\nfor letter in dual_alpha_list:\n    stopword_list.append(letter)","3f701a66":"print(stopword_list)\nprint(len(stopword_list))\nprint(len(lema_train_text))","a2e704c9":"def search_stopwords(data, search_stop=True):\n  output=\"\"\n  if search_stop:\n    data=data.split(\" \")\n    for word in data:\n      if not word in stopword_list:\n        output=output+\" \"+word \n  else:\n    output=data\n  return str(output.strip())\n\npotential_stopwords = []\nfor line in tqdm_notebook(lema_train_text, total=159571): \n    potential_stopwords.append(search_stopwords(line))\nprint(len(potential_stopwords))\n\ndef string_combine_a(stopword):\n  final_a=\"\"\n  for item in range(39893):\n    final_a=final_a+\" \"+stopword[item]\n  return final_a\n\ndef string_combine_b(stopword):\n  final_b=\"\"\n  for item in range(39893,79785):\n    final_b=final_b+\" \"+stopword[item]\n  return final_b\n\ndef string_combine_c(stopword):\n  final_c=\"\"\n  for item in range(79785,119678):\n    final_c=final_c+\" \"+stopword[item]\n  return final_c\n\ndef string_combine_d(stopword):\n  final_d=\"\"\n  for item in range(119678,159571):\n    final_d=final_d+\" \"+stopword[item]\n  return final_d\n\ntotal_string_potential_a=string_combine_a(potential_stopwords)\ntotal_string_potential_b=string_combine_b(potential_stopwords)\ntotal_string_potential_c=string_combine_c(potential_stopwords)\ntotal_string_potential_d=string_combine_d(potential_stopwords)\n\ndef word_count(str):\n    counts = dict()\n    words = str.split()\n\n    for word in words:\n        if word in counts:\n            counts[word] += 1\n        else:\n            counts[word] = 1\n    return counts\n\ntotal_string_potential_a_dict=word_count(total_string_potential_a)\ntotal_string_potential_b_dict=word_count(total_string_potential_b)\ntotal_string_potential_c_dict=word_count(total_string_potential_c)\ntotal_string_potential_d_dict=word_count(total_string_potential_d)\n\ntotal_string_potential_a_df = pd.DataFrame(list(total_string_potential_a_dict.items()),columns = ['Word','Count'])\ntotal_string_potential_b_df = pd.DataFrame(list(total_string_potential_b_dict.items()),columns = ['Word','Count'])\ntotal_string_potential_c_df = pd.DataFrame(list(total_string_potential_c_dict.items()),columns = ['Word','Count'])\ntotal_string_potential_d_df = pd.DataFrame(list(total_string_potential_d_dict.items()),columns = ['Word','Count'])\n\ntop50_potential_stopwords_a=total_string_potential_a_df.sort_values(by=['Count'],ascending=False).head(50)\ntop50_potential_stopwords_b=total_string_potential_b_df.sort_values(by=['Count'],ascending=False).head(50)\ntop50_potential_stopwords_c=total_string_potential_c_df.sort_values(by=['Count'],ascending=False).head(50)\ntop50_potential_stopwords_d=total_string_potential_d_df.sort_values(by=['Count'],ascending=False).head(50)\n\n","606970b2":"#Looking for common terms in all top 50 dataframes.\ncommon_potential_stopwords=list(reduce(set.intersection,map(set,[top50_potential_stopwords_a.Word,top50_potential_stopwords_b.Word,top50_potential_stopwords_c.Word,top50_potential_stopwords_d.Word])))\nprint(common_potential_stopwords)","d475b078":"#Retaining certain words and removing others from the above list.\npotential_stopwords=['editor', 'reference', 'thank', 'work','find', 'good', 'know', 'like', 'look', 'thing', 'want', 'time', 'list', 'section','wikipedia', 'doe', 'add','new', 'try', 'think', 'write','use', 'user', 'way', 'page']\n\n#Adding above retrived words into the stopwords list.\nfor word in potential_stopwords:\n    stopword_list.append(word)","0199190a":"def remove_stopwords(text, remove_stop=True):\n  output = \"\"\n  if remove_stop:\n    text=text.split(\" \")\n    for word in text:\n      if word not in stopword_list:\n        output=output + \" \" + word\n  else :\n    output=text\n\n  return str(output.strip())\n\n#Removing Stopwords from Train Data\nprocessed_train_data = [] \nfor line in tqdm_notebook(lema_train_text, total=159571): \n    processed_train_data.append(remove_stopwords(line))","d023bb3d":"max_features=148844\nmaxpadlen = 200          \nval_split = 0.2      \nembedding_dim_fasttext = 300","f13410be":"#Tokenization\ntokenizer = Tokenizer(num_words=max_features)\ntokenizer.fit_on_texts(list(processed_train_data))\nlist_tokenized_train = tokenizer.texts_to_sequences(processed_train_data)","1b795dd3":"#Indexing\nword_index=tokenizer.word_index\nprint(len(word_index))","3d6d1b75":"#padding\ntraining_padded=pad_sequences(list_tokenized_train, maxlen=maxpadlen, padding = 'post')","08296c26":"print('Tokenized sentences: \\n', training_padded[10])\nprint('One hot label: \\n', y[10])","a21676bd":"#Splitting data into Training and Validation Set\n\nx_train, x_val, y_train, y_val = train_test_split(training_padded, y, test_size=0.2, random_state=2)","4e5c0951":"print('Number of entries in each category: ')\nprint('Training: ', y_train.sum(axis=0))\nprint('Validation: ', y_val.sum(axis=0))","9039d168":"embeddings_index_fasttext = {}\nf = open('..\/input\/popular-embedding\/wiki-news-300d-1M\/wiki-news-300d-1M.vec', encoding='utf8')\nfor line in f:\n    line.encode('utf-8').strip()\n    values = line.split()\n    word = values[0]\n    embeddings_index_fasttext[word] = np.asarray(values[1:], dtype='float32')\nf.close()\nembedding_matrix_fasttext = np.random.random((len(word_index) + 1, embedding_dim_fasttext))\nfor word, i in word_index.items():\n    embedding_vector = embeddings_index_fasttext.get(word)\n    if embedding_vector is not None:\n        embedding_matrix_fasttext[i] = embedding_vector","d8b9a604":"model_1 = tf.keras.Sequential([\n\ttf.keras.layers.Embedding(len(word_index) + 1,\n                           embedding_dim_fasttext,\n                           weights = [embedding_matrix_fasttext],\n                           input_length = maxpadlen,\n                           trainable=False,\n                           name = 'embeddings'),\n  tf.keras.layers.Input(shape=(maxpadlen, ),dtype='int32'),\n  tf.keras.layers.LSTM(40,return_sequences=True, name='lstm_layer'),\n  tf.keras.layers.GlobalMaxPooling1D(),\n  tf.keras.layers.Dropout(.1),\n  tf.keras.layers.Dense(30, activation='relu', kernel_initializer='he_uniform'),\n\ttf.keras.layers.Dropout(.1),\n\ttf.keras.layers.Dense(6, activation='sigmoid', kernel_initializer='glorot_uniform')\n])\nmodel_1.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel_1.summary()","55324a3a":"history_1 = model_1.fit(x_train,y_train, epochs=2, batch_size=32,  validation_data=(x_val, y_val))","8cdb6e7a":"def plot_graphs(history_1, string):\n  plt.plot(history_1.history[string])\n  plt.plot(history_1.history['val_'+string])\n  plt.xlabel(\"Epochs\")\n  plt.ylabel(string)\n  plt.legend([string, 'val_'+string])\n  plt.show()\n\nplot_graphs(history_1, 'accuracy')\nplot_graphs(history_1, 'loss')","545f762a":"model_2 = tf.keras.Sequential([\n\ttf.keras.layers.Embedding(len(word_index) + 1,\n                           embedding_dim_fasttext,\n                           weights = [embedding_matrix_fasttext],\n                           input_length = maxpadlen,\n                           trainable=False,\n                           name = 'embeddings'),\n  tf.keras.layers.Input(shape=(maxpadlen, ),dtype='int32'),\n  tf.keras.layers.LSTM(50,return_sequences=True, name='lstm_layer'),\n  tf.keras.layers.Conv1D(filters=64, kernel_size=3, padding='same', activation='relu', kernel_initializer='he_uniform'),\n  tf.keras.layers.MaxPooling1D(3),\n  tf.keras.layers.GlobalMaxPool1D(),\n  tf.keras.layers.BatchNormalization(),\n  tf.keras.layers.Dense(40, activation=\"relu\", kernel_initializer='he_uniform'),\n  tf.keras.layers.Dropout(0.2),\n  tf.keras.layers.Dense(30, activation=\"relu\", kernel_initializer='he_uniform'),\n  tf.keras.layers.Dropout(0.2),\n  tf.keras.layers.Dense(6, activation=\"sigmoid\", kernel_initializer='glorot_uniform')\n])\nmodel_2.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\nmodel_2.summary()","57cfa7af":"history_2 = model_2.fit(x_train,y_train, epochs=2, batch_size=32,  validation_data=(x_val, y_val))","fa4233e0":"def plot_graphs(history_2, string):\n  plt.plot(history_2.history[string])\n  plt.plot(history_2.history['val_'+string])\n  plt.xlabel(\"Epochs\")\n  plt.ylabel(string)\n  plt.legend([string, 'val_'+string])\n  plt.show()\n\nplot_graphs(history_2, 'accuracy')\nplot_graphs(history_2, 'loss')","8448c338":"sub = pd.read_csv(\"..\/input\/jigsaw-toxic-severity-rating\/comments_to_score.csv\")","ce7d7039":"c=0\nclean=[]\nfor i in sub['text']:\n  i=clean_text(i)\n  i=lemma(i)\n  i=remove_stopwords(i)\n  clean.append(i)","b5bf5d84":"sub['Cleaned_Comments']=clean","bbd6feba":"sub.head()","86543b3d":"X_ = tokenizer.texts_to_sequences(sub['Cleaned_Comments'])\ntest_padded = pad_sequences(X_, maxlen=maxpadlen, truncating='post')\npred = model_1.predict(test_padded)","e0231be4":"sub['score']=0.0","c609c3d4":"for i in range(len(pred)):\n    sub['score'][i]=pred[i][0]+pred[i][1]+pred[i][2]+pred[i][3]+pred[i][4]+pred[i][5]","6da7db14":"sub.head()","c8cf8d3b":"for i in range(len(pred)):\n  if sub['score'][i]>1:\n    sub['score'][i]=1","9b117ea4":"sub.drop(['text'],axis=1,inplace=True)\nsub.drop(['Cleaned_Comments'],axis=1,inplace=True)","8b1b6078":"sub.head()","20bf3b9a":"sub[['comment_id', 'score']].to_csv(\"submission.csv\", index=False)","8ff7a677":"# **Data Visualization**","64404077":"# **Submission**","4a512e82":"# **LSTM-CNN Model**","32fd121e":"Maximum comment length are ranging from 0 to 200","9d955030":"## **Importing Data**\nThe data that we have used for the model is Kaggle\u2019s Toxic Comment Classification Dataset on Wikipedia\u2019s Talk page edits.","26a77aa0":"# **LSTM**","fb20c89b":"# **Data Pre-Processing**\n\n","47a7bf59":"**If you liked this Notebook, please do upvote.\n\n **","7d8c3ee7":"# **Importing Libraries**","9ebae35a":"### **We'd really appriciate an upvote. It is our first competition and we'd really motivates us to go on and do more projects. and we are open to all the suggestions and feedback from you all since we believe in learning from out mistakes. Thank You!**\n\n## **Introduction**\nIdentifying harassment in social media discussions is vital, as is determining the number of unpleasant sentiments conveyed inside the comment. Organizations can save time and manual labor in regulating these platforms by automating this comment classification approach.The primary purpose is to determine the level of negativity and toxicity in internet comments. This could help to identify people who abuse individuals. As a result, it will eventually assist in the execution of policies and the penalty of individuals who do not obey, which can subsequently be used to reduce the level of toxicity in discussions. Using LSTM, CNN and FastText we aspire to build a multi-label classification model that separates comments into six groups according to their toxicity level: toxic, severe toxic, obscene, threat, insult, and identity-hate.\n\n**We have used FastText word embedding to make the model more efficient even on the unseen data.**","1bcfa55b":"# **Plotting Graph for LSTM-CNN**","c6d8b923":"Number of toxic comments in the dataset are significantly higher. Identity Hate comments, on the other hand, are the lowest.","8e3b6680":"# **Plotting Graph for LSTM**"}}