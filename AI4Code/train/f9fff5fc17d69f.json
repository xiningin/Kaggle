{"cell_type":{"4348f436":"code","d669c736":"code","3aa114f9":"code","0dc60f93":"code","4c1e45dd":"code","cd0386e1":"code","5ae937ea":"code","3951074e":"code","2b57bdfc":"code","78ea846f":"code","65314b70":"code","f7eb3207":"code","c9fd183b":"code","c687507e":"code","b25c75f7":"code","3f4d2a96":"code","0688cb3b":"code","5ac5098c":"code","ed479005":"code","498738dd":"code","af699eb9":"code","58ba3a6e":"code","ec9ad150":"code","f556cffc":"code","6a95e89f":"markdown","6f1f9615":"markdown","7cfbca6c":"markdown","09616335":"markdown","a79cd596":"markdown","b5c60afc":"markdown","0a8954ae":"markdown","e85c8f30":"markdown","e0c14fa2":"markdown","91003ed8":"markdown","30aafe3b":"markdown"},"source":{"4348f436":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt \nimport seaborn as sns\n%matplotlib inline\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly.offline as py\nimport plotly.express as px\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","d669c736":"df = pd.read_excel('\/kaggle\/input\/serratus-ultrahigh-throughput-viral-discovery\/notebook\/200411\/div_v_alignment_test1.xlsx')\ndf.head()","3aa114f9":"# checking dataset\n\nprint (\"Rows     : \" ,df.shape[0])\nprint (\"Columns  : \" ,df.shape[1])\nprint (\"\\nFeatures : \\n\" ,df.columns.tolist())\nprint (\"\\nMissing values :  \", df.isnull().sum().values.sum())\nprint (\"\\nUnique values :  \\n\",df.nunique())","0dc60f93":"# Distribution of different type of amount\nfig , ax = plt.subplots(1,3,figsize = (12,5))\n\nbowtie2 = df.bowtie2.values\nurmap= df.urmap.values\nmu = df.mu.values\n\nsns.distplot(bowtie2 , ax = ax[0] , color = 'blue').set_title('Bowtie2' , fontsize = 14)\nsns.distplot(urmap , ax = ax[1] , color = 'cyan').set_title('URMAP' , fontsize = 14)\nsns.distplot(mu , ax = ax[2] , color = 'purple').set_title('MU' , fontsize = 14)\n\n\nplt.show()","4c1e45dd":"import matplotlib.gridspec as gridspec\nfrom scipy.stats import skew\nfrom sklearn.preprocessing import RobustScaler,MinMaxScaler\nfrom scipy import stats\nimport matplotlib.style as style\nstyle.use('seaborn-colorblind')","cd0386e1":"def plotting_3_chart(df, feature): \n    ## Creating a customized chart. and giving in figsize and everything. \n    fig = plt.figure(constrained_layout=True, figsize=(10,6))\n    ## crea,ting a grid of 3 cols and 3 rows. \n    grid = gridspec.GridSpec(ncols=3, nrows=3, figure=fig)\n    #gs = fig3.add_gridspec(3, 3)\n\n    ## Customizing the histogram grid. \n    ax1 = fig.add_subplot(grid[0, :2])\n    ## Set the title. \n    ax1.set_title('Histogram')\n    ## plot the histogram. \n    sns.distplot(df.loc[:,feature], norm_hist=True, ax = ax1)\n\n    # customizing the QQ_plot. \n    ax2 = fig.add_subplot(grid[1, :2])\n    ## Set the title. \n    ax2.set_title('QQ_plot')\n    ## Plotting the QQ_Plot. \n    stats.probplot(df.loc[:,feature], plot = ax2)\n\n    ## Customizing the Box Plot. \n    ax3 = fig.add_subplot(grid[:, 2])\n    ## Set title. \n    ax3.set_title('Box Plot')\n    ## Plotting the box plot. \n    sns.boxplot(df.loc[:,feature], orient='v', ax = ax3 );\n \n\nprint('Skewness: '+ str(df['bowtie2'].skew())) \nprint(\"Kurtosis: \" + str(df['bowtie2'].kurt()))\nplotting_3_chart(df, 'bowtie2')","5ae937ea":"stats.probplot(df['urmap'].values, dist=\"norm\", plot=plt)\nplt.show()","3951074e":"stats.probplot(df['mu'].values, dist=\"norm\", plot=plt)\nplt.show()","2b57bdfc":"sns.heatmap(df.corr(), annot = True, linewidths=.5, cmap='cubehelix')\nplt.title('Correlations', fontsize = 20)\nplt.show()","78ea846f":"f, (ax1, ax2) = plt.subplots(1, 2, sharey = True)\n\nax1.plot(df.bowtie2, df.urmap, c = 'green')\nax1.set_title('Bowtie2 vs. Urmap', c = 'green')\nax2.scatter(df.urmap, df.bowtie2, c='red')\nax2.set_title('Urmap vs. Bowtie2', c ='red')\n\nplt.ylabel('Urmap', fontsize = 20)\n\nplt.show()","65314b70":"sns.boxplot(x=df['urmap'], color = 'cyan')\nplt.title('Urmap Boxplot', fontsize = 20)\nplt.show()","f7eb3207":"sns.boxplot(x=df['bowtie2'], color = 'magenta')\nplt.title('Bowtie2 Boxplot', fontsize = 20)\nplt.show()","c9fd183b":"#Code from Mario Filho\nfrom category_encoders import OneHotEncoder\nfrom sklearn.linear_model import LinearRegression, Ridge\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler, MaxAbsScaler\n\ncols_selected = ['urmap']\nohe = OneHotEncoder(cols=cols_selected, use_cat_names=True)\ndf_t = ohe.fit_transform(df[cols_selected+['bowtie2']])\n\n#scaler = MaxAbsScaler()\nX = df_t.iloc[:,:-1]\ny = df_t.iloc[:, -1].fillna(df_t.iloc[:, -1].mean()) \/ df_t.iloc[:, -1].max()\n\nmdl = Ridge(alpha=0.1)\nmdl.fit(X,y)\n\npd.Series(mdl.coef_, index=X.columns).sort_values().head(10).plot.barh()","c687507e":"ax = df.groupby('urmap')['bowtie2'].mean().plot(kind='barh', figsize=(12,8),\n                                                           title='Mean estimated Urmap')\nplt.xlabel('Mean estimated Urmap')\nplt.ylabel('Bowtie2')\nplt.show()","b25c75f7":"ax = df.groupby('bowtie2.1')['urmap.1'].min().sort_values(ascending=True).plot(kind='barh', figsize=(12,8), color='r',\n                                                                                  title='Min.estimated Bowtie2.1')\nplt.xlabel('Min.estimated Bowtie2.1')\nplt.ylabel('Urmap.1')\nplt.show()","3f4d2a96":"ax = df.groupby('bowtie2')['urmap', 'bowtie2.1'].sum().plot(kind='bar', rot=45, figsize=(12,6), logy=True,\n                                                                 title='Rate of Read Aligners')\nplt.xlabel('Rate of Read Aligners')\nplt.ylabel('Log')\n\nplt.show()","0688cb3b":"ax = df.groupby('mu_count')['bowtie2', 'urmap'].sum().plot(kind='bar', rot=45, figsize=(12,6), logy=True,\n                                                                 title='Read Aligners')\nplt.xlabel('Read Aligners')\nplt.ylabel('Log')\n\nplt.show()","5ac5098c":"ax = df.groupby('mu')['urmap', 'bowtie2'].sum().plot(kind='barh', figsize=(14,8),\n                                                                 title='', logx=True, linewidth=3)\nplt.xlabel('Log')\nplt.ylabel('Read Aligners Rate')\nplt.show()","ed479005":"ax = df.groupby('bowtie2')['urmap'].mean().sort_values(ascending=True).plot(kind='barh', figsize=(20,6), color='orange',\n                                                                                    title='Read Aligners')\nplt.xlabel('Count')\nplt.ylabel('Bowtie2')\nplt.show()","498738dd":"fig=sns.lmplot(x='bowtie2', y=\"urmap\",data=df)","af699eb9":"import matplotlib.ticker as ticker\nax = sns.distplot(df['bowtie2'])\nplt.xticks(rotation=45)\nax.xaxis.set_major_locator(ticker.MultipleLocator(2))\nfigsize=(10, 4)","58ba3a6e":"plt.style.use('fivethirtyeight')\ndf.plot(subplots=True, figsize=(4, 4), sharex=False, sharey=False)\nplt.show()","ec9ad150":"def plot_dist_col(column):\n    pos__df = df[df['bowtie2'] ==1]\n    neg__df = df[df['bowtie2'] ==0]\n\n    '''plot dist curves for train and test weather data for the given column name'''\n    fig, ax = plt.subplots(figsize=(8, 8))\n    sns.distplot(pos__df[column].dropna(), color='green', ax=ax).set_title(column, fontsize=16)\n    sns.distplot(neg__df[column].dropna(), color='purple', ax=ax).set_title(column, fontsize=16)\n    plt.xlabel(column, fontsize=15)\n    plt.legend(['Bowtie2', 'Urmap'])\n    plt.show()\nplot_dist_col('urmap')","f556cffc":"from scipy import stats\n\nplt.figure(figsize=(8,6))\nfig,ax = plt.subplots(2,2,figsize=(10,8))\nsns.distplot(df['bowtie2'], fit = stats.norm,color='coral',ax=ax[0][0])\nsns.distplot(df['mu'], fit = stats.norm,color='coral',ax=ax[0][1])\nsns.distplot(df['urmap'], fit = stats.norm,color='coral',ax=ax[1][0])\nsns.distplot(df['bowtie2.1'], fit = stats.norm,color='coral',ax=ax[1][1])\n\nplt.tight_layout()\nplt.show()","6a95e89f":"Das War's Kaggle Notebook Runner: Mar\u00edlia Prata  @mpwolke","6f1f9615":"![](https:\/\/www.ebi.ac.uk\/training\/online\/sites\/ebi.ac.uk.training.online\/files\/resize\/user\/18\/Figure19-700x527.png)https:\/\/www.ebi.ac.uk\/training\/online\/course\/functional-genomics-ii-common-technologies-and-data-analysis-methods\/read-mapping-or","7cfbca6c":"#Read Mapping or Alignment\n\nFast gapped-read alignment with Bowtie 2. Authors: Ben Langmead, and Steven L Salzberg\n\nNat Methods. Author manuscript; available in PMC 2013 Apr 1. Published in final edited form as: Nat Methods. 2012 Mar 4; 9(4): 357\u2013359. Published online 2012 Mar 4. doi: 10.1038\/nmeth.1923\n\nAs the rate of sequencing increases, greater throughput is demanded from read aligners. The full-text minute index is often used to make alignment very fast and memory-efficient, but the approach is ill-suited to finding longer, gapped alignments. Bowtie 2 combines the strengths of the full-text minute index with the flexibility and speed of hardware-accelerated dynamic programming algorithms to achieve a combination of high speed, sensitivity and accuracy.\n\nAligning sequencing reads to a reference genome is the first step in many comparative genomics pipelines, including pipelines for variant calling1, isoform quantitation2 and differential gene expression3. In many cases, the alignment step is the slowest. This is because for each read the aligner must solve a difficult computational problem: determining the read's likely point of origin with respect to a reference genom\n\nUngapped aligners such as Bowtie will usually fail to align reads spanning gaps and will therefore miss evidence for these events. Gaps greatly increase the size of the search space and reduce the effectiveness of pruning, thereby substantially slowing aligners built solely on index-assisted alignment. Bowtie 2 extends the full-text minute index\u2013based approach of Bowtie to permit gapped alignment by dividing the algorithm broadly into two stages: an initial, ungapped seed-finding stage that benefits from the speed and memory efficiency of the full-text minute index and a gapped extension stage that uses dynamic programming and benefits from the efficiency of single-instruction multiple-data (SIMD) parallel processing available on modern processors. The combination of full-text minute index\u2013assisted seed alignment and SIMD-accelerated dynamic programming achieves an effective combination of speed, sensitivity and accuracy across a range of read lengths and sequencing technologies. https:\/\/www.ncbi.nlm.nih.gov\/pmc\/articles\/PMC3322381\/\n\n\nMapping of reads to reference sequences is an essential step in a wide range of biological studies. The large size of datasets generated with next-generation sequencing technologies motivates the development of fast mapping software. https:\/\/www.biorxiv.org\/content\/10.1101\/2020.01.12.903351v1\n\nArticle URMAP, an ultra-fast read mapper by Robert C. Edgar\n\ndoi: https:\/\/doi.org\/10.1101\/2020.01.12.903351 Now published in PeerJ doi: 10.7717\/peerj.9338","09616335":"Citation: Naumenko, F.M., Abnizova, I.I., Beka, N. et al. Novel read density distribution score shows possible aligner artefacts, when mapping a single chromosome. BMC Genomics 19, 92 (2018). https:\/\/doi.org\/10.1186\/s12864-018-4475-6\n\n\n![](https:\/\/media.springernature.com\/lw685\/springer-static\/image\/art%3A10.1186%2Fs12864-018-4475-6\/MediaObjects\/12864_2018_4475_Fig4_HTML.gif?as=webp)Coefficients of variation of the sample, case2. Panel labels: general (total) CVS are marked in green, head CVS - in mauve, tail CVS - in brown. SE are shown with light colour bars, PE \u2013 with dark colour bars\nhttps:\/\/bmcgenomics.biomedcentral.com\/articles\/10.1186\/s12864-018-4475-6","a79cd596":"#URMAP (Ultra Fast Read Mapper),BOWTIE2\n\nURMAP, a new read mapping algorithm. URMAP is an order of magnitude faster than BWA and Bowtie2 with comparable accuracy on a benchmark test using simulated paired 150nt reads of a well-studied human genome. https:\/\/www.biorxiv.org\/content\/10.1101\/2020.01.12.903351v1\n\nBowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes.http:\/\/bowtie-bio.sourceforge.net\/bowtie2\/index.shtml","b5c60afc":"#Codes from Augustin Pugliese https:\/\/www.kaggle.com\/agustinpugliese\/fish-weight-analysis-and-prediction","0a8954ae":"#I would like to present something like the figure above. Instead, let's see what I can perform.","e85c8f30":"#Conclusion: Bowtie2 gave the same amount of information that Urmap? If you have any idea I'll appreciate to hear from you.","e0c14fa2":"![](https:\/\/encrypted-tbn0.gstatic.com\/images?q=tbn%3AANd9GcSB2OmEzGpR0OonqOi6-jQ3OuR3HtWl5qqQrA&usqp=CAU)slideserve.com","91003ed8":"Venn diagram showing agreement of BWA, Bowtie2 and URMAP\n\nOn unmappable regions with 2 \u00d7150 reads of GRCh38 with MAPQ \u22643. These mappers agree that 49.6M bases (intersection of the three \nregions) are not mappable. \n\n#URMAP, an Ultra-Fast read mapper -  Author: Robert Edgar - Published June 24, 2020PubMed 32612885\n\n![](https:\/\/dfzljdn9uc3pi.cloudfront.net\/2020\/9338\/1\/fig-8-1x.jpg) DOI: 10.7717\/peerj.9338\/fig-8 https:\/\/peerj.com\/articles\/9338\/","30aafe3b":"![](https:\/\/www.intechopen.com\/media\/chapter\/53334\/media\/F1.png)https:\/\/www.intechopen.com\/books\/cloud-computing-architecture-and-applications\/cloud-computing-for-next-generation-sequencing-data-analysis"}}