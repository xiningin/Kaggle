{"cell_type":{"6cd460e3":"code","c327be54":"code","ab897b22":"code","ea8b36f9":"code","c5024b79":"code","0e6f61d6":"code","d6bb92c3":"code","3f3e5527":"code","fc74704a":"code","edb4e55d":"code","d63dd042":"code","070562cc":"code","824d3b21":"code","433844e1":"markdown","e621a0fa":"markdown","755d60d0":"markdown","f98b402b":"markdown","19b3e0c6":"markdown","850f331a":"markdown","ce20d904":"markdown","9c9096fa":"markdown","d00c4204":"markdown","d7fd47e0":"markdown","9a993338":"markdown","d1e94d40":"markdown"},"source":{"6cd460e3":"dec_hidden_state = [5,1,20]","c327be54":"%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Let's visualize our decoder hidden state\nplt.figure(figsize=(1.5, 4.5))\nsns.heatmap(np.transpose(np.matrix(dec_hidden_state)), annot=True, cmap=sns.light_palette(\"purple\", as_cmap=True), linewidths=1)","ab897b22":"annotation = [3,12,45] #e.g. Encoder hidden state","ea8b36f9":"# Let's visualize the single annotation\nplt.figure(figsize=(1.5, 4.5))\nsns.heatmap(np.transpose(np.matrix(annotation)), annot=True, cmap=sns.light_palette(\"orange\", as_cmap=True), linewidths=1)","c5024b79":"def single_dot_attention_score(dec_hidden_state, enc_hidden_state):\n    # TODO: return the dot product of the two vectors\n    return np.dot(dec_hidden_state, enc_hidden_state)\n    \nsingle_dot_attention_score(dec_hidden_state, annotation)","0e6f61d6":"annotations = np.transpose([[3,12,45], [59,2,5], [1,43,5], [4,3,45.3]])","d6bb92c3":"# Let's visualize our annotation (each column is an annotation)\nax = sns.heatmap(annotations, annot=True, cmap=sns.light_palette(\"orange\", as_cmap=True), linewidths=1)","3f3e5527":"def dot_attention_score(dec_hidden_state, annotations):\n    # TODO: return the product of dec_hidden_state transpose and enc_hidden_states\n    return np.matmul(np.transpose(dec_hidden_state), annotations)\n    \nattention_weights_raw = dot_attention_score(dec_hidden_state, annotations)\nattention_weights_raw","fc74704a":"def softmax(x):\n    x = np.array(x, dtype=np.float128)\n    e_x = np.exp(x)\n    return e_x \/ e_x.sum(axis=0) \n\nattention_weights = softmax(attention_weights_raw)\nattention_weights","edb4e55d":"def apply_attention_scores(attention_weights, annotations):\n    # TODO: Multiple the annotations by their weights\n    return attention_weights * annotations\n\napplied_attention = apply_attention_scores(attention_weights, annotations)\napplied_attention","d63dd042":"# Let's visualize our annotations after applying attention to them\nax = sns.heatmap(applied_attention, annot=True, cmap=sns.light_palette(\"orange\", as_cmap=True), linewidths=1)","070562cc":"def calculate_attention_vector(applied_attention):\n    return np.sum(applied_attention, axis=1)\n\nattention_vector = calculate_attention_vector(applied_attention)\nattention_vector","824d3b21":"# Let's visualize the attention context vector\nplt.figure(figsize=(1.5, 4.5))\nsns.heatmap(np.transpose(np.matrix(attention_vector)), annot=True, cmap=sns.light_palette(\"Blue\", as_cmap=True), linewidths=1)","433844e1":"## What is Attention?\n* **Attention** is ***simply a vector, often the outputs of dense layer using softmax function.***\n* Before Attention mechanism, ***translation relies on reading a complete sentence and compress all information into a fixed-length vector***, as you can image, a sentence with hundreds of words represented by several words will surely lead to information loss, inadequate translation, etc.\n\n## Attention Architecture with Idea Behind it.\n\n* The **basic idea:** each time the **model predicts an output word, it only uses parts of an input where the most relevant information is concentrated instead of an entire sentence.** In ***other words, it only pays attention to some input words. Let\u2019s investigate how this is implemented.***\n\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/1*9Lcq9ni9aujScFYyyHRhhA.png)\n\n* Encoder works as usual, and the**difference is only on the decoder\u2019s part.** As you can see from a picture, ***the decoder\u2019s hidden state is computed with a context vector, the previous output and the previous hidden state. But now we use not a single context vector c, but a separate context vector c_i for each target word.***\n* These context vectors are **computed as a weighted sum of annotations generated by the encoder.** In **Bahdanau\u2019s paper, they use a Bidirectional LSTM, so these annotations are concatenations of hidden states in forward and backward directions.**\n* The weight of each annotation is computed by an alignment model which scores how well the **inputs and the output match.** An alignment model is a **feedforward neural network**, for instance. In general, it can be any other model as well.\n* As a result, the **alphas\u200a\u2014\u200athe weights of hidden states when computing a context vector\u200a\u2014\u200ashow how important a given annotation is in deciding the next state and generating the output word. These are the attention scores.**\n\n## Why Attention?\n\n* The **core of Probabilistic Language Model** is to **assign a probability to a sentence by Markov Assumption.** Due to the nature of sentences that consist of different numbers of words, RNN is naturally introduced to model the **conditional probability among words.**\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/0*SX7ClVkt8w9J39ed.)\n\n**Vanilla RNN (the classic one) often gets trapped when modeling:**\n\n* ***Structure Dilemma:*** in real world, **the length of outputs and inputs can be totally different**, while **Vanilla RNN** can only **handle fixed-length problem which is difficult for the alignment.** Consider an ***EN-FR translation examples: \u201che doesn\u2019t like apples\u201d \u2192 \u201cIl n\u2019aime pas les pommes\u201d.***\n* ***Mathematical Nature:*** it suffers from **Gradient Vanishing\/Exploding** which means ***it is hard to train when sentences are long enough (maybe at most 4 words).***\n* ***Translation often requires arbitrary input length and out put length, to deal with the deficits above, encoder-decoder model is adopted and basic RNN cell is changed to GRU or LSTM cell, hyperbolic tangent activation is replaced by ReLU. We use GRU cell here.***\n\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/0*VwQyyHLPDgEWSD-2.)\n\n* **Embedding layer** maps **discrete words into dense vectors for computational efficiency**. Then **embedded word vectors are fed into encoder**, aka ***GRU cells sequentially.*** What happened during **encoding?** Information flows from left to right and **each word vector** is **learned according to not only current input but also all previous words.** When **the sentence is completely read, encoder generates an output and a hidden state at timestep 4 for further processing.** For ***encoding part, decoder (GRUs as well) grabs the hidden state from encoder, trained by teacher forcing (a mode that previous cell\u2019s output as current input), then generate translation words sequentially.***\n\n* It seems amazing as this model can be applied to **N-to-M sequence**, yet there still is **one main deficit left unsolved: is one hidden state really enough?**\n\n## How does attention work?\n\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/0*VrRTrruwf2BtW4t5.)\n\n* Similar to the **basic encoder-decoder architecture,** this fancy mechanism **plug a context vector into the gap between encoder and decoder.** According to the schematic above, **blue represents encoder** and **red represents decoder;** and we could see that **context vector takes all cells\u2019 outputs as input to compute the probability distribution of source language words for each single word decoder wants to generate.** By utilizing this mechanism, **it is possible for decoder to capture somewhat global information rather than solely to infer based on one hidden state.**\n* And to **build context vector is fairly simple.** For a **fixed target word**, ***first***, we **loop over all encoders\u2019 states to compare target** and **source states to generate scores for each state in encoders.** Then we could **use softmax to normalize all scores, which generates the probability distribution conditioned on target states.** At last, the ***weights are introduced to make context vector easy to train. That\u2019s it. Math is shown below:***\n\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/0*4y96boGNMiNVHNo8.)\n\n**To understand the seemingly complicated math, we need to keep three key points in mind:**\n* ***During decoding,context vectors are computed for every output word.*** So we will have a **2D matrix whose size is # of target words multiplied by # of source words.** Equation **(1) demonstrates how to compute a single value given one target word and a set of source word.**\n* **Once context vector is computed, attention vector** could be computed by **context vector, target word, and attention function f.**\n* We need **attention mechanism to be trainable**. According to equation **(4), both styles offer the trainable weights (W in Luong\u2019s, W1 and W2 in Bahdanau\u2019s). Thus, different styles may result in different performance.**\n\n## Attention Scoring\n### Inputs to the scoring function\nLet's start by looking at the inputs we'll give to the scoring function. We will assume we're in the first step in the decoging phase. The first input to the scoring function is the hidden state of decoder (assuming a toy RNN with three hidden nodes -- not usable in real life, but easier to illustrate):","e621a0fa":"\n### Annotations Matrix\nLet's now look at scoring all the annotations at once. To do that, here's our annotation matrix:","755d60d0":"### IMPLEMENT: Scoring All Annotations at Once\nLet's calculate the scores of all the annotations in one step using matrix multiplication. Let's continue to us the dot scoring method\n\n<img src=\"http:\/\/yaox023.com\/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\/RNN\/attention%E7%90%86%E8%AE%BA\/Attention_python%E6%BC%94%E7%A4%BA\/images\/scoring_functions.png\" \/>\n\nTo do that, we'll have to transpose `dec_hidden_state` and [matrix multiply](https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.matmul.html) it with `annotations`.","f98b402b":"Let's visualize how the context vector looks now that we've applied the attention scores back on it:","19b3e0c6":"Now that we have the context vector, we can concatinate it with the hidden state and pass it through a hidden layer to produce the the result of this decoding time step.\n\n### References : \n\n[1] Vinyals, Oriol, et al. Show and tell: A neural image caption generator. arXiv:1411.4555 (2014).  \n[2] Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. arXiv:1409.0473 (2014).  \n[3] Cho, Kyunghyun, Aaron Courville, and Yoshua Bengio. Describing Multimedia Content using Attention-based Encoder\u2013Decoder Networks. arXiv:1507.01053 (2015)  \n[4] Xu, Kelvin, et al. Show, attend and tell: Neural image caption generation with visual attention. arXiv:1502.03044 (2015).  \n[5] Sukhbaatar, Sainbayar, Jason Weston, and Rob Fergus. End-to-end memory networks. Advances in Neural Information Processing Systems. (2015).  \n[6] Joulin, Armand, and Tomas Mikolov. Inferring Algorithmic Patterns with Stack-Augmented Recurrent Nets. arXiv:1503.01007 (2015).  \n[7] Hermann, Karl Moritz, et al. Teaching machines to read and comprehend. Advances in Neural Information Processing Systems. (2015).  \n[8] Raffel, Colin, and Daniel PW Ellis. Feed-Forward Networks with Attention Can Solve Some Long-Term Memory Problems. arXiv:1512.08756 (2015).  \n[9] Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., & Gomez, A. et al. . Attention Is All You Need. arXiv: 1706.03762 (2017).  ","850f331a":"And it can be visualized like this (each column is a hidden state of an encoder time step):","ce20d904":"Let's visualize this vector:","9c9096fa":"Contrast this with the raw annotations visualized earlier in the notebook, and we can see that the second and third annotations (columns) have been nearly wiped out. The first annotation maintains some of its value, and the fourth annotation is the most pronounced.\n\n# Calculating the Attention Context Vector\nAll that remains to produce our attention context vector now is to sum up the four columns to produce a single attention context vector\n","d00c4204":"### IMPLEMENT: Scoring a Single Annotation\nLet's calculate the dot product of a single annotation. Numpy's [dot()](https:\/\/docs.scipy.org\/doc\/numpy\/reference\/generated\/numpy.dot.html) is a good candidate for this operation","d7fd47e0":"Looking at these scores, can you guess which of the four vectors will get the most attention from the decoder at this time step?\n\n## Softmax\nNow that we have our scores, let's apply softmax:\n<img src=\"http:\/\/yaox023.com\/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\/RNN\/attention%E7%90%86%E8%AE%BA\/Attention_python%E6%BC%94%E7%A4%BA\/images\/softmax.png\" \/>","9a993338":"Even when knowing which annotation will get the most focus, it's interesting to see how drastic softmax makes the end score become. The first and last annotation had the respective scores of 927 and 929. But after softmax, the attention they'll get is 0.12 and 0.88 respectively.\n\n# Applying the scores back on the annotations\nNow that we have our scores, let's multiply each annotation by its score to proceed closer to the attention context vector. This is the multiplication part of this formula (we'll tackle the summation part in the latter cells)\n\n<img src=\"http:\/\/yaox023.com\/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\/RNN\/attention%E7%90%86%E8%AE%BA\/Attention_python%E6%BC%94%E7%A4%BA\/images\/Context_vector.png\" \/>","d1e94d40":"Our first scoring function will score a single annotation (encoder hidden state), which looks like this:"}}