{"cell_type":{"97429e28":"code","222a1981":"code","adde66b1":"code","9f1f9417":"code","445f82f7":"code","7aba1a9f":"code","60728555":"code","935dde65":"code","ce2e2cc5":"code","f44fe4e0":"code","9cb7b7eb":"code","69e5d3b2":"code","a308d43b":"code","3bf0b2c8":"code","e7c962bb":"code","27c1e5d1":"code","3dcc65b7":"markdown","2337d9ae":"markdown"},"source":{"97429e28":"!pip install tensorflow==1.12.0","222a1981":"import cv2\nimport math\nimport glob\nimport numpy as np\nimport os\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nfrom sklearn.cluster import MiniBatchKMeans\nfrom utils import build_empty_kernels\nfrom utils import build_dice_kernels","adde66b1":"# function to convert input image to a 2 colors matrix using kMeans algorythm\n# it assings 1 to values to 'white' color and -1 value to a black color\ndef prepare_image_data(filename):\n    image = cv2.imread(filename)\n    (h, w) = image.shape[:2]\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    image = image.reshape(-1,1)\n    clt = MiniBatchKMeans(n_clusters = 2)\n    labels = clt.fit_predict(image)\n    quant = clt.cluster_centers_.astype(\"uint8\")[labels]\n    quant = quant.reshape((h, w))\n    \n    quant = np.int32(quant)\n    quant[quant == quant.min()] = -1\n    quant[quant == quant.max()] = 1\n    \n    return quant","9f1f9417":"base_path = '\/kaggle\/input\/d6-dices-images\/dataset-images\/'\ndataset = glob.glob(os.path.join(base_path, '*.jpg'))","445f82f7":"# function to plot sample images\n\ndef display_samples(data, is_gray=False):\n    fig=plt.figure(figsize=(20, 20))\n    for i in range(1, 6):\n        fig.add_subplot(1, 6, i)\n        if is_gray:\n            plt.imshow(data[i], cmap='gray', vmin=-1, vmax=1)\n        else:\n            plt.imshow(data[i])\n        plt.axis('off')\n    plt.show()","7aba1a9f":"data = [plt.imread(image) for image in dataset[:6]]\ndisplay_samples(data)","60728555":"#displaying processed images:\nprocessed_images = [prepare_image_data(image) for image in dataset[:6]]\ndisplay_samples(processed_images, is_gray=True)","935dde65":"#building empty-dice filters\nempty_dice_filters = build_empty_kernels()\n\ndisplay_samples(empty_dice_filters, is_gray=True)","ce2e2cc5":"# function to compute convolution between a given image and filters\n\ndef compute_conv(image_data, kernels):\n    image_data = np.expand_dims(image_data, axis=0)\n    image_data = np.expand_dims(image_data, axis=3)\n    image_data = np.float32(image_data)\n\n    empty_kernels = np.float32(kernels)\n\n    kernels = np.expand_dims(kernels, axis=0)\n    kernels = kernels.transpose(2, 3, 0, 1)\n    \n    res = tf.nn.conv2d(image_data, kernels, [1,1,1,1], padding='SAME')\n    res = tf.squeeze(res)\n    sess = tf.Session()\n    with sess.as_default():\n        res = res.eval()\n        \n    return list(np.int32(res.transpose(2,0,1)))","f44fe4e0":"# function segment original image to images of individual dices based on the result of convolution \ndef get_dice_images(image, kernels):\n    peaks = []\n    dices = []\n    size = 17\n\n    original = image.copy()\n    \n    while True:\n        max_val = -999999\n\n        conv_results = compute_conv(image, kernels)\n        \n        for conv_result in conv_results:\n            maxx = conv_result.max()\n            \n            if maxx > max_val:\n                max_val = maxx\n                peak = np.where(conv_result==maxx)\n\n        if(max_val < 300):  \n            break \n                     \n        cx = peak[1][0]\n        cy = peak[0][0]\n        \n        dices.append(original[cy - size:cy + size, cx - size:cx + size].copy())\n        peaks.append(peak)\n        image = cv2.circle(image, (peak[1][0], peak[0][0]), 17,(0,0,0), -1)\n        \n    return dices","9cb7b7eb":"#crooping original images of individual dices\n\nres = get_dice_images(processed_images[0], empty_dice_filters)\ndisplay_samples(res, is_gray=True)","69e5d3b2":"#buidling dice-like kernel filters\ndice_kernels, dice_sides = build_dice_kernels()\nrandom_dice_kernels = [dice_kernels[1],dice_kernels[50],dice_kernels[100],dice_kernels[150],dice_kernels[200],dice_kernels[250]]\ndisplay_samples(random_dice_kernels, is_gray=True)","a308d43b":"#combining everything in one function\ndef predict(dice_images, dice_sides, dice_kernels):\n    labels = []\n\n    for dice_image in dice_images:\n\n        label = 0\n        max_val = -999999\n\n        conv_results = compute_conv(dice_image, dice_kernels)\n        \n        for kernel_id in range(len(conv_results)):\n            cur_max = conv_results[kernel_id].max()\n            \n            if cur_max > max_val:\n                max_val = cur_max\n                label = dice_sides[kernel_id]\n\n        labels.append(label)\n        \n    return labels\n\ndef process_image(filename, dice_kernels, dice_sides, empty_kernels):\n    image = prepare_image_data(filename)\n    dice_images = get_dice_images(image, empty_kernels)\n    labels = predict(dice_images, dice_sides, dice_kernels)\n    return labels","3bf0b2c8":"data = [plt.imread(image) for image in dataset[:6]]\nlabels = [process_image(image, dice_kernels, dice_sides, empty_dice_filters) for image in dataset[:6]]","e7c962bb":"def display_samples_with_pred_labels(data, labels):\n    fig=plt.figure(figsize=(20, 20))\n    for i in range(1, 6):\n        fig.add_subplot(1, 6, i)\n        plt.imshow(data[i])\n        plt.axis('off')\n        labels[i].sort()\n        plt.title(str(labels[i]))\n    plt.show()","27c1e5d1":"display_samples_with_pred_labels(data, labels)","3dcc65b7":"### Displaying original images:","2337d9ae":"### Displaying processed images with reduced colors (2 colors):"}}