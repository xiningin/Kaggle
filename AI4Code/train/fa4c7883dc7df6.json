{"cell_type":{"eca8c924":"code","8fee91ad":"code","5f219d6d":"code","95441f15":"code","ab590978":"code","5f7ecb66":"code","6f727027":"code","d82756cf":"code","9181781d":"code","1a68fa4b":"code","e85cd274":"code","d0fd9ed1":"code","114c184b":"code","76a3c5a9":"code","5eaba7de":"code","79739f17":"code","ae964e9a":"markdown","338aa45b":"markdown","9638b2af":"markdown","611a6244":"markdown","62648bdf":"markdown","bf23c75a":"markdown","eb83ff7d":"markdown","4a16b6f9":"markdown","27029ca9":"markdown","f6392343":"markdown"},"source":{"eca8c924":"import tensorflow as tf\nimport matplotlib.pyplot as plt \nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split as tts\nimport os\nimport math\nimport cv2\nimport sklearn.preprocessing as pp\nfrom tqdm import tqdm_notebook as tqdm\nfrom sklearn.utils import shuffle","8fee91ad":"#Function for loading the image data\ndef loadData(path):\n    \"parse the root path with the labled child folders folder\"\n    imgs = []\n    labels = []\n    folders = os.listdir(path)\n    \n    for folder in folders:\n        os.chdir(os.path.join(path,folder))\n        files = os.listdir()\n        for file in files:\n            img = cv2.imread(file)\n            if img.shape != (150,150,3):\n                continue\n            else:\n                imgs.append(img)\n                labels.append(folder)\n\n    \n    \n    lbl_encoded = pp.LabelEncoder()\n    lbl_vls = lbl_encoded.fit_transform(labels).reshape(-1,1)\n    one_hot = pp.OneHotEncoder(sparse=False)\n    labels = one_hot.fit_transform(lbl_vls)\n    return imgs, labels\n        \n    \n    \n    ","5f219d6d":"X_train, Y_train = loadData('\/kaggle\/input\/seg_train\/seg_train')\nX_test, Y_test = loadData('\/kaggle\/input\/seg_test\/seg_test')","95441f15":"print(len(X_test))\nprint(len(Y_test))\nprint(len(X_train))\nprint(len(Y_train))\n","ab590978":"X_train = np.array(X_train)\nY_train = np.array(Y_train)\nX_test = np.array(X_test)\nY_test = np.array(Y_test)\n","5f7ecb66":"fig,ax =plt.subplots(5,5,figsize=(18,16))\nfor i in range(5):\n    for j in range(5):\n        index=np.random.randint(X_train.shape[0])\n        ax[i][j].imshow(X_train[index])\n        ax[i][j].axis('off')\n        ax[i][j].set_title(Y_train[index])","6f727027":"class CNNConstructor():\n    \n    def __init__(self):\n        self.active=True\n        \n    def initWeights(self,shape,name='Weights'):\n        return tf.Variable(tf.truncated_normal(shape=shape,stddev=0.05,name=name))\n    \n    def initBias(self,num,name='Bias'):\n        return tf.Variable(tf.constant(0.7,shape=[num]),name=name)\n    \n    def convLayer(self,input,kernel_size, num_kernels=64,\n                 num_channels=3,conv_stride=1,pool_stride=2,padding='SAME',\n                 pooling=True,activate=True, name='Conv_layer'):\n        \n        \n        conv_volume = [ kernel_size,kernel_size,num_channels,num_kernels]\n        weights = self.initWeights(shape = conv_volume)\n        bias = self.initBias(num = num_kernels)\n        \n        conv_layer = tf.nn.conv2d(input, filter=weights, strides= [1,conv_stride,conv_stride,1],\n                                 padding=padding)\n        conv_layer = tf.add(conv_layer, bias)\n        \n        if pooling:\n            conv_layer = tf.nn.max_pool(conv_layer,\n                                       ksize=[1,2,2,1],\n                                       strides=[1,pool_stride,pool_stride,1],\n                                       padding=padding)\n        if activate:\n            conv_layer = tf.nn.relu(conv_layer)\n            \n        return conv_layer, weights\n    \n    def flatten_conv_layer(self, conv_layer, name='Flatten_layer'):\n        conv_shapes = conv_layer.get_shape()\n        n_features = conv_shapes[1:4].num_elements()\n\n        return tf.reshape(conv_layer, shape=[-1, n_features]), n_features\n    \n    def dens_layer(self,input,n_inpt,n_out,activation=True,name='Dens'):\n        \n        weights = self.initWeights(shape=[n_inpt,n_out])\n        bias = self.initBias(num=n_out)\n        \n        dens = tf.matmul(input, weights)\n        dens = tf.add(dens, bias)\n        \n        if activation:\n            dens = tf.nn.relu(dens)\n        return dens\n        ","d82756cf":"class batch():\n    def __init__(self,imgs,labels):\n        self.X = imgs\n        self.Y = labels\n        self.batch=0\n\n    def shuffle(self,state=101,new=True):\n        self.X = shuffle(self.X,random_state=state)\n        self.Y = shuffle(self.Y,random_state=state)\n        if new:\n            self.batch = 0\n        \n        \n    def next_batch(self,batch_size=100):\n        \n        if self.X.shape[0]<batch_size*self.batch:\n            X,Y = self.X[self.batch*batch_size:],self.Y[self.batch*batch_size:]\n            self.batch=0\n            return X,Y\n        else:\n            X,Y = self.X[self.batch*batch_size:(self.batch+1)*batch_size],self.Y[self.batch*batch_size:(self.batch+1)*batch_size]\n            self.batch += 1 \n            return X,Y\n        \n        ","9181781d":"def plot_conv_weights(weights, input_channel=0):\n    \n    # Retrieve the values of the weight-variables\n    w_values = session.run(weights)\n    \n    # Number of filters used in the conv. layer.\n    n_kernels = w_values.shape[3]\n    n_grids = math.ceil(np.sqrt(n_kernels))\n    print('Total number of kernels: {} \\n\\t  Plotting grid: {}x{}'.format(n_kernels,\n                                                                          n_grids,\n                                                                          n_grids))\n    # Plot.\n    fig, axes = plt.subplots(n_grids, n_grids, figsize=(10, 10))\n    axes = axes.flatten()\n    \n    for i, ax in enumerate(axes):\n        if i < n_kernels:\n            ax.imshow(w_values[:, :, input_channel, i],\n                      vmin=np.min(w_values),\n                      vmax=np.max(w_values),\n                      interpolation='nearest',\n                      cmap='viridis')\n        \n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()\n    \n    return fig\n\ndef plot_conv_layer(layer, image):\n    \n    # Feed an image to the leyer of interest.\n    feed_dict = {X: [image]}\n    conv_values = session.run(layer, feed_dict=feed_dict)\n    \n    \n    # Number of filters used in the conv. layer.\n    n_kernels = conv_values.shape[3]\n    n_grids = math.ceil(np.sqrt(n_kernels))\n    print('Total number of kernels: {} \\n\\t  Plotting grid: {}x{}'.format(n_kernels,\n                                                                          n_grids,\n                                                                          n_grids))\n    # Plot.\n    fig, axes = plt.subplots(n_grids, n_grids, figsize=(10, 10))\n    axes = axes.flatten()\n    for i, ax in enumerate(axes):\n        if i < n_kernels:\n            ax.imshow(conv_values[0, :, :, i],\n                      interpolation='nearest',\n                      cmap='binary')\n        \n        ax.set_xticks([])\n        ax.set_yticks([])\n    plt.show()\n    \n    return fig","1a68fa4b":"n_classes = 6\nn_channels = 3\nn_pixels = 150\n\nkernel_size = 3\nn_kernels_l1 = 128\nn_kernels_l2 = 128\nn_kernels_l3 = 64\nn_kernels_l4 = 32\nn_neurons_fc1 = 1024\nn_neurons_fc2 = 512\n","e85cd274":"tf.reset_default_graph()\n\nX = tf.placeholder(tf.float32, shape= (None, n_pixels,n_pixels,n_channels), name = 'InputImages')\nY = tf.placeholder(tf.float32, shape = (None, n_classes), name = 'Labels')","d0fd9ed1":"CNN = CNNConstructor()\n\nC1,W1 = CNN.convLayer(input=X,kernel_size=kernel_size,num_kernels=n_kernels_l1, pooling=False)\n\nC2,W2 = CNN.convLayer(input = C1,kernel_size=kernel_size,num_channels=n_kernels_l1, num_kernels=n_kernels_l2, pooling=True)\n\nC3,W3 = CNN.convLayer(input= C2,kernel_size=kernel_size,num_channels=n_kernels_l2, num_kernels=n_kernels_l3, pooling = False)\n\nC4,W4 = CNN.convLayer(input= C3,kernel_size=kernel_size,num_channels=n_kernels_l3, num_kernels=n_kernels_l4, pooling = True)\n\nflat, n_features = CNN.flatten_conv_layer(C3)\n\nfc = CNN.dens_layer(input=flat, n_inpt=n_features, n_out=n_neurons_fc1, activation=True, name='Dense_1')\n\ndpo = tf.nn.dropout(fc,keep_prob=0.5)\n\nfc2 = CNN.dens_layer(input=dpo, n_inpt=n_neurons_fc1, n_out=n_neurons_fc2, activation=True, name='Dense_2')\n\nout_layer = CNN.dens_layer(input=fc2, n_inpt=n_neurons_fc2, n_out=n_classes, activation=False, name='Output')","114c184b":"\n# this adds a name to a node in the tensorboar\nwith tf.name_scope('Cross_Entropy'):  \n    cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=out_layer,\n                                                               labels=Y)\ncost_function = tf.reduce_mean(cross_entropy)\nwith tf.name_scope('Loss_function'):  # this adds a name to a node in the tensorboar\n    optimizer = tf.train.AdamOptimizer(learning_rate=1e-4).minimize(cost_function)\n\n# Evaluation\nY_pred = tf.argmax(out_layer, axis=1)\nY_true = tf.argmax(Y, axis=1)\n\nwith tf.name_scope('Accuracy'):\n    correct_prediction = tf.equal(Y_pred, Y_true)\n    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))","76a3c5a9":"batch_size = 100\nepochs = 25\npath_logs = '\/kaggle\/working'\n\n#saver = tf.train.Saver()\nsession = tf.Session()\nsession.run(tf.global_variables_initializer())\naccuaracy_values = []\nvalid_accuracy_values = []\n\n#merged = tf.summary.merge_all()\n#writer=tf.summary.FileWriter(path_logs) # creates file with tensorboard data stored\n#writer.add_graph(session.graph)         # writes data to the file,\n                                        # for variables need to use merged = tf.summary.merge_all()\n# to initialize the tensorboard use 'tensorboard --logdir=path' in cmd\n\n\ndata=batch(X_train,Y_train)\nvalid_data = batch(X_test,Y_test)\n\n\nfor i in tqdm(range(epochs)):\n    acc_epoch = []\n    valid_acc_epoch = []\n    data.shuffle(state=np.random.randint(0,500))\n    valid_data.shuffle(state=np.random.randint(0,500))\n    \n    for j in tqdm(range(len(Y_train)\/\/batch_size)):\n        \n        batch_x, batch_y = data.next_batch(batch_size)\n        \n        feed_train = {X: batch_x,\n                      Y: batch_y}\n\n        session.run(optimizer, feed_dict=feed_train)\n\n        if j % 10 == 0:\n            acc_j = session.run(accuracy, feed_dict=feed_train)\n            acc_epoch.append(acc_j)\n            valid_x,valid_y = valid_data.next_batch(batch_size)\n            feed_valid = {X:valid_x,Y:valid_y}\n            v_acc_j=session.run(accuracy, feed_dict=feed_valid)\n            valid_acc_epoch.append(v_acc_j)\n            #msg = \"Batch: {0:>6}, Training Accuracy: {1:>6.1%}\"\n            #print(msg.format(j + 1, acc_j))\n            #summary, acc = session.run([merged, accuracy], feed_dict=feed_train)\n            #test_writer.add_summary(summary, j)\n        \n    acc = np.mean(acc_epoch)\n    accuaracy_values.append(acc)\n    val_acc = np.mean(valid_acc_epoch)\n    valid_accuracy_values.append(val_acc)\n    print('Epoch {} train accuracy :{}'.format(i+1,acc))\n    print('Epoch {} validation accuracy :{}'.format(i+1,val_acc))\n    #if val_acc>=valid_accuracy_values[-1]:\n        #save_path = saver.save(session, \"{}\/model.ckpt\".format(path_logs))\n        #print('model saved to {}'.format(save_path))\n        ","5eaba7de":"plt.plot(accuaracy_values)\nplt.plot(valid_accuracy_values)\nplt.show()","79739f17":"saver = tf.train.Saver()\n\nwith tf.Session() as session:\n    saver.restore(session,'\/kaggle\/working\/model.ckpt')\n    test_data = batch(imgs=X_test,labels=Y_test)\n    test_data.shuffle()\n    x_data_test, y_data_test = test_data.next_batch(100)\n    plot_conv_layer(C1,image=x_data_test[50,:,:,:])\n    plot_conv_layer(C2,image=x_data_test[50,:,:,:])\n    plot_conv_layer(C3,image=x_data_test[50,:,:,:])\n    plot_conv_layer(C4,image=x_data_test[50,:,:,:])  ","ae964e9a":"# Convert into numpy arrays for better usability","338aa45b":"# Build The Model","9638b2af":"# Define the functions to plot kernels and weights ","611a6244":"# Have a look on the data","62648bdf":"# Get the data","bf23c75a":"# Bonus: check which features the model has used for learning","eb83ff7d":"# Check how model trained","4a16b6f9":"# Build the CNN Constructor","27029ca9":"# Train the model","f6392343":"# Set hyperparameters for the model"}}