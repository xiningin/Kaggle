{"cell_type":{"fd691834":"code","4aa95eb4":"code","f92dccc4":"code","9ef6032e":"code","63ab89a5":"code","4c5d765f":"code","71cf5ff4":"code","f7db8493":"code","f29a10b9":"code","4a4cf294":"code","a2fc9aa6":"code","ed0ed70f":"code","5a66097c":"code","c927a61d":"code","b800a2b6":"code","d1a1deea":"code","aae46980":"code","c4e222ef":"code","6482cbec":"code","d06796a3":"code","4a562b4e":"code","c52d8fad":"code","5b5e461f":"code","14d2d8e6":"code","de49135e":"code","5c617023":"code","57f49de9":"markdown","cb63dc64":"markdown","8b62e247":"markdown","ecced156":"markdown","9dc25de7":"markdown","12c2538d":"markdown","14009735":"markdown","4d158bc9":"markdown","0e2c2f5a":"markdown","b6c6de07":"markdown","154ce9df":"markdown"},"source":{"fd691834":"!nvidia-smi","4aa95eb4":"!nvcc --version","f92dccc4":"import torch, torchvision\nprint(torch.__version__, torch.cuda.is_available())","9ef6032e":"!pip install detectron2 -f \\\n  https:\/\/dl.fbaipublicfiles.com\/detectron2\/wheels\/cu110\/torch1.7\/index.html","63ab89a5":"import pandas as pd\nimport numpy as np\nimport pandas as pd \nfrom tqdm import tqdm\nfrom tqdm import tqdm_notebook as tqdm # progress bar\nfrom datetime import datetime\nimport time\nimport matplotlib.pyplot as plt\n#from pycocotools.coco import COCO\nimport os, json, cv2, random\nimport skimage.io as io\nimport copy\nfrom pathlib import Path\nfrom typing import Optional\n\n\n# torch\nimport torch\n\n# Albumenatations\nimport albumentations as A\nfrom albumentations.pytorch.transforms import ToTensorV2\n\n#from pycocotools.coco import COCO\nfrom sklearn.model_selection import StratifiedKFold\n\n# glob\nfrom glob import glob\n\n# numba\nimport numba\nfrom numba import jit\n\nimport warnings\nwarnings.filterwarnings('ignore') #Ignore \"future\" warnings and Data-Frame-Slicing warnings.\n\n\n# detectron2\nfrom detectron2.structures import BoxMode\nfrom detectron2 import model_zoo\nfrom detectron2.config import get_cfg\nfrom detectron2.data import DatasetCatalog, MetadataCatalog\nfrom detectron2.engine import DefaultPredictor, DefaultTrainer, launch\nfrom detectron2.evaluation import COCOEvaluator\nfrom detectron2.structures import BoxMode\nfrom detectron2.utils.visualizer import ColorMode\nfrom detectron2.utils.logger import setup_logger\nfrom detectron2.utils.visualizer import Visualizer\n\nfrom detectron2.data import DatasetCatalog, MetadataCatalog, build_detection_test_loader, build_detection_train_loader\nfrom detectron2.data import detection_utils as utils\n\n\nfrom detectron2.data import DatasetCatalog, MetadataCatalog, build_detection_test_loader, build_detection_train_loader\nfrom detectron2.data import detection_utils as utils\nimport detectron2.data.transforms as T\nfrom detectron2.evaluation import COCOEvaluator, inference_on_dataset\n\nsetup_logger()","4c5d765f":"f = open('\/kaggle\/input\/papers-images\/train\/train\/samples.json',)\nthing_classes  = []\nthing_classes_id = {}\ndata_annotations=[]\ndata = json.load(f)\n#----Images----\ndata_images=data['images']\n#---annotations-\nfor i in data['annotations']:\n    annot_obj ={\"id\": i['id'],\"image_id\": i['image_id'],\"category_id\":i['category_id'],\n          \"x_min\":i['bbox'][0], #left\n          \"y_min\":i['bbox'][1], #top\n          \"x_max\":i['bbox'][0]+i['bbox'][2], #left+width\n          \"y_max\":i['bbox'][1]+i['bbox'][3] #top+hieght\n         }\n    data_annotations.append(annot_obj) \n#---categories-\nfor i in data['categories']:\n    thing_classes.append(i['name'])\n    thing_classes_id[i['name']]=i['id']\nf.close()\nprint(\"thing_classes=\",thing_classes)\nprint(\"thing_classes_id=\",thing_classes_id)","71cf5ff4":"thing_classes= ['None','text', 'title', 'list', 'table', 'figure']","f7db8493":"train_meta = pd.DataFrame(data_images)\ntrain_meta = train_meta[['id', 'file_name', 'width', 'height']]\ntrain_meta = train_meta.rename(columns={\"id\":\"image_id\"})\nprint(\"train_meta size=\",len(train_meta))\ntrain_meta.head(3)","f29a10b9":"train_df = pd.DataFrame(data_annotations)\nprint(\"train_df size=\",len(train_df))\ntrain_df.head(3)","4a4cf294":"imgdir=\"\/kaggle\/input\/papers-images\/train\/train\"\n\ndebug=False\nsplit_mode=\"valid20\" # all_train Or  valid20 \nimage_Width=601\nimage_Height=792\n\nnum_folds=5\nSelected_fold=1 #1,2,3,4,5 ","a2fc9aa6":"def get_PL_data_dicts(\n    imgdir: Path,\n    _train_df: pd.DataFrame,\n    _train_meta: pd.DataFrame,\n    use_cache: bool = True,\n    target_indices: Optional[np.ndarray] = None,\n    debug: bool = False,\n    data_type:str=\"train\"\n   \n):\n    if debug:\n            train_meta = train_meta.iloc[:100]  # For debug...\n    dataset_dicts = []\n    for index, train_meta_row in tqdm(_train_meta.iterrows(), total=len(_train_meta)):\n                    record = {}\n                    image_id,file_name, width,height = train_meta_row.values\n                    filename = str(f'{imgdir}\/{file_name}')\n                    record[\"file_name\"] = filename\n                    record[\"image_id\"] = image_id\n                    record[\"width\"] = width\n                    record[\"height\"] = height\n                    objs = []\n                    for index2, row in _train_df.query(\"image_id == @image_id\").iterrows():\n                        class_id = row[\"category_id\"]\n                        bbox_resized = [\n                            float(row[\"x_min\"]),\n                            float(row[\"y_min\"]),\n                            float(row[\"x_max\"]),\n                            float(row[\"y_max\"]),\n                        ]\n                        obj = {\n                            \"bbox\": bbox_resized,\n                            \"bbox_mode\": BoxMode.XYXY_ABS,\n                            \"category_id\": class_id,\n                        }\n                        objs.append(obj)\n                    record[\"annotations\"] = objs\n                    dataset_dicts.append(record)\n                    \n    if target_indices is not None:\n        dataset_dicts = [dataset_dicts[i] for i in target_indices]\n\n    return dataset_dicts\n\n                                  ","ed0ed70f":"Data_Resister_training=\"PL_data_train\";\nData_Resister_valid=\"PL_data_valid\";\n\nif split_mode == \"all_train\":\n    DatasetCatalog.register(\n        Data_Resister_training,\n        lambda: get_PL_data_dicts(\n            imgdir,\n            train_df,\n            train_meta,\n            debug=debug,\n            data_type=\"train\"\n        ),\n    )\n    MetadataCatalog.get(Data_Resister_training).set(thing_classes=thing_classes)\n    \n    \n    dataset_dicts_train = DatasetCatalog.get(Data_Resister_training)\n    metadata_dicts_train = MetadataCatalog.get(Data_Resister_training)\n    \n    \nelif split_mode == \"valid20\":\n\n    n_dataset = len(train_meta)\n    n_train = int(n_dataset * 0.95)\n    print(\"n_dataset\", n_dataset, \"n_train\", n_train)\n    rs = np.random.RandomState(12)\n    inds = rs.permutation(n_dataset)\n    train_inds, valid_inds = inds[:n_train], inds[n_train:]\n    DatasetCatalog.register(\n        Data_Resister_training,\n        lambda: get_PL_data_dicts(\n            imgdir,\n            train_df,\n            train_meta,\n            target_indices=train_inds,\n            debug=debug,\n            data_type=\"train\"\n        ),\n    )\n    MetadataCatalog.get(Data_Resister_training).set(thing_classes=thing_classes)\n    \n\n    DatasetCatalog.register(\n        Data_Resister_valid,\n        lambda: get_PL_data_dicts(\n            imgdir,\n            train_df,\n            train_meta,\n            target_indices=valid_inds,\n            debug=debug,\n            data_type=\"val\"\n            ),\n        )\n    MetadataCatalog.get(Data_Resister_valid).set(thing_classes=thing_classes)\n    \n    dataset_dicts_train = DatasetCatalog.get(Data_Resister_training)\n    metadata_dicts_train = MetadataCatalog.get(Data_Resister_training)\n\n    dataset_dicts_valid = DatasetCatalog.get(Data_Resister_valid)\n    metadata_dicts_valid = MetadataCatalog.get(Data_Resister_valid)\n    \nelse:\n    raise ValueError(f\"[ERROR] Unexpected value split_mode={split_mode}\")","5a66097c":"print(\"dicts training size=\",len(dataset_dicts_train),\"################  dicts valid size=\",len(dataset_dicts_valid))","c927a61d":"dataset_dicts_train[11]","b800a2b6":"dataset_dicts_valid[0]","d1a1deea":"def custom_mapper(dataset_dict):\n    \n    dataset_dict = copy.deepcopy(dataset_dict)\n    image = utils.read_image(dataset_dict[\"file_name\"], format=\"BGR\")\n    transform_list = [T.RandomBrightness(0.8, 1.2),\n                      T.RandomFlip(prob=0.5, horizontal=False, vertical=True),\n                      T.RandomFlip(prob=0.5, horizontal=True, vertical=False)\n                      ]\n    image, transforms = T.apply_transform_gens(transform_list, image)\n    dataset_dict[\"image\"] = torch.as_tensor(image.transpose(2, 0, 1).astype(\"float32\"))\n\n    annos = [\n        utils.transform_instance_annotations(obj, transforms, image.shape[:2])\n        for obj in dataset_dict.pop(\"annotations\")\n        if obj.get(\"iscrowd\", 0) == 0\n    ]\n    instances = utils.annotations_to_instances(annos, image.shape[:2])\n    dataset_dict[\"instances\"] = utils.filter_empty_instances(instances)\n    return dataset_dict\nclass AugTrainer(DefaultTrainer):\n    @classmethod\n    def build_train_loader(cls, cfg):\n        return build_detection_train_loader(cfg, mapper=custom_mapper)","aae46980":"cfg = get_cfg()\nconfig_name = \"COCO-Detection\/faster_rcnn_R_50_FPN_3x.yaml\" \n\ncfg.merge_from_file(model_zoo.get_config_file(config_name))\n\ncfg.DATASETS.TRAIN = (Data_Resister_training,)\n\nif split_mode == \"all_train\":\n    cfg.DATASETS.TEST = ()\nelse:\n    cfg.DATASETS.TEST = (Data_Resister_valid,)\n    cfg.TEST.EVAL_PERIOD = 1000\n\ncfg.DATALOADER.NUM_WORKERS = 0\n#cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(config_name)\ncfg.MODEL.WEIGHTS=\"\/kaggle\/input\/layout-parser-weights\/Weights\/mask_rcnn_R_50_FPN_3x\/model_final.pth\"\n\ncfg.SOLVER.IMS_PER_BATCH = 4\ncfg.SOLVER.BASE_LR = 0.0025\n\ncfg.SOLVER.WARMUP_ITERS = 10\ncfg.SOLVER.MAX_ITER = 2000 #adjust up if val mAP is still rising, adjust down if overfit\ncfg.SOLVER.STEPS = (500, 1000) # must be less than  MAX_ITER \ncfg.SOLVER.GAMMA = 0.05\n\n\ncfg.SOLVER.CHECKPOINT_PERIOD = 100000  # Small value=Frequent save need a lot of storage.\ncfg.MODEL.ROI_HEADS.BATCH_SIZE_PER_IMAGE = 4\ncfg.MODEL.ROI_HEADS.NUM_CLASSES = 6\n\n\nos.makedirs(cfg.OUTPUT_DIR, exist_ok=True)\n\n\n#Training using custom trainer defined above\ntrainer = AugTrainer(cfg) \n#trainer = DefaultTrainer(cfg) \ntrainer.resume_or_load(resume=False)\ntrainer.train()","c4e222ef":"evaluator = COCOEvaluator(Data_Resister_training, cfg, False, output_dir=\".\/output\/\")\ncfg.MODEL.WEIGHTS=\".\/output\/model_final.pth\"\ncfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5   # set a custom testing threshold\nval_loader = build_detection_test_loader(cfg, Data_Resister_training)\ninference_on_dataset(trainer.model, val_loader, evaluator)","6482cbec":"import pandas as pd\nmetrics_df = pd.read_json(\".\/output\/metrics.json\", orient=\"records\", lines=True)\nmdf = metrics_df.sort_values(\"iteration\")\nmdf.head(10).T","d06796a3":"fig, ax = plt.subplots()\n\nmdf1 = mdf[~mdf[\"total_loss\"].isna()]\nax.plot(mdf1[\"iteration\"], mdf1[\"total_loss\"], c=\"C0\", label=\"train\")\nif \"validation_loss\" in mdf.columns:\n    mdf2 = mdf[~mdf[\"validation_loss\"].isna()]\n    ax.plot(mdf2[\"iteration\"], mdf2[\"validation_loss\"], c=\"C1\", label=\"validation\")\n\n# ax.set_ylim([0, 0.5])\nax.legend()\nax.set_title(\"Loss curve\")\nplt.show()","4a562b4e":"fig, ax = plt.subplots()\n\nmdf1 = mdf[~mdf[\"fast_rcnn\/cls_accuracy\"].isna()]\nax.plot(mdf1[\"iteration\"], mdf1[\"fast_rcnn\/cls_accuracy\"], c=\"C0\", label=\"train\")\n# ax.set_ylim([0, 0.5])\nax.legend()\nax.set_title(\"Accuracy curve\")\nplt.show()","c52d8fad":"fig, ax = plt.subplots()\nmdf1 = mdf[~mdf[\"loss_box_reg\"].isna()]\nax.plot(mdf1[\"iteration\"], mdf1[\"loss_box_reg\"], c=\"C0\", label=\"train\")\n# ax.set_ylim([0, 0.5])\nax.legend()\nax.set_title(\"loss_box_reg\")\nplt.show()","5b5e461f":"!pip install -U layoutparser ","14d2d8e6":"import layoutparser as lp","de49135e":"model = lp.Detectron2LayoutModel('lp:\/\/PubLayNet\/faster_rcnn_R_50_FPN_3x\/config',\n                                 '.\/output\/model_final.pth',\n                                 extra_config=[\"MODEL.ROI_HEADS.SCORE_THRESH_TEST\", 0.8],\n                                 label_map={0:\"None\",1: \"text\", 2: \"title\", 3: \"list\", 4:\"table\", 5:\"figure\"})\n#######################################################\nimage = cv2.imread('\/kaggle\/input\/papers-images\/train\/train\/PMC3576793_00004.jpg')\n#plt.imshow(image)\ncolor_map = {\n    'text':   'red',\n    'title':  'blue',\n    'list':   'green',\n    'table':  'yellow',\n    'figure': 'pink',\n}\n\nlayout_predicted = model.detect(image)\nlp.draw_box(image,\n              [b.set(id=f'{b.type}\/{b.score:.2f}') for b in layout_predicted],\n              color_map=color_map,\n              show_element_id=True, id_font_size=10,\n              id_text_background_color='black',\n              id_text_color='white')","5c617023":"cfg.MODEL.WEIGHTS = \".\/output\/model_final.pth\"\ncfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5   # set a custom testing threshold for this model\n#cfg.DATASETS.TEST = (\"Data_Resister_training\", )\npredictor = DefaultPredictor(cfg)\n\n###############################################################\n\nfig, ax = plt.subplots(2, 2, figsize =(20,20))\nindices=[ax[0][0],ax[1][0],ax[0][1],ax[1][1] ]\ni=-1\n# Show some qualitative results by predicting on test set images\nNUM_TEST_SAMPLES = 4\nsamples = random.sample(dataset_dicts_train, NUM_TEST_SAMPLES)\nfor i, sample in enumerate(samples):\n    img = cv2.imread(sample[\"file_name\"])\n    outputs = predictor(img)\n    visualizer = Visualizer(img, metadata=metadata_dicts_train,scale=0.5,)\n    visualizer = visualizer.draw_instance_predictions(\n        outputs[\"instances\"].to(\"cpu\"))\n    display_img = visualizer.get_image()[:, :, ::-1]\n    indices[i].grid(False)\n    indices[i].imshow(display_img)","57f49de9":"# Data Visualization","cb63dc64":"### References\n* https:\/\/layout-parser.readthedocs.io\/en\/latest\/notes\/installation.html\n* https:\/\/github.com\/Layout-Parser\/layout-model-training\/blob\/master\/tools\/train_net.py\n* https:\/\/towardsdatascience.com\/auto-parse-and-understand-any-document-5d72e81b0be9\n* https:\/\/layout-parser.readthedocs.io\/en\/latest\/api_doc\/models.html","8b62e247":"### Installation\n* detectron2 is not pre-installed in this kaggle docker, so let's install it.\n* we need to know CUDA and pytorch version to install correct detectron2.","ecced156":"# **Layout Parser Model Training**","9dc25de7":"# Detectron2\n\nDetectron2 is Facebook AI Research's next generation software system that implements state-of-the-art object detection algorithms. It is a ground-up rewrite of the previous version, Detectron, and it originates from maskrcnn-benchmark","12c2538d":"fig = plt.figure(figsize =(40,40))\nax = fig.add_subplot(1,1,1)\n\nd=dataset_dicts_valid[1]   \nimg = cv2.imread(d[\"file_name\"])\nv = Visualizer(img[:, :, ::-1],\n                metadata=metadata_dicts_valid, \n                scale=1.5, \n                instance_mode=ColorMode.IMAGE_BW   # remove the colors of unsegmented pixels. This option is only available for segmentation models\n)\nout = v.draw_dataset_dict(d)\nax.grid(False)\nax.axis('off')\nax.imshow(out.get_image()[:, :, ::-1])","14009735":"* It seems CUDA=11.0 and torch==1.7.0 is used in this kaggle docker image.\n* See installation for details. https:\/\/detectron2.readthedocs.io\/en\/latest\/tutorials\/install.html","4d158bc9":"### Install Pre-Built Detectron2","0e2c2f5a":"# importing libraries","b6c6de07":"# configs","154ce9df":"# Data Augmentation"}}