{"cell_type":{"d8db9bcd":"code","b694e64c":"code","f40c634b":"code","1ccb157c":"code","a013602c":"code","107254d3":"code","afdf2cea":"code","d6f26bc6":"code","3aec8d02":"code","7a63879a":"code","bddc92a7":"code","c3a6b886":"code","5ff1cb8d":"code","dbdad750":"markdown","9683a802":"markdown","88f69076":"markdown","d077f0fa":"markdown","cf564895":"markdown","09c6707e":"markdown","05b4ac77":"markdown","a7c1c523":"markdown","823d89ef":"markdown","4fc7abff":"markdown","ea19f5ea":"markdown","af3acdad":"markdown","d3db86ea":"markdown","80b8f49a":"markdown","322a8abb":"markdown","e4349363":"markdown"},"source":{"d8db9bcd":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import Sequential\nfrom tensorflow.keras.layers import Dropout,Flatten,Dense,BatchNormalization\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.callbacks import EarlyStopping\n\nimport sklearn\nfrom sklearn.model_selection import KFold, train_test_split\n\nimport pathlib\nimport os","b694e64c":"data_path = pathlib.Path(r'..\/input\/chess-pieces-detection-images-dataset')\n\n# glob all 'jpg' image files\nimg_path = list(data_path.glob('**\/*.jpg'))\n\n# split label names from file directory\nimg_labels = list(map(lambda x: os.path.split(os.path.split(x)[0])[1], img_path))","f40c634b":"pd_img_path = pd.Series(img_path, name='PATH').astype(str)\npd_img_labels = pd.Series(img_labels, name='LABELS').astype(str)\n\nimg_df = pd.merge(pd_img_path, pd_img_labels, right_index=True, left_index=True)\n\nimg_df = img_df.sample(frac = 1).reset_index(drop=True)\nimg_df.head()","1ccb157c":"img_df['LABELS'].value_counts(ascending=True)\n# It is small dataset","a013602c":"plt.figure(figsize=(10, 10))\nfor i in range(9):\n  ax = plt.subplot(3, 3, i+1)\n  plt.imshow(plt.imread(img_df.PATH[i]))\n  plt.title(img_df.LABELS[i])\n  plt.axis(\"off\")","107254d3":"train_dataset, test_dataset = train_test_split(img_df, train_size=0.9, shuffle=True, stratify=img_df['LABELS'])\nprint(\"Number of train data:\", train_dataset.shape[0])\nprint(\"Number of test data:\", test_dataset.shape[0])","afdf2cea":"# resize image to (224,224)\nwidth = 224\nheight = 224\n\n# use tensorflow real-time image data augmentation\ndatagen = ImageDataGenerator(rescale=1\/255.0,         # [0,255] -> [0,1]\n                             horizontal_flip = True,  # chess pieces look simillar horizontally\n                             rotation_range = 20,\n                             width_shift_range=0.1,\n                             height_shift_range=0.1,\n                             zoom_range = 0.3,\n                             validation_split=0.2)","d6f26bc6":"def create_model():\n    \n  # load pretrained model 'VGG16'\n  base_model=keras.applications.VGG16(\n    include_top=False,\n    weights=\"imagenet\",\n    input_shape=(width, height ,3))\n  # trainable = False\n  base_model.trainable = False\n  \n  model=Sequential()\n  model.add(base_model)\n  model.add(BatchNormalization())   # batch normalization\n  model.add(Dropout(0.4))           # dropout for preventing overfitting\n  model.add(Flatten())\n  model.add(Dense(256,activation='relu',kernel_initializer='he_normal'))\n  model.add(Dropout(0.4))\n  model.add(Dense(5,activation='softmax',kernel_initializer='glorot_normal'))    # softmax classification for 5 labels\n  \n  model.compile(optimizer='adam',\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n  \n  return model","3aec8d02":"model = create_model()\nEPOCHS = 6\nhistories = []\n\nkfold = KFold(5, shuffle=True, random_state=123)\n\nfor f, (trn_ind, val_ind) in enumerate(kfold.split(train_dataset)):\n  print(); print(\"#\"*50)\n  print(\"Fold: \",f+1)\n  print(\"#\"*50)\n  train_ds = datagen.flow_from_dataframe(img_df.loc[trn_ind,:], \n                                         x_col='PATH', y_col='LABELS',\n                                         target_size=(width,height),\n                                         class_mode = 'categorical', color_mode = 'rgb',\n                                         batch_size = 16, shuffle = True)\n  val_ds = datagen.flow_from_dataframe(img_df.loc[val_ind,:], \n                                       x_col='PATH', y_col='LABELS',\n                                       target_size=(width,height),\n                                       class_mode = 'categorical', color_mode = 'rgb',\n                                       batch_size = 16, shuffle = True)\n  \n  # Define start and end epoch for each folds\n  fold_start_epoch = f * EPOCHS\n  fold_end_epoch = EPOCHS * (f+1)\n  \n  # fit\n  history=model.fit(train_ds, initial_epoch=fold_start_epoch , epochs=fold_end_epoch, \n                    validation_data=val_ds, shuffle=True)\n  \n  # store history for each folds\n  histories.append(history)","7a63879a":"test_gen = ImageDataGenerator(rescale=1\/255.0) # just rescaling for test data\ntest_ds = test_gen.flow_from_dataframe(test_dataset, x_col='PATH', y_col='LABELS',\n                                       target_size=(width,height),\n                                       class_mode = 'categorical', \n                                       color_mode = 'rgb',\n                                       batch_size = 16)","bddc92a7":"test_loss, test_acc = model.evaluate(test_ds) \nprint(f'Model accuracy on test: {test_acc*100:6.2f}')","c3a6b886":"def plot_acc_loss(histories):\n  acc, val_acc = [], []\n  loss, val_loss = [], []\n  for i in range(len(histories)):\n    acc += histories[i].history['accuracy']\n    val_acc += histories[i].history['val_accuracy']\n\n    loss += histories[i].history['loss']\n    val_loss += histories[i].history['val_loss']\n  \n  total_epoch = len(histories) * len(history.epoch) # num of fold * each epoch \n  epochs_range = range(total_epoch)\n\n  plt.figure(figsize=(8, 8))\n  plt.subplot(2, 1, 1)\n  plt.plot(epochs_range, acc, label='Training Accuracy')\n  plt.plot(epochs_range, val_acc, label='Validation Accuracy')\n  plt.legend(loc='lower right')\n  plt.title('Training and Validation Accuracy')\n\n  plt.subplot(2, 1, 2)\n  plt.plot(epochs_range, loss, label='Training Loss')\n  plt.plot(epochs_range, val_loss, label='Validation Loss')\n  plt.legend(loc='upper right')\n  plt.title('Training and Validation Loss')\n  plt.show()","5ff1cb8d":"# plot accuracy and loss of train and validation dataset\nplot_acc_loss(histories)","dbdad750":"## evaluate","9683a802":"### plot images","88f69076":"# 6. Testing\n## make test imagedatagenerator and testset for evaluating","d077f0fa":"### make pandas dataframe with image file path and labels","cf564895":"# Introduction\n###  This dataset has 670 images of chess pieces for 5 classes, I thought it has not enough images to classify 5 classes. So I use KFold method as data augmentation improving model for small image dataset and import VGG16 pretrained model for this dataset. Let's go!","09c6707e":"# 7. Visualize the result","05b4ac77":"# KFold for small image dataset","a7c1c523":"## 1. Introduction\n## 2. Import modules\n## 3. Load data with Pandas\n## 4. Divide train and test dataset\n## 5. Model with VGG16\n## 6. KFold training\n## 7. Testing\n## 8. Visualize the result","823d89ef":"# 4. Model with VGG16","4fc7abff":"## make train imagedatagenerator ","ea19f5ea":"# 2. Load data with Pandas","af3acdad":"# 3. Divide train and test dataset","d3db86ea":"# 5. KFold training\n### This dataset have only 606 train data, it's small so i use KFold method with k=5. Then i can use more than 606 data for training, and also use tensorflow real-time image data augmentation such as 'horizontal_flip', 'rotate', 'shift', 'zoom'.","80b8f49a":"### count image files for each labels","322a8abb":"![](http:\/\/scikit-learn.org\/stable\/_images\/grid_search_cross_validation.png)","e4349363":"# 1. Import modules"}}