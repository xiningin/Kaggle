{"cell_type":{"b1344567":"code","54c4e969":"code","eac2ac3b":"code","e76b6a0e":"code","00ef5f53":"code","26f832bd":"code","4803591b":"code","3d658f38":"code","3fd8dacb":"code","b8f2caf0":"code","d5ac1be9":"code","a9375982":"code","6dd45c60":"code","c884fd2c":"code","3e7c3b58":"code","001974e9":"code","4445c697":"code","063d8a15":"code","648408c4":"code","d828049d":"code","4c0633f8":"code","7d7c9d27":"markdown","bef65115":"markdown"},"source":{"b1344567":"%config Completer.use_jedi = False","54c4e969":"import sys\nfrom fastai.vision.all import *\nsys.path.append(\"\/kaggle\/input\/pointnet\/models\")\nsys.path.append(\"\/kaggle\/input\/helmet-assignment-helpers\/helmet-assignment-main\")\nfrom helmet_assignment.features import add_track_features\nfrom helmet_assignment.score import NFLAssignmentScorer\nfrom tqdm.notebook import tqdm\n\nfrom pointnet_utils import PointNetEncoder, feature_transform_reguliarzer","eac2ac3b":"class cameraRotationNet(nn.Module):\n    def __init__(self, in_ch = 3, n_cls = 2):\n        super().__init__()\n        self.encoder1 = PointNetEncoder(global_feat=True, feature_transform=True, channel=in_ch)\n        self.encoder2 = PointNetEncoder(global_feat=True, feature_transform=True, channel=in_ch)\n        head = create_head(1024*2, n_cls, concat_pool=False)\n        head[0] = Identity()\n        head[1] = Identity()\n        self.head = head\n    \n    def forward(self, x1, x2):\n        x1, _, tf1 = self.encoder1(x1)\n        x2, _, tf2 = self.encoder2(x2)\n        x = torch.cat([x1, x2], 1)\n        x = self.head(x)\n        return x, tf1, tf2","e76b6a0e":"class myLoss(Module):\n    def __init__(self, mat_diff_loss_scale=0.001):\n        super().__init__()\n        self.mat_diff_loss_scale = mat_diff_loss_scale\n\n    def forward(self, pred, target):\n        loss = F.cross_entropy(pred[0], target)\n        mat_diff_loss1 = feature_transform_reguliarzer(pred[1])\n        mat_diff_loss2 = feature_transform_reguliarzer(pred[2])\n\n        total_loss = loss + (mat_diff_loss1 + mat_diff_loss2) * self.mat_diff_loss_scale\n        return total_loss","00ef5f53":"class track_data():\n    def __init__(self, is_sub, normalize = False, flip_y = True):\n        \n        if is_sub:\n            data = pd.read_csv('\/kaggle\/input\/nfl-health-and-safety-helmet-assignment\/test_player_tracking.csv')\n        else:\n            data = pd.read_csv('\/kaggle\/input\/nfl-health-and-safety-helmet-assignment\/train_player_tracking.csv')\n        print('Adding track features... ', end=\"\", flush=True)\n        data = add_track_features(data)\n        print('Done!')\n        data = data.query(\"est_frame > 0\").copy()\n        \n        if normalize:\n            print('Normalizing x-coordinate by frame for all videos... ', end=\"\", flush=True)\n            data['x'] = data.groupby('est_frame')['x'].transform(lambda x: (x - x.mean())\/x.std())\n            print('Done!')\n            print('Normalizing y-coordinate by frame for all videos... ', end=\"\", flush=True)\n            data['y'] = data.groupby('est_frame')['y'].transform(lambda x: (x - x.mean())\/x.std())\n            print('Done!')\n            \n        if flip_y:\n            data['y'] = - data['y']\n            \n        self.data = data\n        \n    def match_video_frames(self, video, frames):\n        game_play = '_'.join(video.split('_')[:-1])\n        data = (self.data\n            .query(f'game_play == \"{game_play}\"')\n            .reset_index(drop=True)\n            .rename({'est_frame':'frame'}, axis = 1)\n            .pivot('frame', 'player', ['x','y'])\n            .reindex(frames)\n            .interpolate(limit_direction='both')\n            .unstack()\n            .unstack(level=0)\n            .sort_index(axis=0, level=1)\n            .swaplevel(0, 1))\n        return data","26f832bd":"td = track_data(False)","4803591b":"bbox_df = pd.read_csv('\/kaggle\/input\/nfl-health-and-safety-helmet-assignment\/train_labels.csv')\nbbox_df['x'] = bbox_df['left'] + bbox_df['width']\/2\nbbox_df['y'] = bbox_df['top'] + bbox_df['height']\/2\nbbox_df['game_play'] = bbox_df['video_frame'].apply(lambda x: '_'.join(x.split('_')[:2]))\nbbox_df = bbox_df.query('view == \"Endzone\"')","3d658f38":"_video_frame = []\n_video_xyz = []\n_gt_label = []\nfor video_frame, data in tqdm(bbox_df.groupby('video_frame')):\n    _video_frame.append(video_frame)\n    _video_xyz.append(np.array([\n        (data['x'].values - data['x'].mean())\/data['x'].std(),\n        (data['y'].values - data['y'].mean())\/data['y'].std(),\n        [0] * len(data)\n    ]).T)\n    _gt_label.append(data['label'].values)\nvideo_df = pd.DataFrame({\n    'video_frame':_video_frame,\n    'video_xyz':_video_xyz,\n    'gt_label':_gt_label\n})\nvideo_df.tail(2)","3fd8dacb":"_track_frame = []\n_track_xyz = []\n_track_label = []\nfor video, data in tqdm(bbox_df.groupby('video')):\n    frames = data['frame'].unique()\n    video[:-4]\n    _df = td.match_video_frames(video, frames).reset_index()\n    for frame, data in _df.groupby('frame'):\n        _track_frame.append(video[:-4] + '_' + str(frame))\n        _track_xyz.append(np.array([\n             (data['x'].values - data['x'].mean())\/data['x'].std(),\n            -(data['y'].values - data['y'].mean())\/data['y'].std(),\n             [0] * len(data)\n        ]).T)\n        _track_label.append(data['player'].values)\ntrack_df = pd.DataFrame({\n    'video_frame':_track_frame,\n    'track_xyz':_track_xyz,\n    'track_label':_track_label\n})\ntrack_df.tail(2)","b8f2caf0":"df = pd.merge(video_df, track_df, on = 'video_frame')\nM = []\nfor _, data in tqdm(df.iterrows(), total=len(df)):\n    a = data['gt_label']\n    b = data['track_label']\n    M.append(np.tile(a, (len(b), 1)).T == np.tile(b, (len(a), 1)))\ndf['match_matrix'] = M\na = [i for i, x in enumerate(df['video_xyz']) if np.isnan(x).any()]\ndf = df.drop(a).reset_index(drop = True)\n# cam_rot = pd.read_csv('\/kaggle\/input\/nfl-camera-rotation-dataset-builder\/camera_rotation.csv')\ncam_rot_end = pd.read_csv('\/kaggle\/input\/nlf-helmet-safety-camera-rotations\/NFL-rotations-plays.csv')\ncam_rot_end['video'] = cam_rot_end['play'] + '_Endzone'\ncam_rot_end['angle'] = cam_rot_end['Endzone']\ncam_rot_sid = pd.read_csv('\/kaggle\/input\/nlf-helmet-safety-camera-rotations\/NFL-rotations-plays.csv')\ncam_rot_sid['video'] = cam_rot_sid['play'] + '_Sideline'\ncam_rot_sid['angle'] = cam_rot_sid['Sideline']\ncam_rot = pd.concat([cam_rot_end, cam_rot_sid]).drop(['Sideline', 'Endzone'], axis = 1)\ndf['video'] = df['video_frame'].apply(lambda x: '_'.join(x.split('_')[:-1]))\ndf['view'] = df['video'].apply(lambda x: x.split('_')[-1])\ndf = pd.merge(df, cam_rot, on = 'video')\ndf = df.query('view == \"Endzone\"')\ndf.tail(2)","d5ac1be9":"df['game'] = df['video_frame'].apply(lambda x: x.split('_')[0])\ngames = df['game'].unique()\nfrom sklearn.model_selection import KFold\nkf = KFold(n_splits=5, random_state=6, shuffle=True)\nfolds = kf.split(games, games)\nfolds = [games[f] for _,f in folds]\n\ndf['fold'] = [((np.vstack(folds) == g).sum(axis = 1) * np.array(range(5))).sum() for g in df['game']]\ndf['fold'].value_counts()","a9375982":"def to_tensor(x: np.ndarray):\n    return torch.tensor(x, dtype = torch.float)\n\ndef pad_cloud(x: torch.Tensor):\n    s = x.shape\n    if len(s) > 1:\n        if s[0] < 22:\n            x = F.pad(x, (0, 0, 0, 22 - s[0]))\n        else:\n            x = x[:22]\n    return x\n    \ndef pad_matrix(x: torch.Tensor):\n    s = x.shape\n    if s[0] < 22:\n        x = F.pad(x, (0, 0, 0, 22 - s[0]))\n    else:\n        x = x[:22]\n    if s[1] < 22:\n        x = F.pad(x, (0, 22 - s[0], 0, 0))\n    else:\n        x = x[:,:22]\n    return x\n\ndef transpose(x: torch.Tensor):\n    s = x.shape\n    if len(s) > 1:\n        return x.transpose(1,2)\n    else:\n        return x\n    \ndef shuffle(x: torch.Tensor):\n    order=9999\n    s = x.shape\n    if len(s) > 1:\n        p = torch.randperm(x1.shape[-1])\n        return x[:,:,p]\n    else:\n        return x\n    \ndef add_noise(x: torch.Tensor):\n    s = x.shape\n    if len(s) > 1:\n        return x + torch.randn(x.size(), device = x.device) * 0.1\n    else:\n        return x","6dd45c60":"def myPointBlock():\n    return TransformBlock(type_tfms = to_tensor, item_tfms = pad_cloud, batch_tfms = transpose)\ndef myMatrixBlock():\n    return TransformBlock(type_tfms = to_tensor, item_tfms = pad_matrix)","c884fd2c":"fold = 0\ndblock = DataBlock(\n    blocks = (myPointBlock, myPointBlock, CategoryBlock),\n    get_x = [ColReader('video_xyz'), ColReader('track_xyz')],\n    get_y = [ColReader('angle')],\n#     batch_tfms = [shuffle, add_noise],\n    n_inp = 2,\n    splitter = IndexSplitter(df[df['fold'] == fold].index)\n#     splitter = RandomSplitter(seed = 42)\n)\ndls = dblock.dataloaders(df, bs = 64, num_workers = 4)","3e7c3b58":"x1, x2, y = dls.one_batch()\nmodel = cameraRotationNet()\nres = model(x1.cpu(), x2.cpu())\nres[0].shape","001974e9":"# class detect_nan(Callback):\n#     def after_batch(self):\n#         if torch.isinf(self.loss) or torch.isnan(self.loss): \n#             print(self.learn.xb[0].min(), self.learn.xb[0].max(), self.learn.xb[0].mean())\n#             print(self.learn.xb[1].min(), self.learn.xb[1].max(), self.learn.xb[1].mean())\n#             print(self.learn.yb[0].min(), self.learn.yb[0].max(), self.learn.xb[2].mean())\n#             print(self.learn.xb)\n#             print(self.learn.yb)\n#             plt.imshow(self.learn.yb[0])\n#             raise CancelFitException","4445c697":"from scipy.optimize import linear_sum_assignment\n\ndef myMetric(x, y):\n    x = x[0].sigmoid().detach().cpu().numpy()\n    match = [linear_sum_assignment(-xx) for xx in x]\n    return torch.stack([yy[m].sum()\/22 for yy, m in zip(y, match)]).mean()","063d8a15":"def myAccuracy(x, y):\n    return accuracy(x[0], y)","648408c4":"model = cameraRotationNet()\nlearn = Learner(dls, model, loss_func=myLoss(), metrics=myAccuracy, cbs = GradientClip())","d828049d":"# learn.lr_find()","4c0633f8":"learn.fit_one_cycle(20, 1e-4)","7d7c9d27":"### K-fold split","bef65115":"## Building the Dataframes"}}