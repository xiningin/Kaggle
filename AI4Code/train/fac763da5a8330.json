{"cell_type":{"dcee902b":"code","1ed4acd6":"code","2b835e7b":"code","093d6472":"code","0ac54861":"code","ded064c0":"code","149d84cd":"code","47e74da9":"code","cfefac78":"code","ce6c0d9f":"code","7df55545":"code","55df400a":"code","e177ae6c":"code","22e6f362":"code","47fdd4b8":"code","ddf3f188":"code","5280c32b":"code","416a6711":"code","685897ae":"code","8a8191ad":"code","47bb82cb":"markdown","3bb3c28a":"markdown"},"source":{"dcee902b":"import pandas as pd\n\n# Data Path\ndata_path = '\/kaggle\/input\/aerial-cactus-identification\/'\n\nlabels = pd.read_csv(data_path + 'train.csv')\nsubmission = pd.read_csv(data_path + 'sample_submission.csv')","1ed4acd6":"from zipfile import ZipFile\n\n# Extract train image data\nwith ZipFile(data_path + 'train.zip') as zipper:\n    zipper.extractall()\n    \n# Extract test image data\nwith ZipFile(data_path + 'test.zip') as zipper:\n    zipper.extractall()","2b835e7b":"import torch # Pytorch \nimport random\nimport numpy as np\n\n# Fix Seed value\ndef set_seed(seed):\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    np.random.seed(seed)\n    random.seed(seed)\n\nset_seed(10)","093d6472":"# Set device\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')","0ac54861":"from sklearn.model_selection import train_test_split\n\n# Split train data, valid data\ntrain, valid = train_test_split(labels, \n                                test_size=0.1,\n                                stratify=labels['has_cactus'],\n                                random_state=10)","ded064c0":"import cv2\nfrom torch.utils.data import Dataset # Class for generating data\n\nclass ImageDataset(Dataset):\n    # Initialization Method (Generator)\n    def __init__(self, df, img_dir = '.\/', transform=None):\n        super().__init__() # Inherit Dataset's __init__() method\n        self.df = df\n        self.img_dir = img_dir\n        self.transform = transform\n    \n    # Dataset Size Return Method\n    def __len__(self):\n        return len(self.df)\n    \n    # Data return method corresponding to index (idx)\n    def __getitem__(self, idx):\n        img_path = self.img_dir + self.df.iloc[idx, 0] # Image File Path\n        image = cv2.imread(img_path) # Read image file\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # Image color correction\n        label = self.df.iloc[idx, 1] # Image label (target value)\n        # Transform image\n        if self.transform is not None:\n            image = self.transform(image)\n        return image, label","149d84cd":"from torchvision import transforms # Module for image transform\n\n# Transforms for train dataset\ntransform_train = transforms.Compose([transforms.ToPILImage(),\n                                      transforms.Pad(32, padding_mode='symmetric'),\n                                      transforms.RandomHorizontalFlip(),\n                                      transforms.RandomVerticalFlip(),\n                                      transforms.RandomRotation(10),\n                                      transforms.ToTensor(),\n                                      transforms.Normalize(mean=[0.5, 0.5, 0.5],\n                                                           std=[0.2, 0.2, 0.2])])\n# Transforms for valid dataset\ntransform_test= transforms.Compose([transforms.ToPILImage(),\n                                    transforms.Pad(32, padding_mode='symmetric'),\n                                    transforms.ToTensor(),\n                                    transforms.Normalize(mean=[0.5, 0.5, 0.5],\n                                                         std=[0.2, 0.2, 0.2])])","47e74da9":"dataset_all = ImageDataset(df=labels, img_dir='train\/', transform=transform_train)\ndataset_valid = ImageDataset(df=valid, img_dir='train\/', transform=transform_test)","cfefac78":"from torch.utils.data import DataLoader # Class for generating data loaders\n\nloader_all = DataLoader(dataset=dataset_all, batch_size=32, \n                          shuffle=True)\nloader_valid = DataLoader(dataset=dataset_valid, batch_size=32, \n                          shuffle=False)","ce6c0d9f":"import torch.nn as nn # Neural Network Module\nimport torch.nn.functional as F # Frequently used functions in neural network modules\n\nclass Model(nn.Module):\n    # Define Neural Network Layer\n    def __init__(self):\n        super().__init__() # Inherit method __init__() of nn.Module\n        # First to fifth convolution, batch normalization, maximum pooling layer\n        self.layer1 = nn.Sequential(nn.Conv2d(in_channels=3, out_channels=32,\n                                              kernel_size=3, padding=2),\n                                    nn.BatchNorm2d(32), # Batch Normalization\n                                    nn.LeakyReLU(), # LeakyReLU Activation Function\n                                    nn.MaxPool2d(kernel_size=2))\n\n        self.layer2 = nn.Sequential(nn.Conv2d(in_channels=32, out_channels=64,\n                                              kernel_size=3, padding=2),\n                                    nn.BatchNorm2d(64),\n                                    nn.LeakyReLU(),\n                                    nn.MaxPool2d(kernel_size=2))\n        \n        self.layer3 = nn.Sequential(nn.Conv2d(in_channels=64, out_channels=128,\n                                              kernel_size=3, padding=2),\n                                    nn.BatchNorm2d(128),\n                                    nn.LeakyReLU(),\n                                    nn.MaxPool2d(kernel_size=2))\n        \n        self.layer4 = nn.Sequential(nn.Conv2d(in_channels=128, out_channels=256,\n                                              kernel_size=3, padding=2),\n                                    nn.BatchNorm2d(256),\n                                    nn.LeakyReLU(),\n                                    nn.MaxPool2d(kernel_size=2))\n        \n        self.layer5 = nn.Sequential(nn.Conv2d(in_channels=256, out_channels=512,\n                                              kernel_size=3, padding=2),\n                                    nn.BatchNorm2d(512),\n                                    nn.LeakyReLU(),\n                                    nn.MaxPool2d(kernel_size=2))\n        # Average Pooling Layer\n        self.avg_pool = nn.AvgPool2d(kernel_size=4) \n        # Fully-connected Layer\n        self.fc1 = nn.Linear(in_features=512 * 1 * 1, out_features=64)\n        self.fc2 = nn.Linear(in_features=64, out_features=2)\n\n    # Define Feed Forward \n    def forward(self, x):\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.layer4(x)\n        x = self.layer5(x)\n        x = self.avg_pool(x)\n        x = x.view(-1, 512 * 1 * 1) # Flatten\n        x = self.fc1(x)\n        x = self.fc2(x)\n        return x","7df55545":"model = Model().to(device)\n\nmodel","55df400a":"# Loss Function\ncriterion = nn.CrossEntropyLoss()","e177ae6c":"# Optimizer\noptimizer = torch.optim.Adamax(model.parameters(), lr=0.0001)","22e6f362":"epochs = 50 # Total Epoch\n\n# Train as much as the total epoch.\nfor epoch in range(epochs):\n    epoch_loss = 0 # Initialize Loss by Epoch\n    # Repeat extracting data by mini batch size 'repeat times'\n    for images, labels in loader_all:\n        # Assign data images, label's mini batch to device\n        images = images.to(device)\n        labels = labels.to(device)\n        \n        # Initialize gradient of optimizer\n        optimizer.zero_grad()\n        # Use image data as input for neural network models to calculate output values\n        outputs = model(images)\n        # Calculate the loss values of output and labels using the loss function\n        loss = criterion(outputs, labels)\n        # Perform Backpropagation\n        loss.backward()\n        # Renewal of weight\n        optimizer.step()\n        \n        epoch_loss += loss.item() # Add Loss in Current Batch\n        \n    print(f'epoch: [{epoch+1}\/{epochs}], loss: {epoch_loss\/len(loader_all):.4f}')","47fdd4b8":"from sklearn.metrics import roc_auc_score # ROC AUC Calculation Function\n\n# Initialize a list containing predicted probability values and real values\ntrue_list = []\npreds_list = []\n\nmodel.eval() # Set model to evaluation state\n\nwith torch.no_grad(): # Disable gradient calculation\n    for images, labels in loader_valid:\n        # Assign images, label data mini-batch to device\n        images = images.to(device)\n        labels = labels.to(device)\n        # Use image data as input for neural network models to calculate output values\n        outputs = model(images)\n        preds = torch.softmax(outputs.cpu(), dim=1)[:, 1] # Predicted Probability Value\n        true = labels.cpu() # True Value \n        # Add predicted probability values and real values to the list\n        preds_list.extend(preds)\n        true_list.extend(true)\n        \n    # Validation Data ROC AUC Score Calculation\n    print(f'Valid Data ROC AUC : {roc_auc_score(true_list, preds_list):.4f}')","ddf3f188":"dataset_test = ImageDataset(df=submission, img_dir='test\/', transform=transform_test)\nloader_test = DataLoader(dataset=dataset_test, batch_size=32, \n                         shuffle=False)","5280c32b":"model.eval() # Set model to evaluation state\n\npreds = [] # Initialize variables for storing target prediction values\n\nwith torch.no_grad(): # Disable gradient calculation\n    for images, _ in loader_test:\n        # Assign data images' mini batch to device\n        images = images.to(device)\n        # Use image data as input for neural network models to calculate output values\n        outputs = model(images)\n        # Probability that the target value is 1 (predicted value)\n        preds_part = torch.softmax(outputs.cpu(), dim=1)[:, 1].tolist()\n        # Connecting pres_part to pres\n        preds.extend(preds_part)","416a6711":"submission['has_cactus'] = preds\nsubmission.to_csv('submission.csv', index=False)","685897ae":"submission","8a8191ad":"import shutil\n\nshutil.rmtree('.\/train')\nshutil.rmtree('.\/test')","47bb82cb":"# Aerial Cactus Identification Competition\n### This is simple CNN modeling code which gets ROC AUC 0.9999\n### If you think this notebook is useful, Please Upvote!\n\n- [Competition Link](https:\/\/www.kaggle.com\/c\/aerial-cactus-identification)\n- [Modeling Reference Notebook Link](https:\/\/www.kaggle.com\/bonhart\/simple-cnn-on-pytorch-for-beginers)\n","3bb3c28a":"# Upvote is FREE \ud83d\udc4d"}}