{"cell_type":{"2968c74b":"code","eae2dc77":"code","ddd4f1fb":"code","82d45f7f":"code","fa122673":"code","36060aaa":"code","8ddb937e":"code","7a1b6d52":"code","08f2782d":"code","7024f714":"code","11428287":"code","db767422":"code","f31375b5":"code","0da2cf59":"code","6a06c8c8":"code","122bbf83":"markdown","185e5c4b":"markdown","7128a482":"markdown","ffe0a24a":"markdown","ac3376b4":"markdown","202af611":"markdown","776385d4":"markdown","96932b6a":"markdown","56630cb8":"markdown","eb8a6b7e":"markdown"},"source":{"2968c74b":"import pandas as pd\nfrom pprint import pprint\nfrom time import time\nfrom collections import Counter\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.ensemble import RandomForestClassifier\nsns.set_context('talk')","eae2dc77":"train = pd.read_json('..\/input\/train.json', orient='columns')\ntest = pd.read_json('..\/input\/test.json', orient='columns')","ddd4f1fb":"f, ax = plt.subplots(figsize=(5,6))\nsns.countplot(y = 'cuisine', \n                   data = train,\n                  order = train.cuisine.value_counts(ascending=False).index)","82d45f7f":"ingredients_individual = Counter([ingredient for ingredient_list in train.ingredients for ingredient in ingredient_list])\ningredients_individual = pd.DataFrame.from_dict(ingredients_individual,orient='index').reset_index()","fa122673":"ingredients_individual = ingredients_individual.rename(columns={'index':'Ingredient', 0:'Count'})","36060aaa":"sns.barplot(x = 'Count', \n            y = 'Ingredient',\n            data = ingredients_individual.sort_values('Count', ascending=False).head(10))","8ddb937e":"f, ax = plt.subplots(figsize=(15,10))\nsns.barplot(x='number_ingredients_meal',\n            y='number_meals',\n            data= (train.ingredients.map(lambda l: len(l))\n                    .value_counts()\n                    .sort_index()\n                    .reset_index()\n                    .rename(columns={'index':'number_ingredients_meal', 'ingredients':'number_meals'}))\n            )","7a1b6d52":"f, ax = plt.subplots(figsize=(32,15))\nsns.boxplot(x='cuisine',\n            y='number_ingredients',\n            data= (pd.concat([train.cuisine,train.ingredients.map(lambda l: len(l))], axis=1)\n                    .rename(columns={'ingredients':'number_ingredients'}))\n            )","08f2782d":"train_ingredients_text = train.ingredients.apply(lambda s: ' '.join(w.lower() for w in s)).str.replace('[^\\w\\s]','')\ntest_ingredients_text = test.ingredients.apply(lambda s: ' '.join(w.lower() for w in s)).str.replace('[^\\w\\s]','')","7024f714":"lb = LabelEncoder()\ntrain_y = lb.fit_transform(train.cuisine)","11428287":"#pipeline = Pipeline([\n#    ('tfidf', TfidfVectorizer()),\n#    ('clf', RandomForestClassifier())\n#])\n#parameters = {\n#    'tfidf__use_idf': (True, False),\n#    'tfidf__norm': ('l1', 'l2'),\n#    'clf__n_estimators': (50,150)\n#}\n#if __name__ == '__main__':\n#    grid_search = GridSearchCV(pipeline, parameters, cv=5,\n#                               n_jobs=-1, verbose=1)\n\n#    print(\"Performing grid search...\")\n#    print(\"pipeline:\", [name for name, _ in pipeline.steps])\n#    print(\"parameters:\")\n#    pprint(parameters)\n#    t0 = time()\n#    grid_search.fit(train_ingredients_text, train_y)\n#    print(\"done in %0.3fs\" % (time() - t0))\n#    print()\n\n#    print(\"Best score: %0.3f\" % grid_search.best_score_)\n#    print(\"Best parameters set:\")\n#    best_parameters = grid_search.best_estimator_.get_params()\n#    for param_name in sorted(parameters.keys()):\n#        print(\"\\t%s: %r\" % (param_name, best_parameters[param_name]))\n\n#pred_y = grid_search.predict(test_ingredients_text)","db767422":"clf = RandomForestClassifier(n_estimators=150)\nvectorizer = TfidfVectorizer(norm='l2',use_idf=True)\ntrain_x = vectorizer.fit_transform(train_ingredients_text)\ntest_x = vectorizer.transform(test_ingredients_text)","f31375b5":"clf.fit(train_x, train_y)","0da2cf59":"pred_y = clf.predict(test_x)","6a06c8c8":"test_id = [test_id for test_id in test.id]\nsub = pd.DataFrame({'id': test_id, 'cuisine': lb.inverse_transform(pred_y)}, columns=['id', 'cuisine'])\nsub.to_csv('predicitions.csv', index=False)","122bbf83":"**TF** = Term Frequency, $tf_{td}=\\frac{f_{td}}{\\sum_{t'\\in d}f_{td}}$, i.e. number of times term $t$ occurs in document $d$ ($f_{td}$) weighted by the number of words in document $d$. There are also other possible weights.\n\n**IDF** = Inverse Document Frequency. IDF measures how much information a word provides (rare vs. common words). Given the number of documents $N$ and the number of documents $d$ that contain term $t$ ($\\mathcal{D}_t$), it is defined as $idf_t=log(\\frac{N}{|\\mathcal{D}_t|})$.\n\n**TF-IDF** = Term Frequency - Inverse Document Frequency, $tfidf_{td} = tf_{td}*idf_t$","185e5c4b":"## Fitting a model to the training data ","7128a482":"### Distribution of number of ingredients in meals","ffe0a24a":"## Distribution of cuisines in the data set","ac3376b4":"### Boxplots for numer of ingredients per cuisine\nThere seems to be no cuisines that use far less or more ingredients per meal.","202af611":"## Analysis of ingredients","776385d4":"### Preparation of ingredient list for TF-IDF","96932b6a":"### Most common ingredients","56630cb8":"## Fitting a Random Forest Classifier","eb8a6b7e":"**Pipeline with Gridsearch:**"}}