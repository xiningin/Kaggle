{"cell_type":{"ee599ba1":"code","2831cd7b":"code","f2c93fc8":"code","6e08ebcb":"markdown"},"source":{"ee599ba1":"%%writefile submission.py\n\nimport random\nfrom sklearn.naive_bayes import MultinomialNB\nimport numpy as np\n\n# Idea: save the last N rounds in a ringbuffer.\n#   FIXME: (Looking at the size of the problem, one could probably store the complete timeline, which would be more elegant ..)\n\nnum_of_rounds = 6 # Used in buffer\n# Has to be an even number, as I log my moves and the opponent move\n\nringbuffer = [0]*num_of_rounds\nringbuffer_full = 0\nringbuffer_idx = 0\n\nswitch_to_predictive_mode = 200 # Round in which you move over from strategy 1 to the predictive strategy\n\nmy_last_move = -1\n\nclf = MultinomialNB()\n\ndef ml(observation, configuration):\n    global my_last_move, num_of_rounds, switch_to_predictive_mode\n    global ringbuffer, ringbuffer_full, ringbuffer_idx\n    global clf\n    \n    if observation.step > 0:\n        ringbuffer_idx_old = ringbuffer_idx \n        ringbuffer[ringbuffer_idx] = my_last_move\n        ringbuffer_idx = ringbuffer_idx+1\n        ringbuffer[ringbuffer_idx] = observation.lastOpponentAction\n        ringbuffer_idx = (ringbuffer_idx+1)%num_of_rounds\n        \n        if ringbuffer_idx == 0:\n            ringbuffer_full = True\n        \n        if ringbuffer_full:\n            # define X and y\n            idx = ringbuffer_idx\n            X   = np.array([0]*(num_of_rounds-2))\n            i=0\n            while True:\n                X[i]=ringbuffer[idx]\n                X[i+1]=ringbuffer[idx+1]\n                i += 2\n                idx = (idx+2)%num_of_rounds\n                \n                if idx == ringbuffer_idx_old:\n                    break\n            \n            X=X.reshape(1, -1)\n            y=[observation.lastOpponentAction]\n            \n            clf.partial_fit(X, y, classes=[0,1,2])\n        \n        if observation.step > switch_to_predictive_mode:\n            # define latest\n            idx = (ringbuffer_idx+2)%num_of_rounds\n            X   = np.array([0]*(num_of_rounds-2))\n            i=0\n            while True:\n                X[i]=ringbuffer[idx]\n                X[i+1]=ringbuffer[idx+1]\n                i += 2\n                idx = (idx+2)%num_of_rounds\n                \n                if i == num_of_rounds-2:\n                    break\n            \n            X=X.reshape(1, -1)\n            pred = clf.predict(X)\n            pred=int(pred[0])\n            my_last_move = (pred+1)%3\n            return my_last_move\n    \n    my_last_move = random.randint(0,2)\n    \n    return my_last_move","2831cd7b":"%%writefile random_strategy.py\n\nimport random\n\ndef random_strategy(observation, configuration):\n    return random.randint(0, 2)","f2c93fc8":"from kaggle_environments import make\n\nenv = make(\"rps\", configuration={\"episodeSteps\": 1000})\n\nenv.run([\"submission.py\", \"random_strategy.py\"])\n\nenv.render(mode=\"ipython\", width=800, height=800)","6e08ebcb":"Classical approaches to this problem are probably mostly in the domain of reinforcement learning.\n\nHowever, another idea is to use machine learning and always use the last N number of games to predict the next move of your opponent. As a next step, you select a beating move.\n\nA simple version of this approach is given below and uses a Bayesian Classifier and an incremental learing approach.\n\nMaybe it is of help to someone."}}