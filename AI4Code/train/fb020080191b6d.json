{"cell_type":{"368a41b4":"code","510e1ec6":"code","91904e95":"code","8b831319":"code","f38c3462":"code","d475e0d8":"code","3e636d70":"code","bdb925c4":"code","8ff0f84a":"code","3b8b7734":"code","02699e4e":"code","187efa89":"code","a5ddc4fe":"code","d0f49a23":"code","89e892ee":"code","0f3130ef":"code","41c3f4ab":"code","67810381":"code","2e35a04b":"code","73106a5e":"code","553bd54f":"code","4e3717df":"code","3e543ac5":"code","0fdf5b5e":"code","2bab9376":"code","44daf3ee":"code","193a5789":"code","34c550cb":"code","b7ac6739":"code","4d280a64":"code","82d32675":"code","de01e4d2":"code","5678607e":"code","b3f009ce":"code","b00b4496":"code","01c1c71c":"code","d48e1bc8":"code","b21b85c1":"code","6967350a":"code","0b73a615":"code","1c2e2b7f":"code","7ec514f4":"code","3d0b03fe":"code","9a91cc55":"code","3cea6f37":"code","48043b8a":"code","0a819713":"code","6aa61c29":"code","63603100":"code","ecf68a1f":"code","79103f20":"code","0bd986c2":"code","7804e51a":"code","a5da4175":"markdown","368be026":"markdown","beb21cd6":"markdown","225db7a6":"markdown","34f043ee":"markdown","d3b606eb":"markdown","89238b20":"markdown","bb06dbc2":"markdown","45c8ed9c":"markdown","299fc634":"markdown","02dbf48c":"markdown","23c201a5":"markdown","33dc63c5":"markdown","dda6aca8":"markdown","ca8b4dc5":"markdown","b248f2c7":"markdown","ed950376":"markdown","70ae74d1":"markdown"},"source":{"368a41b4":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n%matplotlib inline","510e1ec6":"apps_df = pd.read_csv('..\/input\/googleplaystore.csv')\nreviews = pd.read_csv('..\/input\/googleplaystore_user_reviews.csv')","91904e95":"apps_df.head(10)","8b831319":"reviews.head()","f38c3462":"apps_df['Rating'].describe()","d475e0d8":"extraordinary_app = apps_df[apps_df['Rating'] > 5.]\nextraordinary_app.head()","3e636d70":"extraordinary_app_reviews = reviews[reviews['App'] == extraordinary_app.iloc[0]['App']]","bdb925c4":"extraordinary_app_reviews.head()","8ff0f84a":"apps_df = apps_df.drop(apps_df[apps_df['Rating'] > 5].index, axis=0)","3b8b7734":"apps_df['Rating'].isnull().sum()","02699e4e":"apps_df = apps_df.drop(apps_df[apps_df['Rating'].isnull()].index, axis=0)","187efa89":"apps_df['Rating'].describe()","a5ddc4fe":"apps_df['Rating'].hist(bins=50)","d0f49a23":"plt.figure(figsize=(18,10))\napps_df['Category'].value_counts().plot(kind='bar')","89e892ee":"apps_df['Content Rating'].value_counts().plot(kind='bar')","0f3130ef":"apps_df['Type'].value_counts().plot(kind='bar')","41c3f4ab":"apps_df['Price'] = apps_df['Price'].apply(lambda x: float(x.replace('$', ''))).astype('float64')","67810381":"plt.figure(figsize=(18,10))\napps_df[apps_df['Price'] > 0.]['Price'].hist(bins=100)","2e35a04b":"apps_df['Genres'].value_counts()","73106a5e":"apps_df['Genres'].apply(lambda x: len(x.split(';'))).value_counts()","553bd54f":"apps_df['Main Genre'] = apps_df['Genres'].apply(lambda x: x.split(';')[0])\napps_df['Sub Genre'] = apps_df['Genres'].apply(lambda x: x.split(';')[1] if len(x.split(';')) > 1 else 'no sub genre')","4e3717df":"plt.figure(figsize=(18,10))\napps_df['Main Genre'].value_counts().plot(kind='bar')","3e543ac5":"apps_df[apps_df['Sub Genre'] != 'no sub genre']['Sub Genre'].value_counts().plot(kind='bar')","0fdf5b5e":"plt.figure(figsize=(18,10))\napps_df['Installs'].value_counts().plot(kind='bar')","2bab9376":"apps_df['Reviews'] = apps_df['Reviews'].astype('int64')","44daf3ee":"plt.figure(figsize=(18,10))\napps_df['Reviews'].hist(bins=100)","193a5789":"spans = [1000, 10000, 100000, 1000000, 10000000, 100000000]\n\nplt.figure(figsize=(18, 4 * len(spans)))\nprev=0\nfor i, span in enumerate(spans):\n    plt.subplot(len(spans), 1, i+1)\n    subset = apps_df[(apps_df['Reviews'] > prev) & (apps_df['Reviews'] < span)]\n    subset['Reviews'].hist(bins=100)\n    plt.title(\"{:,}\".format(prev) + ' - ' + \"{:,}\".format(span))\n    prev=span","34c550cb":"installs_categories = apps_df['Installs'].value_counts().index\ninstalls_categories_list = [(x, int(x.replace(',', '').replace('+', ''))) for x in installs_categories]\nsorted_installs = sorted(installs_categories_list, key= lambda x: x[1])\n\nplt.figure(figsize=(18, 5 * len(sorted_installs)))\nfor i, installs in enumerate(sorted_installs):\n    plt.subplot(len(sorted_installs), 1, i+1)\n    subset = apps_df[apps_df['Installs'] == installs[0]]\n    subset['Reviews'].hist(bins=100)\n    plt.title(\"Installs: \"+installs[0])","b7ac6739":"apps_df['Installs (int)'] = apps_df['Installs'].apply(lambda x: int(x.replace(',', '').replace('+', '')))","4d280a64":"sns.lmplot(\"Installs (int)\", \"Reviews\", data=apps_df, aspect=2)\nax = plt.gca()\n_ = ax.set_title('Overall correlation between installs and reviews')","82d32675":"sns.lmplot(\"Installs (int)\", \"Reviews\", data=apps_df, aspect=2, hue='Type')","de01e4d2":"apps_df.corr()['Reviews']","5678607e":"apps_df[apps_df['Type'] == 'Free'].corr()['Reviews']","b3f009ce":"apps_df[apps_df['Type'] == 'Paid'].corr()['Reviews']","b00b4496":"sns.lmplot(\"Installs (int)\", \"Reviews\", data=apps_df[apps_df['Type'] == 'Paid'], aspect=2)","01c1c71c":"sns.lmplot(\"Installs (int)\", \"Reviews\", data=apps_df[(apps_df['Type'] == 'Paid') & (apps_df['Installs (int)'] < 1e7)], aspect=2)","d48e1bc8":"apps_df[(apps_df['Type'] == 'Paid') & (apps_df['Installs (int)'] < 1e7)].corr()['Reviews']","b21b85c1":"apps_under10mil_installs_df = apps_df[apps_df['Installs (int)'] < 1e7]","6967350a":"columns_to_encode = ['Category', 'Main Genre', 'Content Rating']\n\nfor col in columns_to_encode:\n    def get_prefix(col):\n        if col == 'Main Genre':\n            return 'Genre'\n        else:\n            return col\n    \n    col_labels_ctg = apps_under10mil_installs_df[col].astype('category')\n    col_dummies = pd.get_dummies(col_labels_ctg, prefix=get_prefix(col))\n    \n    apps_under10mil_installs_df = pd.concat([apps_under10mil_installs_df, col_dummies], axis=1)\n    del apps_under10mil_installs_df[col]","0b73a615":"subgenres = set(list(apps_df[apps_df['Sub Genre'] != 'no sub genre']['Sub Genre']))\n\nfor subgenre in subgenres:\n    col_name = 'Genre_' + subgenre\n    apps_under10mil_installs_df[col_name] = apps_under10mil_installs_df['Sub Genre'].apply(\n        lambda x: 1 if x == subgenre else 0)\n    \ndel apps_under10mil_installs_df['Sub Genre']","1c2e2b7f":"def get_strongest_correlations(col, num):\n    corrs = apps_under10mil_installs_df.corr()[col]\n    max_num = len(list(corrs))\n    if num > max_num:\n        num = max_num\n        print ('Features limit exceeded. Max number of features: ', max_num)\n        \n    corrs = corrs.drop(col)\n    idx = list(corrs.abs().sort_values(ascending=False).iloc[:num].index)\n    return corrs[idx], idx","7ec514f4":"installs_corrs, _ = get_strongest_correlations('Installs (int)', 20)\nplt.figure(figsize=(18,10))\ninstalls_corrs.plot(kind='bar')","3d0b03fe":"reviews_corrs, _ = get_strongest_correlations('Reviews', 20)\nplt.figure(figsize=(18,10))\nreviews_corrs.plot(kind='bar')","9a91cc55":"rating_corrs, _ = get_strongest_correlations('Rating', 20)\nplt.figure(figsize=(18,10))\nrating_corrs.plot(kind='bar')","3cea6f37":"from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error","48043b8a":"train = apps_under10mil_installs_df.sample(frac=0.8)\ntest_and_validation = apps_under10mil_installs_df.loc[~apps_under10mil_installs_df.index.isin(train.index)]\nvalidation = test_and_validation.sample(frac=0.5)\ntest = test_and_validation.loc[~test_and_validation.index.isin(validation.index)]\n\nprint(train.shape, validation.shape, test.shape)","0a819713":"def get_features(num_features):\n    col_to_predict = 'Rating'\n    rating_corrs, idx = get_strongest_correlations(col_to_predict, num_features)\n    if col_to_predict in idx:\n        idx.remove(col_to_predict)\n    return idx\n\ndef compare_predictions(predicted, test_df, target_col):\n    check_df = pd.DataFrame(data=predicted, index=test_df.index, columns=[\"Predicted \"+target_col])\n    check_df = pd.concat([check_df, test_df[[target_col]]], axis=1)\n    check_df[\"Error, %\"] = np.abs(check_df[\"Predicted \"+target_col]*100\/check_df[target_col] - 100)\n    check_df['Error, val'] = check_df[\"Predicted \"+target_col] - check_df[target_col]\n    return (check_df.sort_index(), check_df[\"Error, %\"].mean())\n\ndef evaluate_predictions(model, train_df, test_df, features, target_col):\n    train_pred = model.predict(train_df[features])\n    train_rmse = mean_squared_error(train_pred, train_df[target_col]) ** 0.5\n\n    test_pred = model.predict(test_df[features])\n    test_rmse = mean_squared_error(test_pred, test_df[target_col]) ** 0.5\n\n    print(\"RMSEs:\")\n    print(train_rmse, test_rmse)\n    \n    return test_pred","6aa61c29":"def rfr_model_evaluation(num_features=30, n_estimators=100, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0., max_leaf_nodes=None, use_test=False):\n    rfr = RandomForestRegressor(random_state=42, n_estimators=n_estimators, max_depth=max_depth, min_samples_split=min_samples_split, min_samples_leaf=min_samples_leaf, min_weight_fraction_leaf=min_weight_fraction_leaf, max_leaf_nodes=max_leaf_nodes)\n    features = get_features(num_features)\n    rfr.fit(train[features], train['Rating'])\n    if use_test:\n        rfr_test_predictions = evaluate_predictions(rfr, train, test, features, 'Rating')\n        check_df, avg_error = compare_predictions(rfr_test_predictions, test, 'Rating')\n        print(\"Average test error:\", avg_error)\n    else:\n        rfr_validation_predictions = evaluate_predictions(rfr, train, validation, features, 'Rating')\n        check_df, avg_error = compare_predictions(rfr_validation_predictions, validation, 'Rating')\n        print(\"Average validation error:\", avg_error)\n    return check_df, avg_error","63603100":"check, error = rfr_model_evaluation()","ecf68a1f":"num_features_list = [1] + [x for x in range(5, 91, 5)] + [96]\nmax_depth_list = [None] + [x for x in range(3, 11)] + [x for x in range(15, 36, 5)]\nmin_samples_split_list = [x for x in range(2, 11)] + [x for x in range(15, 101, 5)]\nmin_samples_leaf_list = [x for x in range(1, 15)] + [0.001] + list(np.linspace(0.005,0.1,20).round(3))\nmin_weight_fraction_leaf_list = [0., 0.001] + list(np.linspace(0.005, 0.3, 30).round(3))\nmax_leaf_nodes_list = [None] + [x for x in range(5, 101, 5)]\nn_estimators = [x for x in range(10, 220, 20)]\n\nhyperparams = {\n    'num_features': num_features_list,\n    'max_depth': max_depth_list,\n    'min_samples_split': min_samples_split_list,\n    'min_samples_leaf': min_samples_leaf_list,\n    'min_weight_fraction_leaf': min_weight_fraction_leaf_list,\n    'max_leaf_nodes': max_leaf_nodes_list,\n    'n_estimators': n_estimators\n}\n\nvalidation_results = []\nfor hp_name, hp_list in hyperparams.items():\n    errors = []\n    for hp_val in hp_list:\n        if hp_name == 'num_features':\n            _, error = rfr_model_evaluation(num_features=hp_val)\n        elif hp_name == 'max_depth':\n            _, error = rfr_model_evaluation(max_depth=hp_val)\n        elif hp_name == 'min_samples_split':\n            _, error = rfr_model_evaluation(min_samples_split=hp_val)\n        elif hp_name == 'min_samples_leaf':\n            _, error = rfr_model_evaluation(min_samples_leaf=hp_val)\n        elif hp_name == 'min_weight_fraction_leaf':\n            _, error = rfr_model_evaluation(min_weight_fraction_leaf=hp_val)\n        elif hp_name == 'max_leaf_nodes':\n            _, error = rfr_model_evaluation(max_leaf_nodes=hp_val)\n        elif hp_name == 'n_estimators':\n            _, error = rfr_model_evaluation(n_estimators=hp_val)\n            \n        errors.append(error)\n    validation_results.append((hp_name, errors))","79103f20":"fig = plt.figure(figsize=(18, 30))\n\nfor i, result in enumerate(validation_results):\n    ax = fig.add_subplot(len(validation_results), 1, i+1)\n    hp_name = result[0]\n    hp_errors = result[1]\n    \n    ax.set_title(hp_name)\n    ax.plot(range(0, len(hp_errors)), hp_errors)\n    plt.sca(ax)\n    x_labels = hyperparams[hp_name]\n    plt.xticks(range(0, len(hp_errors)), x_labels)\n    \nfig.tight_layout()\nplt.show()","0bd986c2":"check, error = rfr_model_evaluation(num_features=96, n_estimators=110, max_depth=10, min_samples_split=45,\n                                    min_samples_leaf=14, min_weight_fraction_leaf=0.005, max_leaf_nodes=75)","7804e51a":"check, error = rfr_model_evaluation(num_features=96, n_estimators=110, max_depth=10, min_samples_split=45,\n    min_samples_leaf=14, min_weight_fraction_leaf=0.005, max_leaf_nodes=75, use_test=True)","a5da4175":"Even though correlation between Installs and Reviews for Paid application was stronger with whole dataset rather than with dataset, limited on Installs by 10mil, the limited dataset in that matter seems to have a better distribution and less outstanding values.","368be026":"# Predicting rating of the app.\nLet's try to predict rating of the app. We'll use random forest regressor to try to predict it.","beb21cd6":"The plot turned out to be highly uninformative because of very large values at X scale (1 step is 1e7=10,000,000 reviews), and most of apps on that scale go very close to 0. Let's make several subplots for different categories.","225db7a6":"First, let's take a look at reviews distribution for apps where there are 0-1000, 0-100,000, 0-1,000,000 reviews, and then look at more higher spans.","34f043ee":"# Initial data exploration","d3b606eb":"If we are to take all possible correlations into the picture, we have to one-hot-encode all rlevant categorical data, such as Category, Content Rating, Main Genre, Sub Genre.","89238b20":"# Target Installs, Rating, Reviews\n\nThe most important things about an app are Installs, Rating and Reviews in that order. As a publisher, we are interested in our product to reach bigger audience, with better ratings and optionally with more feedbacks (as reviews).\n\nLet's explore correlations about those 3 columns.","bb06dbc2":"Installs correlate strongly with reviews amount, and that is already explored correlation. There are some genres and categories that got some correlations with installs, but nothing strong (<0.1).","45c8ed9c":"While Google does not give away exact information about how many installs an app have, we can access to the amount of reviews, and based on that we can roughly (but better than Google-given information) estimate the installs.","299fc634":"Rating is one of the essential stats about the app. We're going to drop all rows without ratings.","02dbf48c":"Now let's look at reviews distribution for each category in 'Installs'","23c201a5":"It seems that there differences in correlation between installs and the amount of reviews for free apps.","33dc63c5":"Now we have ~10% error rate on validation set. Final assesment against test set:","dda6aca8":"Ratings positively correlate with reviews. It seems natural that on average people would like to send review for a better app, and this is the strongest correlation.","ca8b4dc5":"Overall, there is no strong correlation that could indicate that a particular app will have better rating or more install. The overall quality of the app is seems to be the most obvious and strongest predictor. Another good predictor is a budget that was set for adds campaign.","b248f2c7":"It seems that the row have some missplaced values. Let's remove the row.","ed950376":"Outstanding performance! Algorithm managed to generalize on 30 features with max correlation of about 0.15! Let's try to improve it further.","70ae74d1":"It seems that there are multiple genres listed in Genres column. We need to split it it."}}