{"cell_type":{"ad448aa9":"code","509e90d6":"code","2121b712":"code","6d11557a":"code","949b4cc2":"code","68268854":"code","41a839b2":"code","56ebcf08":"code","a66c37d6":"code","1fa30ea4":"code","55baad37":"code","a154e081":"code","0044883d":"code","02c84088":"code","40e934f4":"code","c23639b8":"code","b9598f23":"code","5386b664":"code","bc82c37c":"code","621013b6":"code","544777a4":"code","794f1b5e":"code","f6cab3a0":"code","751bc83e":"code","4c407917":"code","2ec0ef6e":"code","b24ea764":"code","e0db5dd5":"code","9e004fd2":"code","e6e9e46c":"markdown","c3b95dd3":"markdown","d972eaa7":"markdown","ac6432f5":"markdown","c99febf9":"markdown","791d6579":"markdown","7f9e405b":"markdown","875c7de3":"markdown","2d5392f8":"markdown","e0e4c6ed":"markdown","bed0be68":"markdown","f087a3d0":"markdown","da01c974":"markdown","88b890ea":"markdown","911bc485":"markdown","7fc11d14":"markdown","f06137a0":"markdown","901fbdfa":"markdown","a41ac0c4":"markdown","5f994d32":"markdown","c40f8988":"markdown","13b0679d":"markdown","53ad0705":"markdown","95dc49d6":"markdown","8ff7ebfe":"markdown","ef573961":"markdown","b3c07203":"markdown","e026c378":"markdown","cc013817":"markdown","01d3041f":"markdown","a689727e":"markdown","fa217305":"markdown","22bc58e4":"markdown","0ce84a0f":"markdown","d85ad256":"markdown","32483913":"markdown"},"source":{"ad448aa9":"from IPython.display import HTML\nHTML('''\n<script>\n  function code_toggle() {\n    if (code_shown){\n      $('div.input').hide('500');\n      $('#toggleButton').val('Show Code')\n    } else {\n      $('div.input').show('500');\n      $('#toggleButton').val('Hide Code')\n    }\n    code_shown = !code_shown\n  }\n\n  $( document ).ready(function(){\n    code_shown=false;\n    $('div.input').hide()\n  });\n<\/script>\n<form action=\"javascript:code_toggle()\"><input type=\"submit\" id=\"toggleButton\" value=\"Show Code\"><\/form>''')","509e90d6":"%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nplt.style.use('ggplot')\n\nimport seaborn as sns # for making plots with seaborn\ncolor = sns.color_palette()\nsns.set(rc={'figure.figsize':(25,15)})\n\nimport plotly\n# connected=True means it will download the latest version of plotly javascript library.\nplotly.offline.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\n\nimport plotly.figure_factory as ff\nimport cufflinks as cf\n\n\nimport warnings\nwarnings.filterwarnings('ignore')","2121b712":"\ndf = pd.read_csv('..\/input\/googleplaystore.csv')\n\n#print(df.dtypes)\n#df.loc[df.App=='Tiny Scanner - PDF Scanner App']\n# df[df.duplicated(keep='first')]\ndf.drop_duplicates(subset='App', inplace=True)\ndf = df[df['Android Ver'] != np.nan]\ndf = df[df['Android Ver'] != 'NaN']\ndf = df[df['Installs'] != 'Free']\ndf = df[df['Installs'] != 'Paid']\n\n#print(len(df))","6d11557a":"print('Number of apps in the dataset : ' , len(df))\ndf.sample(7)","949b4cc2":"\n# - Installs : Remove + and ,\n\ndf['Installs'] = df['Installs'].apply(lambda x: x.replace('+', '') if '+' in str(x) else x)\ndf['Installs'] = df['Installs'].apply(lambda x: x.replace(',', '') if ',' in str(x) else x)\ndf['Installs'] = df['Installs'].apply(lambda x: int(x))\n#print(type(df['Installs'].values))\n","68268854":"# - Size : Remove 'M', Replace 'k' and divide by 10^-3\n#df['Size'] = df['Size'].fillna(0)\n\ndf['Size'] = df['Size'].apply(lambda x: str(x).replace('Varies with device', 'NaN') if 'Varies with device' in str(x) else x)\n\ndf['Size'] = df['Size'].apply(lambda x: str(x).replace('M', '') if 'M' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: str(x).replace(',', '') if 'M' in str(x) else x)\ndf['Size'] = df['Size'].apply(lambda x: float(str(x).replace('k', '')) \/ 1000 if 'k' in str(x) else x)\n\n\ndf['Size'] = df['Size'].apply(lambda x: float(x))\ndf['Installs'] = df['Installs'].apply(lambda x: float(x))\n\ndf['Price'] = df['Price'].apply(lambda x: str(x).replace('$', '') if '$' in str(x) else str(x))\ndf['Price'] = df['Price'].apply(lambda x: float(x))\n\ndf['Reviews'] = df['Reviews'].apply(lambda x: int(x))\n#df['Reviews'] = df['Reviews'].apply(lambda x: 'NaN' if int(x) == 0 else int(x))\n#print(df.loc[df.Size == 0.713]) #index = 3384\n#df.loc[df.col1 == '']['col2']\n\n# 0 - Free, 1 - Paid\n# df['Type'] = pd.factorize(df['Type'])[0]\n#print(df.dtypes)","41a839b2":"#print(df.dtypes)\n\n\nx = df['Rating'].dropna()\ny = df['Size'].dropna()\nz = df['Installs'][df.Installs!=0].dropna()\np = df['Reviews'][df.Reviews!=0].dropna()\nt = df['Type'].dropna()\nprice = df['Price']\n\np = sns.pairplot(pd.DataFrame(list(zip(x, y, np.log(z), np.log10(p), t, price)), \n                        columns=['Rating','Size', 'Installs', 'Reviews', 'Type', 'Price']), hue='Type', palette=\"Set2\")","56ebcf08":"number_of_apps_in_category = df['Category'].value_counts().sort_values(ascending=True)\n\ndata = [go.Pie(\n        labels = number_of_apps_in_category.index,\n        values = number_of_apps_in_category.values,\n        hoverinfo = 'label+value'\n    \n)]\n\nplotly.offline.iplot(data, filename='active_category')","a66c37d6":"data = [go.Histogram(\n        x = df.Rating,\n        xbins = {'start': 1, 'size': 0.1, 'end' :5}\n)]\n\nprint('Average app rating = ', np.mean(df['Rating']))\nplotly.offline.iplot(data, filename='overall_rating_distribution')","1fa30ea4":"import scipy.stats as stats\nf = stats.f_oneway(df.loc[df.Category == 'BUSINESS']['Rating'].dropna(), \n               df.loc[df.Category == 'FAMILY']['Rating'].dropna(),\n               df.loc[df.Category == 'GAME']['Rating'].dropna(),\n               df.loc[df.Category == 'PERSONALIZATION']['Rating'].dropna(),\n               df.loc[df.Category == 'LIFESTYLE']['Rating'].dropna(),\n               df.loc[df.Category == 'FINANCE']['Rating'].dropna(),\n               df.loc[df.Category == 'EDUCATION']['Rating'].dropna(),\n               df.loc[df.Category == 'MEDICAL']['Rating'].dropna(),\n               df.loc[df.Category == 'TOOLS']['Rating'].dropna(),\n               df.loc[df.Category == 'PRODUCTIVITY']['Rating'].dropna()\n              )\n\nprint(f)\nprint('\\nThe p-value is extremely small, hence we reject the null hypothesis in favor of the alternate hypothesis.\\n')\n#temp = df.loc[df.Category.isin(['BUSINESS', 'DATING'])]\n\ngroups = df.groupby('Category').filter(lambda x: len(x) > 286).reset_index()\narray = groups['Rating'].hist(by=groups['Category'], sharex=True, figsize=(20,20))","55baad37":"groups = df.groupby('Category').filter(lambda x: len(x) >= 170).reset_index()\n#print(type(groups.item.['BUSINESS']))\nprint('Average rating = ', np.nanmean(list(groups.Rating)))\n#print(len(groups.loc[df.Category == 'DATING']))\nc = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 720, len(set(groups.Category)))]\n\n\n#df_sorted = df.groupby('Category').agg({'Rating':'median'}).reset_index().sort_values(by='Rating', ascending=False)\n#print(df_sorted)\n\nlayout = {'title' : 'App ratings across major categories',\n        'xaxis': {'tickangle':-40},\n        'yaxis': {'title': 'Rating'},\n          'plot_bgcolor': 'rgb(250,250,250)',\n          'shapes': [{\n              'type' :'line',\n              'x0': -.5,\n              'y0': np.nanmean(list(groups.Rating)),\n              'x1': 19,\n              'y1': np.nanmean(list(groups.Rating)),\n              'line': { 'dash': 'dashdot'}\n          }]\n          }\n\ndata = [{\n    'y': df.loc[df.Category==category]['Rating'], \n    'type':'violin',\n    'name' : category,\n    'showlegend':False,\n    #'marker': {'color': 'Set2'},\n    } for i,category in enumerate(list(set(groups.Category)))]\n\n\n\nplotly.offline.iplot({'data': data, 'layout': layout})\n\n","a154e081":"groups = df.groupby('Category').filter(lambda x: len(x) >= 50).reset_index()","0044883d":"# sns.set_style('ticks')\n# fig, ax = plt.subplots()\n# fig.set_size_inches(8, 8)\nsns.set_style(\"darkgrid\")\nax = sns.jointplot(df['Size'], df['Rating'])\n#ax.set_title('Rating Vs Size')","02c84088":"\nc = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, len(list(set(groups.Category))))]\n\nsubset_df = df[df.Size > 40]\ngroups_temp = subset_df.groupby('Category').filter(lambda x: len(x) >20)\n\n# for category in enumerate(list(set(groups_temp.Category))):\n#     print (category)\n\ndata = [{\n    'x': groups_temp.loc[subset_df.Category==category[1]]['Rating'], \n    'type':'scatter',\n    'y' : subset_df['Size'],\n    'name' : str(category[1]),\n    'mode' : 'markers',\n    'showlegend': True,\n    #'marker': {'color':c[i]}\n    #'text' : df['rating'],\n    } for category in enumerate(['GAME', 'FAMILY'])]\n\n\nlayout = {'title':\"Rating vs Size\", \n          'xaxis': {'title' : 'Rating'},\n          'yaxis' : {'title' : 'Size (in MB)'},\n         'plot_bgcolor': 'rgb(0,0,0)'}\n\nplotly.offline.iplot({'data': data, 'layout': layout})\n\n# heavy_categories = [ 'ENTERTAINMENT', 'MEDICAL', 'DATING']\n\n# data = [{\n#     'x': groups.loc[df.Category==category]['Rating'], \n#     'type':'scatter',\n#     'y' : df['Size'],\n#     'name' : category,\n#     'mode' : 'markers',\n#     'showlegend': True,\n#     #'text' : df['rating'],\n#     } for category in heavy_categories]","40e934f4":"paid_apps = df[df.Price>0]\np = sns.jointplot( \"Price\", \"Rating\", paid_apps)","c23639b8":"subset_df = df[df.Category.isin(['GAME', 'FAMILY', 'PHOTOGRAPHY', 'MEDICAL', 'TOOLS', 'FINANCE',\n                                 'LIFESTYLE','BUSINESS'])]\nsns.set_style('darkgrid')\nfig, ax = plt.subplots()\nfig.set_size_inches(15, 8)\np = sns.stripplot(x=\"Price\", y=\"Category\", data=subset_df, jitter=True, linewidth=1)\ntitle = ax.set_title('App pricing trend across categories')\n","b9598f23":"#print('Junk apps priced above 350$')\ndf[['Category', 'App']][df.Price > 200]","5386b664":"fig, ax = plt.subplots()\nfig.set_size_inches(15, 8)\nsubset_df_price = subset_df[subset_df.Price<100]\np = sns.stripplot(x=\"Price\", y=\"Category\", data=subset_df_price, jitter=True, linewidth=1)\ntitle = ax.set_title('App pricing trend across categories - after filtering for junk apps')","bc82c37c":"# Stacked bar graph for top 5-10 categories - Ratio of paid and free apps\n#fig, ax = plt.subplots(figsize=(15,10))\n\nnew_df = df.groupby(['Category', 'Type']).agg({'App' : 'count'}).reset_index()\n#print(new_df)\n\n# outer_group_names = df['Category'].sort_values().value_counts()[:5].index\n# outer_group_values = df['Category'].sort_values().value_counts()[:5].values\n\nouter_group_names = ['GAME', 'FAMILY', 'MEDICAL', 'TOOLS']\nouter_group_values = [len(df.App[df.Category == category]) for category in outer_group_names]\n\na, b, c, d=[plt.cm.Blues, plt.cm.Reds, plt.cm.Greens, plt.cm.Purples]\n\n\ninner_group_names = ['Paid', 'Free'] * 4\ninner_group_values = []\n#inner_colors = ['#58a27c','#FFD433']\n\n\nfor category in outer_group_names:\n    for t in ['Paid', 'Free']:\n        x = new_df[new_df.Category == category]\n        try:\n            #print(x.App[x.Type == t].values[0])\n            inner_group_values.append(int(x.App[x.Type == t].values[0]))\n        except:\n            #print(x.App[x.Type == t].values[0])\n            inner_group_values.append(0)\n\nexplode = (0.025,0.025,0.025,0.025)\n# First Ring (outside)\nfig, ax = plt.subplots(figsize=(10,10))\nax.axis('equal')\nmypie, texts, _ = ax.pie(outer_group_values, radius=1.2, labels=outer_group_names, autopct='%1.1f%%', pctdistance=1.1,\n                                 labeldistance= 0.75,  explode = explode, colors=[a(0.6), b(0.6), c(0.6), d(0.6)], textprops={'fontsize': 16})\nplt.setp( mypie, width=0.5, edgecolor='black')\n \n# Second Ring (Inside)\nmypie2, _ = ax.pie(inner_group_values, radius=1.2-0.5, labels=inner_group_names, labeldistance= 0.7, \n                   textprops={'fontsize': 12}, colors = [a(0.4), a(0.2), b(0.4), b(0.2), c(0.4), c(0.2), d(0.4), d(0.2)])\nplt.setp( mypie2, width=0.5, edgecolor='black')\nplt.margins(0,0)\n \n# show it\nplt.tight_layout()\nplt.show()\n\n\n\n#ax = sns.countplot(x=\"Category\", hue=\"Type\", data=new_df)\n\n#df.groupby(['Category', 'Type']).count()['App'].unstack().plot(kind='bar', stacked=True, ax=ax)\n#ylabel = plt.ylabel('Number of apps')\n\n","621013b6":"trace0 = go.Box(\n    y=np.log10(df['Installs'][df.Type=='Paid']),\n    name = 'Paid',\n    marker = dict(\n        color = 'rgb(214, 12, 140)',\n    )\n\n)\ntrace1 = go.Box(\n    y=np.log10(df['Installs'][df.Type=='Free']),\n    name = 'Free',\n    marker = dict(\n        color = 'rgb(0, 128, 128)',\n    )\n)\nlayout = go.Layout(\n    title = \"Number of downloads of paid apps Vs free apps\",\n    yaxis= {'title': 'Number of downloads (log-scaled)'}\n)\ndata = [trace0, trace1]\nplotly.offline.iplot({'data': data, 'layout': layout})","544777a4":"temp_df = df[df.Type == 'Paid']\ntemp_df = temp_df[temp_df.Size > 5]\n#type_groups = df.groupby('Type')\n\ndata = [{\n    #'x': type_groups.get_group(t)['Rating'], \n    'x' : temp_df['Rating'],\n    'type':'scatter',\n    'y' : temp_df['Size'],\n    #'name' : t,\n    'mode' : 'markers',\n    #'showlegend': True,\n    'text' : df['Size'],\n    } for t in set(temp_df.Type)]\n\n\nlayout = {'title':\"Rating vs Size\", \n          'xaxis': {'title' : 'Rating'},\n          'yaxis' : {'title' : 'Size (in MB)'},\n         'plot_bgcolor': 'rgb(0,0,0)'}\n\nplotly.offline.iplot({'data': data, 'layout': layout})","794f1b5e":"#df['Installs'].corr(df['Reviews'])#df['Insta \n#print(np.corrcoef(l, rating))\n\ncorrmat = df.corr()\n#f, ax = plt.subplots()\np =sns.heatmap(corrmat, annot=True, cmap=sns.diverging_palette(220, 20, as_cmap=True))","f6cab3a0":"df_copy = df.copy()\n\ndf_copy = df_copy[df_copy.Reviews > 10]\ndf_copy = df_copy[df_copy.Installs > 0]\n\ndf_copy['Installs'] = np.log10(df['Installs'])\ndf_copy['Reviews'] = np.log10(df['Reviews'])\n\nsns.lmplot(\"Reviews\", \"Installs\", data=df_copy)\nax = plt.gca()\n_ = ax.set_title('Number of Reviews Vs Number of Downloads (Log scaled)')","751bc83e":"reviews_df = pd.read_csv('..\/input\/googleplaystore_user_reviews.csv')","4c407917":"merged_df = pd.merge(df, reviews_df, on = \"App\", how = \"inner\")\nmerged_df = merged_df.dropna(subset=['Sentiment', 'Translated_Review'])","2ec0ef6e":"grouped_sentiment_category_count = merged_df.groupby(['Category', 'Sentiment']).agg({'App': 'count'}).reset_index()\ngrouped_sentiment_category_sum = merged_df.groupby(['Category']).agg({'Sentiment': 'count'}).reset_index()\n\nnew_df = pd.merge(grouped_sentiment_category_count, grouped_sentiment_category_sum, on=[\"Category\"])\n#print(new_df)\nnew_df['Sentiment_Normalized'] = new_df.App\/new_df.Sentiment_y\nnew_df = new_df.groupby('Category').filter(lambda x: len(x) ==3)\n# new_df = new_df[new_df.Category.isin(['HEALTH_AND_FITNESS', 'GAME', 'FAMILY', 'EDUCATION', 'COMMUNICATION', \n#                                      'ENTERTAINMENT', 'TOOLS', 'SOCIAL', 'TRAVEL_AND_LOCAL'])]\nnew_df\n\ntrace1 = go.Bar(\n    x=list(new_df.Category[::3])[6:-5],\n    y= new_df.Sentiment_Normalized[::3][6:-5],\n    name='Negative',\n    marker=dict(color = 'rgb(209,49,20)')\n)\n\ntrace2 = go.Bar(\n    x=list(new_df.Category[::3])[6:-5],\n    y= new_df.Sentiment_Normalized[1::3][6:-5],\n    name='Neutral',\n    marker=dict(color = 'rgb(49,130,189)')\n)\n\ntrace3 = go.Bar(\n    x=list(new_df.Category[::3])[6:-5],\n    y= new_df.Sentiment_Normalized[2::3][6:-5],\n    name='Positive',\n    marker=dict(color = 'rgb(49,189,120)')\n)\n\ndata = [trace1, trace2, trace3]\nlayout = go.Layout(\n    title = 'Sentiment analysis',\n    barmode='stack',\n    xaxis = {'tickangle': -45},\n    yaxis = {'title': 'Fraction of reviews'}\n)\n\nfig = go.Figure(data=data, layout=layout)\n\nplotly.offline.iplot({'data': data, 'layout': layout})","b24ea764":"#merged_df.loc[merged_df.Type=='Free']['Sentiment_Polarity']\nsns.set_style('ticks')\nsns.set_style(\"darkgrid\")\nfig, ax = plt.subplots()\nfig.set_size_inches(11.7, 8.27)\nax = sns.boxplot(x='Type', y='Sentiment_Polarity', data=merged_df)\ntitle = ax.set_title('Sentiment Polarity Distribution')","e0db5dd5":"from wordcloud import WordCloud\nwc = WordCloud(background_color=\"white\", max_words=200, colormap=\"Set2\")\n# generate word cloud\n\nfrom nltk.corpus import stopwords\nstop = stopwords.words('english')\nstop = stop + ['app', 'APP' ,'ap', 'App', 'apps', 'application', 'browser', 'website', 'websites', 'chrome', 'click', 'web', 'ip', 'address',\n            'files', 'android', 'browse', 'service', 'use', 'one', 'download', 'email', 'Launcher']\n\n#merged_df = merged_df.dropna(subset=['Translated_Review'])\nmerged_df['Translated_Review'] = merged_df['Translated_Review'].apply(lambda x: \" \".join(x for x in str(x).split(' ') if x not in stop))\n#print(any(merged_df.Translated_Review.isna()))\nmerged_df.Translated_Review = merged_df.Translated_Review.apply(lambda x: x if 'app' not in x.split(' ') else np.nan)\nmerged_df.dropna(subset=['Translated_Review'], inplace=True)\n\n\nfree = merged_df.loc[merged_df.Type=='Free']['Translated_Review'].apply(lambda x: '' if x=='nan' else x)\nwc.generate(''.join(str(free)))\nplt.figure(figsize=(10, 10))\nplt.imshow(wc, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()","9e004fd2":"paid = merged_df.loc[merged_df.Type=='Paid']['Translated_Review'].apply(lambda x: '' if x=='nan' else x)\nwc.generate(''.join(str(paid)))\nplt.figure(figsize=(10, 10))\nplt.imshow(wc, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()","e6e9e46c":"# Sneak peek at the dataset","c3b95dd3":"# Exploring Correlations","d972eaa7":"**Shocking...Apps priced above 250\\$ !!! ** Let's quickly examine what these junk apps are.","ac6432f5":"# Pricing Strategy - Free Vs Paid?\nHow do app prices impact app rating?","c99febf9":"## Average rating of apps\nDo any apps perform really good or really bad?","791d6579":"# Sizing Strategy - Light Vs Bulky?\n\nHow do app sizes impact the app rating?","7f9e405b":"Most top rated apps are optimally priced between **~1\\$ to ~30\\$**. There are only a very few apps priced above 20\\$.","875c7de3":"## WORDCLOUD - A quick look on reviews\n","2d5392f8":"**Paid apps have a relatively lower number of downloads than free apps.** However, it is not too bad.","e0e4c6ed":"                    Distribution of free and paid apps across major categories","bed0be68":"                            The average app ratings across categories is significantly different.","f087a3d0":"**A moderate positive correlation of 0.63 exists between the number of reviews and number of downloads.** This means that customers tend to download a given app more if it has been reviewed by a larger number of people. \n\nThis also means that many active users who download an app usually also leave back a review or feedback. \n\nSo, getting your app reviewed by more people maybe a good idea to increase your app's capture in the market!","da01c974":"## Current pricing trend - How to price your app?","88b890ea":"## Best performing categories","911bc485":"- **Family** and **Game** apps have the highest market prevelance. \n- Interestingly, **Tools, Business and Medical** apps are also catching up.","7fc11d14":"- **Majority of the paid apps that are highly rated have small sizes.** This means that most paid apps are designed and developed to cater to specific functionalities and hence are not bulky.\n\n\n- **Users prefer to pay for apps that are light-weighted.** A paid app that is bulky may not perform well in the market.","f06137a0":"## App ratings across categories - One Way Anova Test","901fbdfa":"## Android market breakdown\nWhich category has the highest share of (active) apps in the market?","a41ac0c4":"<script>\n  function code_toggle() {\n    if (code_shown){\n      $('div.input').hide('500');\n      $('#toggleButton').val('Show Code')\n    } else {\n      $('div.input').show('500');\n      $('#toggleButton').val('Hide Code')\n    }\n    code_shown = !code_shown\n  }\n\n  $( document ).ready(function(){\n    code_shown=false;\n    $('div.input').hide()\n  });\n<\/script>\n<form action=\"javascript:code_toggle()\"><input type=\"submit\" id=\"toggleButton\" value=\"Show Code\"><\/form>","5f994d32":"## Data Cleaning\n - Convert all app sizes to MB\n - Remove '+' from 'Number of Installs' to make it numeric\n - Convert all review text to English language using Google Translator library","c40f8988":"- **Free apps receive a lot of harsh comments** which are indicated as outliers on the negative Y-axis. \n\n- **Users are more lenient and tolerant while reviewing paid apps - moderate choice of words.** They are never extremely negative while reviewing a paid app. ","13b0679d":"   ** FREE APPS **\n> \n**Negative words: ads, bad, hate**\n>\n**Positive words: good, love, best, great**","53ad0705":"   ** PAID APPS **\n> \n**Negative words: malware, problem**\n>\n**Positive words: great, love, easy**","95dc49d6":"    This is the basic exploratory analysis to look for any evident patterns or relationships between the features. ","8ff7ebfe":"# Are paid apps downloaded as much as free apps?","ef573961":"## Basic EDA","b3c07203":"- **Health and Fitness** apps perform the best, having more than **85% positive reviews**.\n\n\n- On the contrary, many **Game and Social** apps perform bad leading to **50% positive and 50% negative**.","e026c378":"Generally, most apps do well with an average rating of **4.17**.\n\nLet's break this down and inspect if we have categories which perform exceptionally good or bad.","cc013817":"Most top rated apps are optimally sized between **~2MB to ~40MB** - neither too light nor too heavy.","01d3041f":"# How do the sizes of paid apps and free apps vary?","a689727e":"- Clearly, **Medical and Family apps** are the most expensive. Some medical apps extend even upto 80\\$.\n\n\n- All other apps are priced under 30\\$.\n\n\n- Surprisingly, **all game apps are reasonably priced below 20\\$.**","fa217305":"## Distribution of paid and free apps across categories","22bc58e4":"Most bulky apps ( >50MB) belong to the **Game** and **Family** category. Despite this, these bulky apps are fairly highly rated indicating that they are bulky for a purpose.","0ce84a0f":"# CONCLUSION\n\n - Average rating of (active) apps on Google Play Store is **4.17**.\n \n \n - **Users prefer to pay for apps that are light-weighted.** Thus, a paid app that is bulky may not perform well in the market.\n \n \n - Most of the top rated apps are **optimally sized between ~2MB to ~40MB** - neither too light nor too heavy.\n \n \n - Most of the top rated apps are **optimally priced between ~1\\$ to ~30\\$** - neither too cheap nor too expensive.\n \n \n - **Medical and Family apps are the most expensive** and even extend upto 80\\$.\n \n \n - Users tend to download a given app more if it has been reviewed by a large number of people.\n \n \n - **Health and Fitness** apps receive more than **85% positive reviews**. **Game and Social** apps receive mixed feedback - **50% positive and 50% negative.**\n \n \n - **Users are more grim and harsh while reviewing free apps** than paid apps. ","d85ad256":"\n- Almost all app categories perform decently. **Health and Fitness** and **Books and Reference** produce the highest quality apps with **50% apps having a rating greater than 4.5.** This is extremely high!\n\n\n- On the contrary, **50% of apps in the Dating category have a rating lesser than the average rating**. \n\n\n- A few **junk apps** also exist in the **Lifestyle**, **Family** and **Finance** category.\n","32483913":"# Basic sentiment analysis - User reviews "}}