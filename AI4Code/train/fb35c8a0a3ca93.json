{"cell_type":{"12283654":"code","0baa0a7c":"code","70136492":"code","956bd86e":"code","bf732733":"code","8940c49e":"code","a465c0f7":"code","0c920dbf":"code","77d01101":"code","c88511fc":"code","a04a58c2":"code","fa84abea":"code","d84449a0":"code","32d2209c":"code","18d0acbd":"code","c55085a3":"code","0756eb08":"code","f927ffea":"code","5a7bcbc7":"code","93b8c0db":"markdown","6a8542e8":"markdown","c59af8a5":"markdown","1973a271":"markdown","c5a70ca4":"markdown"},"source":{"12283654":"%matplotlib inline\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport numpy as np\nbase_dir = '..\/input\/swiss-rail-plan\/'\nstops_df = pd.read_csv(os.path.join(base_dir, 'stops.csv'))\nstops_df['stop_lon'] = stops_df['stop_lon'].map(float)\nstops_df['stop_lat'] = stops_df['stop_lat'].map(float)\nstops_df.sample(3)\nstops_df.plot.scatter(x='stop_lon', y = 'stop_lat')\n# limit range to swiss-ish places (other places skew the map too much)\nstops_df['stop_lon'] = np.clip(stops_df['stop_lon'], 6, 10)\nstops_df['stop_lat'] = np.clip(stops_df['stop_lat'], 45.5, 48)","0baa0a7c":"fig = plt.figure(figsize=(14,10))\nax1 = fig.add_subplot(111)\nwest, south, east, north = 5, 45, 11, 48\nm = Basemap(projection='merc', llcrnrlat=south, urcrnrlat=north,\n            llcrnrlon=west, urcrnrlon=east, lat_ts=south, ax=ax1)\nm.etopo()\nm.drawcountries()\nm.drawrivers()\nt_lon, t_lat = m(stops_df['stop_lon'].values, stops_df['stop_lat'].values)\nax1.scatter(t_lon, t_lat)","70136492":"stop_dict = {c_row['stop_name']: (c_row['stop_lon'], c_row['stop_lat'])\n                                        for _, c_row in stops_df.iterrows()}","956bd86e":"def show_stop(stop_name, ax, **kwargs):\n    c_lon, c_lat = stop_dict[stop_name]\n    ax.plot(c_lon, c_lat, '.', **kwargs)\n    ax.text(c_lon, c_lat, stop_name)\ndef show_leg(start_name, end_name, ax, **kwargs):\n    s_lon, s_lat = stop_dict[start_name]\n    e_lon, e_lat = stop_dict[end_name]\n    ax.plot([s_lon, e_lon], [s_lat, e_lat], '-')","bf732733":"fig, (ax1) = plt.subplots(1, 1, figsize = (10, 5))\nax1.axis('off')\nfor _, c_row in stops_df.sample(50).iterrows():    \n    show_stop(c_row['stop_name'], ax=ax1)","8940c49e":"import cloudpickle\nwith open('..\/input\/parsing-sbb-routes-as-a-graph\/all_legs.pkl', 'rb') as f:\n    all_legs = cloudpickle.load(f)","a465c0f7":"print(len(all_legs), 'number of legs')\nfor _, c_leg in zip(range(3), all_legs):\n    print(c_leg)    ","0c920dbf":"fig, (ax1) = plt.subplots(1, 1, figsize = (10, 5))\nunique_dict = {tuple(sorted([c_leg.start, c_leg.stop])): c_leg for c_leg in all_legs}\nunique_legs = list(unique_dict.values())\nprint(len(unique_legs), 'number of legs')\nfor i, c_leg in zip(range(50), unique_legs):\n    if i<=5: \n        print(c_leg)\n    show_leg(c_leg.start, c_leg.stop, ax = ax1)","77d01101":"leg_df = pd.DataFrame(unique_legs) \npd.melt(leg_df, value_vars=['start', 'stop'])\\\n    .groupby('value').size() \\\n    .reset_index(name='counts')\\\n    .sort_values('counts', ascending=False)\\\n    .head(5)","c88511fc":"leg_df[leg_df['start'].isin(['Z\u00fcrich HB']) | leg_df['stop'].isin(['Z\u00fcrich HB'])].head(5)","a04a58c2":"def tree_calc_total_distance(start, \n                            stop, \n                            leg_list, \n                            mode = 'bfs',\n                             maximum_distance = None,\n                            _callback = None):\n    visited_legs = set([start])\n    start_stack = [[0, start, None]]\n    while len(start_stack)>0:\n        if mode=='bfs':\n            cur_distance, cur_start, last_leg = start_stack.pop(0) \n        elif mode=='dfs':\n            cur_distance, cur_start, last_leg = start_stack.pop()\n        else:\n            raise ValueError('Dont know how to search trees like that, {}'.format(mode))\n        if (_callback is not None) and (last_leg is not None):\n            _callback(last_leg.start, last_leg.stop)\n        \n        legs_to_check = []\n        for temp_leg in leg_list: \n            # since we want to check forward and backward\n            for cur_leg in [temp_leg,\n                            temp_leg._replace(start=temp_leg.stop, \n                                           stop=temp_leg.start)]:\n                if cur_leg.start==cur_start:\n                    if cur_leg.stop==stop:\n                        if _callback is not None:\n                            _callback(cur_start, stop)\n                        return cur_distance+cur_leg.distance\n                    elif cur_leg.stop not in visited_legs:\n                        legs_to_check += [cur_leg]\n\n        for c_leg in legs_to_check:\n            # we want to avoid visiting any of the stops on this iteration again\n            visited_legs.add(c_leg.stop)\n\n        for c_leg in legs_to_check:\n            # this goes all the way down the before returning\n            new_dist = cur_distance+c_leg.distance\n            if (maximum_distance is None) or (maximum_distance is not None and (new_dist<maximum_distance)):\n                start_stack += [[new_dist, c_leg.stop, c_leg]]\n    return None              ","fa84abea":"# a utility function to compare the methods\nfrom time import time\ndef timeit(f, number = 5): # homemade sloppy timeit\n    start = time()\n    for i in range(number):\n        f()\n    return (time()-start)\/number\n\ndef compare_dfs_and_bfs(start, stop, max_dist = 100000):\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize = (10, 10))\n    ax1.axis('off')\n    ax2.axis('off')\n    def _dfs_callback(x1, x2):\n        show_stop(x1, ax=ax1)\n        show_stop(x2, ax=ax1)\n        show_leg(x1, x2, ax=ax1)\n    tree_calc_total_distance(start, stop, \n                             unique_legs, \n                             mode='dfs', \n                             maximum_distance=max_dist,\n                            _callback = _dfs_callback)\n    time_search = lambda mode: timeit(lambda : tree_calc_total_distance(start, stop, unique_legs, mode=mode, maximum_distance=max_dist), number=1)\n    \n    ax1.set_title('Depth First - Compute: %2.2fs' % time_search('dfs'))\n    def _bfs_callback(x1, x2):\n        show_stop(x1, ax=ax2)\n        show_stop(x2, ax=ax2)\n        show_leg(x1, x2, ax=ax2)\n    tree_calc_total_distance(start, stop, \n                             unique_legs, \n                             mode='bfs', \n                             maximum_distance=max_dist,\n                            _callback = _bfs_callback)\n    ax2.set_title('Breadth First - Compute:%2.2fs' % time_search('bfs'))","d84449a0":"compare_dfs_and_bfs('Buchs AG, Wynenfeld', \n                    'Buchs AG, Heuweg', max_dist = 2000)","32d2209c":"compare_dfs_and_bfs('Z\u00fcrich, Beckenhof', \n                    'Z\u00fcrich, Milchbuck', max_dist = 1500)","18d0acbd":"compare_dfs_and_bfs('Z\u00fcrich, Beckenhof', \n                    'Z\u00fcrich, Oerlikon', max_dist = 3000)","c55085a3":"compare_dfs_and_bfs('Z\u00fcrich HB', \n                    'Luzern', max_dist = 100000)","0756eb08":"compare_dfs_and_bfs('Uster, Strick', 'Gossau ZH, Mitteldorf', max_dist = 1500)","f927ffea":"import sys\nsys.setrecursionlimit(200) # code is sloppy so lets not go nuts\ndef r_calc_total_distance(start, stop, leg_list, \n                        visited_legs = None, \n                        _callback = None):\n    if visited_legs is None:\n        visited_legs = set([start])\n    \n    legs_to_check = []\n    for temp_leg in leg_list: \n        # since we want to check forward and backward\n        for cur_leg in [temp_leg,\n                        temp_leg._replace(start=temp_leg.stop, \n                                       stop=temp_leg.start)]:\n            if cur_leg.start==start:\n                if cur_leg.stop==stop:\n                    if _callback is not None:\n                        _callback(start, stop)\n                    return cur_leg.distance\n                elif cur_leg.stop not in visited_legs:\n                    legs_to_check += [cur_leg]\n    \n    if len(legs_to_check)<1:\n        return None\n    \n    for c_leg in legs_to_check:\n        # we want to avoid visiting any of the stops on this iteration again\n        visited_legs.add(c_leg.stop)\n    \n    for c_leg in legs_to_check:\n        if _callback is not None:\n            _callback(start, c_leg.start)\n            _callback(c_leg.start, c_leg.stop)\n        # this goes all the way down the before returning\n        next_dist = r_calc_total_distance(c_leg.stop, \n                                        stop, \n                                        leg_list=leg_list, \n                                        visited_legs=visited_legs,\n                                       _callback = _callback)\n        if next_dist is not None:\n            return c_leg.distance+next_dist\n    return None              ","5a7bcbc7":"fig, ax1 = plt.subplots(1, 1, figsize = (20, 10))\ndef my_callback(x1, x2):\n    show_stop(x1, ax=ax1)\n    show_stop(x2, ax=ax1)\n    show_leg(x1, x2, ax=ax1)\ntry:\n    out_dist = r_calc_total_distance('Z\u00fcrich, Beckenhof', \n                               'Luzern', \n                               unique_legs, \n                              _callback = my_callback)\nexcept RecursionError as e:\n    print('Not connected, too deep', e)","93b8c0db":"# Recursive Implementation\nHere is the first naive attempt at an algorithm. It is fairly simple and goes through the legs one at a time and tries them in both directions. This version is just a test","6a8542e8":"# Load the actual graph as legs\nHere we have broken down the entire SBB network as a series of point to point legs","c59af8a5":"# Traversal Algorithm\nHere we try our algorithm using breadth and depth-first searches (mode `bfs` or `dfs`) where we effectively just use the `start_stack` as a Queue (FIFO) for BFS or Stack (LIFO) for DFS","1973a271":"# Overview\nThe code here is just to test out a few graph traversal algorithms on some SBB network data and visualize how they work and which methods are most efficient for calculating routes.","c5a70ca4":"## Super Simple Test Case\nHere we try cities that are two stops apart"}}