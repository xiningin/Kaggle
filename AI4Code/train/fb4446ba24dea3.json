{"cell_type":{"ce3e4bb8":"code","bb1d532c":"code","09eb3ba5":"code","eaf85cb3":"code","40af2c70":"code","6fd40267":"code","d012cccd":"code","ec18d52e":"code","d6f4cd20":"code","3d4e6938":"code","b96affa8":"code","4139f090":"code","3dd3e425":"code","35917096":"code","458a6055":"code","4015ce5f":"code","b12f3905":"code","93fdbf3f":"code","e3442641":"code","e106394a":"code","cd5fbe5b":"code","6ebcdbcd":"code","31cb2e9d":"code","528893fb":"code","9aed514e":"code","1de62e7c":"code","c293b102":"code","dab79d58":"code","61731452":"code","25a53e9b":"code","1315147a":"code","7ef8032c":"code","6f150d68":"code","273db019":"code","e7c7a330":"code","59866a0a":"code","5ee4452d":"markdown"},"source":{"ce3e4bb8":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n!pip install pytorch-pretrained-bert\n!pip install seqeval\n\n# Any results you write to the current directory are saved as output.","bb1d532c":"dframe = pd.read_csv(\"..\/input\/ner.csv\", encoding = \"ISO-8859-1\", error_bad_lines=False)","09eb3ba5":"dframe.head()","eaf85cb3":"dataset=dframe.drop(['Unnamed: 0', 'lemma', 'next-lemma', 'next-next-lemma', 'next-next-pos',\n       'next-next-shape', 'next-next-word', 'next-pos', 'next-shape',\n       'next-word', 'prev-iob', 'prev-lemma', 'prev-pos',\n       'prev-prev-iob', 'prev-prev-lemma', 'prev-prev-pos', 'prev-prev-shape',\n       'prev-prev-word', 'prev-shape', 'prev-word','shape'],axis=1)","40af2c70":"dataset.head()","6fd40267":"class SentenceGetter(object):\n    \n    def __init__(self, dataset):\n        self.n_sent = 1\n        self.dataset = dataset\n        self.empty = False\n        agg_func = lambda s: [(w,p, t) for w,p, t in zip(s[\"word\"].values.tolist(),\n                                                       s['pos'].values.tolist(),\n                                                        s[\"tag\"].values.tolist())]\n        self.grouped = self.dataset.groupby(\"sentence_idx\").apply(agg_func)\n        self.sentences = [s for s in self.grouped]\n    \n    def get_next(self):\n        try:\n            s = self.grouped[\"Sentence: {}\".format(self.n_sent)]\n            self.n_sent += 1\n            return s\n        except:\n            return None","d012cccd":"getter = SentenceGetter(dataset)","ec18d52e":"sentences = [\" \".join([s[0] for s in sent]) for sent in getter.sentences]\nsentences[0]","d6f4cd20":"labels = [[s[2] for s in sent] for sent in getter.sentences]\nprint(labels[0])","3d4e6938":"tags_vals = list(set(dataset[\"tag\"].values))\ntag2idx = {t: i for i, t in enumerate(tags_vals)}","b96affa8":"tag2idx","4139f090":"import torch\nfrom torch.optim import Adam\nfrom torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\nfrom keras.preprocessing.sequence import pad_sequences\nfrom sklearn.model_selection import train_test_split\nfrom pytorch_pretrained_bert import BertTokenizer, BertConfig\nfrom pytorch_pretrained_bert import BertForTokenClassification, BertAdam\nfrom tqdm import tqdm, trange","3dd3e425":"MAX_LEN = 40\nbs =64","35917096":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\nn_gpu = torch.cuda.device_count()","458a6055":"torch.cuda.get_device_name(0) ","4015ce5f":"tokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True)","b12f3905":"tokenized_texts = [tokenizer.tokenize(sent) for sent in sentences]\nprint(tokenized_texts[0])","93fdbf3f":"input_ids = pad_sequences([tokenizer.convert_tokens_to_ids(txt) for txt in tokenized_texts],\n                          maxlen=MAX_LEN, dtype=\"long\", truncating=\"post\", padding=\"post\")","e3442641":"input_ids","e106394a":"tags = pad_sequences([[tag2idx.get(l) for l in lab] for lab in labels],\n                     maxlen=MAX_LEN, value=tag2idx[\"O\"], padding=\"post\",\n                     dtype=\"long\", truncating=\"post\")","cd5fbe5b":"tags","6ebcdbcd":"attention_masks = [[float(i>0) for i in ii] for ii in input_ids]","31cb2e9d":"attention_masks","528893fb":"tr_inputs, val_inputs, tr_tags, val_tags = train_test_split(input_ids, tags, \n                                                            random_state=2018, test_size=0.1)\ntr_masks, val_masks, _, _ = train_test_split(attention_masks, input_ids,\n                                             random_state=2018, test_size=0.1)","9aed514e":"tr_inputs = torch.tensor(tr_inputs)\nval_inputs = torch.tensor(val_inputs)\ntr_tags = torch.tensor(tr_tags)\nval_tags = torch.tensor(val_tags)\ntr_masks = torch.tensor(tr_masks)\nval_masks = torch.tensor(val_masks)","1de62e7c":"train_data = TensorDataset(tr_inputs, tr_masks, tr_tags)\ntrain_sampler = RandomSampler(train_data)\ntrain_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=bs)\n\nvalid_data = TensorDataset(val_inputs, val_masks, val_tags)\nvalid_sampler = SequentialSampler(valid_data)\nvalid_dataloader = DataLoader(valid_data, sampler=valid_sampler, batch_size=bs)","c293b102":"train_data","dab79d58":"model = BertForTokenClassification.from_pretrained(\"bert-base-uncased\", num_labels=len(tag2idx))","61731452":"model.cuda()","25a53e9b":"FULL_FINETUNING = True\nif FULL_FINETUNING:\n    param_optimizer = list(model.named_parameters())\n    no_decay = ['bias', 'gamma', 'beta']\n    optimizer_grouped_parameters = [\n        {'params': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.01},\n        {'params': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)],\n         'weight_decay_rate': 0.0}\n    ]\nelse:\n    param_optimizer = list(model.classifier.named_parameters()) \n    optimizer_grouped_parameters = [{\"params\": [p for n, p in param_optimizer]}]\noptimizer = Adam(optimizer_grouped_parameters, lr=3e-5)","1315147a":"from seqeval.metrics import f1_score\n\ndef flat_accuracy(preds, labels):\n    pred_flat = np.argmax(preds, axis=2).flatten()\n    labels_flat = labels.flatten()\n    return np.sum(pred_flat == labels_flat) \/ len(labels_flat)","7ef8032c":"epochs = 5\nmax_grad_norm = 1.0\n\nfor _ in trange(epochs, desc=\"Epoch\"):\n    # TRAIN loop\n    model.train()\n    tr_loss = 0\n    nb_tr_examples, nb_tr_steps = 0, 0\n    for step, batch in enumerate(train_dataloader):\n        # add batch to gpu\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n        # forward pass\n        loss = model(b_input_ids, token_type_ids=None,\n                     attention_mask=b_input_mask, labels=b_labels)\n        # backward pass\n        loss.backward()\n        # track train loss\n        tr_loss += loss.item()\n        nb_tr_examples += b_input_ids.size(0)\n        nb_tr_steps += 1\n        # gradient clipping\n        torch.nn.utils.clip_grad_norm_(parameters=model.parameters(), max_norm=max_grad_norm)\n        # update parameters\n        optimizer.step()\n        model.zero_grad()\n    # print train loss per epoch\n    print(\"Train loss: {}\".format(tr_loss\/nb_tr_steps))\n    # VALIDATION on validation set\n    model.eval()\n    eval_loss, eval_accuracy = 0, 0\n    nb_eval_steps, nb_eval_examples = 0, 0\n    predictions , true_labels = [], []\n    for batch in valid_dataloader:\n        batch = tuple(t.to(device) for t in batch)\n        b_input_ids, b_input_mask, b_labels = batch\n        \n        with torch.no_grad():\n            tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                                  attention_mask=b_input_mask, labels=b_labels)\n            logits = model(b_input_ids, token_type_ids=None,\n                           attention_mask=b_input_mask)\n        logits = logits.detach().cpu().numpy()\n        label_ids = b_labels.to('cpu').numpy()\n        predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n        true_labels.append(label_ids)\n        \n        tmp_eval_accuracy = flat_accuracy(logits, label_ids)\n        \n        eval_loss += tmp_eval_loss.mean().item()\n        eval_accuracy += tmp_eval_accuracy\n        \n        nb_eval_examples += b_input_ids.size(0)\n        nb_eval_steps += 1\n    eval_loss = eval_loss\/nb_eval_steps\n    print(\"Validation loss: {}\".format(eval_loss))\n    print(\"Validation Accuracy: {}\".format(eval_accuracy\/nb_eval_steps))\n    pred_tags = [tags_vals[p_i] for p in predictions for p_i in p]\n    valid_tags = [tags_vals[l_ii] for l in true_labels for l_i in l for l_ii in l_i]\n    print(\"F1-Score: {}\".format(f1_score(pred_tags, valid_tags)))","6f150d68":"model.eval()\npredictions = []\ntrue_labels = []\neval_loss, eval_accuracy = 0, 0\nnb_eval_steps, nb_eval_examples = 0, 0\nfor batch in valid_dataloader:\n    batch = tuple(t.to(device) for t in batch)\n    b_input_ids, b_input_mask, b_labels = batch\n\n    with torch.no_grad():\n        tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                              attention_mask=b_input_mask, labels=b_labels)\n        logits = model(b_input_ids, token_type_ids=None,\n                       attention_mask=b_input_mask)\n        \n    logits = logits.detach().cpu().numpy()\n    predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n    label_ids = b_labels.to('cpu').numpy()\n    true_labels.append(label_ids)\n    tmp_eval_accuracy = flat_accuracy(logits, label_ids)\n\n    eval_loss += tmp_eval_loss.mean().item()\n    eval_accuracy += tmp_eval_accuracy\n\n    nb_eval_examples += b_input_ids.size(0)\n    nb_eval_steps += 1\n\npred_tags = [[tags_vals[p_i] for p_i in p] for p in predictions]\nvalid_tags = [[tags_vals[l_ii] for l_ii in l_i] for l in true_labels for l_i in l ]\nprint(\"Validation loss: {}\".format(eval_loss\/nb_eval_steps))\nprint(\"Validation Accuracy: {}\".format(eval_accuracy\/nb_eval_steps))\nprint(\"Validation F1-Score: {}\".format(f1_score(pred_tags, valid_tags)))","273db019":"pred_tags","e7c7a330":"test_sentence = [\"I have recently bought a new samsung galaxy phone\"]\n\ntokenized_test_texts = [tokenizer.tokenize(sent) for sent in test_sentence]\nprint(\"Tokenized Test Sentence\")\nprint(tokenized_test_texts[0])\n\nprint(\"Padding Test Sequence\")\ninput_ids = pad_sequences([tokenizer.convert_tokens_to_ids(txt) for txt in tokenized_test_texts],\n                          maxlen=MAX_LEN, dtype=\"long\", truncating=\"post\", padding=\"post\")\n\ntest_attention_masks = [[float(i>0) for i in ii] for ii in input_ids]\n\ntest_inputs = torch.tensor(input_ids)\ntest_masks = torch.tensor(test_attention_masks)\n\ntest_sentence_data = TensorDataset(test_inputs, test_masks)\ntrain_sentence_sampler = RandomSampler(test_sentence_data)\ntest_sentence_dataloader = DataLoader(test_sentence_data, sampler=train_sentence_sampler, batch_size=bs)\n\n\nmodel.eval()\npredictions = []\n#true_labels = []\neval_loss, eval_accuracy = 0, 0\nnb_eval_steps, nb_eval_examples = 0, 0\nfor batch in test_sentence_dataloader:\n    batch = tuple(t.to(device) for t in batch)\n    b_input_ids, b_input_mask = batch\n\n    with torch.no_grad():\n        tmp_eval_loss = model(b_input_ids, token_type_ids=None,\n                              attention_mask=b_input_mask)\n        logits = model(b_input_ids, token_type_ids=None,\n                       attention_mask=b_input_mask)\n        \n    logits = logits.detach().cpu().numpy()\n    predictions.extend([list(p) for p in np.argmax(logits, axis=2)])\n\n\npred_tags = [[tags_vals[p_i] for p_i in p] for p in predictions]\n","59866a0a":"pred_tags","5ee4452d":"TEST ON RANDOM INPUT"}}