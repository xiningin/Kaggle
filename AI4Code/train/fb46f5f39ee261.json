{"cell_type":{"655750d9":"code","f3be7aed":"code","3d89f1e7":"code","d88c1f31":"code","bdd0b47a":"code","637c9142":"code","ab574251":"code","87e4a6c5":"code","49e93141":"code","95c759ee":"code","31665162":"code","9862b94e":"code","875b0818":"code","82020233":"code","f7c0d435":"code","7933b372":"code","906428bb":"code","3c3a9395":"code","34c7cc56":"markdown","6842f50d":"markdown"},"source":{"655750d9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f3be7aed":"import osmnx as ox\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\n\nfrom shapely.geometry import Point\nfrom sklearn.preprocessing import MinMaxScaler\n\ncity = ox.gdf_from_place('S\u00e3o Paulo, S\u00e3o Paulo, Brasil')\nmm = MinMaxScaler()","3d89f1e7":"data = pd.read_csv(\"\/kaggle\/input\/eleicoes-municipais-2016-sp\/sao_paulo.csv\", converters={\"coordenadas\": eval})\ndata[\"geometry\"] = data[\"coordenadas\"].apply(lambda x : Point(x))","d88c1f31":"SP_cities = gpd.read_file(\"\/kaggle\/input\/eleicoes-municipais-2016-sp\/sp_municipios\/35MUE250GC_SIR.shp\")\nSP_cities.head()","bdd0b47a":"sp_city = SP_cities[SP_cities[\"NM_MUNICIP\"] == \"S\u00c3O PAULO\"][\"geometry\"].values[0]","637c9142":"candidate = \"EDUARDO SUPLICY\"\n\nagg = data.groupby([\"endere\u00e7o\", \"candidato\"], as_index=False).agg({\"votos\": \"sum\", \n                                                                   \"coordenadas\": \"first\",\n                                                                   \"zona\": \"first\",\n                                                                   \"geometry\": \"first\"})\n\nagg = agg[agg[\"candidato\"] == candidate] \nagg = agg[agg[\"geometry\"].apply(lambda x: x.within(sp_city))]\n\nprint(\"{} has {} votes\".format(candidate, agg[\"votos\"].sum()))\n\ngeo_agg = gpd.GeoDataFrame(agg, crs={\"init\": \"epsg:4326\"}, geometry=agg[\"geometry\"])\ngeo_agg[\"votos_size\"] = mm.fit_transform(geo_agg[[\"votos\"]])","ab574251":"geo_agg.shape","87e4a6c5":"max_amount = float(geo_agg[\"votos\"].max())\n\nfig, ax = plt.subplots(figsize=(15, 15))\ncity.plot(ax=ax, color=\"grey\", alpha=0.4)\n\n\n### We plot all locations in red to represent without votes. If there are votes they, they will be covered\ngeo_agg.plot(ax=ax, markersize=5.5, color=\"red\", marker=\"o\", label=\"Se\u00e7\u00f5es sem votos\")\n\n\ngeo_agg.plot(column=\"votos\", \n             ax=ax, \n             markersize=100 * geo_agg[\"votos_size\"], \n             marker=\"o\", \n             vmax=max_amount,\n             cmap=\"Greens\", \n             legend=True,\n             label=\"Se\u00e7\u00f5es com votos\")\n\nplt.xticks([], [])\nplt.yticks([], [])\nplt.title(\"Votos de \" + candidate + \" por regi\u00e3o\")\nplt.legend()\nplt.show()","49e93141":"sp_zones = gpd.read_file(\"\/kaggle\/input\/eleicoes-municipais-2016-sp\/SP_ZONAS_janeiro_2018\/ZONAS_FINAL.shp\")\nsp_zones.head()","95c759ee":"sp_zones.shape","31665162":"agg_with_sectors = gpd.sjoin(sp_zones, geo_agg, how=\"inner\", op='intersects')","9862b94e":"agg_with_sectors.columns","875b0818":"agg_with_sectors = agg_with_sectors.groupby(\"FIRST_NOME\", as_index=False).agg({\"votos\": \"sum\", \"geometry\": \"first\"})\nagg_with_sectors = gpd.GeoDataFrame(agg_with_sectors, crs={\"init\": \"epsg:4326\"}, geometry=agg_with_sectors[\"geometry\"])","82020233":"agg_with_sectors.head()","f7c0d435":"agg_with_sectors.shape","7933b372":"agg_with_sectors[\"votos\"].sum()","906428bb":"variable = \"votos\"\n\nfig, ax = plt.subplots(figsize=(15, 15))\ncity.plot(ax=ax, color=\"#ece5e5\")\n\nvmax = agg_with_sectors[variable].quantile(0.99)\nvmin = agg_with_sectors[variable].quantile(0.01)\n\nax = agg_with_sectors.plot(column=variable, \n         cmap=\"Greens\", \n         legend=True,\n         ax=ax,\n         k=10,\n         vmax=vmax,\n         vmin=vmin\n         )\n\n\nplt.xticks([], [])\nplt.yticks([], [])\nplt.title(\"Votos de \" + candidate + \" por zona eleitoral\")\nplt.legend()\nplt.show()","3c3a9395":"variable = \"votos\"\nagg_with_sectors[\"name\"] = agg_with_sectors[\"FIRST_NOME\"].apply(lambda x: x.split(\" - \")[1])\n\nfig, ax = plt.subplots(figsize=(35, 35))\ncity.plot(ax=ax, color=\"#ece5e5\")\n\nvmax = agg_with_sectors[variable].quantile(0.99)\nvmin = agg_with_sectors[variable].quantile(0.01)\n\nax = agg_with_sectors.plot(column=variable, \n         cmap=\"Greens\", \n         legend=True,\n         ax=ax,\n         k=10,\n         vmax=vmax,\n         vmin=vmin\n         )\n\nagg_with_sectors.apply(lambda x: ax.annotate(s=x[\"name\"], xy=x.geometry.centroid.coords[0], ha='center', color=\"blue\"), axis=1);\nplt.xticks([], [])\nplt.yticks([], [])\nplt.title(\"Votos de \" + candidate + \" por zona eleitoral\")\nplt.legend()\nplt.show()","34c7cc56":"Adding annotations with the Zona names","6842f50d":"# Plot maps using zones shapes\n"}}