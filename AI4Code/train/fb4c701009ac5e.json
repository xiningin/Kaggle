{"cell_type":{"0ffa20a3":"code","8f3470b1":"code","7577b3ae":"code","1bdd3c24":"code","91841592":"code","d8768330":"code","4d370580":"code","8e60d1a7":"code","64eb1f39":"code","a290ff0c":"code","cbc4762c":"code","d83e5db4":"code","c6a5683b":"code","2e219e4b":"code","998f35c9":"code","d65edb36":"code","bda4e839":"code","025fe880":"code","0c5b2040":"code","92176d0a":"code","e283f609":"code","c50912fd":"code","2c5b7f05":"code","bdc2211d":"code","8017e2d0":"code","9468b532":"code","1091486a":"code","95de3f95":"code","f3a837ba":"code","a6b4d0ad":"code","8b1e795a":"markdown","0576b138":"markdown","10217b78":"markdown","22f7b457":"markdown","473d2ad4":"markdown","4de44f40":"markdown","c3c4f72c":"markdown","57590e49":"markdown","0d262be1":"markdown","ad13b1e1":"markdown"},"source":{"0ffa20a3":"import tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras.preprocessing.image import ImageDataGenerator\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.models import Sequential, Model\nfrom tensorflow.keras.layers import GlobalAveragePooling2D,Dense, BatchNormalization, Dropout, Flatten, Conv2D, MaxPooling2D,Activation\nfrom tensorflow.keras.optimizers import Adam\n# Manipula\u00e7\u00e3o e visualiza\u00e7\u00e3o\nimport numpy as np\nimport pandas as pd\nimport random\nimport os\n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n%matplotlib inline","8f3470b1":"import warnings\nwarnings.filterwarnings(\"ignore\")","7577b3ae":"TRAIN_DIR = \"..\/input\/food11-image-dataset\/training\/\"\nVAL_DIR = \"..\/input\/food11-image-dataset\/validation\/\"\nTEST_DIR= \"..\/input\/food11-image-dataset\/evaluation\/\"\n\nval_loss = list()\nval_accuracy = list()\ntest_loss= list()\ntest_accuracy = list()","1bdd3c24":"BATCH_SIZE = 16\nseeds = 41\nim_shape = (250,250)","91841592":"# Subdivision in test\/validation\ndata_generator = ImageDataGenerator(rescale=1.\/255, validation_split=0.2)\nval_data_generator = ImageDataGenerator(rescale=1.\/255, validation_split=0.2)\ntest_generator = ImageDataGenerator(rescale=1.\/255)\n\n\n# Generator of Train\ntrain_generator = data_generator.flow_from_directory(TRAIN_DIR, target_size=im_shape, shuffle=True, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"training\")\n# Generator para parte valida\u00e7\u00e3o\nvalidation_generator = val_data_generator.flow_from_directory(VAL_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"validation\")\n\n# Generator para dataset de teste\ntest_generator = test_generator.flow_from_directory(TEST_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE)\n#\nnb_train_samples = train_generator.samples\nnb_validation_samples = validation_generator.samples\nnb_test_samples = test_generator.samples\nclasses = list(train_generator.class_indices.keys())\nprint('Classes: '+str(classes))\nnum_classes  = len(classes)","d8768330":"plt.figure(figsize=(15,15))\nfor i in range(9):\n    #gera subfigures\n    plt.subplot(330 + 1 + i)\n    batch = train_generator.next()[0]*255\n    image = batch[0].astype('uint8')\n    plt.imshow(image)\nplt.show()","4d370580":"model = Sequential()\nmodel.add(Conv2D(16, kernel_size=(3, 3),activation='relu',input_shape=(im_shape[0],im_shape[1],3)))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Conv2D(32, kernel_size=(3,3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.2))\nmodel.add(Conv2D(64, kernel_size=(3,3), activation='relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Flatten())\nmodel.add(Dense(100, activation='relu'))\nmodel.add(Dropout(0.2))\nmodel.add(Dense(num_classes, activation='softmax'))\nmodel.summary()\n\nmodel.compile(loss='categorical_crossentropy',\n              optimizer=Adam(),\n              metrics=['accuracy'])","8e60d1a7":"epochs = 12\n\n#Callback to save the best model\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=5,verbose=1)\n]\n\n#Training\nhistory = model.fit(\n        train_generator,\n        steps_per_epoch=nb_train_samples \/\/ BATCH_SIZE,\n        epochs=epochs,\n        callbacks = callbacks_list,\n        validation_data=validation_generator,\n        verbose = 1,\n        validation_steps=nb_validation_samples \/\/ BATCH_SIZE)","64eb1f39":"# Load the best saved model\nfrom tensorflow.keras.models import load_model\n\n#model = load_model('..\/input\/classify-food-datas-models\/model.h5')\nmodel = load_model('model.h5')\nscore = model.evaluate_generator(validation_generator)\nval_loss.append(score[0])\nval_accuracy.append(score[1])\nprint('\\n\\nVal loss:', score[0])\nprint('Val accuracy:', score[1])\n\nscore = model.evaluate_generator(test_generator)\nprint('\\nTest loss:', score[0])\nprint('Test accuracy:', score[1])\n\ntest_loss.append(score[0])\ntest_accuracy.append(score[1])","a290ff0c":"import itertools\n\n#Plot the confusion matrix. Set Normalize = True\/False\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n    \"\"\"\n    This function prints and plots the confusion matrix.\n    Normalization can be applied by setting `normalize=True`.\n    \"\"\"\n    plt.figure(figsize=(10,10))\n    plt.imshow(cm, interpolation='nearest', cmap=cmap)\n    plt.title(title)\n    plt.colorbar()\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n        cm = np.around(cm, decimals=2)\n        cm[np.isnan(cm)] = 0.0\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, cm[i, j],\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n    plt.tight_layout()\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')","cbc4762c":"from sklearn.metrics import classification_report, confusion_matrix\n\n#Confution Matrix and Classification Report\nY_pred = model.predict_generator(test_generator)#, nb_test_samples \/\/ BATCH_SIZE, workers=1)\ny_pred = np.argmax(Y_pred, axis=1)\ntarget_names = classes\n\n#Confution Matrix\ncm = confusion_matrix(test_generator.classes, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\nprint('Classification Report')\nprint(classification_report(test_generator.classes, y_pred, target_names=target_names))","d83e5db4":"data_generator = ImageDataGenerator(\n        validation_split=0.2,\n        rotation_range=20,\n        width_shift_range=0.2,\n        height_shift_range=0.2,\n        rescale=1.\/255,\n        shear_range=0.2,\n        zoom_range=0.2,\n        horizontal_flip=True,\n        fill_mode='nearest')\n\nval_data_generator = ImageDataGenerator(rescale=1.\/255, validation_split=0.2)","c6a5683b":"test_generator = ImageDataGenerator(rescale=1.\/255)\n\n\n# Generator of Train\ntrain_generator = data_generator.flow_from_directory(TRAIN_DIR, target_size=im_shape, shuffle=True, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"training\")\n# Generator para parte valida\u00e7\u00e3o\nvalidation_generator = val_data_generator.flow_from_directory(VAL_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"validation\")\n\n# Generator para dataset de teste\ntest_generator = test_generator.flow_from_directory(TEST_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE)\n\nnb_train_samples = train_generator.samples\nnb_validation_samples = validation_generator.samples\nnb_test_samples = test_generator.samples\nclasses = list(train_generator.class_indices.keys())\nprint('Classes: '+str(classes))\nnum_classes  = len(classes)","2e219e4b":"model2 = Sequential()\nmodel2.add(Conv2D(16, kernel_size=(3, 3),\n                 activation='relu',\n                 input_shape=(im_shape[0],im_shape[1],3)))\nmodel2.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel2.add(Conv2D(32, kernel_size=(3,3), activation='relu'))\nmodel2.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel2.add(Dropout(0.2))\n\nmodel2.add(Conv2D(64, kernel_size=(3,3), activation='relu'))\nmodel2.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel2.add(Flatten())\n\nmodel2.add(Dense(100, activation='relu'))\nmodel2.add(Dropout(0.2))\nmodel2.add(Dense(num_classes, activation='softmax'))\nmodel2.summary()\n\n# Compila o modelo\nmodel2.compile(loss='categorical_crossentropy',\n              optimizer=Adam(),\n              metrics=['accuracy'])\n\n############################################################\nepochs = 12\n\n#Callback to save the best model\ncallbacks_list2 = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model2.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=5,verbose=1)\n]\n\n#Training\nhistory2 = model2.fit(\n        train_generator,\n        steps_per_epoch=nb_train_samples \/\/ BATCH_SIZE,\n        epochs=epochs,\n        callbacks = callbacks_list2,\n        validation_data=validation_generator,\n        verbose = 1,\n        validation_steps=nb_validation_samples \/\/ BATCH_SIZE)","998f35c9":"model_2 = load_model('model2.h5')\nscore = model_2.evaluate_generator(validation_generator)\n\nval_loss.append(score[0])\nval_accuracy.append(score[1])\n\nprint('Val loss:', score[0])\nprint('Val accuracy:', score[1])\n\nscore = model_2.evaluate_generator(test_generator)\n\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\n\ntest_loss.append(score[0])\ntest_accuracy.append(score[1])","d65edb36":"#Confution Matrix and Classification Report\nY_pred = model_2.predict_generator(test_generator)#, nb_test_samples \/\/ BATCH_SIZE, workers=1)\ny_pred = np.argmax(Y_pred, axis=1)\ntarget_names = classes\n\n#Confution Matrix\ncm = confusion_matrix(test_generator.classes, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\nprint('Classification Report')\nprint(classification_report(test_generator.classes, y_pred, target_names=target_names))","bda4e839":"from tensorflow.keras.applications.inception_resnet_v2 import InceptionResNetV2, preprocess_input\n\ndata_generator = ImageDataGenerator(\n        validation_split=0.2,\n        rotation_range=45,\n        width_shift_range=0.2,\n        height_shift_range=0.2,\n        preprocessing_function=preprocess_input,\n        shear_range=0.2,\n        zoom_range=0.2,\n        horizontal_flip=True,\n        fill_mode='nearest')\n\nval_data_generator = ImageDataGenerator(preprocessing_function=preprocess_input,validation_split=0.2)\n\ntest_generator = ImageDataGenerator(preprocessing_function=preprocess_input)","025fe880":"train_generator = data_generator.flow_from_directory(TRAIN_DIR, target_size=im_shape, shuffle=True, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"training\")\n# Generator para parte valida\u00e7\u00e3o\nvalidation_generator = val_data_generator.flow_from_directory(TRAIN_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE, subset=\"validation\")\n\n# Generator para dataset de teste\n\ntest_generator = test_generator.flow_from_directory(TEST_DIR, target_size=im_shape, shuffle=False, seed=seeds,\n                                                     class_mode='categorical', batch_size=BATCH_SIZE)\n\nnb_train_samples = train_generator.samples\nnb_validation_samples = validation_generator.samples\nnb_test_samples = test_generator.samples\nclasses = list(train_generator.class_indices.keys())\nprint('Classes: '+str(classes))\nnum_classes  = len(classes)","0c5b2040":"plt.figure(figsize=(15,15))\nfor i in range(9):\n    #gera subfigures\n    plt.subplot(330 + 1 + i)\n    batch = train_generator.next()[0]*255\n    image = batch[0].astype('uint8')\n    plt.imshow(image)\nplt.show()","92176d0a":"base_model = InceptionResNetV2(weights='imagenet', include_top=False, input_shape=(im_shape[0], im_shape[1], 3))\n\nx = base_model.output\nx = Flatten()(x)\nx = Dense(100, activation='relu')(x)\npredictions = Dense(num_classes, activation='softmax', kernel_initializer='random_uniform')(x)\n\nmodel3 = Model(inputs=base_model.input, outputs=predictions)\n\n# Freezing pretrained layers\nfor layer in base_model.layers:\n    layer.trainable=False\n    \noptimizer = Adam()\nmodel3.compile(optimizer=optimizer,loss='categorical_crossentropy',metrics=['accuracy'])","e283f609":"epochs = 15\n\n# Saving the best model\ncallbacks_list = [\n    keras.callbacks.ModelCheckpoint(\n        filepath='model3.h5',\n        monitor='val_loss', save_best_only=True, verbose=1),\n    keras.callbacks.EarlyStopping(monitor='val_loss', patience=6,verbose=1)\n]\n\nhistory = model3.fit(\n        train_generator,\n        steps_per_epoch=nb_train_samples \/\/ BATCH_SIZE,\n        epochs=epochs,\n        callbacks = callbacks_list,\n        validation_data=validation_generator,\n        verbose = 1,\n        validation_steps=nb_validation_samples \/\/ BATCH_SIZE)","c50912fd":"#Vamos ver como foi o treino?\n\nhistory_dict = history.history\nloss_values = history_dict['loss']\nval_loss_values = history_dict['val_loss']\n\nepochs_x = range(1, len(loss_values) + 1)\nplt.figure(figsize=(10,10))\nplt.subplot(2,1,1)\nplt.plot(epochs_x, loss_values, 'bo', label='Training loss')\nplt.plot(epochs_x, val_loss_values, 'b', label='Validation loss')\nplt.title('Training and validation Loss and Accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\n#plt.legend()\nplt.subplot(2,1,2)\nacc_values = history_dict['accuracy']\nval_acc_values = history_dict['val_accuracy']\nplt.plot(epochs_x, acc_values, 'bo', label='Training acc')\nplt.plot(epochs_x, val_acc_values, 'b', label='Validation acc')\n#plt.title('Training and validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Acc')\nplt.legend()\nplt.show()","2c5b7f05":"# Load the best saved model\n# model = load_model('..\/input\/classify-food-datas-models\/model3.h5')\nmodel = load_model('model3.h5')\nscore = model.evaluate_generator(validation_generator)\nval_loss.append(score[0])\nval_accuracy.append(score[1])\nprint('Val loss:', score[0])\nprint('Val accuracy:', score[1])\n\nscore = model.evaluate_generator(test_generator)\n\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])\n\ntest_loss.append(score[0])\ntest_accuracy.append(score[1])","bdc2211d":"#Confution Matrix and Classification Report\nY_pred = model.predict_generator(test_generator)#, nb_test_samples \/\/ BATCH_SIZE, workers=1)\ny_pred = np.argmax(Y_pred, axis=1)\ntarget_names = classes\n\n#Confution Matrix\ncm = confusion_matrix(test_generator.classes, y_pred)\nplot_confusion_matrix(cm, target_names, normalize=False, title='Confusion Matrix')\nprint('Classification Report')\nprint(classification_report(test_generator.classes, y_pred, target_names=target_names))","8017e2d0":"import seaborn as sns\n\ndate_results={\n    \"Val_loss\":[val_loss[0],val_loss[1],val_loss[2]],\n    \"Val_accuracy\":[val_accuracy[0],val_accuracy[1],val_accuracy[2]],\n    \"Test_loss\":[test_loss[0],test_loss[1],test_loss[2]],\n    \"Test_accuracy\":[test_accuracy[0],test_accuracy[1],test_accuracy[2]],\n    \"Model\":['CNN1','CNN20','TL45']}\n\ndate_result=pd.DataFrame(date_results)\ndate_result2 = date_result.iloc[:3,:4]*100\ndate_result3 = pd.concat([date_result2,date_result['Model']],axis=1)\ndate_result3.head()","9468b532":"date_result4 = date_result3.copy()\ndate_result4.index = date_result4['Model']\ndate_result4 = date_result4.drop(columns=\"Model\")\ndate_result4.head()","1091486a":"date_result4.plot.line(figsize=(10,5),color=['#ff9605','#483D8B','#FF0000','#0000FF'])","95de3f95":"sns.set_theme(style=\"white\", context=\"talk\")\nrs = np.random.RandomState(8)","f3a837ba":"# Set up the matplotlib figure\n\nf, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 8), sharex=True)\n#\n\n# Generate some sequential data\nx = np.array(date_result3.columns[:4])\ny1 = np.array(date_result3.iloc[0,:4].values)\ny1 = [round(num,2) for num in y1]\n#\nsns.barplot(x=x, y=y1, palette=\"rocket\", ax=ax1)\nax1.axhline(0, color=\"k\", clip_on=False)\nax1.set_ylabel(date_result3[\"Model\"][0])\n#ax1.text(x=x,y=y1,color='black', ha=\"center\")\nax1.text(0.08, 1.10, y1[0], ha=\"left\", va=\"top\", transform=ax1.transAxes)\nax1.text(0.33, 0.36, y1[1], ha=\"left\", va=\"top\", transform=ax1.transAxes)\nax1.text(0.57, 1.05, y1[2], ha=\"left\", va=\"top\", transform=ax1.transAxes)\nax1.text(0.83, 0.39, y1[3], ha=\"left\", va=\"top\", transform=ax1.transAxes)\n#\n# Center the data to make it diverging\ny2 = np.array(date_result3.iloc[1,:4].values)\ny2 = [ round(num,2) for num in y2]\nsns.barplot(x=x, y=y2, palette=\"rocket\", ax=ax2)#vlag\nax2.axhline(0, color=\"k\", clip_on=False)\nax2.set_ylabel(date_result3[\"Model\"][1])\nax2.text(0.08, 1.10, y2[0], ha=\"left\", va=\"top\", transform=ax2.transAxes)\nax2.text(0.33, 0.5, y2[1], ha=\"left\", va=\"top\",  transform=ax2.transAxes)\nax2.text(0.57, 1.05, y2[2], ha=\"left\", va=\"top\", transform=ax2.transAxes)\nax2.text(0.83, 0.5, y2[3], ha=\"left\", va=\"top\",  transform=ax2.transAxes)\n#\n# Randomly reorder the data to make it qualitative\ny3 = np.array(date_result3.iloc[2,:4].values)\ny3 = [ round(num,2) for num in y3]\nsns.barplot(x=x, y=y3, palette=\"rocket\", ax=ax3)\nax3.axhline(0, color=\"k\", clip_on=False)\nax3.set_ylabel(date_result3[\"Model\"][2])\nax3.text(0.08, 0.73, y3[0], ha=\"left\", va=\"top\", transform=ax3.transAxes)\nax3.text(0.33, 1.1, y3[1], ha=\"left\", va=\"top\",  transform=ax3.transAxes)\nax3.text(0.57, 0.65, y3[2], ha=\"left\", va=\"top\", transform=ax3.transAxes)\nax3.text(0.83, 1.1, y3[3], ha=\"left\", va=\"top\",  transform=ax3.transAxes)\n\n# Finalize the plot\nsns.despine(bottom=True)\nplt.setp(f.axes, yticks=[])\nplt.tight_layout(h_pad=2)\nplt.title(\"Peformance of CNN's and Transfer Learn\",x=0.5,y=4)","a6b4d0ad":"Y_pred_cnn=GBC.predict(X_test)\n\n\n\ncfm_GBC = confusion_matrix(Y_test, Y_pred_GBC)\ncfm_GBC=cfm_GBC \/ cfm_GBC.astype(np.float).sum(axis=1)\n\ncfm_BC = confusion_matrix(Y_test, Y_pred_BC)\ncfm_BC=cfm_BC \/ cfm_BC.astype(np.float).sum(axis=1)\n\ncfm_DTC = confusion_matrix(Y_test, Y_pred_DTC)\ncfm_DTC=cfm_DTC \/ cfm_DTC.astype(np.float).sum(axis=1)\n\ncfm_RF = confusion_matrix(Y_test, Y_pred_RF)\ncfm_RF=cfm_RF \/ cfm_RF.astype(np.float).sum(axis=1)\n\nf, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex='col', sharey='row', figsize=(10,8))\nsns.heatmap(cfm_GBC, annot = True,  linewidths=.5, ax=ax1, cbar =None)\nax1.set_title('Gradient Boosting Classifier')\nplt.ylabel('True label')\nplt.xlabel('Predicted label')\nsns.heatmap(cfm_BC, annot = True,  linewidths=.5, ax=ax2, cbar =None)\nax2.set_title('Bagging Classifier')\nplt.ylabel('True label')\nplt.xlabel('Predicted label')\nsns.heatmap(cfm_DTC, annot = True, linewidths=.5, ax=ax3, cbar =None)\nax3.set_title('Decision Tree Classifier')\nplt.ylabel('True label')\nplt.xlabel('Predicted label')\nsns.heatmap(cfm_RF, annot = True, linewidths=.5, ax=ax4, cbar =None)\nax4.set_title('Random Forest Classifier')\nplt.ylabel('True label')\nplt.xlabel('Predicted label')","8b1e795a":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n    Generate DataBase to model1\n<\/span>","0576b138":"<span style=\" font-family: Times New Roman ; font-size: 35px;\">\n    <p style=\"font-size: 25px;\">This notebook is useful to understand how implement Deep Learning.  I made a comparison using Data Augmentation and Transfer Lerning.<\/p>\n<\/span>\n    <h1  style=\" font-family: Times New Roman ; font-size: 35px;\">Summary<\/h1>\n    <ol  style=\" text-align:left; font-family: Times New Roman ; font-size: 22px;\">\n        <li>Settings\n            <ol style=\" text-align:left; font-family: Times New Roman ; font-size: 18px;\">\n                <li>Settings DataBase Path<\/li>\n                <li>Settings to CNN<\/li>\n            <\/ol>\n        <\/li>\n        <li>Generate DataBase to model1<p style=\"font-size: 18px;\">This model has not Data Augmentation<\/p><\/li>\n        <li>Creating CNN to model1<\/li>\n        <li>Generate Database with <u>Data Augmentation<\/u> to model 2<\/li>\n        <li>Creating CNN to model2<\/li>\n        <li>Let's use transfer learn !<\/li>\n        <li>What are the results? <\/li>\n    <\/ol>\n  ","10217b78":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n    Creating CNN to model1\n<\/span>    \n<p><li>model.h5 created<\/li><\/p>","22f7b457":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n   Generate Database <u>with Data Augmentation<\/u> to model 2\n    <\/span>","473d2ad4":"<span style=\" font-family: Times New Roman ; font-size: 25px\">\n    Now we can see the Difference between CNN and Transfer Learning!\n<\/span>","4de44f40":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n    Settings to CNN <\/span>","c3c4f72c":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\nWhat are the results ?\n<\/span>","57590e49":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n    Creating CNN to model2\n<\/span>    \n<p><li>model2.h5 created<\/li><\/p>","0d262be1":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\n    Setting Databases Path <span>","ad13b1e1":"<span style=\" font-family: Times New Roman ; font-size: 35px\">\nLet's use transfer learn !\n<\/span>"}}