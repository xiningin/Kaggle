{"cell_type":{"cf65cb93":"code","91d9853b":"code","88ee0a53":"code","2d356256":"code","6d4ed92b":"code","9215d036":"code","fc7eef3d":"code","cfdad98f":"code","b97c01d8":"code","28c1a02c":"code","31902391":"code","f9f05985":"code","86db9f59":"code","78998e5f":"markdown","cde56349":"markdown"},"source":{"cf65cb93":"import torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set()\n\nfrom scipy import integrate as integrate\nfrom scipy.integrate import odeint\nfrom scipy.integrate import quad\n\n# Test: 1-dressed gluon\ndef ab(a,b,phia,phib):\n    return 1-np.cos(a)*np.cos(b)-np.cos(phia-phib)*np.sin(a)*np.sin(b)\n\ndef AB(a,b,phia,phib):\n    return 1+np.cos(a)*np.cos(b)-np.cos(phia-phib)*np.sin(a)*np.sin(b)\n\ndef U(a,b,j,phia,phib,phij,L):\n    return 2**(L\/2)*np.cos(j)**L*np.sqrt(ab(a,b,phia,phib)\/AB(a,j,phia,phij)\/ab(j,b,phij,phib))**L\n\ndef integrand(a,b,j,phia,phib,phij,L):\n    return ab(a,b,phia,phib)\/ab(a,j,phia,phij)\/ab(j,b,phij,phib)*(U(a,b,j,phia,phib,phij,L)-1)*np.sin(j)\n\ndef int1(a,b,j,phia,phib,L):\n    #return quad(integrand, 0, 2*np.pi, args=(a,b,j,phia,phib,L))[0]\n    return quad(lambda phij: integrand(a,b,j,phia,phib,phij,L), 0, 2*np.pi)[0]\n\ndef int2(a,b,phia,phib,L):\n    return quad(lambda j: int1(a,b,j,phia,phib,L), 10**-5, np.pi\/2)[0]\n\n#https:\/\/stackoverflow.com\/questions\/35215161\/most-efficient-way-to-map-function-over-numpy-array\n# testmap function over numpy array\nx = np.array([1, 2, 3, 4, 5])\nf = lambda x: x ** 2\nsquares = f(x)\nprint(squares)\n\nA = np.array([[1, 1], [2, 1], [3, -3]])\nprint(A[2,0])\n\ndef fun(a, b):\n    f = a + b\n    return f\n\nfun_l = [[fun(a, b) for a in range(4)] for b in range(5)]\nfun_np = np.array(fun_l)\nprint(type(fun_np))\nprint(fun_np)\nprint(fun_np[:, 1])\n\n#replace quad by sum\ndef intsum(expr, a, b, N=100):\n    value = 0\n    value2 = 0\n    for n in range(1, N+1):\n        value += expr(a + (( n - 1 \/ 2) * ((b - a) \/ N)))\n    value2 = (b - a) \/ N *value\n    return value2\n\n\nf1 = lambda x:x**2\nprint(intsum(f1, 0, 1))\nf2 = lambda x, y:x**2 + y\n#def f2y(y):\n    #return intsum(f2, 100, 0, 1)\n#print(f2(1, 1))\n\n\ndef int_sum(b, L):\n    a=0.\n    #b=np.pi\n    phia=0.\n    phib=np.pi\n    #L=1\n    int1 = lambda j: integrand(a,b,j,phia,phib,0,L)\/2\n    int2 = intsum(int1, 10**-5, np.pi\/2, 100) \n    return int2\n\nprint(int2(0,np.pi,0,np.pi,3)\/4\/np.pi)\nprint(int_sum(np.pi, 3))\n    ","91d9853b":"#ODEint\n\n#print(integrand(0,np.pi,np.pi\/2,0,np.pi,np.pi,2))\n#print(int1(0,np.pi,np.pi\/2,0,np.pi,2)\/4\/np.pi)\n#print(int2(0,np.pi,0,np.pi,2)\/4\/np.pi)\n\n# function that returns dy\/dt\ndef model(y, t):\n    a=0.\n    b=np.pi\n    phia=0.\n    phib=np.pi\n    dydt = int2(a,b,phia,phib,t)\/4\/np.pi #integration from scipy\n    return dydt\n\ndef model_s(y, t, b=np.pi):\n    dydt = int_sum(b, t) #integration by sum\n    return dydt\n\n# initial condition\ny0 = 1\n\n# time points\nt_odeint = np.linspace(0,3)\n\n# solve ODE\n%time x_odeint = odeint(model,y0,t_odeint)\n%time x_odeint_s = odeint(model_s,y0,t_odeint)\n\n# plot results\neuler_constant = 0.57721566490153286060 # Euler Mascheroni Constant\n\ndef psy_analytic(x):\n    '''\n        Profile of the exact solution\n    '''\n    return 1 - (euler_constant * x + torch.lgamma(1 + x)) \/ 2.\n\nx0 = torch.unsqueeze(torch.linspace(0, 3, 20), dim=1)  # x data (tensor), shape=(100, 1)\n#x = x0.clone().detach(requires_grad=True)\nx=x0.clone().detach().requires_grad_(True)\nya = psy_analytic(x)\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_odeint,x_odeint_s, \"rx\", label = \"ODEint_s\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","88ee0a53":"#Euler method: one-step\ntmax = 3\ndt = 0.15\nnt = int(tmax\/dt) \n#t  = np.linspace(0., tmax, 20)\nt_euler = np.linspace(0., nt * dt, nt)\n\n\nnb = 20\nbmax = np.pi\nbmin = np.pi \/ 2 + 10**-2 # collinear divergent around np.pi \/ 2\nb0 = [1 for num in range(nb)] # discretization along b direction\n#bi = np.linspace(bmin, bmax, nb)\nbi = np.linspace(bmin, bmax, nb)\nprint(bi)\nX0 = np.array(b0, dtype=\"float32\")\nX  = np.zeros([nt, len(X0)]) #nt * nb\nprint(X0)\nprint(X)\n\n\ndef model2(b,t):\n    a= 0\n    #b=np.pi\n    phia=0.\n    phib=np.pi\n    return int2(a,b,phia,phib,t)\/4\/np.pi\n#f = lambda b,t: model2(b,t)\n#f_v = np.vectorize(model2)\n#print([model2(np.pi \/ 2 +10**-1, t) for t in t_euler.tolist()])\n\ndef model2_s(b,t):\n    return int_sum(b, t) #integration by sum\n\n%time fl = [[model2_s(b,t) for b in bi.tolist()] for t in t_euler.tolist()] #nested list comprehension\nfl_np = np.array(fl)\n#print(fl_np[: -1])\n#print(int2(0,np.pi,0,np.pi,2)\/4\/np.pi)\n\ndef Euler(func, X0, t):\n    #dt = t[1] - t[0]\n    #nt = len(t)\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt-1):\n        X[i+1] = X[i] + func[i] * dt\n    return X\n\n%time X_euler = Euler(fl_np, X0, t_euler)\nx_euler = X_euler[:,-1]\n#print(X_euler)\n\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","2d356256":"#Modify Euler's method: Adams\u2013Bashforth 2-4 Step\nt_ab = np.linspace(0., nt * dt, nt)\n\ndef AB2(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + func[0] * dt\n    for i in range(nt-2):\n        X[i+2] = X[i+1] + dt * (3. * func[i+1] - func[i]) \/ 2.\n    return X\n\ndef AB3(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + func[0] * dt\n    #X[2] = X[1] + func[1] * dt\n    X[2] = X[1] + dt * (3. * func[1]  - func[0] ) \/ 2.\n    for i in range(nt-3):\n        X[i+3] = X[i+2] + dt * ( 23 * func[i+2] - 16 * func[i+1] + 5 * func[i] ) \/ 12\n    return X\n\ndef AB4(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + func[0] * dt\n    X[2] = X[1] + dt * (3. * func[1]  - func[0] ) \/ 2.\n    X[3] = X[2] + dt * ( 23 * func[2] - 16 * func[1] + 5 * func[0] ) \/ 12\n    for i in range(nt-4):\n        X[i+4] = X[i+3] + dt * ( 55 * func[i+3] - 59 * func[i+2] + 37 * func[i+1] - 9 * func[i] ) \/ 24\n    return X\n\n%time X_ab2 = AB2(fl_np, X0, t_ab)\nx_ab2 = X_ab2[:,-1]\n%time X_ab3 = AB3(fl_np, X0, t_ab)\nx_ab3 = X_ab3[:,-1]\n%time X_ab4 = AB4(fl_np, X0, t_ab)\nx_ab4 = X_ab4[:,-1]\n#print(X_ab2)\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\nplt.plot(t_ab, x_ab2, \"gs\", label = \"AB2\")\nplt.plot(t_ab, x_ab3, \"bX\", label = \"AB3\")\nplt.plot(t_ab, x_ab4, \"yd\", label = \"AB4\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(6,4),dpi=100)\n#plt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\n#plt.plot(t_odeint,, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, np.subtract(x_euler, ya.data.flatten().numpy()), \"or\", label = \"Euler\")\nplt.plot(t_ab, np.subtract(x_ab2, ya.data.flatten().numpy()), \"gs\", label = \"AB2\")\nplt.plot(t_ab, np.subtract(x_ab3, ya.data.flatten().numpy()), \"bX\", label = \"AB3\")\nplt.plot(t_ab, np.subtract(x_ab4, ya.data.flatten().numpy()), \"yd\", label = \"AB4\")\n#plt.plot(t_trap, np.subtract(x_trap, ya.data.flatten().numpy()), \"cP\", label = \"TRAP\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","6d4ed92b":"#Trapezoidal rule w\/ Adams\u2013Bashforth Method\nt_trap = np.linspace(0., nt * dt, nt)\n\ndef TRAP(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    #X[1] = X[0] + func[0] * dt\n    for i in range(nt-1):\n        X[i+1] = X[i] + dt * (func[i+1] + func[i]) \/ 2.\n    return X\n\ndef TRAP2(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + dt * (func[1] + func[0]) \/ 2.\n    for i in range(nt-2):\n        X[i+2] = X[i+1] + dt * (3. * func[i+1] - func[i]) \/ 2.\n    return X\n\ndef TRAP3(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + dt * (func[1] + func[0]) \/ 2.\n    #X[2] = X[1] + dt * (3. * func[1] - func[0]) \/ 2.\n    X[2] = X[1] + dt * (func[2] + func[1]) \/ 2.\n    for i in range(nt-3):\n        X[i+3] = X[i+2] + dt * ( 23 * func[i+2] - 16 * func[i+1] + 5 * func[i] ) \/ 12\n    return X\n\n%time X_trap = TRAP(fl_np, X0, t_trap)\nx_trap = X_trap[:,-1]\n%time X_trap2 = TRAP2(fl_np, X0, t_trap)\nx_trap2 = X_trap2[:,-1]\n#%time X_trap3 = TRAP3(fl_np, X0, t_trap)\n#x_trap3 = X_trap3[:,-1]\n#print(X_ab4)\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\nplt.plot(t_ab, x_ab2, \"gs\", label = \"AB2\")\nplt.plot(t_trap, x_trap, \"cP\", label = \"TRAP\")\nplt.plot(t_trap, x_trap2, \"bX\", label = \"TRAP2\")\n#plt.plot(t_trap, x_trap3, \"yd\", label = \"TRAP3\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(6,4),dpi=100)\n#plt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\n#plt.plot(t_odeint,, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, np.subtract(x_euler, ya.data.flatten().numpy()), \"or\", label = \"Euler\")\nplt.plot(t_ab, np.subtract(x_ab2, ya.data.flatten().numpy()), \"gs\", label = \"AB2\")\nplt.plot(t_trap, np.subtract(x_trap, ya.data.flatten().numpy()), \"cP\", label = \"TRAP\")\nplt.plot(t_trap, np.subtract(x_trap2, ya.data.flatten().numpy()), \"bX\", label = \"TRAP2\")\n#plt.plot(t_trap, np.subtract(x_trap3, ya.data.flatten().numpy()), \"yd\", label = \"TRAP3\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","9215d036":"#Backwards Euler (Implicit) Method","fc7eef3d":"#More Methods:\n#https:\/\/github.com\/devkapupara\/ODE-Methods\n#http:\/\/math.oit.edu\/~paulr\/Upper\/Math_45x\/Math_452\/multistep.pdf\n#https:\/\/en.wikipedia.org\/wiki\/Linear_multistep_method\n#https:\/\/hplgit.github.io\/num-methods-for-PDEs\/doc\/pub\/nonlin\/pdf\/nonlin-4print.pdf","cfdad98f":"#ODEint\n\n#print(integrand(0,np.pi,np.pi\/2,0,np.pi,np.pi,2))\n#print(int1(0,np.pi,np.pi\/2,0,np.pi,2)\/4\/np.pi)\n#print(int2(0,np.pi,0,np.pi,2)\/4\/np.pi)\n\n# function that returns dy\/dt\ndef model_r(y, t):\n    a=0.\n    b=np.pi\n    phia=0.\n    phib=np.pi\n    dydt = y * int2(a,b,phia,phib,t)\/4\/np.pi #integration from scipy\n    return dydt\n\ndef model_rs(y, t, b=np.pi):\n    dydt = y * int_sum(b, t) #integration by sum\n    return dydt\n\n# initial condition\ny0 = 1\n\n# time points\nt_odeint = np.linspace(0,5)\n\n# solve ODE\n%time x_odeint = odeint(model_r,y0,t_odeint)\n%time x_odeint_s = odeint(model_rs,y0,t_odeint)\n\n# plot results\neuler_constant = 0.57721566490153286060 # Euler Mascheroni Constant\n\ndef psy_analytic_r(x):\n    '''\n        Profile of the exact solution\n    '''\n    return torch.exp(- (euler_constant * x + torch.lgamma(1 + x)) \/ 2.)\n    #return np.exp(- (euler_constant * x + gammaln(1 + x)) \/ 2.)\n\n\nx0 = torch.unsqueeze(torch.linspace(0, 5, 50), dim=1)  # x data (tensor), shape=(100, 1)\n#x = x0.clone().detach(requires_grad=True)\nx=x0.clone().detach().requires_grad_(True)\nyb = psy_analytic_r(x)\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), yb.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_odeint,x_odeint_s, \"rx\", label = \"ODEint_s\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","b97c01d8":"#Euler method: one-step\ntmax = 5\ndt = 0.1\nnt = int(tmax\/dt) \n#t  = np.linspace(0., tmax, 20)\nt_euler = np.linspace(0., nt * dt, nt)\n\n\nnb = 50\nbmax = np.pi\nbmin = np.pi \/ 2 + 10**-2 # collinear divergent around np.pi \/ 2\nb0 = [1 for num in range(nb)] # discretization along b direction\n#bi = np.linspace(bmin, bmax, nb)\nbi = np.linspace(bmin, bmax, nb)\nprint(bi)\nX0 = np.array(b0, dtype=\"float32\")\nX  = np.zeros([nt, len(X0)]) #nt * nb\nprint(X0)\nprint(X)\n\n\ndef model2(b,t):\n    a= 0\n    #b=np.pi\n    phia=0.\n    phib=np.pi\n    return int2(a,b,phia,phib,t)\/4\/np.pi\n#f = lambda b,t: model2(b,t)\n#f_v = np.vectorize(model2)\n#print([model2(np.pi \/ 2 +10**-1, t) for t in t_euler.tolist()])\n\ndef model2_s(b,t):\n    return int_sum(b, t) #integration by sum\n\n%time fl = [[model2_s(b,t) for b in bi.tolist()] for t in t_euler.tolist()] #nested list comprehension\nfl_np = np.array(fl)\n#print(fl_np[: -1])\n#print(int2(0,np.pi,0,np.pi,2)\/4\/np.pi)\n\ndef Euler(func, X0, t):\n    #dt = t[1] - t[0]\n    #nt = len(t)\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt-1):\n        X[i+1] = X[i] + X[i] * func[i] * dt\n    return X\n\n%time X_euler = Euler(fl_np, X0, t_euler)\nx_euler = X_euler[:,-1]\n#print(X_euler)\n\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), yb.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","28c1a02c":"#Modify Euler's method: Adams\u2013Bashforth 2-4 Step\nt_ab = np.linspace(0., nt * dt, nt)\n\ndef AB2(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + X[0] * func[0] * dt\n    for i in range(nt-2):\n        X[i+2] = X[i+1] + X[i+1] * dt * (3. * func[i+1] - func[i]) \/ 2.\n    return X\n\ndef AB3(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + X[0] * func[0] * dt\n    #X[2] = X[1] + func[1] * dt\n    X[2] = X[1] + X[1] * dt * (3. * func[1]  - func[0] ) \/ 2.\n    for i in range(nt-3):\n        X[i+3] = X[i+2] + X[i+2] * dt * ( 23 * func[i+2] - 16 * func[i+1] + 5 * func[i] ) \/ 12\n    return X\n\ndef AB4(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + X[0] * func[0] * dt\n    X[2] = X[1] + X[1] * dt * (3. * func[1]  - func[0] ) \/ 2.\n    X[3] = X[2] + X[2] * dt * ( 23 * func[2] - 16 * func[1] + 5 * func[0] ) \/ 12\n    for i in range(nt-4):\n        X[i+4] = X[i+3] + X[i+3] * dt * ( 55 * func[i+3] - 59 * func[i+2] + 37 * func[i+1] - 9 * func[i] ) \/ 24\n    return X\n\n%time X_ab2 = AB2(fl_np, X0, t_ab)\nx_ab2 = X_ab2[:,-1]\n%time X_ab3 = AB3(fl_np, X0, t_ab)\nx_ab3 = X_ab3[:,-1]\n%time X_ab4 = AB4(fl_np, X0, t_ab)\nx_ab4 = X_ab4[:,-1]\n#print(X_ab2)\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), yb.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\nplt.plot(t_ab, x_ab2, \"gs\", label = \"AB2\")\nplt.plot(t_ab, x_ab3, \"bX\", label = \"AB3\")\nplt.plot(t_ab, x_ab4, \"yd\", label = \"AB4\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(6,4),dpi=100)\n#plt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\n#plt.plot(t_odeint,, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, np.subtract(x_euler, yb.data.flatten().numpy()), \"or\", label = \"Euler\")\nplt.plot(t_ab, np.subtract(x_ab2, yb.data.flatten().numpy()), \"gs\", label = \"AB2\")\nplt.plot(t_ab, np.subtract(x_ab3, yb.data.flatten().numpy()), \"bX\", label = \"AB3\")\nplt.plot(t_ab, np.subtract(x_ab4, yb.data.flatten().numpy()), \"yd\", label = \"AB4\")\n#plt.plot(t_trap, np.subtract(x_trap, ya.data.flatten().numpy()), \"cP\", label = \"TRAP\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","31902391":"print(x_euler)\nprint(x_ab2)\nprint(yb.data.numpy().flatten())","f9f05985":"#Trapezoidal rule w\/ Adams\u2013Bashforth Method\nt_trap = np.linspace(0., nt * dt, nt)\n\ndef TRAP(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    #X[1] = X[0] + func[0] * dt\n    for i in range(nt-1):\n        X[i+1] = X[i] + X[i] * dt * (func[i+1] + func[i]) \/ 2.\n    return X\n\ndef TRAP2(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + X[0] * dt * (func[1] + func[0]) \/ 2.\n    for i in range(nt-2):\n        X[i+2] = X[i+1] + X[i+1] * dt * (3. * func[i+1] - func[i]) \/ 2.\n    return X\n\ndef TRAP3(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    X[1] = X[0] + X[0] * dt * (func[1] + func[0]) \/ 2.\n    #X[2] = X[1] + dt * (3. * func[1] - func[0]) \/ 2.\n    X[2] = X[1] + X[1] * dt * (func[2] + func[1]) \/ 2.\n    for i in range(nt-3):\n        X[i+3] = X[i+2] + X[i+2] * dt * ( 23 * func[i+2] - 16 * func[i+1] + 5 * func[i] ) \/ 12\n    return X\n\n%time X_trap = TRAP(fl_np, X0, t_trap)\nx_trap = X_trap[:,-1]\n%time X_trap2 = TRAP2(fl_np, X0, t_trap)\nx_trap2 = X_trap2[:,-1]\n#%time X_trap3 = TRAP3(fl_np, X0, t_trap)\n#x_trap3 = X_trap3[:,-1]\n#print(X_ab4)\n\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), yb.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_ab, x_euler, \"or\", label = \"Euler\")\nplt.plot(t_ab, x_ab2, \"gs\", label = \"AB2\")\nplt.plot(t_trap, x_trap, \"cP\", label = \"TRAP\")\nplt.plot(t_trap, x_trap2, \"b*\", label = \"TRAP2\")\n#plt.plot(t_trap, x_trap3, \"yd\", label = \"TRAP3\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(6,4),dpi=100)\n#plt.plot(x.data.numpy(), ya.data.numpy(), color = \"orange\", label = \"Exact solution\")\n#plt.plot(t_odeint,, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, np.subtract(x_euler, yb.data.flatten().numpy()), \"or\", label = \"Euler\")\nplt.plot(t_ab, np.subtract(x_ab2, yb.data.flatten().numpy()), \"gs\", label = \"AB2\")\nplt.plot(t_trap, np.subtract(x_trap, yb.data.flatten().numpy()), \"cP\", label = \"TRAP\")\nplt.plot(t_trap, np.subtract(x_trap2, yb.data.flatten().numpy()), \"b*\", label = \"TRAP2\")\n#plt.plot(t_trap, np.subtract(x_trap3, ya.data.flatten().numpy()), \"yd\", label = \"TRAP3\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","86db9f59":"#Runge\u2013Kutta method\nt_rk2 = np.linspace(0., nt * dt, nt)\n\n%time fl_rk2 = [[model2_s(b, t + dt \/ 2) for b in bi.tolist()] for t in t_euler.tolist()] #nested list comprehension\n%time fl_rk4 = [[model2_s(b, t + dt) for b in bi.tolist()] for t in t_euler.tolist()] #nested list comprehension\nfl_rk2_np = np.array(fl_rk2)\nfl_rk4_np = np.array(fl_rk4)\n\ndef RK2(func, func2, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt-1):\n        K1 = X[i] * func[i]\n        K2 = (X[i] + K1 * dt \/ 2) * func2[i]\n        X[i+1] = X[i] +  dt * (K1  + K2) \/ 2\n    return X\n\ndef RK4(func, func2, func3, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt-1):\n        K1 = X[i] * func[i]\n        K2 = (X[i] + K1 * dt \/ 2) * func2[i]\n        K3 = (X[i] + K2 * dt \/ 2) * func2[i]\n        K4 = (X[i] + K3 * dt) * func3[i]\n        X[i+1] = X[i] +  dt * (K1  + 2 * K2 + 2* K3 + K4) \/ 6\n    return X\n\n#RK4 w\/ Adams-Bashforth 3 Step\ndef RK4_AB3(func, X0, t):\n    X  = np.zeros([nt, len(X0)])\n    X[0:3] = X_rk4[0:3]\n    for i in range(nt-3):\n        X[i+3] = X[i+2] + X[i+2] * dt * ( 23 * func[i+2] - 16 * func[i+1] + 5 * func[i] ) \/ 12\n    return X\n\n%time X_rk2 = RK2(fl_np , fl_rk2_np, X0, t_rk2)\nx_rk2 = X_rk2[:,-1]\n%time X_rk4 = RK4(fl_np , fl_rk2_np , fl_rk4_np, X0, t_rk2)\nx_rk4 = X_rk4[:,-1]\n#print(X_rk4)\nX_rk4_ab3 = RK4_AB3(fl_np, X0, t_rk2)\nx_rk4_ab3 = X_rk4_ab3[:,-1]\n\n# view data\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(x.data.numpy(), yb.data.numpy(), color = \"orange\", label = \"Exact solution\")\nplt.plot(t_odeint,x_odeint, \"mv\", label = \"ODEint\")\nplt.plot(t_euler, x_euler, \"or\", label = \"Euler\")\nplt.plot(t_rk2, x_rk2, \"gs\", label = \"RK2\")\nplt.plot(t_rk2, x_rk4, \"cP\", label = \"RK4\")\nplt.plot(t_rk2, x_rk4_ab3, \"b*\", label = \"RK4_AB3\")\n#plt.grid()\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()\n\nplt.figure(figsize=(6,4),dpi=100)\nplt.plot(t_euler, np.subtract(x_euler, yb.data.flatten().numpy()), \"or\", label = \"Euler\")\nplt.plot(t_rk2, np.subtract(x_rk2, yb.data.flatten().numpy()), \"gs\", label = \"RK2\")\nplt.plot(t_rk2, np.subtract(x_rk4, yb.data.flatten().numpy()), \"cP\", label = \"RK4\")\nplt.plot(t_rk2, np.subtract(x_rk4_ab3, yb.data.flatten().numpy()), \"b*\", label = \"RK4_AB3\")\nplt.xlabel('L')\nplt.ylabel('g(L)')\nplt.legend()\nplt.show()","78998e5f":"Testing the numerical method for partially (2-loop) resummed:\n\\begin{align}\n\\partial_{L}g_{\\bar{n}b}^{2R}\\left(L\\right)&=\\int_{L}\\frac{d\\Omega_{j}}{4\\pi}W_{\\bar{n}b}^{j} g_{\\bar{n}b}^{\\left(2R\\right)}\\left(L\\right)[U_{\\bar{n}bj}\\left(L\\right)-1]\n\\end{align}","cde56349":"Testing the numerical method for 1-dressed gluon:\n\\begin{align}\n\\partial_{L}g_{\\bar{n}b}^{dg-1}\\left(L\\right)&=\\int_{L}\\frac{d\\Omega_{j}}{4\\pi}W_{\\bar{n}b}^{j} [U_{\\bar{n}bj}\\left(L\\right)-1]\n\\end{align}"}}