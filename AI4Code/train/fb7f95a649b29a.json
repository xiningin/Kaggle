{"cell_type":{"138daac6":"code","c3af4af2":"code","dd5a38cf":"code","da6d21ae":"code","3f362543":"code","b89e2b7b":"code","7ad1ccb1":"code","165694f9":"code","28818544":"code","e14d9941":"code","69467af4":"code","f7149b5d":"code","c36e2727":"code","ba0fe12e":"code","e2c45bd6":"code","bdf58784":"code","4d16ed59":"code","c2ba6826":"code","68566824":"markdown","fb8b530d":"markdown","b0b04d8b":"markdown","98c92464":"markdown","983f2b9d":"markdown","03d23c54":"markdown","d0c7a2cb":"markdown"},"source":{"138daac6":"import numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport cv2\nfrom sklearn.decomposition import PCA\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom mpl_toolkits.mplot3d import proj3d\nfrom imageio import imread\nfrom skimage.transform import resize\nfrom scipy.spatial import distance\nfrom keras.models import load_model\nimport pandas as pd\nfrom tqdm import tqdm","c3af4af2":"train_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/train_relationships.csv\")\ntest_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/sample_submission.csv\")","dd5a38cf":"!pip install git+https:\/\/github.com\/rcmalli\/keras-vggface.git","da6d21ae":"from keras_applications.imagenet_utils import _obtain_input_shape\nfrom keras_vggface.vggface import VGGFace\n\n# Convolution Features\nvgg_features = VGGFace(include_top=False, input_shape=(160, 160, 3), pooling='avg')\nmodel = vgg_features","3f362543":"def prewhiten(x):\n    if x.ndim == 4:\n        axis = (1, 2, 3)\n        size = x[0].size\n    elif x.ndim == 3:\n        axis = (0, 1, 2)\n        size = x.size\n    else:\n        raise ValueError('Dimension should be 3 or 4')\n\n    mean = np.mean(x, axis=axis, keepdims=True)\n    std = np.std(x, axis=axis, keepdims=True)\n    std_adj = np.maximum(std, 1.0\/np.sqrt(size))\n    y = (x - mean) \/ std_adj\n    return y\n\ndef l2_normalize(x, axis=-1, epsilon=1e-10):\n    output = x \/ np.sqrt(np.maximum(np.sum(np.square(x), axis=axis, keepdims=True), epsilon))\n    return output\n\ndef load_and_align_images(filepaths, margin,image_size = 160):\n    \n    aligned_images = []\n    for filepath in filepaths:\n        img = imread(filepath)\n        aligned = resize(img, (image_size, image_size), mode='reflect')\n        aligned_images.append(aligned)\n            \n    return np.array(aligned_images)\n\n","b89e2b7b":"def calc_embs(filepaths, margin=10, batch_size=512):\n    pd = []\n    for start in tqdm(range(0, len(filepaths), batch_size)):\n        aligned_images = prewhiten(load_and_align_images(filepaths[start:start+batch_size], margin))\n        pd.append(model.predict_on_batch(aligned_images))\n    embs = l2_normalize(np.concatenate(pd))\n\n    return embs","7ad1ccb1":"test_images = os.listdir(\"..\/input\/recognizing-faces-in-the-wild\/test\/\")\ntest_embs = calc_embs([os.path.join(\"..\/input\/recognizing-faces-in-the-wild\/test\/\", f) for f in test_images])\nnp.save(\"test_embs_vgg.npy\", test_embs)","165694f9":"test_embs.shape","28818544":"model_path = '..\/input\/facenet-keras\/facenet_keras.h5'\nmodel = load_model(model_path)","e14d9941":"test_embs_vgg = calc_embs([os.path.join(\"..\/input\/recognizing-faces-in-the-wild\/test\/\", f) for f in test_images])\nnp.save(\"test_embs_fnet.npy\", test_embs_vgg)","69467af4":"test_embs_vgg.shape","f7149b5d":"test_df[\"distance\"] = 0\nimg2idx = dict()\nfor idx, img in enumerate(test_images):\n    img2idx[img] = idx","c36e2727":"for idx, row in tqdm(test_df.iterrows(), total=len(test_df)):\n    imgs = [test_embs[img2idx[img]] for img in row.img_pair.split(\"-\")]\n    test_df.loc[idx, \"distance1\"] = distance.euclidean(*imgs)\n    \n    # For vggface\n    imgs_2 = [test_embs_vgg[img2idx[img]] for img in row.img_pair.split(\"-\")]\n    test_df.loc[idx, \"distance2\"] = distance.euclidean(*imgs_2)","ba0fe12e":"test_df['distance'] = test_df[['distance1','distance2']].mean(axis=1)\ntest_df.head()","e2c45bd6":"all_distances = test_df.distance.values\nsum_dist = np.sum(all_distances)","bdf58784":"probs = []\nfor dist in tqdm(all_distances):\n    prob = np.sum(all_distances[np.where(all_distances <= dist)[0]])\/sum_dist\n    probs.append(1 - prob)","4d16ed59":"sub_df = pd.read_csv(\"..\/input\/recognizing-faces-in-the-wild\/sample_submission.csv\")\nsub_df.is_related = probs\nsub_df.to_csv(\"submission.csv\", index=False)","c2ba6826":"sub_df.head()","68566824":"Finally, we convert the distances to probabiliy values and submit the result","fb8b530d":"Let's load our pretrained model.","b0b04d8b":"This kernel is clone of this nice kernel: https:\/\/www.kaggle.com\/suicaokhoailang\/facenet-baseline-in-keras-0-749-lb Just add pretrained vggface model and take the average of the predictions of the two models.","98c92464":"Here we'll compute all the embeddings for the test images using the pretrained model","983f2b9d":"Here's preprocessing stuff. The images from the test set seem to already be aligned, so I'll omit that part here for clarity.","03d23c54":"FaceNet model","d0c7a2cb":"Next, we compute the actual distance between provided image pairs"}}