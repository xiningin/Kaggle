{"cell_type":{"1dfa5e13":"code","75bb88c9":"code","c359fb51":"code","12339019":"code","6e5690c1":"code","5dbf963b":"code","1e9f6d95":"code","3a1a811f":"code","ab55d91b":"code","416889e3":"code","e2ce7fa6":"code","7fe3b7e6":"code","b62ff451":"code","b840521c":"code","043ee694":"code","e35b3f40":"code","be349d81":"code","12924670":"code","f898c430":"code","b03cbb2e":"code","77b0626f":"code","03a2de5f":"code","e628618b":"code","7a651154":"code","2ef37a06":"code","161b15ec":"code","68473c83":"code","3852175d":"code","6345a5a6":"code","4c1a4f3c":"markdown","4f66de6e":"markdown","63f84f05":"markdown","7c7ba921":"markdown","3032921a":"markdown","4d591b8f":"markdown","d74a772e":"markdown","dae8f98f":"markdown","eb078eb1":"markdown","59d44974":"markdown","ec9e358c":"markdown","0800633a":"markdown","d505fb26":"markdown","d242d83d":"markdown","84da1578":"markdown","ba2aacc5":"markdown","317ec427":"markdown","8f7a1fd4":"markdown","60710919":"markdown","79af2ae7":"markdown","13707891":"markdown","6638bb38":"markdown","2f75eb08":"markdown","a744e63f":"markdown","b30a2c58":"markdown","4a5b8065":"markdown","901eab67":"markdown","b5ddbd16":"markdown","aab75b08":"markdown","911ae07b":"markdown","62595651":"markdown","03825194":"markdown","0fb380a1":"markdown","64a96dc1":"markdown"},"source":{"1dfa5e13":"import numpy as np\nimport pandas as pd\nimport os\n\nfrom sklearn.model_selection import train_test_split\nfrom xgboost import XGBClassifier\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.ensemble import RandomForestRegressor\n\nfrom sklearn.metrics import mean_squared_error\n\nprint(os.listdir(\"..\/input\"))\n","75bb88c9":"data=pd.read_csv('..\/input\/winemag-data-130k-v2.csv')\ndata.head()","c359fb51":"data=data.drop(columns=['Unnamed: 0', 'description'])\ndata=data.reset_index(drop=True)","12339019":"data.describe()","6e5690c1":"print(\"Total number of examples: \", data.shape[0])\nprint(\"Number of examples with the same title and description: \", data[data.duplicated(['description','title'])].shape[0])","5dbf963b":"data=data.drop_duplicates(['description','title'])\ndata=data.reset_index(drop=True)","1e9f6d95":"data.info()","3a1a811f":"total = data.isnull().sum().sort_values(ascending = False)\npercent = (data.isnull().sum()\/data.isnull().count()*100).sort_values(ascending = False)\nmissing_data  = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])\nmissing_data","ab55d91b":"data=data.dropna(subset=['price'])\ndata=data.reset_index(drop=True)","416889e3":"data[(data['price'] > 2200)]","e2ce7fa6":"import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef pastel_plot(data, x, y):\n    plt.figure(figsize = (15,6))\n    plt.title('Points histogram - whole dataset')\n    sns.set_color_codes(\"pastel\")\n    sns.barplot(x = x, y=y, data=df)\n    locs, labels = plt.xticks()\n    plt.show()","7fe3b7e6":"temp = data[\"points\"].value_counts()\ndf = pd.DataFrame({'points': temp.index,\n                   'number_of_wines': temp.values\n                  })\n\npastel_plot(df,'points', 'number_of_wines')","b62ff451":"plt.figure(figsize=(20,5))\nplt.title(\"Distribution of price\")\nax = sns.distplot(data[\"price\"])","b840521c":"plt.figure(figsize=(20,5))\nplt.title(\"Distribution of price\")\nax = sns.distplot(data[data[\"price\"]<200]['price'])\n\npercent=data[data['price']>200].shape[0]\/data.shape[0]*100\nprint(\"There are :\", percent, \"% wines more expensive then 200 USD\")","043ee694":"z=data.groupby(['country'])['price','points'].mean().reset_index().sort_values('price',ascending=False)\nz[['country','price']].head(n=10)","e35b3f40":"plt.figure(figsize = (14,6))\nplt.title('Wine prices in diffrent countries')\nsns.barplot(x = 'country', y=\"price\", data=z.head(10))\nlocs, labels = plt.xticks()\nplt.show()","be349d81":"z=z.sort_values('points', ascending=False)\nz[['country','points']].head(10)","12924670":"plt.figure(figsize = (14,6))\nplt.title('Points for wines in diffrent countries')\nsns.set_color_codes(\"pastel\")\nsns.barplot(x = 'country', y=\"points\", data=z.head(5))\nlocs, labels = plt.xticks()\nplt.show()","f898c430":"country=data['country'].value_counts()\ncountry.head(10).plot.bar()\ncountry.head(20)","b03cbb2e":"z['quality\/price']=z['points']\/z['price']\nz.sort_values('quality\/price', ascending=False)[['country','quality\/price']]","77b0626f":"df1= data[data.variety.isin(data.variety.value_counts().head(6).index)]\n\nplt.figure(figsize = (14,6))\nsns.boxplot(\n    x = 'variety',\n    y = 'points',\n    data = df1\n)","03a2de5f":"from sklearn.model_selection import train_test_split\nfrom catboost import Pool, CatBoostRegressor, cv\n\nX=data.drop(columns=['points'])\n\nX=X.fillna(-1)\nprint(X.columns)\ncategorical_features_indices =[0,1, 3,4,5,6,7,8,9,10]\ny=data['points']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, \n                                                    random_state=42)\n\nX_train, X_valid, y_train, y_valid = train_test_split(X_train, y_train, test_size=0.2, \n                                                    random_state=52)","e628618b":"categorical_features_indices","7a651154":"def perform_model(X_train, y_train,X_valid, y_valid,X_test, y_test):\n    model = CatBoostRegressor(\n        random_seed = 400,\n        loss_function = 'RMSE',\n        iterations=400,\n    )\n    \n    model.fit(\n        X_train, y_train,\n        cat_features = categorical_features_indices,\n        eval_set=(X_valid, y_valid),\n        verbose=False\n    )\n    \n    print(\"RMSE on training data: \"+ model.score(X_train, y_train).astype(str))\n    print(\"RMSE on test data: \"+ model.score(X_test, y_test).astype(str))\n    \n    return model\n    ","2ef37a06":"model=perform_model(X_train, y_train,X_valid, y_valid,X_test, y_test)","161b15ec":"feature_score = pd.DataFrame(list(zip(X.dtypes.index, model.get_feature_importance(Pool(X, label=y, cat_features=categorical_features_indices)))),\n                columns=['Feature','Score'])\n\nfeature_score = feature_score.sort_values(by='Score', ascending=False, inplace=False, kind='quicksort', na_position='last')\n","68473c83":"plt.rcParams[\"figure.figsize\"] = (12,7)\nax = feature_score.plot('Feature', 'Score', kind='bar', color='c')\nax.set_title(\"Catboost Feature Importance Ranking\", fontsize = 14)\nax.set_xlabel('')\n\nrects = ax.patches\n\nlabels = feature_score['Score'].round(2)\n\nfor rect, label in zip(rects, labels):\n    height = rect.get_height()\n    ax.text(rect.get_x() + rect.get_width()\/2, height + 0.35, label, ha='center', va='bottom')\n\nplt.show()","3852175d":"X=data.drop(columns=['points','title', 'region_1'])\nX=X.fillna(-1)\n\nprint(X.columns)\ncategorical_features_indices =[0,1,3,4,5,6,7,8]\ny=data['points']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, \n                                                    random_state=42)\n\nX_train, X_valid, y_train, y_valid = train_test_split(X_train, y_train, test_size=0.2, \n                                                    random_state=52)","6345a5a6":"model=perform_model(X_train, y_train,X_valid, y_valid,X_test, y_test)","4c1a4f3c":"We see that if we want to see better price distribution we have to scale our price or drop the tail. \nWe will drop the tail, so the values that are above 200 dollars. We are also want to calculate how many wines are more expensive then 200 dolars. ","4f66de6e":"We see that there is a column called 'Unnamed: 0', which contains IDs of each wine. IDs are of course can't help us in order to regression, so we should drop this column.  We will also drop description column, because in this kernel we will not play with NLP.","63f84f05":"# ** If you are intrested in NLP, please check my other kernel on the same data https:\/\/www.kaggle.com\/mistrzuniu1\/catboost-points-predictions-with-simple-nlp\/**","7c7ba921":"As we can see we dropped only 0.59 percent of wines and now we can see that price distribution is also normal. ","3032921a":"### Missing values.\nNow, we will investigate our dataset in order to see how many missing values there is. ","4d591b8f":"# Feature importance with Catboost.\nFirst we will prepare our train and test data. We will use sklearn Library. ","d74a772e":"Now, we want to explore our features in more statistic way.\nWe will use describe method from pandas. \nIt will return us information about:\n* mean\n* standard deviation\n* minimum value\n* maximum value\n* 25%,50%,75% quantille","dae8f98f":"Let's try to drop 3 columns which gives least information.","eb078eb1":"Now, we are ready to create feature importance plot. ","59d44974":"We can easily note, that the wines in Switzerland are the most expensive one. I think the most impactful factor is much higher prices for all goods in this country. \nThe highest mean of points came to England \nBased on our data let's try make some guesses why England wines are the best.\n* Most sommeliers come from England\n* England provide information only for thier best wines\n* They are simply the best :)\n\nWe can partly check our second guess. Let's see how many wines are in dataset from particular country.","ec9e358c":"Let's take a quick look also on highest priced wines. ","0800633a":"The most missing values are in region, destination, tester name and price columns.\n\nI'm worried the most about wines with NaN in price columns. We don't want to predict points for wines which price are undeclared. We will drop rows with NaN value in this column.\n\nUsefulness of other columns will be investigate on the **Feature extraction ** stage. Maybe that NaN values are meaningful for particular columns..","d505fb26":"We see that there is huge number of missing values. Let's see how many percent.","d242d83d":"# 1. Data analaysis\nBefore we go into more complicated work, first we have to explore our dataset.\n\nLet's have a quick look at our features.","84da1578":"### **Duplicates.**\nFirst of all let's explore our data. On first look into data we can see that there are many duplicates, which we have to drop.\n\nLet's see how many duplicates are in the data.","ba2aacc5":"We can see that England isn't even in first 20's, so our guess make more sense. ;)","317ec427":"All of 3 highest priced wines are comes from France. ","8f7a1fd4":"We can see that all wines have number of points above 80. And points has normal distribution. The most wines have 88 points.\n\nWe can also get exact distribution not only the histogram. We will show it on price column","60710919":"As we can see only price is continous variable in our input. As we can see on minimum and maximium value there is really high \ndiverse in price feature. There is wine which cost 3300 dollars , but we can see that 75 percent of wines are cheaper than 42 dollars.","79af2ae7":"What is next step? You can play with tunning model. Good idea will be also testing XgBoost or neural netoworks approch. If you want to maximize the score you should also read about model stacking and genetic programming. If you want to know how to do NLP on the description, you should see my other kernel. ","13707891":"As we can see the most important feature is price. Tester has also big impact for the points score.","6638bb38":"We can see that there are almost 10k records with the same title and description. We should drop rows columns in order to get proper result.","2f75eb08":"As we can see our model perform only a little worse, but we save some computing time and RAM usability. Feature selecion technique is much more useful with larger dataset, where a lot of columns are useless.","a744e63f":"To solve our 'problem' Important thing to investegate will be also price\/quality factor.","b30a2c58":"# Data visualization\nRemeber that in this stage our goal is not only to explore our data in order to get better predictions. We also want to get better understanding what is in data and explore data in 'normal' way. This kind of approch can be useful if we have to do some feature engineering, where good data understanding can really help to produce better features. \n\nThe most common ways to visualize data are:\n* histograms\n* box plots\n* swarm plots\n* joint plot\n* heatmaps\n\nData can be visualized by **matplotlib, seaborn library** and **built in methods from pandas dataframes**","4a5b8065":"Let's run our model and check score.","901eab67":"What can we see now? England was first on points ranking, but on points\/quality ranking they are the second from the end. \nSo, yeah, they provided information only for let's say 'premium' wines.  ","b5ddbd16":"Create CatBoostRegressor model with Mean squared error loss function.","aab75b08":"In this tutorial we are going to predict number of points, based on input features. I will try to show whole pipeline in solving this type of problems.\n\n<math xmlns=\"http:\/\/www.w3.org\/1998\/Math\/MathML\" display=\"block\">\nMachine learning problem typically are divided into two groups.\nLet's define our problem in simple math terms. \n\n* x will be our input\n* y will be vale of  <mi>f(x)<\/mi> - in our case points.\n\n<center>\n  <mi>f<\/mi>\n  <mo>:<\/mo>\n  <mi>x<\/mi>\n  <mo stretchy=\"false\">&#x2192;<!-- \u2192 --><\/mo>\n  <mi>y<\/mi>\n<\/math><\/center>\n\n1. **Regression** - If y is real number or continuous\n * Classification predictions can be evaluated using accuracy, whereas regression predictions cannot.\n2. **Classification** - If y is discrete or categorical variable\n * Regression predictions can be evaluated using root mean squared error, whereas classification predictions cannot.\n\nWe can easily figure out that our problem is Regression problem, because we want to predict number of points, which is continuose variable. \n\nWe have few ways to solve this problem. Actually most common ways are: \n\n1. **Neural networks**\n2. Bagging and Boosting decision trees - **Random forest**\n\n> * Bagging (Bootstrap Aggregation) is used when our goal is to reduce the variance of a decision tree. Here idea is to create several subsets of data from training sample chosen randomly with replacement. Now, each collection of subset data is used to train their decision trees. As a result, we end up with an ensemble of different models. Average of all the predictions from different trees are used which is more robust than a single decision tree.\n> * Random Forest is an extension over bagging. It takes one extra step where in addition to taking the random subset of data, it also takes the random selection of features rather than using all features to grow trees. When you have many random trees. It\u2019s called Random Forest\n\n> **Reference**: https:\/\/towardsdatascience.com\/decision-tree-ensembles-bagging-and-boosting-266a8ba60fd9\n\nSo, what we have to do first? \n\nIn this kernel I will do it in that pattern, which is commonly used for solving this type of problems: \n1. Data analaysis\n2. Data visualisation\n3. Feature selection\n4. Model training\n5. Feature extraction with PCA \n\nThere is great visualisation of typical pipeline:\n![logo](https:\/\/cdn-images-1.medium.com\/max\/2000\/1*2T5rbjOBGVFdSvtlhCqlNg.png)\n        A standard machine learning pipeline (source: Practical Machine Learning with Python, Apress\/Springer)","911ae07b":"And now perform the model once again. ","62595651":"# 3. Feature selection\nOn this stage we want to make our dataset smaller without loosing acuracy of model. \nSo how can we do it? \nWe can make correlation plot and drop columns which correlation will be close to 1 or -1. \nWhat is correlation?\n\n> Correlation is a statistical measurement of the relationship between two variables. Possible correlations range from +1 to \u20131. A zero correlation indicates that there is no relationship between the variables. A correlation of \u20131 indicates a perfect negative correlation, meaning that as one variable goes up, the other goes down. A correlation of +1 indicates a perfect positive correlation, meaning that both variables move in the same direction together.\n\nReference: https:\/\/www.verywellmind.com\/what-is-correlation-2794986\n\nThere are also some 'automatic' algorithm to do feature selection:\n\n1. Feature selection with correlation - find out which features are correleted and then drop \nall except one.\n\n2. Univariate feature selection - Univariate feature selection works by selecting the best features based on univariate statistical tests.\n\n3. Recursive feature elimination - Given an external estimator that assigns weights to features (e.g., the coefficients of a linear model), recursive feature elimination (RFE) is to select features by recursively considering smaller and smaller sets of features.\n\n4. Tree based feature selection - Tree-based estimators can be used to compute feature importances, which in turn can be used to discard irrelevant features (when coupled with the sklearn.feature_selection.SelectFromModel meta-transformer):\n\n**Reference**: http:\/\/scikit-learn.org\/stable\/modules\/feature_selection.html#univariate-feature-selection\n\nWe will use Univariate feature selection based on feature importances from CatboostRegressor. ","03825194":"Let's investigate which country have most expensive and most high rated wines. First of all we will sort it by price and then plot.","0fb380a1":"What we can read from this plot? For example, that the Red Blend has low points variance. If the boxes are taller then the variance is higher. If box is higher then other box, then it have more high values then other. \n\n**If you want to more info visit: ** https:\/\/www.wellbeingatschool.org.nz\/information-sheet\/understanding-and-interpreting-box-plots","64a96dc1":"We can also can explore data with box plots. There is a nice visualisation what box plot can tell us. \n\n![logo](https:\/\/www.wellbeingatschool.org.nz\/sites\/default\/files\/W@S_boxplot-labels.png)\n**Resource**: https:\/\/www.wellbeingatschool.org.nz\/sites\/default\/files\/W@S_boxplot-labels.png"}}