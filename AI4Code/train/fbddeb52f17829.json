{"cell_type":{"fd600bed":"code","41a7ce08":"code","6dfa3d07":"code","7b1dc14f":"code","493c7341":"code","5a0013a9":"code","4a522dfb":"code","399c9219":"code","618cea82":"code","fdc92920":"code","6359b981":"code","be6955e0":"code","f4af8bc4":"code","f3bab0df":"code","e47f80b1":"markdown","e357d5a9":"markdown","4e77b490":"markdown","871bdc8e":"markdown","f0ecdba3":"markdown","f54a3666":"markdown","daa8882c":"markdown","0e5f70d6":"markdown","bc4bcad3":"markdown","55d45a73":"markdown"},"source":{"fd600bed":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sqlalchemy import create_engine\n\npd.set_option('display.max_columns', None)","41a7ce08":"# set variables\nTEAM_NAME = \"Chelsea\"\nSEASON = \"2008\/2009\"","6dfa3d07":"# create engine to the SQLite database\nengine = create_engine(\"sqlite:\/\/\/\/kaggle\/input\/soccer\/database.sqlite\")","7b1dc14f":"# fetch team info\nteam = pd.read_sql_query(\"SELECT * FROM Team WHERE team_long_name LIKE '%\" + TEAM_NAME + \"%';\", engine).loc[0]\nteam_id = int(team[\"team_api_id\"])\nprint(team)","493c7341":"# fetch country info based on selected team\ncountry = pd.read_sql_query(\"SELECT * FROM Match WHERE home_team_api_id = \" + str(team_id) + \";\", engine).loc[0]\ncountry","5a0013a9":"# get country id\ncountry_id = int(country[\"country_id\"])","4a522dfb":"# get all matches of season for country\nmatches = pd.read_sql_query(\n    \"SELECT * FROM Match WHERE country_id = \" + str(country_id) + \" AND season = '\" + SEASON + \"';\", engine)\nmatches.head()","399c9219":"# filter team's matches\nmatches_home = matches[matches[\"home_team_api_id\"] == team_id]\nmatches_away = matches[matches[\"away_team_api_id\"] == team_id]","618cea82":"def get_player_position(match, team_situation, idx):\n    if team_situation == \"home\":\n        prefix = \"home_player_\"\n    else:\n        prefix = \"away_player_\"\n    X = float(match[prefix + 'X' + str(idx)])\n    Y = float(match[prefix + 'Y' + str(idx)])\n    return (X, Y)","fdc92920":"def get_match_formation(match, team_situation):\n    formation = []\n    # exclude the goalkeeper\n    for i in range(2, 12):\n        formation.append(get_player_position(match, team_situation, i))\n    return formation","6359b981":"def get_all_season_formations(matches, team_situation):\n    formations = []\n    for idx in matches.index:\n        match = matches.loc[idx]\n        formations.extend(get_match_formation(match, team_situation))\n    return formations","be6955e0":"# fetch formations for both home and away matches\nhome_formations = get_all_season_formations(matches_home, \"home\")\naway_formations = get_all_season_formations(matches_away, \"away\")","f4af8bc4":"def show_formations(team_full_name, home, away):\n    # show plots side by side\n    fig, axes = plt.subplots(1, 2, figsize=(15, 8))\n    axes[0].set_title(team_full_name + \" Home Formation\", fontdict={'fontsize': 20, 'fontweight': 500})\n    axes[0].axis(\"off\")\n    data = pd.DataFrame(home, columns=['X', 'Y'])\n    sns.kdeplot(data['X'], data['Y'], shade=True, n_levels=12, cmap=\"RdBu_r\", ax=axes[0])\n    axes[1].set_title(team_full_name + \" Away Formation\", fontdict={'fontsize': 20, 'fontweight': 500})\n    axes[1].axis(\"off\")\n    data = pd.DataFrame(away, columns=['X', 'Y'])\n    sns.kdeplot(data['X'], data['Y'], shade=True, n_levels=12, cmap=\"RdBu_r\", ax=axes[1])","f3bab0df":"show_formations(team[\"team_long_name\"], home_formations, away_formations)","e47f80b1":"## Functions to extract formations\nThe formations from all the season matches have to be extracted. Each player's position is described in `Match` table (we have stored them in the `matches` _DataFrame_). The position is described using a couple of (X, Y) and the columns that hold this data are named as `{home\/away}_player_{X\/Y}{1-11}` where 1 denotes the goalkeeper.","e357d5a9":"## Extract the id of the country\nWe observe that the second column of our `country` object is the `country_id` column which is exactly what we need in order to fetch the team's matches (we could have also used the `home_team_api_id` and `away_team_api_id` from the `Match` table to achieve the same results).","4e77b490":"## Get all matches of season for the given country\nWe fetch all the matches that have been played for the given season in the given country.","871bdc8e":"# Formation comparison between home and away matches for a specific team during a specific season\nIn this task, we select a team and a season (from the available ones of the dataset) and plot the formations most used by this team in both home and away matches in order to compare them.\n\n## Setting up the environment\nFirst of all, we have to import a number of different libraries that we will use later on. This is pretty normal stuff, we will use `seaborn` in order to plot the formation as kernel density estimate plots and `sqlalchemy` is used because our data is in _.sqlite_ form\n\nWe also set the max number of columns displayed from our _DataFrames_ to `None`, since we need to be able to see the whole row instead of just a fragment of it.","f0ecdba3":"## Getting Team Information\nFrom now on, we are simply writing SQL queries to the SQLite database trying to fetch the data needed for our purposes. Here, we just need to fetch the information of the team we specified with the `TEAM_NAME` variable, and then use the SQL result to get the team's id.","f54a3666":"## Selecting Variables\nFirst things first, we need to decide which team and for what season we want to display the formations used. The `TEAM_NAME` can be any string that could specify a team from the given dataset. However, there is no need to be extremely accurate and write something like **\"KRC Genk\"** instead of just **\"Genk\"**, since SQL can do that for us. The `SEASON` should be of the format **\"STARTING_YEAR\/ENDING_YEAR\"**.","daa8882c":"## Where is this team located?\nUsing the team information we are able to find the country that this team is located by fetching the first championship match where that time is the host (the first home match of the team).","0e5f70d6":"## Filter only specified team's matches\nWe only need the matches for the selected team, thus we perform filtering in the `matches` _DataFrame_ and separate the home matches from the away matches.","bc4bcad3":"## Connection to DB\nIn order to connect with the SQLite database we have to create an engine using the `sqlalchemy` library. We just need to pass the path to the _.sqlite_ file.","55d45a73":"## Formations Display\nWe are using the `matplotlib.pyplot` `sublots` function in order to divide the plot into two subplots. The `kdeplot` from `seaborn` **\"is a method for visualizing the distribution of observations in a dataset, analagous to a histogram. KDE represents the data using a continuous probability density curve in one or more dimensions\"**, according to the documentation (found here: https:\/\/seaborn.pydata.org\/generated\/seaborn.kdeplot.html)."}}