{"cell_type":{"6ce3dcc7":"code","8fd9b806":"code","bc80b217":"code","2b0cc454":"code","cd4449a3":"code","203f2619":"code","cf27da24":"code","717973a0":"code","0fb47b7e":"code","a5f7c61f":"code","53f671e3":"code","907b1f32":"code","1f6af8a3":"code","98678217":"code","2a23554f":"markdown","5f700b62":"markdown"},"source":{"6ce3dcc7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom PIL import Image\n\nimport os\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim \n\nimport torchvision\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision import transforms\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","8fd9b806":"import zipfile\nwith zipfile.ZipFile('..\/input\/aerial-cactus-identification\/train.zip', 'r') as zip_ref:\n    zip_ref.extractall('train\/')\n    \nwith zipfile.ZipFile('..\/input\/aerial-cactus-identification\/test.zip', 'r') as zip_ref:\n    zip_ref.extractall('test\/')    ","bc80b217":"train_dir = '\/kaggle\/working\/train\/train'\ntest_dir = '\/kaggle\/working\/test\/test'\n\ntrain = pd.read_csv(\"..\/input\/aerial-cactus-identification\/train.csv\")\ntrain.head()","2b0cc454":"class GetData(Dataset):\n    def __init__(self, df, data_dir, transform):\n        super().__init__()\n        self.df = df\n        self.data_dir = data_dir\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, index):       \n        img_name = self.df.id[index]\n        label = self.df.has_cactus[index]\n        \n        img_path = os.path.join(self.data_dir, img_name)\n        image = Image.open(img_path)\n        image = self.transform(image)\n        return image, label","cd4449a3":"data_transf = transforms.Compose([\n    transforms.ToTensor()\n])\ntrain_data = GetData(df = train, data_dir = train_dir, transform = data_transf)\ntrain_loader = DataLoader(dataset = train_data, batch_size = 64,shuffle=True)","203f2619":"!pip install efficientnet_pytorch","cf27da24":"from efficientnet_pytorch import EfficientNet\nmodel = EfficientNet.from_name('efficientnet-b1')","717973a0":"# Unfreeze model weights\nfor param in model.parameters():\n    param.requires_grad = True","0fb47b7e":"num_ftrs = model._fc.in_features\nmodel._fc = nn.Linear(num_ftrs, 1)","a5f7c61f":"model = model.to('cuda')\noptimizer = optim.Adam(model.parameters())\nloss_func = nn.BCELoss()\n\nloss_log = []\n\nfor epoch in range(5):    \n    model.train()    \n    for ii, (data, target) in enumerate(train_loader):\n        data, target = data.cuda(), target.cuda()\n        target=target.view(-1,1).float()\n\n        optimizer.zero_grad()\n        output = model(data)                \n    \n        m = nn.Sigmoid()\n        loss = loss_func(m(output), target)\n        loss.backward()\n\n        optimizer.step()  \n        \n        if ii % 1000 == 0:\n            loss_log.append(loss.item())\n       \n    print('Epoch: {} - Loss: {:.6f}'.format(epoch + 1, loss.item()))","53f671e3":"plt.figure(figsize=(10,8))\nplt.plot(loss_log)","907b1f32":"submit = pd.read_csv('..\/input\/aerial-cactus-identification\/sample_submission.csv')\ntest_data = GetData(df = submit, data_dir = test_dir, transform = data_transf)\ntest_loader = DataLoader(dataset = test_data, shuffle=False)","1f6af8a3":"predict = []\nwith torch.no_grad():\n    model.eval()\n    for data,_ in test_loader:\n        data = data.cuda()\n        output = model(data)    \n\n        pred = torch.sigmoid(output)\n        predicted_vals = pred > 0.5\n        predict.append(int(predicted_vals))\n    \nsubmit['has_cactus'] = predict\nsubmit.to_csv('submission.csv', index=False)","98678217":"submit.head()","2a23554f":"# have a good coding","5f700b62":"# hello i suggest you to simple train process with [this code](https:\/\/www.kaggle.com\/ateplyuk\/pytorch-efficientnet)\n\ni modify \n\n- matplotlib.image -> PIL.Image\n    - so, it doesn't need 'transforms.toPIL ...'\n- use torch.no_grad()\n    - we need to use all. because model.eval() means 'use model layer inference mode' and torch.no_grad() means 'shut down autograd engine'. "}}