{"cell_type":{"9c1b08f7":"code","202f5a71":"code","76b3c0f5":"code","b582a7c3":"code","94ed0d98":"code","87b15132":"code","15415f6b":"code","2def6b00":"code","7d235dbe":"code","050032ab":"code","81f3ea82":"code","74b1cf4c":"code","c5bc12e6":"code","7e462c3d":"code","602bef59":"code","cf3c7430":"code","fc7e666b":"code","25cd9fbc":"code","7db86569":"code","fdaddc6d":"code","ae407255":"code","834d907d":"code","127ed935":"code","a7e454ef":"code","31952384":"code","72a0a100":"code","6d23a4bf":"code","fa5c366d":"code","76bdcbef":"code","768dd37e":"code","b16a30eb":"code","32ad5d77":"code","ae7b046b":"code","abb45196":"code","e9741f18":"code","b7e6e4be":"code","fea72197":"code","dc2c414d":"code","0b9568cf":"code","63dcb4f0":"code","6688901d":"code","3be29d5f":"code","93fa5a8e":"code","119b4d8a":"code","bcac6e3d":"code","33e108ef":"code","015fe105":"code","550592a9":"code","98dd288b":"code","b8186b51":"code","f8e3957f":"code","8a0847dd":"code","f9f9a666":"code","0632116a":"code","51c96e74":"code","8308da1a":"code","ca7f628d":"markdown","66709aac":"markdown","349ac547":"markdown","61d0de21":"markdown","0438920b":"markdown","65474782":"markdown","507491c1":"markdown","5dfdcb82":"markdown","ddd309a4":"markdown","08e1865a":"markdown","b28b2af1":"markdown","62c5c94c":"markdown","c0d8a882":"markdown","ad60b455":"markdown","67d5265b":"markdown","76c58ef6":"markdown","ea6f7362":"markdown","d6cea7d8":"markdown","951bc668":"markdown","cb9299fb":"markdown","b3f4dadf":"markdown"},"source":{"9c1b08f7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier","202f5a71":"import warnings\nwarnings.filterwarnings(\"ignore\")","76b3c0f5":"data = pd.read_csv('..\/input\/forest-cover-type-dataset\/covtype.csv')","b582a7c3":"data","94ed0d98":"print('Data Dimensions:','Rows(Records):', data.shape[0],'Columns(Features):', data.shape[1])","87b15132":"data.isnull().sum()","15415f6b":"data.describe()","2def6b00":"skewness = data.skew()\nskewness","7d235dbe":"skew = pd.DataFrame(skewness, index=None, columns=['Skewness'])\nplt.figure(figsize=(20,10))\nsns.barplot(x=skew.index, y='Skewness', data=skew)\nplt.xticks(rotation=90)\nplt.title('Skewness of Features',fontsize=15)","050032ab":"class_dist = data.groupby('Cover_Type').size()\nlabels= '(Type1)Spruce\/Fir', '(Type2)Lodgepole Pine', '(Type3)Ponderosa Pine', '(Type4)Cottonwood\/Willow', '(Type5)Aspen', '(Type6)Douglas-fir', '(Type7)Krummholz'\nfig1, ax1 = plt.subplots()\nfig1.set_size_inches(15,10)\nax1.pie(class_dist, labels=labels, autopct='%1.1f%%')\nax1.axis('equal')\nplt.title('Percentages of Cover Types',fontsize=15)\nplt.show()","81f3ea82":"features = data.loc[:,'Elevation':'Horizontal_Distance_To_Fire_Points']\nsoiltype = data.loc[:,'Soil_Type1':'Soil_Type40']\nwilderness = data.loc[:,'Wilderness_Area1':'Wilderness_Area4']","74b1cf4c":"plt.figure(figsize=(30, 50))\nfor i,col in enumerate(features.columns.values):\n    plt.subplot(5,2,i+1)\n    sns.distplot(features[col])\n    plt.title(col, fontsize=20)\n    \nplt.show()","c5bc12e6":"plt.figure(figsize=(15,8))\nplt.scatter(data[\"Elevation\"], data[\"Horizontal_Distance_To_Hydrology\"],c=data[\"Cover_Type\"],cmap=\"rainbow\")\nplt.title('Elevation - Horizontal Distance to Water and Cover Types')\nplt.xlabel('Elevation')\nplt.ylabel('Horizontal Distance to Water')\nplt.show()","7e462c3d":"plt.figure(figsize=(15,8))\nplt.scatter(data[\"Elevation\"], data[\"Horizontal_Distance_To_Roadways\"],c=data[\"Cover_Type\"],cmap=\"rainbow\")\nplt.title('Elevation - Horizontal Distance to Roadways and Cover Types')\nplt.xlabel('Elevation')\nplt.ylabel('Horizontal Distance to Roadways')\nplt.show()","602bef59":"#data.shape = (581012, 55)\nfeat = features.copy()","cf3c7430":"feat['Cover_Type'] = data['Cover_Type']\nfeat","fc7e666b":"feat=feat.sort_values(by=['Cover_Type'])","25cd9fbc":"cov1cnt = 0\ncovcnt = []\nfor k in range(1,8):\n    for i in range(0,581012):\n        if feat['Cover_Type'][i] == k:\n            cov1cnt = cov1cnt +1\n    covcnt.append(cov1cnt)\ncovcnt","7db86569":"cov1 = feat.iloc[0:211840]\ncov2 = feat.iloc[211840:495141]\ncov3 = feat.iloc[495141:530895]\ncov4 = feat.iloc[530895:533642]\ncov5 = feat.iloc[533642:543135]\ncov6 = feat.iloc[543135:560502]\ncov7 = feat.iloc[560502:581012]","fdaddc6d":"avg1 = cov1.sum().div(211840)\navg2 = cov2.sum().div(495141-211840)\navg3 = cov3.sum().div(530895-495141)\navg4 = cov4.sum().div(533642-530895)\navg5 = cov5.sum().div(543135-533642)\navg6 = cov6.sum().div(560502-543135)\navg7 = cov7.sum().div(581012-560502)","ae407255":"from math import pi\n\n# Set data\ndf = pd.DataFrame({\n'group': ['Type1','Type2','Type3','Type4','Type5','Type6','Type7'],\n'Elevation': [avg1[0],avg2[0],avg3[0],avg4[0],avg5[0],avg6[0],avg7[0]],\n'Aspect': [avg1[1]*20,avg2[1]*20,avg3[1]*20,avg4[1]*20,avg5[1]*20,avg6[1]*20,avg7[1]*20],\n'Slope': [avg1[2]*150,avg2[2]*150,avg3[2]*150,avg4[2]*150,avg5[2]*150,avg6[2]*150,avg7[2]*150],\n'Horizontal_Distance_To_Hydrology': [avg1[3]*10,avg2[3]*10,avg3[3]*10,avg4[3]*10,avg5[3]*10,avg6[3]*10,avg7[3]*10],\n'Vertical_Distance_To_Hydrology': [avg1[4]*50,avg2[4]*50,avg3[4]*50,avg4[4]*50,avg5[4]*50,avg6[4]*50,avg7[4]*50],\n'Horizontal_Distance_To_Roadways': [avg1[5],avg2[5],avg3[5],avg4[5],avg5[5],avg6[5],avg7[5]],\n'Hillshade_9am': [avg1[6]*10,avg2[6]*10,avg3[6]*10,avg4[6]*10,avg5[6]*10,avg6[6]*10,avg7[6]*10],\n'Hillshade_Noon': [avg1[7]*10,avg2[7]*10,avg3[7]*10,avg4[7]*10,avg5[7]*10,avg6[7]*10,avg7[7]*10],\n'Hillshade_3pm': [avg1[8]*20,avg2[8]*20,avg3[8]*20,avg4[8]*20,avg5[8]*20,avg6[8]*20,avg7[8]*20],\n'Horizontal_Distance_To_Fire_Points': [avg1[9],avg2[9],avg3[9],avg4[9],avg5[9],avg6[9],avg7[9]]\n})\n\n\n\nplt.figure(figsize=(20,15)) \n\n# number of variable\ncategories=list(df)[1:]\nN = len(categories)\n \n# What will be the angle of each axis in the plot? (we divide the plot \/ number of variable)\nangles = [n \/ float(N) * 2 * pi for n in range(N)]\nangles += angles[:1]\n \n# Initialise the spider plot\nax = plt.subplot(111, polar=True)\n \n# If you want the first axis to be on top:\nax.set_theta_offset(pi \/ 2)\nax.set_theta_direction(-1)\n \n# Draw one axe per variable + add labels labels yet\nplt.xticks(angles[:-1], categories)\n \n# Draw ylabels\nax.set_rlabel_position(0)\nplt.yticks([1000,2000,3000], [\"1000\",\"2000\",\"3000\"], color=\"black\", size=5)\nplt.ylim(0,3700)\n\nplt.title('Radar Chart of Features',fontsize=15)\n\nfor i in range(0,7):\n    values=df.loc[i].drop('group').values.flatten().tolist()\n    values += values[:1]\n    ax.plot(angles, values, linewidth=1, linestyle='solid', label=\"Type %d\" %i)\n    ax.fill(angles, values, 'b', alpha=0.2)\n    # Add legend\n    plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))","834d907d":"plt.figure(figsize=(30, 50))\nfor i,col in enumerate(features.columns.values):\n    plt.subplot(5,2,i+1)\n    sns.boxplot(x=data['Cover_Type'], y=col, data=data)\n    plt.title(col, fontsize=20)\n    \nplt.show()","127ed935":"def rev_code(row):\n    for c in soiltype.columns:\n        if row[c]==1:\n            return c  \ncover_soil_type = pd.DataFrame()\ncover_soil_type['Cover_Type'] = data['Cover_Type']\ncover_soil_type['Soil_Type']=soiltype.apply(rev_code, axis=1)","a7e454ef":"cover_soil_type","31952384":"plt.figure(figsize=(20,10))\nsns.countplot(x='Soil_Type', hue='Cover_Type',data=cover_soil_type, palette=\"rainbow\")\nplt.xticks(rotation=90)\nplt.title('Count Plot of Soil Types',fontsize=15)","72a0a100":"def rev_code(row):\n    for c in wilderness.columns:\n        if row[c]==1:\n            return c  \n\ncover_wild_type = pd.DataFrame()\ncover_wild_type['Cover_Type'] = data['Cover_Type']\ncover_wild_type['Wilderness_Area']=wilderness.apply(rev_code, axis=1)","6d23a4bf":"cover_wild_type","fa5c366d":"plt.figure(figsize=(20,10))\nsns.countplot(x='Wilderness_Area', hue='Cover_Type',data=cover_wild_type, palette=\"rainbow\")\nplt.xticks(rotation=90)\nplt.title('Count Plot of Wildernes Areas',fontsize=15)","76bdcbef":"mask = np.zeros_like(features.corr(), dtype=np.bool)\nmask[np.triu_indices_from(mask)] = True\n\nplt.figure(figsize=(13,8))\nplt.title('Correlation Table', fontsize=20)\nsns.heatmap(features.corr(),mask=mask,cmap='Blues',linecolor='white',annot=True)","768dd37e":"x = data.loc[:,'Elevation':'Soil_Type40']\ny = data['Cover_Type']","b16a30eb":"remove = ['Hillshade_3pm','Soil_Type7','Soil_Type8','Soil_Type14','Soil_Type15',\n     'Soil_Type21','Soil_Type25','Soil_Type28','Soil_Type36','Soil_Type37']","32ad5d77":"x.drop(remove, axis=1, inplace=True)","ae7b046b":"x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=100)","abb45196":"AC = [] # Accuracy comparisons of the algorithms","e9741f18":"logreg = LogisticRegression(solver='liblinear', multi_class='ovr')\nlogreg.fit(x_train, y_train)\nlogreg_pred = logreg.predict(x_test)\nlogreg_accuracy = accuracy_score(logreg_pred , y_test)\nAC.append(logreg_accuracy)","b7e6e4be":"dectree = DecisionTreeClassifier()\ndectree.fit(x_train, y_train)\ndectree_pred = dectree.predict(x_test)\ndectree_accuracy = accuracy_score(dectree_pred , y_test)\nAC.append(dectree_accuracy)","fea72197":"plt.figure(figsize=(20,20))\nplt.barh(x_train.columns.values, dectree.feature_importances_)\nplt.title('Feature Importance for Decision Tree Algorithm',fontsize=20)\nplt.ylabel('Feature Name')\nplt.xlabel('Gini Value')\nplt.show()","dc2c414d":"from sklearn import tree","0b9568cf":"plt.figure(figsize=(15,15))\ntree.plot_tree(dectree, max_depth=5, fontsize=8)\nplt.show()","63dcb4f0":"randfor = RandomForestClassifier()\nrandfor.fit(x_train, y_train)\nrandfor_pred = randfor.predict(x_test)\nrandfor_accuracy = accuracy_score(randfor_pred , y_test)\nAC.append(randfor_accuracy)","6688901d":"plt.figure(figsize=(20,20))\nplt.barh(x_train.columns.values, randfor.feature_importances_)\nplt.title('Feature Importance for Random Forest Algorithm',fontsize=20)\nplt.ylabel('Feature Name')\nplt.xlabel('Gini Value')\nplt.show()","3be29d5f":"neighbors = np.arange(1,7)\ntrain_accuracy =np.empty(len(neighbors))\ntest_accuracy = np.empty(len(neighbors))\n\nfor i,k in enumerate(neighbors):\n    knn = KNeighborsClassifier(n_neighbors=k)\n    knn.fit(x_train,y_train)\n    train_accuracy[i] = knn.score(x_train, y_train)\n    test_accuracy[i] = knn.score(x_test, y_test)","93fa5a8e":"plt.figure(figsize=(15,10))\nplt.title('k-NN Varying number of neighbors', fontsize=15)\nplt.plot(neighbors, test_accuracy, label='Testing Accuracy')\nplt.plot(neighbors, train_accuracy, label='Training accuracy')\nplt.legend()\nplt.xlabel('Number of neighbors')\nplt.ylabel('Accuracy')\nplt.show()","119b4d8a":"knn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(x_train,y_train)","bcac6e3d":"knn_accuracy=knn.score(x_test,y_test)\nprint('KNN Accuracy:',knn_accuracy)\nAC.append(knn_accuracy)","33e108ef":"predicted = knn.predict(x_test)","015fe105":"predicted\npre = pd.DataFrame(data=predicted, columns=['Pre'])\npre","550592a9":"y_test\nY_test = pd.DataFrame(data=y_test)\nyy_test = Y_test.reset_index()\nyy_test.drop(columns=['index'])","98dd288b":"hold = pd.DataFrame(columns=['Pre'])\na = []\ncounter = 0\nfor i in range(0,174304):\n    if pre['Pre'][i] != yy_test['Cover_Type'][i]:\n        a.append(pre['Pre'][i])\n        counter = counter + 1\n    else:\n        a.append(0)\n        counter = counter + 1\n\nhold['Pre'] = a\nA = range(0,174304)\nplt.figure(figsize=(15,10))\nsns.countplot(x='Pre', data=hold)\nplt.title('The accurate predictions and others', fontsize=20)\nplt.show()","b8186b51":"accurate = 0\nnot_accurate = 0\nfor i in A:\n    if hold['Pre'][i] == 0:\n        accurate = accurate + 1\n    else:\n        not_accurate = not_accurate + 1","f8e3957f":"labels = 'Accurate', 'Not Accurate'\nsizes = [accurate, not_accurate]\n\nfig1, ax1 = plt.subplots()\nfig1.set_size_inches(8,8)\nax1.pie(sizes, labels=labels, autopct='%1.1f%%')\nax1.axis('equal')\nplt.title('Accuracy Rate', fontsize=20)\nplt.show()","8a0847dd":"accuracydata = pd.DataFrame(data=None,columns=['Accuracy'], index=['Logistic Regression','Decision Tree Classifier','Random Forest Classifier','KNN Algorithm'])\naccuracydata['Accuracy'][0] = AC[0]\naccuracydata['Accuracy'][1] = AC[1]\naccuracydata['Accuracy'][2] = AC[2]\naccuracydata['Accuracy'][3] = AC[3]\naccuracydata","f9f9a666":"sns.set(style=\"whitegrid\")\n\nf, ax = plt.subplots(figsize=(10, 3))\naccuracydata = accuracydata.sort_values(\"Accuracy\", ascending=False)\n\nsns.set_color_codes(\"deep\")\nsns.barplot(x=\"Accuracy\", y=accuracydata.index, data=accuracydata,label=\"Accuracy\", color=\"g\")\n\nax.legend(ncol=2, loc=\"lower right\", frameon=True)\nax.set(xlim=(0, 1), ylabel=\"\",xlabel=\"Accuracy Rate\")\n\nplt.title('Comparison of Accuracy Rates of the Algorithms', fontsize=20)","0632116a":"def predictor(el,asp,sc,hh,vh,hr,h9,hN,hf,wa,st):\n    datap = {'Elevation':0, 'Aspect':0, 'Slope':0, 'Horizontal_Distance_To_Hydrology':0,\n       'Vertical_Distance_To_Hydrology':0, 'Horizontal_Distance_To_Roadways':0,\n       'Hillshade_9am':0, 'Hillshade_Noon':0, 'Horizontal_Distance_To_Fire_Points':0, 'Wilderness_Area1':0,\n       'Wilderness_Area2':0, 'Wilderness_Area3':0, 'Wilderness_Area4':0,\n       'Soil_Type1':0, 'Soil_Type2':0, 'Soil_Type3':0, 'Soil_Type4':0, 'Soil_Type5':0,\n       'Soil_Type6':0, 'Soil_Type9':0, 'Soil_Type10':0,\n       'Soil_Type11':0, 'Soil_Type12':0, 'Soil_Type13':0, \n       'Soil_Type16':0, 'Soil_Type17':0, 'Soil_Type18':0,\n       'Soil_Type19':0, 'Soil_Type20':0, 'Soil_Type22':0,\n       'Soil_Type23':0, 'Soil_Type24':0, 'Soil_Type26':0,\n       'Soil_Type27':0, 'Soil_Type29':0, 'Soil_Type30':0,\n       'Soil_Type31':0, 'Soil_Type32':0, 'Soil_Type33':0, \n       'Soil_Type34':0, 'Soil_Type35':0, 'Soil_Type38':0,\n       'Soil_Type39':0, 'Soil_Type40':0}\n    datapre = pd.DataFrame(data=datap,index=[0])\n    datapre['Elevation'] = el\n    datapre['Aspect'] = asp\n    datapre['Slope'] = sc\n    datapre['Horizontal_Distance_To_Hydrology'] = hh\n    datapre['Vertical_Distance_To_Hydrology'] = vh\n    datapre['Horizontal_Distance_To_Roadways'] = hr\n    datapre['Hillshade_9am'] = h9\n    datapre['Hillshade_Noon'] = hN\n    datapre['Horizontal_Distance_To_Fire_Points'] = hf\n    datapre['Wilderness_Area' + str(wa)] =1\n    datapre['Soil_Type' + str(st)] =1\n    predicted = knn.predict(datapre)\n    print('The predicted cover type is: ' + str(predicted))","51c96e74":"predictor(2884,33,12,350,58,872,218,214,1544,3,35)","8308da1a":"predictedknn = knn.predict(x)\npreknn = pd.DataFrame(data=predictedknn, columns=['Pre'])\npreknn.to_csv('submission.csv', index=False)","ca7f628d":"x = independent variables (inputs) <br>\ny = dependent(target) variable (Cover Type)","66709aac":"For a better understanding, we'd better draw a box graph.","349ac547":"### Decision Tree Classifier","61d0de21":"We can see the KNN Algorithm has the most accuracy rate.","0438920b":"# **FOREST COVER TYPE PREDICTION**","65474782":"__Negative Correlations:__ Hillshade_9am (-) Hillshade_3pm <br>\n__Positive Correlations:__ Hillshade_Noon (+) Hillshade_3pm, Aspect (+) Hillshade_3pm, Horizontal_Distance_To_Hydrology (+) Vertical_Distance_To_Hydrology","507491c1":"## Data Analysis","5dfdcb82":"We are going to drop the features which have low standard deviation or co-relation.","ddd309a4":"The skewness for a normal distribution is zero, and any symmetric data should have a skewness near zero. Negative values for the skewness indicate data that are skewed left and positive values for the skewness indicate data that are skewed right.","08e1865a":"We can see the skewnesses on the graphs above better.","b28b2af1":"Type1 and Type2 are lead cover type of the area. Type4 is the least.","62c5c94c":"### Import the data","c0d8a882":"As we can see in the graph, some of the variables have high skewness.","ad60b455":"### KNN Classifier (K Nearest Neighbor Algorithm)","67d5265b":"## Data Modeling","76c58ef6":"### Logistic Regression","ea6f7362":"### Random Forest Classifier","d6cea7d8":"### Import Necessary Libraries","951bc668":"### Data information:\n\n__Elevation__                        = Height in meters.<br>\n__Aspect__                            = Aspect in degrees azimuth.<br>\n__Slope__                            = Slope in degrees.<br>\n__Horizontal_Distance_To_Hydrology__  = Horizontal distance to nearest surface water features.<br>\n__Vertical_Distance_To_Hydrology__    = Vertical distance to nearest surface water features.<br>\n__Horizontal_Distance_To_Roadways__   = Horizontal distance to nearest roadway.<br>\n__Hillshade_9am__                     = Hill shade index at 9am, summer equinox. Value out of 255.<br>\n__Hillshade_Noon__                   = Hill shade index at noon, summer equinox. Value out of 255.<br>\n__Hillshade_3pm__                    = Hill shade index at 3pm, summer equinox. Value out of 255.<br> __Horizontal_Distance_To_Fire_Point__ = Horizontal distance to nearest wildfire ignition points.<br>\n__Wilderness_Area1__                  = Rawah Wilderness Area<br>\n__Wilderness_Area2__                  = Neota Wilderness Area<br>\n__Wilderness_Area3__                  = Comanche Peak Wilderness Area<br>\n__Wilderness_Area4__                 = Cache la Poudre Wilderness Area<br>\n__Soil_Type1 to Soil_Type40__         = Type of the soil.<br>\n__Cover_TypeForest__                 = Cover type, integer value between 1 and 7, with the following key:<br>\n\n1. `Spruce\/Fir`<br>\n2. `Lodgepole Pine`<br>\n3. `Ponderosa Pine`<br>\n4. `Cottonwood\/Willow`<br>\n5. `Aspen`<br>\n6. `Douglas-fir`<br>\n7. `Krummholz`<br>","cb9299fb":"### Checking for missing values:","b3f4dadf":"There aren't any missing values. We can check for the data description."}}