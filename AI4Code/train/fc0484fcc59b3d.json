{"cell_type":{"01731f89":"code","27b0846b":"code","30e7bf23":"code","c6f29921":"code","b8aba2ec":"code","ccfe9935":"code","ad194cf1":"code","a40a0299":"code","5fef3db7":"code","0660a8c2":"code","fb14ada8":"code","4bc71236":"code","621127e1":"code","7fd4385b":"code","75f5476c":"code","17e7095a":"code","983dd08e":"code","e0c6b484":"code","9b5f7aa2":"code","8cbb4a50":"code","49d05c7c":"code","1b13e8de":"code","7fd2f7de":"code","2431aaa6":"code","7bc74fdc":"code","20b37996":"code","3d8c20d5":"code","f6c58504":"code","f9d79529":"markdown"},"source":{"01731f89":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport lightgbm as lgb\nimport time\nimport datetime\n\nimport json\nimport ast\nimport eli5\nimport shap\nfrom eli5.sklearn import PermutationImportance\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold, KFold, RepeatedKFold, train_test_split, GroupKFold, GroupShuffleSplit\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nimport gc\nfrom catboost import CatBoostClassifier\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings(\"ignore\")","27b0846b":"sample_submission = pd.read_csv('..\/input\/sample_submission.csv')\nX_train = pd.read_csv('..\/input\/X_train.csv')\ny_train = pd.read_csv('..\/input\/y_train.csv')\nX_test = pd.read_csv('..\/input\/X_test.csv')","30e7bf23":"sample_submission.head()","c6f29921":"sample_submission.tail()","b8aba2ec":"X_train.head()","ccfe9935":"X_train.tail()","ad194cf1":"X_train.columns","a40a0299":"X_train.dtypes","5fef3db7":"X_train.info()","0660a8c2":"X_train.describe()","fb14ada8":"X_train.isnull().sum()","4bc71236":"y_train.head()","621127e1":"y_train.tail()","7fd4385b":"y_train['surface'].unique()","75f5476c":"X_test.head()","17e7095a":"X_test.tail()","983dd08e":"def aggregate(df):\n    agg_func = {\n        'orientation_X': ['sum','mean', 'max', 'min', 'std'],\n        'orientation_Y': ['sum','mean', 'max', 'min', 'std'],\n        'orientation_Z': ['sum','mean', 'max', 'min', 'std'],\n        'orientation_W': ['sum','mean', 'max', 'min', 'std'],\n        'angular_velocity_X': ['sum','mean', 'max', 'min', 'std'],\n        'angular_velocity_Y': ['sum','mean', 'max', 'min', 'std'],\n        'angular_velocity_Z': ['sum','mean', 'max', 'min', 'std'],\n        'linear_acceleration_X': ['sum','mean', 'max', 'min', 'std'],\n        'linear_acceleration_Y': ['sum','mean', 'max', 'min', 'std'],\n        'linear_acceleration_Z': ['sum','mean', 'max', 'min', 'std'],\n    }\n\n    agg_df = df.groupby(['series_id']).agg(agg_func)\n    agg_df.columns = ['_'.join(col).strip() for col in agg_df.columns.values]\n    agg_df.reset_index(inplace=True)\n\n    df = (df.groupby('series_id')\n          .size()\n          .reset_index(name='count'))\n\n    agg_df = pd.merge(df, agg_df, on='series_id', how='left')\n\n    agg_df\n    return agg_df","e0c6b484":"def quaternion_to_euler(x, y, z, w):\n    import math\n    t0 = +2.0 * (w * x + y * z)\n    t1 = +1.0 - 2.0 * (x * x + y * y)\n    X = math.atan2(t0, t1)\n\n    t2 = +2.0 * (w * y - z * x)\n    t2 = +1.0 if t2 > +1.0 else t2\n    t2 = -1.0 if t2 < -1.0 else t2\n    Y = math.asin(t2)\n\n    t3 = +2.0 * (w * z + x * y)\n    t4 = +1.0 - 2.0 * (y * y + z * z)\n    Z = math.atan2(t3, t4)\n\n    return X, Y, Z\n\ndef fe(actual):\n    new = pd.DataFrame()\n    actual['total_angular_velocity'] = (actual['angular_velocity_X'] ** 2 + actual['angular_velocity_Y'] ** 2 + actual['angular_velocity_Z'] ** 2) ** 0.5\n    actual['total_linear_acceleration'] = (actual['linear_acceleration_X'] ** 2 + actual['linear_acceleration_Y'] ** 2 + actual['linear_acceleration_Z'] ** 2) ** 0.5\n    \n    actual['acc_vs_vel'] = actual['total_linear_acceleration'] \/ actual['total_angular_velocity']\n    \n    x, y, z, w = actual['orientation_X'].tolist(), actual['orientation_Y'].tolist(), actual['orientation_Z'].tolist(), actual['orientation_W'].tolist()\n    nx, ny, nz = [], [], []\n    for i in range(len(x)):\n        xx, yy, zz = quaternion_to_euler(x[i], y[i], z[i], w[i])\n        nx.append(xx)\n        ny.append(yy)\n        nz.append(zz)\n    \n    actual['euler_x'] = nx\n    actual['euler_y'] = ny\n    actual['euler_z'] = nz\n    \n    actual['total_angle'] = (actual['euler_x'] ** 2 + actual['euler_y'] ** 2 + actual['euler_z'] ** 2) ** 5\n    actual['angle_vs_acc'] = actual['total_angle'] \/ actual['total_linear_acceleration']\n    actual['angle_vs_vel'] = actual['total_angle'] \/ actual['total_angular_velocity']\n    \n    def f1(x):\n        return np.mean(np.diff(np.abs(np.diff(x))))\n    \n    def f2(x):\n        return np.mean(np.abs(np.diff(x)))\n    \n    for col in actual.columns:\n        if col in ['row_id', 'series_id', 'measurement_number']:\n            continue\n        new[col + '_mean'] = actual.groupby(['series_id'])[col].mean()\n        new[col + '_min'] = actual.groupby(['series_id'])[col].min()\n        new[col + '_max'] = actual.groupby(['series_id'])[col].max()\n        new[col + '_std'] = actual.groupby(['series_id'])[col].std()\n        new[col + '_max_to_min'] = new[col + '_max'] \/ new[col + '_min']\n\n    return new","9b5f7aa2":"X_train = fe(X_train)\nX_test = fe(X_test)","8cbb4a50":"n_fold = 20\nfolds = StratifiedKFold(n_splits=n_fold, shuffle=True, random_state=11)","49d05c7c":"le = LabelEncoder()\nle.fit(y_train['surface'])\ny_train['surface'] = le.transform(y_train['surface'])","1b13e8de":"def eval_acc(preds, dtrain):\n    labels = dtrain.get_label()\n    return 'acc', accuracy_score(labels, preds.argmax(1)), True\n\ndef train_model(X, X_test, y, params=None, folds=folds, model_type='lgb', plot_feature_importance=False, model=None, groups=y_train['group_id']):\n\n    oof = np.zeros((len(X), 9))\n    prediction = np.zeros((len(X_test), 9))\n    scores = []\n    feature_importance = pd.DataFrame()\n    for fold_n, (train_index, valid_index) in enumerate(folds.split(X, y, groups)):\n        print('Fold', fold_n, 'started at', time.ctime())\n        X_train, X_valid = X.iloc[train_index], X.iloc[valid_index]\n        y_train, y_valid = y.iloc[train_index], y.iloc[valid_index]\n        \n        if model_type == 'lgb':\n            model = lgb.LGBMClassifier(**params, n_estimators = 10000, n_jobs = -1)\n            model.fit(X_train, y_train, \n                    eval_set=[(X_train, y_train), (X_valid, y_valid)], eval_metric='multi_logloss',\n                    verbose=5000, early_stopping_rounds=200)\n            \n            y_pred_valid = model.predict_proba(X_valid)\n            y_pred = model.predict_proba(X_test, num_iteration=model.best_iteration_)\n            \n        if model_type == 'xgb':\n            train_data = xgb.DMatrix(data=X_train, label=y_train, feature_names=X.columns)\n            valid_data = xgb.DMatrix(data=X_valid, label=y_valid, feature_names=X.columns)\n\n            watchlist = [(train_data, 'train'), (valid_data, 'valid_data')]\n            model = xgb.train(dtrain=train_data, num_boost_round=20000, evals=watchlist, early_stopping_rounds=200, verbose_eval=500, params=params)\n            y_pred_valid = model.predict(xgb.DMatrix(X_valid, feature_names=X.columns), ntree_limit=model.best_ntree_limit)\n            y_pred = model.predict(xgb.DMatrix(X_test, feature_names=X.columns), ntree_limit=model.best_ntree_limit)\n        \n        if model_type == 'sklearn':\n            model = model\n            model.fit(X_train, y_train)\n            \n            y_pred_valid = model.predict_proba(X_valid)\n            score = accuracy_score(y_valid, y_pred_valid.argmax(1))\n            print(f'Fold {fold_n}. Accuracy: {score:.4f}.')\n            print('')\n            \n            y_pred = model.predict_proba(X_test)\n        \n        if model_type == 'cat':\n            model = CatBoostClassifier(iterations=20000,  eval_metric='MAE', **params)\n            model.fit(X_train, y_train, eval_set=(X_valid, y_valid), cat_features=[], use_best_model=True, verbose=False)\n\n            y_pred_valid = model.predict(X_valid)\n            y_pred = model.predict(X_test)\n        \n        oof[valid_index] = y_pred_valid\n        scores.append(accuracy_score(y_valid, y_pred_valid.argmax(1)))\n\n        prediction += y_pred    \n        \n        if model_type == 'lgb':\n            # feature importance\n            fold_importance = pd.DataFrame()\n            fold_importance[\"feature\"] = X.columns\n            fold_importance[\"importance\"] = model.feature_importances_\n            fold_importance[\"fold\"] = fold_n + 1\n            feature_importance = pd.concat([feature_importance, fold_importance], axis=0)\n\n    prediction \/= n_fold\n    \n    print('CV mean score: {0:.4f}, std: {1:.4f}.'.format(np.mean(scores), np.std(scores)))\n    \n    if model_type == 'lgb':\n        feature_importance[\"importance\"] \/= n_fold\n        if plot_feature_importance:\n            cols = feature_importance[[\"feature\", \"importance\"]].groupby(\"feature\").mean().sort_values(\n                by=\"importance\", ascending=False)[:50].index\n\n            best_features = feature_importance.loc[feature_importance.feature.isin(cols)]\n\n            plt.figure(figsize=(16, 12));\n            sns.barplot(x=\"importance\", y=\"feature\", data=best_features.sort_values(by=\"importance\", ascending=False));\n            plt.title('LGB Features (avg over folds)');\n        \n            return oof, prediction, feature_importance\n        return oof, prediction\n    \n    else:\n        return oof, prediction","7fd2f7de":"params = {'num_leaves': 123,\n          'min_data_in_leaf': 12,\n          'objective': 'multiclass',\n          'max_depth': 20,\n          'learning_rate': 0.04680350949723872,\n          \"boosting\": \"gbdt\",\n          \"bagging_freq\": 5,\n          \"bagging_fraction\": 0.8933018355190274,\n          \"bagging_seed\": 11,\n          \"verbosity\": -1,\n          'reg_alpha': 0.9498109326932401,\n          'reg_lambda': 0.8058490960546196,\n          \"num_class\": 9,\n          'nthread': -1,\n          'min_split_gain': 0.009913227240564853,\n          'subsample': 0.9027358830703129\n         }\n\noof_lgb, prediction_lgb, feature_importance = train_model(X=X_train, X_test=X_test, y=y_train['surface'], params=params, model_type='lgb', plot_feature_importance=True)","2431aaa6":"import itertools\n\ndef plot_confusion_matrix(truth, pred, classes, normalize=False, title=''):\n    cm = confusion_matrix(truth, pred)\n    if normalize:\n        cm = cm.astype('float') \/ cm.sum(axis=1)[:, np.newaxis]\n    \n    plt.figure(figsize=(10, 10))\n    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)\n    plt.title('Confusion matrix', size=15)\n    plt.colorbar(fraction=0.046, pad=0.04)\n    tick_marks = np.arange(len(classes))\n    plt.xticks(tick_marks, classes, rotation=45)\n    plt.yticks(tick_marks, classes)\n\n    fmt = '.2f' if normalize else 'd'\n    thresh = cm.max() \/ 2.\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        plt.text(j, i, format(cm[i, j], fmt),\n                 horizontalalignment=\"center\",\n                 color=\"white\" if cm[i, j] > thresh else \"black\")\n\n    plt.ylabel('True label')\n    plt.xlabel('Predicted label')\n    plt.grid(False)\n    plt.tight_layout()","7bc74fdc":"plot_confusion_matrix(y_train['surface'], oof_lgb.argmax(1), le.classes_)","20b37996":"model = lgb.LGBMClassifier(**params, n_estimators = 20000, n_jobs = -1)\nX_train, X_valid, y_train, y_valid = train_test_split(X_train, y_train['surface'], test_size=0.2, stratify=y_train['surface'])\nmodel.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_valid, y_valid)], verbose=5000, early_stopping_rounds=200)","3d8c20d5":"eli5.show_weights(model, targets=[0, 1], feature_names=list(X_train.columns), top=40, feature_filter=lambda x: x != '<BIAS>')","f6c58504":"sample_submission['surface'] = le.inverse_transform(prediction_lgb.argmax(1))\nsample_submission.to_csv('lgb_sub.csv', index=False)","f9d79529":"This kernel refers to the following kernel.  \nhttps:\/\/www.kaggle.com\/artgor\/where-do-the-robots-drive  \nhttps:\/\/www.kaggle.com\/vanshjatana\/help-humanity-by-helping-robots-4e306b  "}}