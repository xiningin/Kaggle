{"cell_type":{"1c68cc0b":"code","955bc5c5":"code","6884e736":"code","6f345670":"code","089dec9c":"code","955e7ec1":"code","f51a082e":"code","b3736c0e":"code","4db99e8e":"code","e1d916a9":"code","e39e63ad":"code","e49e6cc9":"code","ec70d778":"code","d0e890c0":"code","9fb7ccb6":"code","0ddb747f":"code","719eea07":"code","c9e1e323":"code","c87f7296":"code","5965984d":"code","a2908532":"code","ca4db368":"code","dc48ab10":"code","ec135326":"code","f783110b":"code","1b46b695":"code","9498fdb3":"code","14b8cfcd":"code","728f3307":"code","91796c32":"code","0dee34ec":"code","cf3abfa9":"code","5455bafe":"code","04ebaaa3":"code","f9fd40bf":"code","2655d270":"code","818409aa":"code","74b150e7":"code","e89a12a3":"code","9c7358fd":"code","906e11b5":"code","5d8d3fe5":"code","96a18233":"code","ce9d8b11":"code","be6ba78e":"code","be99998e":"code","ee1d19ce":"code","470adca9":"code","0005b6a3":"code","601ff7f9":"code","b3d7a7f1":"code","263d0411":"code","0c12c402":"code","f221d2c9":"code","77e4b92e":"code","c4986251":"code","fc1020eb":"code","88985684":"code","16409996":"code","52f3a276":"code","f9767428":"code","869a7aba":"code","4f57b3a3":"code","39d0fc2c":"code","e090d140":"code","bb5594f3":"code","2ebc905c":"code","2d830e0e":"code","8f3d4935":"code","64ec3185":"code","02ef09b3":"code","87d33d3e":"code","bb4d20d2":"code","67bb257c":"code","a39ecdf5":"code","eddc7052":"code","4bcf9c1b":"code","e982fea8":"code","1abbb99f":"code","6032b145":"code","e2b25ebc":"code","869fa5ac":"code","fa241820":"code","2eb1e264":"code","be0aa476":"code","fa46804c":"code","d5f3e367":"code","90045c8c":"code","8b06bf03":"code","fdf1b7b0":"code","6dd75cf8":"code","f8c5d230":"code","7bdef7f8":"code","6e2efa6a":"code","55dad5da":"markdown","73f97747":"markdown","43b004a2":"markdown","0c7b1c2b":"markdown","ae3b192a":"markdown","454beb48":"markdown","28718fc1":"markdown","474195d8":"markdown","da284bf4":"markdown","329b4873":"markdown","6fe5e730":"markdown","5fdc32dd":"markdown","55d8344f":"markdown","f49e0255":"markdown","f21e16f5":"markdown","23f24415":"markdown","37fcc20d":"markdown","3bd6553d":"markdown","45cf6308":"markdown","2f4a1e44":"markdown","01effd42":"markdown","d762f5ee":"markdown","1723dd71":"markdown","a7ae62bb":"markdown","b384e884":"markdown"},"source":{"1c68cc0b":"import this","955bc5c5":"import pandas as pd\nimport numpy as np\n\nimport os\nprint(os.listdir(\"..\/input\"))","6884e736":"mast_data = pd.read_csv('..\/input\/demo_mast.csv', index_col=0, parse_dates=True, infer_datetime_format=True)\nmast_data.head()","6f345670":"ref_data = pd.read_csv('..\/input\/demo_refs.csv', index_col=0, parse_dates=True, infer_datetime_format=True)\nref_data.head()","089dec9c":"# what is this df object?\ntype(mast_data)","955e7ec1":"# get num rows and columns# get n \nmast_data.shape","f51a082e":"# shape is an attribute, not a function\nmast_data.shape()","b3736c0e":"mast_data.info()","4db99e8e":"mast_data.head()","e1d916a9":"mast_data.tail()","e39e63ad":"mast_data.describe()","e49e6cc9":"# subset a single column with a column label\nmast_data['SPD_59_COMB_AVG']","ec70d778":"mast_data.SPD_59_COMB_AVG","d0e890c0":"mast_data.SPD_59_COMB_AVG.head()","9fb7ccb6":"# delete columns\n# this won't drop in-place unless you use the inplace parameter\nmast_data.drop('SPD_59_COMB_AVG', axis=1).head()","0ddb747f":"# Stamp is the index, NOT a column","719eea07":"mast_data.Stamp # this will fail","c9e1e323":"mast_data.index","c87f7296":"# first row\nmast_data.loc['2014-12-17 11:00:00']","5965984d":"# 5th row\nmast_data.loc['2014-12-17 11:40:00']","a2908532":"# first row\nmast_data.iloc[0]","ca4db368":"# 5th row\nmast_data.iloc[4]","dc48ab10":"# last row\nmast_data.iloc[-1]","ec135326":"# the bracket notation\n# row subsetter\n# comma\n# column subsetter\nmast_data.loc['2014-12-17 11:10:00', 'SPD_59_COMB_AVG']","f783110b":"mast_data.loc['2014-12-17 11:00:00':'2014-12-17 12:00:00', ['SPD_59_COMB_AVG', 'DIR_80_AVG', 'T_4_AVG']]","1b46b695":"mast_data.loc[mast_data.index < '2014-12-17 12:00:00', ['SPD_59_COMB_AVG', 'DIR_80_AVG', 'T_4_AVG']]","9498fdb3":"mast_data.loc[mast_data.index.month == 12, ['SPD_59_COMB_AVG', 'DIR_80_AVG', 'T_4_AVG']]","14b8cfcd":"mast_data.index.year.unique()","728f3307":"mast_data.groupby(mast_data.index.year).mean()\n","91796c32":"mast_data.groupby([mast_data.index.year, mast_data.index.month]).mean()","0dee34ec":"annual_profile = mast_data.groupby(mast_data.index.month).mean().SPD_59_COMB_AVG\nannual_profile","cf3abfa9":"mast_data.resample('MS').mean()","5455bafe":"import matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.style.use('ggplot')\n%matplotlib inline","04ebaaa3":"annual_profile.plot();\n# annual_profile.plot(ylim=[0,10], title='Annual wind speed profile');","f9fd40bf":"import plotly\nimport plotly.graph_objs as go\nplotly.__version__","2655d270":"fig = go.FigureWidget(data=[{'x':annual_profile.index,'y':annual_profile.values}])\nfig","818409aa":"ref_data.head()","74b150e7":"yearly_monthly_means = ref_data.resample('MS').mean()\nmonthly_means = ref_data.groupby(ref_data.index.month).mean()\nmonthly_means_for_normal = monthly_means.loc[yearly_monthly_means.index.month]\nmonthly_means_for_normal.index = yearly_monthly_means.index\nyearly_monthly_means_normal = yearly_monthly_means\/monthly_means_for_normal\nyearly_monthly_means_normal_rolling = yearly_monthly_means_normal.rolling(12, center=True, min_periods=10).mean()\nyearly_monthly_means_normal_rolling.head(10)","e89a12a3":"annual_profile.plot(ylim=[0,10])","9c7358fd":"import plotly.graph_objs as go\n\ndata = [{'x':yearly_monthly_means_normal_rolling.index,'y':yearly_monthly_means_normal_rolling[ref], 'name':ref} for ref in yearly_monthly_means_normal_rolling.columns]\nfig = go.FigureWidget(data=data)\nfig","906e11b5":"fig.layout.title = 'Normalized 12-month rolling average'","5d8d3fe5":"# remove references 9 and 10\nref_data.loc[:,'1':'8'].head(10)","96a18233":"# remove references 9 and 10\nref_data.drop(['9','10'], axis=1).head(10)","ce9d8b11":"mast_data.head()","be6ba78e":"anemometers = ['SPD_59_COMB_AVG','SPD_47_COMB_AVG','SPD_32_COMB_AVG','SPD_15_COMB_AVG']\nheights = [59,47,32,15]\nano_data = mast_data.loc[:,anemometers]\nano_data.head()","be99998e":"ano_data = ano_data.dropna()\nano_data.head()","ee1d19ce":"ws = ano_data.mean().values\nano_data.mean()","470adca9":"from scipy import stats\nalpha, intercept, r_value, p_value, std_err = stats.linregress(np.log(heights),np.log(ws))\nalpha, intercept, r_value**2, p_value, std_err","0005b6a3":"print(f'Alpha: {alpha:.3f}; R2: {r_value**2:.4f}; Std error: {std_err*100.0:.2f}%')","601ff7f9":"# select the column you'd like to use from the mast data\n# select the column you'd like to use from the reference data\nsite_corr_data = mast_data.SPD_59_COMB_AVG\nref_corr_data = ref_data.loc[:,'1':'8']","b3d7a7f1":"# resample to monthly averages\nsite_corr_data = site_corr_data.resample('MS').mean()\nref_corr_data = ref_corr_data.resample('MS').mean()","263d0411":"# concatenate into a single dataframe\ncorr_data = pd.concat([site_corr_data, ref_corr_data], axis=1)\ncorr_data = corr_data.dropna()\ncorr_data.head(10)","0c12c402":"results = []\nfor ref in ref_corr_data.columns:\n    temp_results = stats.linregress(corr_data[ref],corr_data.SPD_59_COMB_AVG)\n    results.append(temp_results)\nresults","f221d2c9":"results = [stats.linregress(corr_data[ref],corr_data.SPD_59_COMB_AVG) for ref in ref_corr_data.columns]\nresults","77e4b92e":"results = pd.DataFrame.from_dict(results)\nresults.index = ref_corr_data.columns\nresults","c4986251":"# add a new column\nresults['r2'] = results.rvalue**2\nresults","fc1020eb":"mast_data.head()","88985684":"ws = mast_data.SPD_59_COMB_AVG.dropna()\nws.head()","16409996":"freq_dist = ws.groupby(ws.round()).count()\nfreq_dist\/ws.size*100.0","52f3a276":"bins = pd.cut(ws, bins=np.arange(0,26,0.5))\nws.groupby(bins).count()\/ws.size*100.0","f9767428":"vane = mast_data.DIR_80_AVG.dropna()\nvane.head()","869a7aba":"vane.describe()","4f57b3a3":"vane = vane.replace(360.0,0.0)","39d0fc2c":"sectors = 12\nbin_width = 360\/sectors\ndir_bins = np.floor_divide(np.mod(vane + (bin_width\/2.0),360.0),bin_width)\nprint(f'Number of direction sectors: {sectors}; Sector bin width: {bin_width}')\ndir_bins.tail(15)\nwind_rose = vane.groupby(dir_bins).count()\nwind_rose","e090d140":"dir_edges = np.append(np.append([0],np.arange(bin_width\/2, 360+bin_width\/2, bin_width)),360)\ndir_labels = np.arange(0,361,bin_width)\n# dir_edges\n\ndir_bins = pd.cut(vane, bins=dir_edges)\ndir_bins.sort_values().unique()\n\n# dir_bins = pd.cut(vane, bins=dir_edges, right=False, labels=dir_labels) #zero inclusive\n# vane.groupby(dir_bins).count()","bb5594f3":"ws.plot()","2ebc905c":"vane.plot(figsize=[20,5], style='.');","2d830e0e":"# Colors for plotting\nEDFGreen = '#509E2F'\nEDFOrange = '#FE5815'\nEDFBlue = '#001A70'\n\nws.plot(figsize=[20,5], color=EDFBlue, title='Wind speed')","8f3d4935":"corr_data.head()","64ec3185":"corr_data.plot(kind='scatter', x='1', y='SPD_59_COMB_AVG', xlim=[0,10], ylim=[0,10], color=EDFBlue, title='Monthly wind speed correlation')","02ef09b3":"freq_dist.plot(kind='bar');","87d33d3e":"fig = plt.figure(figsize=[12,8])\nax = fig.add_subplot(111)\nfreq_dist.plot(kind='bar', color=EDFBlue, ax=ax)\nax.set_ylabel('Bin count')\nax.set_xlabel('Wind speed bin [m\/s]')\nax.set_title('Frequency distribution')\nax.set_xticks(np.arange(0,26,5))\nax.set_xticklabels(np.arange(0,26,5))\nplt.show()","bb4d20d2":"ref = '3'\nfig = plt.figure(figsize=[8,6])\nax = fig.add_subplot(111)\ncorr_data.plot(kind='scatter', x=ref, y='SPD_59_COMB_AVG', color=EDFBlue, ax=ax)\nax.plot([0,10], np.array([0,10])*results.loc[ref,'slope']+results.loc[ref,'intercept'], color=EDFGreen)\nax.set_xlim([0,10])\nax.set_ylim([0,10])\nax.set_xlabel('Reference [m\/s]')\nax.set_ylabel('Site [m\/s]')\nax.set_title(f\"Monthly wind speed correlation (R2: {results.loc[ref,'r2']:.3f})\")\nplt.show()","67bb257c":"fig = plt.figure(figsize=(7,7))\nax = fig.add_subplot(111, projection='polar')\ndir_bin_width_radians = np.radians(bin_width)\nax.set_theta_direction('clockwise')\nax.set_theta_zero_location('N')\nax.bar(np.radians(wind_rose.index.values*bin_width), wind_rose.values, width=dir_bin_width_radians, color=EDFGreen)\nax.set_title('Wind rose')\nax.set_yticklabels([])\nax.set_xticklabels(['N', '', 'E', '', 'S', '', 'W', ''])\nplt.show()","a39ecdf5":"import plotly\nprint(plotly.__version__)\nimport plotly.graph_objs as go\nimport plotly.offline as offline\noffline.init_notebook_mode(connected=True)","eddc7052":"fig = go.FigureWidget(data=[{'x':freq_dist.index, 'y':freq_dist.values, 'type':'bar'}])\nfig","4bcf9c1b":"fig.layout.title = 'Wind speed frequency distribution'","e982fea8":"fig.layout.margin.t = 25\nfig.layout.width = 900\nfig.layout.height = 500\nfig.layout.xaxis.title = 'Wind speed [m\/s]'\nfig.layout.yaxis.title = 'Frequency [count]'\nfig.layout.yaxis.tickvals = []","1abbb99f":"fig = go.FigureWidget(\n    data=[{'x':corr_data[ref], \n           'y':corr_data.SPD_59_COMB_AVG, \n           'type':'scatter', \n           'mode':'markers', \n           'name':'Wind speeds',\n           'marker':{'color':EDFBlue,\n                     'size':8},\n           'text':corr_data.index.strftime('%Y-%m'),\n           'hoverinfo':'text'},\n          {'x':[0,10], \n           'y':np.array([0,10])*results.loc[ref,'slope']+results.loc[ref,'intercept'], \n           'type':'scatter', \n           'mode':'lines', \n           'name':'Fit',\n           'line':{'color':EDFGreen,\n                   'width':5}}\n         ],\n    layout={'title':'Monthly wind speed correlation',\n            'width':600,\n            'font':{'size':14},\n            'margin':{'t':30,'b':35,'r':0,'l':35},\n            'xaxis':{'rangemode':'tozero',\n                     'title':'Reference [m\/s]'},\n            'yaxis':{'rangemode':'tozero',\n                     'title':'Site [m\/s]'}})\nfig","6032b145":"mast_data.to_csv('mast_output.csv')\nmast_data.to_parquet('mast_output.parquet')\nprint(os.listdir(\"..\/working\"))","e2b25ebc":"%%timeit\npd.read_csv('mast_output.csv')","869fa5ac":"%%timeit\npd.read_parquet('mast_output.parquet')","fa241820":"import anemoi as an\nan.__version__","2eb1e264":"mast_data.columns.name = 'sensor'\nmast_data.head()","be0aa476":"mast = an.MetMast(data=mast_data, name='Example mast', primary_ano='SPD_59_COMB_AVG', primary_vane='DIR_80_AVG')\nmast.data.head()","fa46804c":"mast.metadata","d5f3e367":"# an.analysis.","90045c8c":"shear = an.analysis.shear.mast_annual(mast)\nshear","8b06bf03":"# ?an.analysis.correlate.ws_correlation_orthoginal_distance_model()","fdf1b7b0":"# ??an.analysis.correlate.ws_correlation_orthoginal_distance_model()","6dd75cf8":"corr_data.head()","f8c5d230":"an.analysis.correlate.ws_correlation_orthoginal_distance_model(corr_data, ref_ws_col='1', site_ws_col='SPD_59_COMB_AVG', force_through_origin=False)","7bdef7f8":"# an.plotting.","6e2efa6a":"shear_fig = an.plotting.shear.annual_mast_results(shear)\noffline.iplot(shear_fig)","55dad5da":"<a id=\"ploting\"><\/a>\n## Plotting module","73f97747":"<a id=\"headtail\"><\/a>\n## Head and tail","43b004a2":"\n<a id=\"freqdist\"><\/a>\n# Frequency distribution\n---\nLastsly for analysis, we can derive the directional wind speed frequency distribution relying heavily on built-in methods. There is a more in-depth blog post about wind roses and frequency distributions using Pandas by [Rob Story](https:\/\/github.com\/wrobstory) which you can find [here](http:\/\/wrobstory.github.io\/2013\/04\/real-world-pandas-2.html). Clearly, Vestas was on the cutting edge back in 2013.\n\n<a id=\"wsfreqdist\"><\/a>\n## Wind speed frequency distribution","0c7b1c2b":"<a id=\"anemoi\"><\/a>\n# Anemoi\n---\nEDF has been developing a wind-specific analysis library called [Anemoi](https:\/\/github.com\/coryjog\/anemoi). This package is based on the PyData ecosystem: NumPy, Pandas, SciPy, statsmodels, and Plotly. This is a freely available package, hosted on PiPy, that anyone or any organization can download and use. We would love to recruit contributors. ","ae3b192a":"<a id=\"slicing\"><\/a>\n## Slicing data\n\nThe axis labeling information in pandas objects serves many purposes ([documentation](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/indexing.html)):\n\n* Identifies data (i.e. provides metadata) using known indicators, important for analysis, visualization, and interactive console display.\n* Enables automatic and explicit data alignment.\n* Allows intuitive getting and setting of subsets of the data set.\n\nIn this section, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas DataFrames of wind data.\n\n<a id=\"columns\"><\/a>\n### Columns","454beb48":"<a id=\"resample\"><\/a>\n## Resample\n\nVery helpful method for wind analysis for frequency conversion and resampling of time series. Object must have a datetime-like index. Also refered to as reaveraging by the industry. [Documentation here](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.resample.html). Documentation on time periods [here](http:\/\/pandas.pydata.org\/pandas-docs\/stable\/timeseries.html#offset-aliases).","28718fc1":"<a id=\"dataframe\"><\/a>\n# DataFrame\n---","474195d8":"Round works great for simple cases but you can be more sophisticated with [cut](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.cut.html). ","da284bf4":"<a id=\"metmast\"><\/a>\n## MetMast\nThe anemoi MetMast object is a pandas DataFrame with a specific format. Namely, with a DateTime Index and column labels following a standardized naming convention. Some other metadata such as latitude, longitude, mast name, elevation, and primary anemometer and wind vane names are also stored. With all this information, the package can infer the required columns needed to perform shear, long-term, and frequency distribution analysis.   ","329b4873":"<a id=\"windrose\"><\/a>\n## Windrose","6fe5e730":"<a id=\"exporting\"><\/a>\n# Exporting data\n---\nGetting data and results out of your notebook is just as important as getting data into a notebook. [to_csv](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.to_csv.html) and [to_parquet](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.to_parquet.html) are my goto methods to do this.","5fdc32dd":"<a id=\"shear\"><\/a>\n### Shear","55d8344f":"<a id=\"rows\"><\/a>\n### Rows\n\n[loc](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.loc.html) indexes by labels or booleans as opposed to [iloc](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.iloc.html#pandas.DataFrame.iloc) which indexes by integer position. For the purposes of wind analysis I use loc almost exclusively. \n","f49e0255":"<a id=\"modules\"><\/a>\n## Analysis modules\n\nWhile Anemoi is still in the very early stages of development it has a couple modules designed to help with wind analysis. You can explore the modeles in the [documentation](https:\/\/coryjog.github.io\/anemoi\/) or by using tab-complete with an.analysis.*tab-complete*.","f21e16f5":"<a id=\"mcp\"><\/a>\n# MCP - Long-term analysis\n---\nSimilarly, we can apply the typical industry measure-correlate-predict method between our reference and mast data using simple least squares. For demonstration purposes we'll apply a monthly correlation between our site and the reference stations.","23f24415":"<a id=\"rowscolumns\"><\/a>\n### Rows and columns","37fcc20d":"![www.awea.org](http:\/\/awea.files.cms-plus.com\/pagelayoutimages\/AWEA_Logo_Web.png)\n\n# AWEA Resource Assessment Workshop - Pre-Conference Python Tutorial\n\n# About this Tutorial\n* Length: 3-ish hours\n* Prerequisites: \n    * No experience necessary \n    * Basic programming concepts and wind assessment methodology helpful\n    * Python very helpful\n* Goals: \n  * Get exposure to fundamental wind analysis tools\n  * Fork this kernel\n  * Become familiar with pandas, numpy, and data visualization \n  * Develop analysis\n<br><br>\n\n# Table of contents:\n- [Introduction](#introduction)\n    - [Python](#python)\n    - [Pandas](#pandas)\n    - [Numpy](#numpy)\n    - [Scipy](#scipy)\n- [Dataset](#data)\n    - [Importing](#importing)\n- [Dataframe](#dataframe)\n\t- General info\n    - [Head and tail](#headtail)\n    - [Slicing data](#slicing)\n        - [Columns](#columns)\n        - [Rows](#rows)\n        - [Rows and columns](#rowscolumns)\n- Split-Apply-Combine\n\t- [Grouped and aggregated calculations](#grouped)\n    - [Resample](#resample)\n    - [Rolling](#rolling)\n- [Shear](#shear)\n- [MCP](#mcp)\n- [Frequency distribution](#freqdist)\n    - [Wind speed](#wsfreqdist)\n    - [Windrose](#windrose)\n- Visualizing data and results\n\t- [Matplotlib](#matplotlib)\n    - [Plotly](#plotly)\n- [Exporting](#exporting)\n- [Anemoi](#anemoi)\n    - [Sensor naming convention](#naming)\n    - [MetMast](#metmast)\n    - Analysis modules\n        - [Shear](#shear)\n        - [Correlate](#correlate)\n    - [Plotting module](#ploting)\n\n<a id=\"introduction\"><\/a> \n# A humble introduction to wind analysis\n---\nThis is a humble introduction to wind analysis using open-source, data science tools. This intro is meant for analysts new to Python-based tools but familiar with wind resource assessment methodology. This notebook is based on the [Pandas for Data Analysis Tutorial](https:\/\/youtu.be\/oGzU688xCUs), presented by Daniel Chen at SciPy 2017 in Austin, Texas. The full GitHub repository of those tutorial notebooks can be found [here](https:\/\/github.com\/chendaniely\/scipy-2017-tutorial-pandas\/tree\/master\/01-notes).\n\nMy main goal is to remove the barier to entry for an analyst or organization interested in adopting modern, open-source, data-analysis tools. Kaggle is a great environment to learn within because it takes care of the software and package installation needed to get up and running. Kernel notebooks are an effective introductory tool because I can develop an analysis and you can copy, or fork, this notebook to develop your own analysis. Most likely, you'll find it easier to install an environment on your own machine using [Anaconda](https:\/\/www.anaconda.com\/download\/) but for sharing and learning, Kernels are highly effective. \n\n<a id=\"python\"><\/a> \n## Python\n\n> Why would you code in Python, it's slow? Why don't you commute by airplane, its really fast? -Jake Vanderplas PyCon 2017\n\nWe won't go into too much detail about [Python](https:\/\/www.python.org\/about\/) here but if you want to learn more there are plenty of resources available online. In summary, Python is a general-purpose scripting language designed to be easy to read and efficient to develop code. Pure Python is not very helpful for wind analysis without additional packages. It is the ecosystem of data analysis packages that greatly extend Python's capabilities and make it very effective at data analysis. This tutorial will introduce you to some of those packages. For a more in-depth tour of the ecosystem, with respect to wind analysis, you can watch the Working Group's webinar [here](https:\/\/register.gotowebinar.com\/recording\/2399581164311633667). You can also see more in-depth wind analysis examples [here](https:\/\/www.kaggle.com\/coryjog\/example-wind-analysis-in-python) and [here](https:\/\/www.kaggle.com\/srlightfoote\/example-wind-analysis-in-r). ","3bd6553d":"<a id=\"plotly\"><\/a>\n## Plotly\n\n[Plolty](https:\/\/plot.ly\/d3-js-for-python-and-pandas-charts\/) combines the very powerful and interactive d3 JavaScript library with a Python API. This allows a wind analyst the ability to make interactive graphics with Python code. You can find a good introductory tutorial [here](https:\/\/plot.ly\/python\/ipython-notebook-tutorial\/).  Plotly just recently released Version 3, which allows the user to access and update each attribute using Python syntax. You can read more about this in [their Medium post](https:\/\/medium.com\/@plotlygraphs\/introducing-plotly-py-3-0-0-7bb1333f69c6).","45cf6308":"<a id=\"correlate\"><\/a>\n### Correlate","2f4a1e44":"Finally, look at all the cool things dataframes can do!\n\nhttps:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.html\n\n# Split - Apply - Combine\n---\n[Groupby](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/groupby.html) is a very useful concept adopted from SQL and can be very helpful in wind profile calculations.\n\n\n<a id=\"grouped\"><\/a>\n## Grouped and aggregated calculations\n\nPandas has a lot of grouping and aggregating functionality built in. This is esspecially helpful for time series analysis of wind data. \n\n","01effd42":"<a id=\"pandas\"><\/a> \n## Pandas\n\nThe [pandas](https:\/\/pandas.pydata.org\/) analysis library is a primary reason for Python's adoption by the data science community. There are a bunch of resources [here](https:\/\/pandas.pydata.org\/talks.html). It can provide quite a bit of value to any organization looking for an easy to adopt tool to analize wind data. One of its strengths is time series analysis and conveniently wind data are mostly in the form of time series.\n\n<a id=\"numpy\"><\/a> \n## Numpy\n\n[Numpy](http:\/\/www.numpy.org\/) is the fundamental package for scientific computing with Python. It is also the primary package upon which Pandas is built and they interface very well with each other. It includes many features that are beneficial to wind analysis and we'll be using the statistics and linear algebra functionality today. You can find a comprehensive, Numpy specific tutorial [here](https:\/\/docs.scipy.org\/doc\/numpy\/user\/quickstart.html).\n\n<a id=\"scipy\"><\/a> \n## Scipy\n[Scipy](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/tutorial\/general.html) is a collection of mathematical algorithms and convenience functions built on the Numpy extension of Python. The following subpackages are especially helpful for wind data analysis:\n* interpolate - Interpolation and smoothing splines\n* linalg - Linear algebra\n* odr - Orthogonal distance regression\n* spatial - Spatial data structures and algorithms (GIS)\n* stats - Statistical distributions and functions\n<br><\/br>\n\n<a id=\"pandas\"><\/a>\n# Dataset\n---\nBut, before we get into analysis we need to get our wind data into our notebook environment. Pandas has a very comprehensive .csv importer which makes ingesting data from an NRG logger or a visualization tool like Windographer very easy. EDF Renwables has provided some anonymized, altered, otherwise unusable data from a meteorological mast in North America along with some nearby reference station data. We'll use these data throughout the rest of the tutorial.\n\n<a id=\"importing\"><\/a>\n## Importing\nThe primary means by which to get data into a notebook is the read_csv method. Here you can find the [documentation and some working examples](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.read_csv.html). We'll use this in the next couple of cells to import our mast and reference data.","d762f5ee":"<a id=\"visualization\"><\/a>\n# Visualization - visulalizing data and results\n---\nThis is an entire tutorial unto itself. I will try to cover the basics and introduce you to some popular plotting libraries. If you'd like to know more you can watch Jake VanderPlas' [presentation from PyCon 2017](https:\/\/www.youtube.com\/watch?v=FytuB8nFHPQ) or just Google 'python visualization'. \n\n<a id=\"matplotlib\"><\/a>\n## Matplotlib\n\nWhile there is plenty of online criticism of this package it remains the most popular and standard plotting library for Python, despite being first released in 2003. If you'd like to know more about the history of this package you can go [here](https:\/\/matplotlib.org\/users\/history.html). The gist is that matplotlib was designed to produce publication-quality charts with a MATLAB-ish interface.  It is very powerful and I find myself using this library often to create effective, stative visuals. The fact that this package is already integrated with Pandas is also very convenient.\n","1723dd71":"<a id=\"naming\"><\/a>\n## Sensor naming\n\nIf the column labels adhere to the [following sensor naming convention](https:\/\/coryjog.github.io\/anemoi\/docs_data_model.html#sensor-naming-convention) then Anemoi can parse the relevant information needed for a wind analysis. The convention consists of sensor type, height, orientation, and signal type, all delimited with an underscore. \n1. Sensor type - [SPD, DIR, T, P, etc.]\n2. Height [m]\n3. Orientation - [N, NE, E, SE, S, SW, W, NW]\n4. Signal - [AVG, SD, MIN, MAX]\n\nSensor name examples:\n* SPD_58_N_AVG\n* SPD_58.2_N_AVG\n* DIR_48_N_AVG\n* DIR_48__AVG (**if orientation will not be used in the analysis then you can omit with a double-underscore**)\n* T_3__AVG\n*P_3__AVG\n\nCustom orientations can be used to denote combined signals such as SEL for selectively averaged or COMB for combined. \n\nThe example data adhere to this naming convention and the DataFrame can be turned into an Anemoi MetMast object:","a7ae62bb":"<a id=\"rolling\"><\/a>\n## Rolling\n\nA typical consistency analysis for reference station data includes plotting the 12-month normalized rolling average wind speeds. The rolling method, along with resample and Panda's automatic index alignment, make it possible to do this in six lines of code. [Documentation here](https:\/\/pandas.pydata.org\/pandas-docs\/stable\/generated\/pandas.DataFrame.rolling.html).","b384e884":"<a id=\"shear\"><\/a>\n# Shear analysis\n---\nApplying the [power law](https:\/\/en.wikipedia.org\/wiki\/Wind_profile_power_law) to our measured met mast data.\n\n![power law](https:\/\/wikimedia.org\/api\/rest_v1\/media\/math\/render\/svg\/585548e6acb797708bc9e78580bd9481809b6915)\n\nWe can do this by fitting a [simple least squares regression](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/generated\/scipy.stats.linregress.html) to the natural log of the measurement heights and mean wind speeds using the scientific computational library [SciPy](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/tutorial\/general.html). To be more techincally accurate we would probably use [ODR](https:\/\/docs.scipy.org\/doc\/scipy-0.14.0\/reference\/odr.html) but for simplicity we don't here."}}