{"cell_type":{"64640bd6":"code","44cc3f95":"code","1c000b0c":"code","cbaeb4e6":"code","2233bc9b":"code","16554447":"code","06129fff":"code","0af7895f":"code","bc55f3a4":"code","c8b67fa5":"code","8ef70f32":"code","6d022f80":"code","39dcdaea":"code","f6f16263":"code","183445f0":"code","aec9c127":"code","3dec8ecc":"code","ed2ac1d6":"code","351d524f":"code","0e50288e":"code","5d5b02f5":"code","6a111165":"code","bcac04bb":"code","0bd88c90":"code","f8f29319":"code","ae9fb963":"code","eb7592a0":"code","ff3cb4fe":"code","36b4c9fe":"code","c337de99":"code","f79cf77e":"code","264b127c":"code","fea5e3af":"code","cddc3997":"code","551263ee":"code","259c4d16":"code","7dfd2da3":"code","35542b93":"code","76c8483e":"code","03711436":"code","5444623f":"code","f03a614b":"code","7facc31c":"code","b3c1f3f4":"code","d9def44d":"code","4bb08e61":"code","6936edb8":"code","7e261b1b":"code","afe08e1a":"code","16a46c5c":"code","5e271051":"code","e8e54abc":"code","53e1b89f":"code","bf43fb1c":"code","ecc578b1":"code","583e72f6":"code","067b004b":"code","84767570":"code","cbffd198":"code","077bf19f":"code","1342239b":"code","566f47ee":"code","1256b91d":"code","686f345b":"code","e62f94b0":"markdown","0821d356":"markdown"},"source":{"64640bd6":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport urllib.request\nfrom PIL import Image\nfrom sklearn import model_selection\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import PolynomialFeatures\n\nimport pickle\n\nfrom sklearn import datasets\nfrom sklearn.metrics import classification_report\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\n\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import RepeatedKFold\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn import svm, datasets\nfrom sklearn.svm import SVR","44cc3f95":"dfi = pd.read_csv(\"diamonds_train.csv\", index_col=0)","1c000b0c":"dfi","cbaeb4e6":"train_dummies_cut = pd.get_dummies(dfi[\"cut\"])\ndfi.index.name = train_dummies_cut.index.name = 'index'\ndfi = dfi.merge(train_dummies_cut, on=list(set(dfi).intersection(set(train_dummies_cut)) | {'index'}))\n\ntrain_dummies_color = pd.get_dummies(dfi[\"color\"])\n\ndfi.index.name = train_dummies_color.index.name = 'index'\ndfi = dfi.merge(train_dummies_color, on=list(set(dfi).intersection(set(train_dummies_color)) | {'index'}))\n\ntrain_dummies_clarity = pd.get_dummies(dfi[\"clarity\"])\ndfi.index.name = train_dummies_clarity.index.name = 'index'\ndfi = dfi.merge(train_dummies_clarity, on=list(set(dfi).intersection(set(train_dummies_clarity)) | {'index'}))\n\n\n","2233bc9b":"dfi","16554447":"dfi.sort_values(by=['depth'], ascending= False, inplace = True)\ndfi2 = dfi.drop(dfi.index[[0,1,2, 3, 4, 40344, 40343, 40342, 40341, 40340, 40339]])\n\ndfi2.sort_values(by=['table'], ascending= False, inplace = True)\ndfi3 = dfi2.drop(dfi2.index[[0,1,2, 3, 4,5, 40333, 40332]])\n\n\ndfi3.sort_values(by=['carat'], ascending= False, inplace = True)\ndfi4  = dfi3.drop(dfi3.index[[0,1,2, 3, 4,5,6,7]])\n\ndfi4","06129fff":"dfi4 = dfi4.replace([0],-1)","0af7895f":"dfi4","bc55f3a4":"\ndfi4.replace(to_replace =[\"D\"], value = 1.0, inplace=True)\ndfi4.replace(to_replace =[\"E\"], value = 1.02, inplace=True)\ndfi4.replace(to_replace =[\"F\"], value = 1.04, inplace=True)\ndfi4.replace(to_replace =[\"G\"], value = 1.06, inplace=True)\ndfi4.replace(to_replace =[\"H\"], value = 1.08, inplace=True)\ndfi4.replace(to_replace =[\"I\"], value = 1.1, inplace=True)\ndfi4.replace(to_replace =[\"J\"], value = 1.12, inplace=True)","c8b67fa5":"dfi4.replace(to_replace =[\"I1\"], value = 1.0, inplace=True)\ndfi4.replace(to_replace =[\"IF\"], value = 1.1, inplace=True)\ndfi4.replace(to_replace =[\"SI1\"], value = 1.2, inplace=True)\ndfi4.replace(to_replace =[\"SI2\"], value = 1.3, inplace=True)\ndfi4.replace(to_replace =[\"VS1\"], value = 1.4, inplace=True)\ndfi4.replace(to_replace =[\"VS2\"], value = 1.5, inplace=True)\ndfi4.replace(to_replace =[\"VVS1\"], value = 1.6, inplace=True)\ndfi4.replace(to_replace =[\"VVS2\"], value = 1.7, inplace=True)","8ef70f32":"dfi4.drop(['cut'], axis=1, inplace= True)\ndfi4.drop(['color'], axis=1, inplace= True)\ndfi4.drop(['clarity'], axis=1, inplace= True)","6d022f80":"yi = np.array(dfi4[\"price\"])\nyi","39dcdaea":"dfi4.drop('price', axis=1, inplace=True)\n","f6f16263":"Xi = np.array(dfi4)","183445f0":"Xi_train, Xi_test, yi_train, yi_test = train_test_split(Xi, yi, test_size=0.20, random_state=185)","aec9c127":"'''from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit_transform(Xi)\nXi.shape'''","3dec8ecc":"model_RFR1 = RandomForestRegressor(n_estimators = 2000, random_state=185, bootstrap=True, oob_score=True)","ed2ac1d6":"model_RFR1.fit(Xi_train, yi_train)","351d524f":"y_real = yi_train\ny_pred = model_RFR1.predict(Xi)\ny_pred_train = model_RFR1.predict(Xi_train)\ny_pred_test = model_RFR1.predict(Xi_test)","0e50288e":"df = pd.read_csv(\"diamonds_train.csv\", index_col=0)","5d5b02f5":"df","6a111165":"train_dummies_cut = pd.get_dummies(df[\"cut\"])\ndf.index.name = train_dummies_cut.index.name = 'index'\ndf = df.merge(train_dummies_cut, on=list(set(df).intersection(set(train_dummies_cut)) | {'index'}))\n\ntrain_dummies_color = pd.get_dummies(df[\"color\"])\n\ndf.index.name = train_dummies_color.index.name = 'index'\ndf = df.merge(train_dummies_color, on=list(set(df).intersection(set(train_dummies_color)) | {'index'}))\n\ntrain_dummies_clarity = pd.get_dummies(df[\"clarity\"])\ndf.index.name = train_dummies_clarity.index.name = 'index'\ndf = df.merge(train_dummies_clarity, on=list(set(df).intersection(set(train_dummies_clarity)) | {'index'}))\n","bcac04bb":"df.sort_values(by=['depth'], ascending= False, inplace = True)\ndf2 = df.drop(df.index[[0,1,2, 3, 4, 40344, 40343, 40342, 40341, 40340, 40339]])\n\n\ndf2.sort_values(by=['table'], ascending= False, inplace = True)\ndf3 = df2.drop(df2.index[[0,1,2, 3, 4,5, 40333, 40332]])\n\ndf3.sort_values(by=['carat'], ascending= False, inplace = True)\ndf6  = df3.drop(df3.index[[0,1,2, 3, 4,5,6,7]])\n","0bd88c90":"df6 = df6.replace([0],-1)","f8f29319":"plt.figure(figsize=(15,10))\nc_p_s = df.corr()\nsns.heatmap(c_p_s , cmap=\"BrBG\",annot=True)","ae9fb963":"unique_color = df6[\"color\"].unique()","eb7592a0":"unique_color","ff3cb4fe":"df6.replace(to_replace =[\"D\"], value = 1.0, inplace=True)\ndf6.replace(to_replace =[\"E\"], value = 1.02, inplace=True)\ndf6.replace(to_replace =[\"F\"], value = 1.04, inplace=True)\ndf6.replace(to_replace =[\"G\"], value = 1.06, inplace=True)\ndf6.replace(to_replace =[\"H\"], value = 1.08, inplace=True)\ndf6.replace(to_replace =[\"I\"], value = 1.1, inplace=True)\ndf6.replace(to_replace =[\"J\"], value = 1.12, inplace=True)","36b4c9fe":"df6","c337de99":"df6.replace(to_replace =[\"I1\"], value = 1.0, inplace=True)\ndf6.replace(to_replace =[\"IF\"], value = 1.1, inplace=True)\ndf6.replace(to_replace =[\"SI1\"], value = 1.2, inplace=True)\ndf6.replace(to_replace =[\"SI2\"], value = 1.3, inplace=True)\ndf6.replace(to_replace =[\"VS1\"], value = 1.4, inplace=True)\ndf6.replace(to_replace =[\"VS2\"], value = 1.5, inplace=True)\ndf6.replace(to_replace =[\"VVS1\"], value = 1.6, inplace=True)\ndf6.replace(to_replace =[\"VVS2\"], value = 1.7, inplace=True)\n","f79cf77e":"df6","264b127c":"df6.drop(['cut'], axis=1, inplace= True)\ndf6.drop(['color'], axis=1, inplace= True)\ndf6.drop(['clarity'], axis=1, inplace= True)","fea5e3af":"df6","cddc3997":"y = np.array(df6[\"price\"])\ny","551263ee":"df6.drop('price', axis=1, inplace=True)","259c4d16":"X = np.array(df6)","7dfd2da3":"X","35542b93":"'''X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0, random_state=7)'''","76c8483e":"'''from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit_transform(X)\nX.shape'''","03711436":"'''seed = 7\n\n# prepare models\nmodels = []\nmodels.append(('LR', LinearRegression()))\nmodels.append(('PR', LinearRegression()))\nmodels.append(('SVR', SVR(kernel = 'rbf')))\nmodels.append(('DTR', DecisionTreeRegressor()))\nmodels.append(('RFR', RandomForestRegressor(n_estimators = 10)))\n\n# evaluate each model in turn\nresults = []\nnames = []\nscoring = 'neg_mean_absolute_error'\nfor name, model in models:\n    kfold = model_selection.KFold(n_splits=4, random_state=7, shuffle=True)\n\n    if name == 'PR':  # Por utilizar el modelo del polinomio\n        poly_reg = PolynomialFeatures(degree = 4)\n        X_poly = poly_reg.fit_transform(X_train)\n        cv_results = model_selection.cross_val_score(model, X_poly, y_train.ravel(), cv=kfold, scoring=scoring)\n    \n    else:  # Para cualquier otro caso\n        cv_results = model_selection.cross_val_score(model, X_train, y_train.ravel(), cv=kfold, scoring=scoring)\n    \n    results.append(cv_results)\n    names.append(name)\n    msg = \"%s: %f (%f)\" % (name, cv_results.mean(), cv_results.std())\n    print(msg)\n\n# boxplot algorithm comparison\nfig = plt.figure()\nfig.suptitle('Algorithm Comparison')\nax = fig.add_subplot(111)\nplt.boxplot(results)\nax.set_xticklabels(names)\nplt.show()'''","5444623f":"'''import pickle\n\nfilename = 'gs_reg_log_pipeline.model'\n# Es importante guardar con el pipeline entero\nwith open('RFR_1.csv', 'wb') as archivo_salida:\n    pickle.dump('RFR', archivo_salida)'''","f03a614b":"model_RFR1.fit(X, y)","7facc31c":"y_real = y\ny_pred = model_RFR1.predict(X)\n'''y_pred_train = model_RFR1.predict(X_train)\ny_pred_test = model_RFR1.predict(X_test)'''","b3c1f3f4":"import numpy as np\nimport sklearn.metrics as metrics\n#importing the Linear Regression Algorithm\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef regression_results(y_true, y_pred):\n\n    # Regression metrics\n    explained_variance=metrics.explained_variance_score(y_true, y_pred)\n    mean_absolute_error=metrics.mean_absolute_error(y_true, y_pred) \n    mse=metrics.mean_squared_error(y_true, y_pred) \n    # RMSLE es usado cuando la variable target se ha convertido al logaritmo (por ser su valor muy grande)\n    if (y_true >= 0).all() and (y_pred >= 0).all():  \n        mean_squared_log_error=metrics.mean_squared_log_error(y_true, y_pred)\n        print('mean_squared_log_error: ', round(mean_squared_log_error,4))\n\n    median_absolute_error=metrics.median_absolute_error(y_true, y_pred)\n    r2=metrics.r2_score(y_true, y_pred)\n\n    print('explained_variance: ', round(explained_variance,4))  # Si se acerca a 1, habr\u00e1 aprendido todos los patrones de nuestro datos.  \n    print('r2: ', round(r2,4))\n    print('MAE: ', round(mean_absolute_error,4))\n    print('MSE: ', round(mse,4))\n    print('RMSE: ', round(np.sqrt(mse),4))","d9def44d":"regression_results(y_true=y_real, y_pred=y_pred)","4bb08e61":"import pickle\n\nfilename = 'gs_reg_log_pipeline.model'\n# Es importante guardar con el pipeline entero\nwith open('RFR_final_RMSE1.csv', 'wb') as archivo_salida:\n    pickle.dump('model_RFR1', archivo_salida)","6936edb8":"dft = pd.read_csv(\"diamonds_test.csv\", index_col=0)","7e261b1b":"dft","afe08e1a":"train_dummies_cut = pd.get_dummies(dft[\"cut\"])\ndft.index.name = train_dummies_cut.index.name = 'index'\ndft = dft.merge(train_dummies_cut, on=list(set(dft).intersection(set(train_dummies_cut)) | {'index'}))\n\ntrain_dummies_color = pd.get_dummies(dft[\"color\"])\n\ndft.index.name = train_dummies_color.index.name = 'index'\ndft = dft.merge(train_dummies_color, on=list(set(dft).intersection(set(train_dummies_color)) | {'index'}))\n\ntrain_dummies_clarity = pd.get_dummies(dft[\"clarity\"])\ndft.index.name = train_dummies_clarity.index.name = 'index'\ndft = dft.merge(train_dummies_clarity, on=list(set(dft).intersection(set(train_dummies_clarity)) | {'index'}))\n","16a46c5c":"dft = dft.replace([0],-1)","5e271051":"dft","e8e54abc":"'''dft.drop(['depth'], axis = 1, inplace = True)\ndft.drop(['table'], axis = 1, inplace = True)'''","53e1b89f":"\ndft.replace(to_replace =[\"D\"], value = 1.0, inplace=True)\ndft.replace(to_replace =[\"E\"], value = 1.02, inplace=True)\ndft.replace(to_replace =[\"F\"], value = 1.04, inplace=True)\ndft.replace(to_replace =[\"G\"], value = 1.06, inplace=True)\ndft.replace(to_replace =[\"H\"], value = 1.08, inplace=True)\ndft.replace(to_replace =[\"I\"], value = 1.1, inplace=True)\ndft.replace(to_replace =[\"J\"], value = 1.12, inplace=True)","bf43fb1c":"dft.replace(to_replace =[\"I1\"], value = 1.0, inplace=True)\ndft.replace(to_replace =[\"IF\"], value = 1.1, inplace=True)\ndft.replace(to_replace =[\"SI1\"], value = 1.2, inplace=True)\ndft.replace(to_replace =[\"SI2\"], value = 1.3, inplace=True)\ndft.replace(to_replace =[\"VS1\"], value = 1.4, inplace=True)\ndft.replace(to_replace =[\"VS2\"], value = 1.5, inplace=True)\ndft.replace(to_replace =[\"VVS1\"], value = 1.6, inplace=True)\ndft.replace(to_replace =[\"VVS2\"], value = 1.7, inplace=True)","ecc578b1":"dft.drop(['cut'], axis=1, inplace= True)\ndft.drop(['color'], axis=1, inplace= True)\ndft.drop(['clarity'], axis=1, inplace= True)","583e72f6":"dft","067b004b":"Xt = np.array(dft)","84767570":"'''from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaler.fit_transform(Xt)\nXt.shape'''","cbffd198":"predictions_submit = model_RFR1.predict(Xt)\npredictions_submit","077bf19f":"sample = pd.read_csv(\"sample_submission.csv\")","1342239b":"submission = pd.DataFrame({\"id\": range(len(predictions_submit)), \"price\": predictions_submit})","566f47ee":"submission","1256b91d":"def chequeator(df_to_submit):\n    \"\"\"\n    Esta funci\u00f3n se asegura de que tu submission tenga la forma requerida por Kaggle.\n    \n    Si es as\u00ed, se guardar\u00e1 el dataframe en un `csv` y estar\u00e1 listo para subir a Kaggle.\n    \n    Si no, LEE EL MENSAJE Y HAZLE CASO.\n    \n    Si a\u00fan no:\n    - apaga tu ordenador, \n    - date una vuelta, \n    - enciendelo otra vez, \n    - abre este notebook y \n    - leelo todo de nuevo. \n    Todos nos merecemos una segunda oportunidad. Tambi\u00e9n t\u00fa.\n    \"\"\"\n    if df_to_submit.shape == sample.shape:\n        if df_to_submit.columns.all() == sample.columns.all():\n            if df_to_submit.id.all() == sample.id.all():\n                print(\"You're ready to submit!\")\n                submission.to_csv(\"submission7.csv\", index = False) #muy importante el index = False\n                urllib.request.urlretrieve(\"https:\/\/i.kym-cdn.com\/photos\/images\/facebook\/000\/747\/556\/27a.jpg\", \"gfg.png\")     \n                img = Image.open(\"gfg.png\")\n                img.show()   \n            else:\n                print(\"Check the ids and try again\")\n        else:\n            print(\"Check the names of the columns and try again\")\n    else:\n        print(\"Check the number of rows and\/or columns and try again\")","686f345b":"chequeator(submission)","e62f94b0":"y_pred = model_RFR1.predict(X_test)\ny_pred","0821d356":"mse=metrics.mean_squared_error(y_true, y_pred)"}}