{"cell_type":{"22484c41":"code","cbbd08f0":"code","ad5635e1":"code","29a5f911":"code","a4b8930e":"code","b56d45ec":"code","f789b3ae":"code","fbf13b09":"code","a13a9d86":"code","8ff852f0":"code","2075a809":"code","ea392a85":"code","0c74e5cd":"code","0602ac77":"code","c2807be7":"code","690a9a9f":"code","fb2d62a1":"code","1f9463dc":"code","d7c598ef":"code","5d8e3d5c":"code","a99430d0":"code","7f139141":"code","d4be7947":"code","bf3a889d":"code","c9cfe1f1":"code","f6062dc1":"markdown","38e8a1b2":"markdown","bfac1992":"markdown","75eb84dc":"markdown","a64384db":"markdown","039dda25":"markdown","877b8374":"markdown","11b76466":"markdown","0dda5fcb":"markdown","4d8448af":"markdown","f67be647":"markdown","7c965dae":"markdown","9cc6ff10":"markdown","ee36f025":"markdown","1eca99f2":"markdown","1ff2d5a3":"markdown","f2637310":"markdown","d86e4e72":"markdown","2fba1123":"markdown","c92c1335":"markdown","0800e52b":"markdown"},"source":{"22484c41":"from mpl_toolkits.mplot3d import Axes3D\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt # plotting\nimport numpy as np # linear algebra\nimport os # accessing directory structure\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression, RidgeClassifier\nfrom sklearn.metrics import accuracy_score,classification_report,confusion_matrix,mean_squared_error\nimport warnings\nwarnings.filterwarnings('ignore')\n%matplotlib inline","cbbd08f0":"print(os.listdir('..\/input'))","ad5635e1":"df1 = pd.read_csv('..\/input\/UCI_Credit_Card.csv', delimiter=',')\ndf1.dataframeName = 'UCI_Credit_Card.csv'\nnRow, nCol = df1.shape\nprint(f'There are {nRow} rows and {nCol} columns')","29a5f911":"defaulters = df1.copy()\nprint(defaulters.shape)\ndefaulters.head()","a4b8930e":"defaulters.describe().T","b56d45ec":"defaulters.rename(columns={'default.payment.next.month':'def_pay'}, inplace=True)\ndefaulters.rename(columns={'PAY_0':'PAY_1'}, inplace=True)","f789b3ae":"# checking the datatype of each feature\ndefaulters.info()","fbf13b09":"defaulters.isna().sum()    # check for missing values for surity","a13a9d86":"def_cnt = (defaulters.def_pay.value_counts(normalize=True)*100)\ndef_cnt.plot.bar(figsize=(6,6))\nplt.xticks(fontsize=12, rotation=0)\nplt.yticks(fontsize=12)\nplt.title(\"Probability Of Defaulting Payment Next Month\", fontsize=15)\nfor x,y in zip([0,1],def_cnt):\n    plt.text(x,y,y,fontsize=12)\nplt.show()","8ff852f0":"plt.subplots(figsize=(20,5))\nplt.subplot(121)\nsns.distplot(defaulters.LIMIT_BAL)\n\nplt.subplot(122)\nsns.distplot(defaulters.AGE)\n\nplt.show()","2075a809":"bins = [20,30,40,50,60,70,80]\nnames = ['21-30','31-40','41-50','51-60','61-70','71-80']\ndefaulters['AGE_BIN'] = pd.cut(x=defaulters.AGE, bins=bins, labels=names, right=True)\n\nage_cnt = defaulters.AGE_BIN.value_counts()\nage_0 = (defaulters.AGE_BIN[defaulters['def_pay'] == 0].value_counts())\nage_1 = (defaulters.AGE_BIN[defaulters['def_pay'] == 1].value_counts())\n\nplt.subplots(figsize=(8,5))\n# sns.barplot(data=defaulters, x='AGE_BIN', y='LIMIT_BAL', hue='def_pay', ci=0)\nplt.bar(age_0.index, age_0.values, label='0')\nplt.bar(age_1.index, age_1.values, label='1')\nfor x,y in zip(names,age_0):\n    plt.text(x,y,y,fontsize=12)\nfor x,y in zip(names,age_1):\n    plt.text(x,y,y,fontsize=12)\nplt.xticks(fontsize=12)\nplt.yticks(fontsize=12)\nplt.title(\"Number of clients in each age group\", fontsize=15)\nplt.legend(loc='upper right', fontsize=15)\nplt.show()\n","ea392a85":"plt.subplots(figsize=(20,10))\n\nind = sorted(defaulters.PAY_1.unique())\npay_0 = (defaulters.PAY_1[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_1[defaulters['def_pay'] == 1].value_counts(normalize=True))\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(231)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-0\", fontsize=15)\n\nind = sorted(defaulters.PAY_2.unique())\npay_0 = (defaulters.PAY_2[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_2[defaulters['def_pay'] == 1].value_counts(normalize=True))\nfor i in pay_0.index:\n    if i not in pay_1.index:\n        pay_1[i]=0\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(232)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-1\", fontsize=15)\n\nind = sorted(defaulters.PAY_3.unique())\npay_0 = (defaulters.PAY_3[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_3[defaulters['def_pay'] == 1].value_counts(normalize=True))\nfor i in pay_0.index:\n    if i not in pay_1.index:\n        pay_1[i]=0\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(233)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-2\", fontsize=15)\n\nind = sorted(defaulters.PAY_4.unique())\npay_0 = (defaulters.PAY_4[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_4[defaulters['def_pay'] == 1].value_counts(normalize=True))\nfor i in pay_0.index:\n    if i not in pay_1.index:\n        pay_1[i]=0\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(234)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-3\", fontsize=15)\n\nind = sorted(defaulters.PAY_5.unique())\npay_0 = (defaulters.PAY_5[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_5[defaulters['def_pay'] == 1].value_counts(normalize=True))\nfor i in pay_0.index:\n    if i not in pay_1.index:\n        pay_1[i]=0\nfor i in pay_1.index:\n    if i not in pay_0.index:\n        pay_0[i]=0\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(235)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-4\", fontsize=15)\n\nind = sorted(defaulters.PAY_6.unique())\npay_0 = (defaulters.PAY_6[defaulters['def_pay'] == 0].value_counts(normalize=True))\npay_1 = (defaulters.PAY_6[defaulters['def_pay'] == 1].value_counts(normalize=True))\nfor i in pay_0.index:\n    if i not in pay_1.index:\n        pay_1[i]=0\nfor i in pay_1.index:\n    if i not in pay_0.index:\n        pay_0[i]=0\ntotal = pay_0.values+pay_1.values\npay_0_prop = np.true_divide(pay_0, total)*100\npay_1_prop = np.true_divide(pay_1, total)*100\nplt.subplot(236)\nplt.bar(ind, pay_1_prop, bottom=pay_0_prop, label='1')\nplt.bar(ind, pay_0_prop, label='0')\nplt.title(\"Repayment Status M-5\", fontsize=15)\n\nplt.xticks(ind, fontsize=12)\nplt.yticks(fontsize=12)\nplt.legend(loc=\"upper right\", fontsize=15)\nplt.suptitle(\"Repayment Status for last 6 months with proportion of defaulting payment next month\", fontsize=20)\n\nplt.show()","0c74e5cd":"g = sns.FacetGrid(defaulters, row='def_pay', col='MARRIAGE')\ng = g.map(plt.hist, 'AGE')\nplt.show()","0602ac77":"g = sns.FacetGrid(defaulters, row='def_pay', col='SEX')\ng = g.map(plt.hist, 'AGE')","c2807be7":"plt.subplots(figsize=(20,10))\n\nplt.subplot(231)\nplt.scatter(x=defaulters.PAY_AMT1, y=defaulters.BILL_AMT1, c='r', s=1)\n\nplt.subplot(232)\nplt.scatter(x=defaulters.PAY_AMT2, y=defaulters.BILL_AMT2, c='b', s=1)\n\nplt.subplot(233)\nplt.scatter(x=defaulters.PAY_AMT3, y=defaulters.BILL_AMT3, c='g', s=1)\n\nplt.subplot(234)\nplt.scatter(x=defaulters.PAY_AMT4, y=defaulters.BILL_AMT4, c='c', s=1)\nplt.ylabel(\"Bill Amount in past 6 months\", fontsize=25)\n\nplt.subplot(235)\nplt.scatter(x=defaulters.PAY_AMT5, y=defaulters.BILL_AMT5, c='y', s=1)\nplt.xlabel(\"Payment in past 6 months\", fontsize=25)\n\nplt.subplot(236)\nplt.scatter(x=defaulters.PAY_AMT6, y=defaulters.BILL_AMT6, c='m', s=1)\n\nplt.show()","690a9a9f":"y1 = defaulters.AGE[defaulters[\"def_pay\"] == 0]\ny2 = defaulters.AGE[defaulters[\"def_pay\"] == 1]\nx1 = defaulters.LIMIT_BAL[defaulters[\"def_pay\"] == 0]\nx2 = defaulters.LIMIT_BAL[defaulters[\"def_pay\"] == 1]\n\nfig,ax = plt.subplots(figsize=(20,10))\nplt.scatter(x1,y1, color=\"r\", marker=\"*\", label='0')\nplt.scatter(x2,y2, color=\"b\", marker=\".\", label='1')\nplt.xlabel(\"LIMITING BALANCE\", fontsize=20)\nplt.ylabel(\"AGE\", fontsize=20)\nplt.xticks(fontsize=15)\nplt.yticks(fontsize=15)\nplt.legend(loc='upper right', fontsize=20)\nplt.show()\n","fb2d62a1":"plt.subplots(figsize=(30,20))\nsns.heatmap(defaulters.corr(), annot=True)\nplt.show()","1f9463dc":"#saleprice correlation matrix\nk = 10 #number of variables for heatmap\ncorrmat = defaulters.corr()\ncols = corrmat.nlargest(k, 'def_pay')['def_pay'].index\ncm = np.corrcoef(defaulters[cols].values.T)\nsns.set(font_scale=1.25)\nplt.subplots(figsize=(10,10))\nhm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)\nplt.show()","d7c598ef":"defaulters.info()","5d8e3d5c":"df_X = defaulters.drop(['def_pay','AGE_BIN'], axis=1)\ndf_y = defaulters.def_pay\n\nX_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.2, random_state=10)\n\nmodel1 = LogisticRegression()\nmodel1.fit(X_train, y_train)\n\ny_pred = model1.predict(X_test)\n\nprint(classification_report(y_pred, y_test))\nprint(confusion_matrix(y_pred, y_test))\nprint('\\nAccuracy Score for model1: ', accuracy_score(y_pred,y_test))","a99430d0":"# change the datatype of categorical features from integer to category\ndefaulters.SEX = defaulters.SEX.astype(\"category\")\ndefaulters.EDUCATION = defaulters.EDUCATION.astype(\"category\")\ndefaulters.MARRIAGE = defaulters.MARRIAGE.astype(\"category\")\ndefaulters.PAY_1 = defaulters.PAY_1.astype(\"category\")\ndefaulters.PAY_2 = defaulters.PAY_2.astype(\"category\")\ndefaulters.PAY_3 = defaulters.PAY_3.astype(\"category\")\ndefaulters.PAY_4 = defaulters.PAY_4.astype(\"category\")\ndefaulters.PAY_5 = defaulters.PAY_5.astype(\"category\")\ndefaulters.PAY_6 = defaulters.PAY_6.astype(\"category\")\ndefaulters.def_type = defaulters.def_pay.astype(\"category\")","7f139141":"df_X = defaulters.drop(['def_pay','AGE_BIN'], axis=1)\ndf_y = defaulters.def_pay\n\nX_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.2, random_state=10)\n\nmodel2 = LogisticRegression()\nmodel2.fit(X_train, y_train)\n\ny_pred = model2.predict(X_test)\n\nprint(classification_report(y_pred, y_test))\nprint(confusion_matrix(y_pred, y_test))\nprint('\\nAccuracy Score for model2: ', accuracy_score(y_pred,y_test))","d4be7947":"df_X = defaulters.drop(['def_pay','AGE_BIN','PAY_2','PAY_3','PAY_4','PAY_5','PAY_6'], axis=1)\ndf_y = defaulters.def_pay\n\nX_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.2, random_state=10)\n\nmodel3 = LogisticRegression()\nmodel3.fit(X_train, y_train)\n\ny_pred = model3.predict(X_test)\n\nprint(classification_report(y_pred, y_test))\nprint(confusion_matrix(y_pred, y_test))\nprint('\\nAccuracy Score for model3: ', accuracy_score(y_pred,y_test))","bf3a889d":"df_X = defaulters[['SEX','MARRIAGE','AGE','BILL_AMT1','EDUCATION','PAY_1']]\ndf_y = defaulters.def_pay\n\nX_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.1, random_state=20)\n\nmodel4 = LogisticRegression()\nmodel4.fit(X_train, y_train)\n\ny_pred = model4.predict(X_test)\ny_train_pred = model4.predict(X_train)\n\nprint(classification_report(y_pred, y_test))\nprint(confusion_matrix(y_pred, y_test))\nprint('\\nTest Accuracy Score for model4: ', accuracy_score(y_pred,y_test))\nprint('\\nTrain Accuracy Score for model4: ', accuracy_score(y_train_pred,y_train))","c9cfe1f1":"df_X = defaulters[['SEX','MARRIAGE','AGE','BILL_AMT1','EDUCATION','PAY_1']]\ndf_y = defaulters.def_pay\n\nX_train, X_test, y_train, y_test = train_test_split(df_X, df_y, test_size=0.3, random_state=20)\n\nmodel5 = RidgeClassifier()\nmodel5.fit(X_train, y_train)\n\ny_pred = model5.predict(X_test)\ny_train_pred = model5.predict(X_train)\n\nprint(classification_report(y_pred, y_test))\nprint(confusion_matrix(y_pred, y_test))\nprint('\\nTest Accuracy Score for model5: ', accuracy_score(y_pred,y_test))\nprint('\\nTrain Accuracy Score for model5: ', accuracy_score(y_train_pred,y_train))","f6062dc1":"* before moving to visualization we first select some features which we feel would be most correlated to the target variable.\n    From the data provided we see that we want to predict whether a person will default in payment next month or not.\n    This prediction depends mostly on previous repayment history, what is the limiting balance, age, education and marriage.\n    Let's plot these first.","38e8a1b2":"    Above plot of Age against limiting balance does not provide any accurate information, as there is mixed variation of clients of all age groups and their current month limiting balance.","bfac1992":"    We have maximum clients from 21-30 age group followed by 31-40. Hence with increasing age group the number of clients that will default the payment next month is decreasing. Hence we can see that Age is important feature to predict the default payment for next month.","75eb84dc":"    By plotting the continous variables we observe that dataset consists of skewed data of limiting balance and age of clients.\n    We have more number of clients having limiting balance between 0 to 200000 currency.\n    We have more number of clients from age bracket of 20 to 40, i.e., clients from mostly young to mid aged groups.\n    We will observe the effect of variables on target variable below","a64384db":"    Above plot shows us the proportion of clients that will default payment next month based on repayment history.\n    For Current month status, the earlier the payment is made lesser are the chances of those clients defaulting the payment.","039dda25":"    we can see that all the 25 columns have 22003 count which indicates there is no missing value.\n    we can see that the repayment status is indicated in columns PAY_0, PAY_2 ... with no PAY_1 column, so we rename PAY_0 to PAY_1 for ease of understanding. ","877b8374":"### Let's check 1st file: ..\/input\/UCI_Credit_Card.csv","11b76466":"    next we check the datatype of each variable of dataset. We see that all the columns are int64 type whereas from previous knowledge we know that SEX, EDUCATION, MARRIAGE, PAY_0, PAY_2, PAY_3, PAY_4, PAY_5, PAY_6, default_payment_next_month are categorical features. So we convert these features in categorical","0dda5fcb":"    As we can see even now the accuracy does not change","4d8448af":"    From above plot we can infer that married people between age bracket of 30 and 50 and unmarried clients of age 20-30 tend to default payment with unmarried clients higher probability to default payment. Hence we can include MARRIAGE feature of clients to find probability of defaulting the payment next month","f67be647":"    We can see that All the examples are predicted to be negative to default payment next month with 77.7% accuracy whereas in the dataset we have 980 observations that are expected to default payment.\n    After doing various random sampling by changing the random_date parameter, we found random_state=10 to be giving highest accuracy for our model1\n    \n    Lets now try changing the datatypes of categorical variables from int to category","7c965dae":"    It can be seen that females of age group 20-30 have very high tendency to default payment compared to males in all age brackets. Hence we can keep the SEX column of clients to predict probability of defaulting payment.","9cc6ff10":"    as we can see that next month default prediction is dependent on repayment status of past six months of all the features given to us. But there is multicollinearity between the Repayment Status features.\n    \n    We will first train model wil all the features and try reducing the non-important features.","ee36f025":"    We can see that by removing the unimportant and multicollinear data, the accuracy has marginally increased by more than 2%","1eca99f2":"    Even after changing the datatype of certain variables there is no change if accuracy of the model.\n    \n    So we evaluate now by dropping the multicollinearity variables and keeping only PAY_1 variable.","1ff2d5a3":"    Above plot indicates that there is higher proportion of clients for whom the bill amount is high but payment done against the same is very low. This we can infer since maximum number of datapoints are closely packed along the Y-axis near to 0 on X-axis","f2637310":"## Introduction\nGreetings!! \nThis notebook is to do EDA on data to predict default of credit card clients","d86e4e72":"    We can see that the dataset consists of 77% clients are not expected to default payment whereas 23% clients are expected to default the payment.","2fba1123":"* now we will check if the past six months bill amount will affect the payment default next month or not:","c92c1335":"    no missing value hence no imputation, now we directly move towards visualzation of defaulters dataset","0800e52b":"    we copy this dataset df1 into another defaulters dataset which will be used for all further computations\n    First look at some of the data to check if data has been read correctly"}}