{"cell_type":{"923874a2":"code","12df15ef":"code","e7019a69":"code","dff526b4":"code","b47432ff":"code","dbfcf6e6":"code","a611e216":"code","ad202c38":"code","2a85783e":"code","0f4827fd":"code","9fd4014a":"code","563dce84":"code","f42692de":"code","d5548f98":"code","db932fa1":"markdown","fdf87dd2":"markdown","cb1871f7":"markdown","8a33b052":"markdown","b35df19e":"markdown","c2b6c64e":"markdown","3ed86eb5":"markdown","c57eb17e":"markdown","36efccb7":"markdown"},"source":{"923874a2":"import os\nimport datetime\nfrom tqdm import tqdm\nimport random\nimport shutil\nimport matplotlib.pyplot as plt\n\nimport numpy as np\nimport pandas as pd\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as Func\nfrom torch.utils.data import Dataset, DataLoader\n\nfrom transformers import BertTokenizer, BertModel, BertConfig, AdamW, get_linear_schedule_with_warmup","12df15ef":"RANDOM_SEED = None\nNUM_OF_CLASSES = 3\nMAX_LENGTH = 192\nTO_USE_POOLING_OUTPUT = False\nRAITO_OF_EVAL_DATA = 0.1\n\nMAX_EPOCH = 5\nTRAIN_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 16\nTEST_BATCH_SIZE = 16\n\nLEARNING_RATE = 8e-6\nWEIGHT_DECAY = 0.001\nDROPOUT_RATE = 0.3\nTO_USE_CLIP_GRAD = True","e7019a69":"class Preprocessor:\n    \"\"\"\n    preprocessing unit\n    \"\"\"\n    INDEX = \"id\"\n    PREMISE = \"premise\"\n    HYPOTHESIS = \"hypothesis\"\n    LANG_AVB = \"lang_avb\"\n    LANGUAGE = \"language\"\n    LAVEL = \"label\"\n\n    def __init__(self, trainDataPath='..\/input\/contradictory-my-dear-watson\/train.csv', testDataPath='..\/input\/contradictory-my-dear-watson\/test.csv', randomSeed=RANDOM_SEED):\n        self.trainDataPath = trainDataPath\n        self.testDataPath = testDataPath\n        self.csvTrainData = None\n        self.csvTestData = None\n        self.random = random\n        if randomSeed is not None:\n            self.random.seed(randomSeed)\n\n    def prepareTrainAndEvalData(self):\n        data = []\n        self.loadTrainData()\n        for index, item in self.csvTrainData.iterrows():\n            texts = []\n            texts.append(self.cleanTexts(item[self.PREMISE]))\n            texts.append(self.cleanTexts(item[self.HYPOTHESIS]))\n            texts.append(item[self.LAVEL])\n            data.append(texts)\n        \n        lenTrainData = int(len(data) * (1 - RAITO_OF_EVAL_DATA))\n        self.random.shuffle(data)\n        trainData = data[:lenTrainData]\n        evalData = data[lenTrainData:]\n\n        return trainData, evalData\n\n    def prepareTestData(self):\n        data = []\n        self.loadTestData()\n        for index, item in self.csvTestData.iterrows():\n            texts = []\n            texts.append(item[self.INDEX])\n            texts.append(self.cleanTexts(item[self.PREMISE]))\n            texts.append(self.cleanTexts(item[self.HYPOTHESIS]))\n            data.append(texts)\n        return data\n\n    def loadTrainData(self):\n        with open(self.trainDataPath) as file:\n            self.csvTrainData = pd.read_csv(file, header=0)\n    \n    def loadTestData(self):\n        with open(self.testDataPath) as file:\n            self.csvTestData = pd.read_csv(file, header=0)\n    \n    # If you want to do additional preproccessings, write them in this unit. \n    def cleanTexts(self, text):\n        text = text.replace('\\t', ' ')\n        \n        #for puctuation in string.punctuation:\n        #    if (puctuation == '.') or (puctuation == ','):\n        #        continue\n        #    else:\n        #        text = text.replace(puctuation, ' ')\n\n        return text","dff526b4":"# For train data\nclass TrainDataSet(Dataset):\n    def __init__(self, trainData, tokenizer):\n        super(TrainDataSet, self).__init__()\n        self.tokenizer = tokenizer\n        self.trainData = trainData\n\n    def __len__(self):\n        return len(self.trainData)\n\n    def __getitem__(self, index):\n        return self.getData(index)\n\n    def encodeToTokenIds(self, text):\n        tokens = self.tokenizer.tokenize(text)\n        tokens.append(self.tokenizer.sep_token)\n        return self.tokenizer.convert_tokens_to_ids(tokens=tokens)\n\n    def getData(self, index):\n        outputData = []\n        premiseTokenIds = self.encodeToTokenIds(' '.join(self.trainData[index][0].split()))\n        hypothesisTokenIds = self.encodeToTokenIds(' '.join(self.trainData[index][1].split()))\n        labelIndex = torch.tensor(self.trainData[index][2], dtype=torch.long)\n        \n        inputs = self.tokenizer.encode_plus(     \n            premiseTokenIds,\n            hypothesisTokenIds,\n            add_special_tokens=True,\n            max_length=MAX_LENGTH,\n            pad_to_max_length=True,\n            truncation=True\n        )\n\n        outputData.append(torch.tensor(inputs['input_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['token_type_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['attention_mask'], dtype=torch.long))\n\n        return outputData, labelIndex\n\n    def getTokenizer(self):\n        return self.tokenizer\n\n# For eval data\nclass EvalDataSet(Dataset):\n    def __init__(self, evalData, tokenizer):\n        super(EvalDataSet, self).__init__()\n        self.tokenizer = tokenizer\n        self.evalData = evalData\n\n    def __len__(self):\n        return len(self.evalData)\n\n    def __getitem__(self, index):\n        return self.getData(index=index)\n\n    def encodeToTokenIds(self, text):\n        tokens = self.tokenizer.tokenize(text)\n        tokens.append(self.tokenizer.sep_token)\n        return self.tokenizer.convert_tokens_to_ids(tokens=tokens)\n\n    def getData(self, index):\n        outputData = []\n        premiseTokenIds = self.encodeToTokenIds(' '.join(self.evalData[index][0].split()))\n        hypothesisTokenIds = self.encodeToTokenIds(' '.join(self.evalData[index][1].split()))\n        labelIndex = torch.tensor(self.evalData[index][2], dtype=torch.long)\n        \n        inputs = self.tokenizer.encode_plus(     \n            premiseTokenIds,\n            hypothesisTokenIds,\n            add_special_tokens=True,\n            max_length=MAX_LENGTH,\n            pad_to_max_length=True,\n            truncation=True\n        )\n\n        outputData.append(torch.tensor(inputs['input_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['token_type_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['attention_mask'], dtype=torch.long))\n\n        return outputData, labelIndex\n\n# For test data\nclass TestDataSet(Dataset):\n    def __init__(self, testData, tokenizer):\n        super(TestDataSet, self).__init__()\n        self.tokenizer = tokenizer\n        self.testData = testData\n        self.labels = []\n\n    def __len__(self):\n        return len(self.testData)\n\n    def __getitem__(self, index):\n        return self.getData(index)\n\n    def encodeToTokenIds(self, text):\n        tokens = self.tokenizer.tokenize(text)\n        tokens.append(self.tokenizer.sep_token)\n        return self.tokenizer.convert_tokens_to_ids(tokens=tokens)\n\n    def getData(self, index):\n        outputData = []\n        self.labels.append(self.testData[index][0])\n        premiseTokenIds = self.encodeToTokenIds(' '.join(self.testData[index][1].split()))\n        hypothesisTokenIds = self.encodeToTokenIds(' '.join(self.testData[index][2].split()))\n        \n        inputs = self.tokenizer.encode_plus(     \n            premiseTokenIds,\n            hypothesisTokenIds,\n            add_special_tokens=True,\n            max_length=MAX_LENGTH,\n            pad_to_max_length=True,\n            truncation=True\n        )\n\n        outputData.append(torch.tensor(inputs['input_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['token_type_ids'], dtype=torch.long))\n        outputData.append(torch.tensor(inputs['attention_mask'], dtype=torch.long))\n\n        return outputData\n\n# This method provides train and eval dataloaders. \nclass BertDataLoader:\n    def __init__(self):\n        self.tokenizer = BertTokenizer.from_pretrained('..\/input\/bert-base-multilingual-cased\/bert-base-multilingual-cased', local_files_only=True)\n        self.preprocessor = Preprocessor()\n        \n    def getTrainAndEvalDataLoader(self):\n        trainData, evalData = self.preprocessor.prepareTrainAndEvalData()\n\n        trainDataSet = TrainDataSet(trainData=trainData, tokenizer=self.tokenizer)\n        evalDataSet = EvalDataSet(evalData=evalData, tokenizer=self.tokenizer)\n        \n        trainDataLoader = DataLoader(trainDataSet, batch_size=TRAIN_BATCH_SIZE, shuffle=True, drop_last=True)\n        evalDataLoader = DataLoader(evalDataSet, batch_size=EVAL_BATCH_SIZE, shuffle=True)\n\n        dataLoadersDict = {'train': trainDataLoader, 'eval': evalDataLoader}\n        return dataLoadersDict","b47432ff":"# Make dataloaders.\ndataLoader = BertDataLoader()\ndataLoadersDict = dataLoader.getTrainAndEvalDataLoader()","dbfcf6e6":"class Model(nn.ModuleList):\n    def __init__(self):\n        super(Model, self).__init__()\n        self.bertModel = SingleBERT(toUsePooling=TO_USE_POOLING_OUTPUT)\n\n        bertConfig = self.bertModel.getConfig()\n        hiddenSize = bertConfig.hidden_size\n        \n        self.classifier = Classifier(hiddenSize=hiddenSize, nClasses=NUM_OF_CLASSES, dropoutRate=DROPOUT_RATE)\n\n    def forward(self, input, tokenTypeIds, attentionMask):\n        output = self.bertModel(input=input, tokenTypeIds=tokenTypeIds, attentionMask=attentionMask)\n        output = self.classifier(output)\n        return output \n\nclass SingleBERT(nn.Module):\n    def __init__(self, toUsePooling=False):\n        super(SingleBERT, self).__init__()\n        self.toUsePooling = toUsePooling\n        self.bertConfig = BertConfig.from_pretrained('..\/input\/bert-base-multilingual-cased\/bert-base-multilingual-cased', local_files_only=True)\n        self.bertModel = BertModel.from_pretrained('..\/input\/bert-base-multilingual-cased\/bert-base-multilingual-cased', local_files_only=True)\n\n        for param in self.bertModel.parameters():\n            param.requires_grad = True\n\n    def forward(self, input, tokenTypeIds, attentionMask):\n        lastLayerOutPut, poolingOutput = self.bertModel(input, attention_mask=attentionMask, token_type_ids=tokenTypeIds, return_dict=False)\n        if self.toUsePooling:\n            return poolingOutput\n        return lastLayerOutPut[:, 0, :]\n\n    def getConfig(self):\n        return self.bertConfig\n\nclass Classifier(nn.Module):\n    def __init__(self, hiddenSize, nClasses, dropoutRate):\n        super(Classifier, self).__init__()\n        self.dropout1 = nn.Dropout(p=dropoutRate)\n        self.linear1 = nn.Linear(in_features=hiddenSize, out_features=hiddenSize)\n        self.batchNorm = nn.BatchNorm1d(num_features=hiddenSize, eps=1e-05, momentum=0.1, affine=False)\n        self.activation = nn.LeakyReLU(negative_slope=0.2, inplace=True)\n        self.dropout2 = nn.Dropout(p=dropoutRate)\n        self.linear2 = nn.Linear(in_features=hiddenSize, out_features=nClasses)\n\n        nn.init.normal_(self.linear1.weight, std=0.04)\n        nn.init.normal_(self.linear2.weight, mean=0.5, std=0.04)\n        nn.init.normal_(self.linear1.bias, 0)\n        nn.init.normal_(self.linear2.bias, 0)\n\n    def forward(self, input):\n        output = self.dropout1(input)\n        output = self.linear1(output)\n        output = self.batchNorm(output)\n        output = self.activation(output)\n        output = self.dropout2(output)\n        output = self.linear2(output)\n        return output","a611e216":"model = Model()","ad202c38":"class LossFunction(nn.Module):\n    def __init__(self):\n        super(LossFunction, self).__init__()\n        self.loss = nn.CrossEntropyLoss()\n\n    def forward(self, inputTensor, lavelTensor):\n        return self.loss(inputTensor, lavelTensor)","2a85783e":"criterion = LossFunction()","0f4827fd":"# To save model's weights\ndef saveWeights(model):\n    saveDirectoryPath = '.\/weight'\n    if not os.path.exists(saveDirectoryPath):\n        os.makedirs(saveDirectoryPath)\n\n    time_now = datetime.datetime.now()\n    time_info = f'{time_now.year}-{time_now.month}-{time_now.day}_{time_now.hour}-{time_now.minute}-{time_now.second}'\n    savePath = saveDirectoryPath +'\/'+ str(time_info) + '.pth'\n\n    try:\n        torch.save(model.state_dict(), savePath)\n        print('Parameters were successfully saved!')\n    except:\n        print('Parameters were not successfully saved!')\n    \n    return None\n\n# For drawing the loss and accuracy rate.\ndef saveLogs(logs):\n    time_now = datetime.datetime.now()\n    time_info = f'{time_now.year}-{time_now.month}-{time_now.day}_{time_now.hour}-{time_now.minute}-{time_now.second}'\n\n    saveDirectoryPath = '.\/logs\/' + str(time_info)\n    if not os.path.exists(saveDirectoryPath):\n        os.makedirs(saveDirectoryPath)\n\n    savePathLoss = saveDirectoryPath  + '\/loss' + '.jpg'\n    savePathAcurracy = saveDirectoryPath  + '\/accuracy' + '.jpg'\n\n    x = [num for num in range(MAX_EPOCH)]\n    epochTrainLosses = logs[0].tolist()\n    epochEvalLosses = logs[1].tolist()\n    epochTrainAccuracies = logs[2].tolist()\n    epochEvalAccuracies = logs[3].tolist()\n\n    # Loss\n    plt.plot(x, epochTrainLosses, color='red', label='Train Loss')\n    plt.plot(x, epochEvalLosses, color='blue', label='Eval Loss')\n\n    plt.xlabel('Epoch')\n    plt.ylabel('Loss')\n    plt.legend(loc='upper right')\n    plt.grid()\n    \n\n    plt.savefig(savePathLoss)\n    plt.clf()\n\n    # Accuracy\n    plt.plot(x, epochTrainAccuracies, color='red', label='Train Accuracy')\n    plt.plot(x, epochEvalAccuracies, color='blue', label='Eval Accuracy')\n\n    plt.xlabel('Epoch')\n    plt.ylabel('Accuracy')\n    plt.legend(loc='lower right')\n    plt.grid()\n \n    plt.savefig(savePathAcurracy)\n    \n    return None\n\n# Check available device.\ndef checkDevice():\n    device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n    print(\"Device: \", device)\n    return device\n\ndef trainModel(model, dataLoadedrsDict, criterion, optimizer):\n    device = checkDevice()\n    model.to(device)\n    criterion.to(device)\n    torch.backends.cudnn.benchmark = True\n\n    total_steps = len(dataLoadedrsDict['train'].dataset) * MAX_EPOCH\n    scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=0, num_training_steps = total_steps)\n    \n    # For progress record.\n    trainLossLogs = np.zeros(shape=MAX_EPOCH, dtype=np.float)\n    evalLossLogs = np.zeros(shape=MAX_EPOCH, dtype=np.float)\n    trainAccuracyLogs = np.zeros(shape=MAX_EPOCH, dtype=np.float)\n    evalAccuracyLogs = np.zeros(shape=MAX_EPOCH, dtype=np.float)\n    \n    # Core part of training\n    for epoch in range(MAX_EPOCH):\n        for phase in ['train', 'eval']:\n            print('-------------------------------------------------------------------------------------------------------------------------------------')\n            print(\"Phase: \", phase)\n\n            if phase == 'train':\n                model.train()\n            else:\n                model.eval()\n\n            epochLoss = 0.0\n            epochCorrects = 0\n            \n            for batch in tqdm(dataLoadedrsDict[phase]):\n                inputs = batch[0][0].to(device)\n                tokenTypeIds = batch[0][1].to(device)\n                attentionMask = batch[0][2].to(device)\n                labels = batch[1].to(device)\n\n                with torch.set_grad_enabled(phase == \"train\"):\n                    outputs = model(input=inputs, tokenTypeIds=tokenTypeIds, attentionMask=attentionMask)\n                    loss = criterion(outputs, labels)\n                    _, predictions = torch.max(outputs, dim=1)\n\n                    if phase == 'train':\n                        optimizer.zero_grad()\n                        loss.backward()\n                        if TO_USE_CLIP_GRAD:\n                            torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n                        optimizer.step()\n                        scheduler.step()\n                        optimizer.zero_grad()\n                    \n                    epochLoss += loss.item() * TRAIN_BATCH_SIZE\n                    epochCorrects += torch.sum(predictions == labels, dim=0)\n\n            epochLoss = epochLoss \/ len(dataLoadedrsDict[phase].dataset)\n            epochAccuracy = epochCorrects.double() \/ len(dataLoadedrsDict[phase].dataset)\n\n            if phase == 'train':\n                trainLossLogs[epoch] = epochLoss\n                trainAccuracyLogs[epoch] = epochAccuracy\n            else:\n                evalLossLogs[epoch] = epochLoss\n                evalAccuracyLogs[epoch] = epochAccuracy\n\n            print('Epoch: {}\/{}  |  Loss: {:.4f}  |  Acc: {:.4f}'.format(epoch+1, MAX_EPOCH, epochLoss, epochAccuracy))\n\n    saveWeights(model=model)\n    logs = [trainLossLogs, evalLossLogs, trainAccuracyLogs, evalAccuracyLogs]\n    saveLogs(logs=logs)\n\n    return model","9fd4014a":"optimizer = AdamW(model.parameters(), lr=LEARNING_RATE, weight_decay=WEIGHT_DECAY, correct_bias=False)","563dce84":"trainedModel = trainModel(model=model, dataLoadedrsDict=dataLoadersDict, criterion=criterion, optimizer=optimizer)","f42692de":"# A function for making inferences using learned parameters.\ndef predict(model, testDataLoader):\n    predictions = []\n    device = checkDevice()\n    model.to(device)\n\n    model.eval()\n\n    for batch in tqdm(testDataLoader):\n        inputs = batch[0].to(device)\n        tokenTypeIds = batch[1].to(device)\n        attentionMask = batch[2].to(device)\n\n        outputs = model(input=inputs, tokenTypeIds=tokenTypeIds, attentionMask=attentionMask)\n        _, prediction = torch.max(outputs, dim=1)\n        prediction = prediction.flatten().tolist()\n        predictions += prediction\n    \n    return predictions\n\n# functions for creating a submission file.\nclass Submitter:\n    def __init__(self, dataSet):\n        self.dataLoader = DataLoader(dataSet, batch_size=TEST_BATCH_SIZE, shuffle=False)\n        self.ids = dataSet.labels\n\n    def makeFile(self, model, weightPath):\n        if weightPath is not None:\n            weights = torch.load(weightPath, map_location={'cuda:0': 'cpu'})\n            model.load_state_dict(weights)\n\n\n        outputLabels = predict(model=model, testDataLoader=self.dataLoader)\n\n        saveDirectoryPath = '.\/'\n        if not os.path.exists(saveDirectoryPath):\n            os.makedirs(saveDirectoryPath)\n\n        savePath =  'submission.csv'\n\n        print(len(self.ids))\n        print(len(outputLabels))\n        dataFrame = pd.DataFrame(list(zip(self.ids, outputLabels)), columns=['id', 'prediction'])\n\n        try:\n            dataFrame.to_csv(savePath, index=False)\n            print(\"Successed !!\")\n        except FileNotFoundError:\n            print(\"Failed !!\")\n","d5548f98":"# Prepare dataset for test. \ntestData = Preprocessor().prepareTestData()\ntokenizer = BertTokenizer.from_pretrained('..\/input\/bert-base-multilingual-cased\/bert-base-multilingual-cased', local_files_only=True)\ndataSet = TestDataSet(testData=testData, tokenizer=tokenizer)\n\n# make a submittion file\nsubmitter = Submitter(dataSet=dataSet)\nsubmitter.makeFile(model=trainedModel, weightPath=None)","db932fa1":"Built dataloaders.","fdf87dd2":"Define model.","cb1871f7":"The followings are functions to create a file for submission using the parameters of the trained model.","8a33b052":"Built preproccess unit.","b35df19e":"Define train function.\nAlso, define some functions to record progress.","c2b6c64e":"Set hyporparameters.","3ed86eb5":"Define loss function. I made the coding using classes in consideration of extensibility.","c57eb17e":"Define optimizer. ","36efccb7":"Train the bert model."}}