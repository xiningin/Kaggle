{"cell_type":{"4df10d2d":"code","71fc08c2":"code","ef848be4":"code","0abc10ad":"code","0d953ad0":"code","973662d3":"code","4f04e23b":"code","46da18e9":"code","69166ce7":"code","e8cd997a":"code","c6cef47a":"code","1477ae9a":"code","8dd76b36":"code","4d2c5f52":"markdown"},"source":{"4df10d2d":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load in \n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the \"..\/input\/\" directory.\n# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n\nimport os\nprint(os.listdir(\"..\/input\"))\n\n# Any results you write to the current directory are saved as output.","71fc08c2":"# Set matplotlib backend\n# This has to be done before other importa that might\n# set it, but only if we're running in script mode\n# rather than being imported.\nif __name__ == '__main__':\n    import matplotlib\n    # Agg backend runs without a display\n    matplotlib.use('Agg')\n    import matplotlib.pyplot as plt\n\nimport os\nimport sys\nimport json\nimport datetime\nimport numpy as np\nimport skimage.io\nfrom imgaug import augmenters as iaa\n","ef848be4":"# Results directory\n# Save submission files here\nRESULTS_DIR = os.path.join(\"\/kaggle\/working\/\")\n\n# The dataset doesn't have a standard train\/val split, so I picked\n# a variety of images to surve as a validation set.\nVAL_IMAGE_IDS = [\n    \"0c2550a23b8a0f29a7575de8c61690d3c31bc897dd5ba66caec201d201a278c2\",\n    \"92f31f591929a30e4309ab75185c96ff4314ce0a7ead2ed2c2171897ad1da0c7\",\n    \"1e488c42eb1a54a3e8412b1f12cde530f950f238d71078f2ede6a85a02168e1f\",\n    \"c901794d1a421d52e5734500c0a2a8ca84651fb93b19cec2f411855e70cae339\",\n    \"8e507d58f4c27cd2a82bee79fe27b069befd62a46fdaed20970a95a2ba819c7b\",\n    \"60cb718759bff13f81c4055a7679e81326f78b6a193a2d856546097c949b20ff\",\n    \"da5f98f2b8a64eee735a398de48ed42cd31bf17a6063db46a9e0783ac13cd844\",\n    \"9ebcfaf2322932d464f15b5662cae4d669b2d785b8299556d73fffcae8365d32\",\n    \"1b44d22643830cd4f23c9deadb0bd499fb392fb2cd9526d81547d93077d983df\",\n    \"97126a9791f0c1176e4563ad679a301dac27c59011f579e808bbd6e9f4cd1034\",\n    \"e81c758e1ca177b0942ecad62cf8d321ffc315376135bcbed3df932a6e5b40c0\",\n    \"f29fd9c52e04403cd2c7d43b6fe2479292e53b2f61969d25256d2d2aca7c6a81\",\n    \"0ea221716cf13710214dcd331a61cea48308c3940df1d28cfc7fd817c83714e1\",\n    \"3ab9cab6212fabd723a2c5a1949c2ded19980398b56e6080978e796f45cbbc90\",\n    \"ebc18868864ad075548cc1784f4f9a237bb98335f9645ee727dac8332a3e3716\",\n    \"bb61fc17daf8bdd4e16fdcf50137a8d7762bec486ede9249d92e511fcb693676\",\n    \"e1bcb583985325d0ef5f3ef52957d0371c96d4af767b13e48102bca9d5351a9b\",\n    \"947c0d94c8213ac7aaa41c4efc95d854246550298259cf1bb489654d0e969050\",\n    \"cbca32daaae36a872a11da4eaff65d1068ff3f154eedc9d3fc0c214a4e5d32bd\",\n    \"f4c4db3df4ff0de90f44b027fc2e28c16bf7e5c75ea75b0a9762bbb7ac86e7a3\",\n    \"4193474b2f1c72f735b13633b219d9cabdd43c21d9c2bb4dfc4809f104ba4c06\",\n    \"f73e37957c74f554be132986f38b6f1d75339f636dfe2b681a0cf3f88d2733af\",\n    \"a4c44fc5f5bf213e2be6091ccaed49d8bf039d78f6fbd9c4d7b7428cfcb2eda4\",\n    \"cab4875269f44a701c5e58190a1d2f6fcb577ea79d842522dcab20ccb39b7ad2\",\n    \"8ecdb93582b2d5270457b36651b62776256ade3aaa2d7432ae65c14f07432d49\",\n]","0abc10ad":"# change directory to the dataset where our\n# custom scripts are found\nos.chdir(\"\/kaggle\/input\/mrcnntools\/\")\n\nfrom config import Config\nimport utils\nimport model as modellib\nimport visualize\n\nos.chdir(\"\/kaggle\/working\/\")","0d953ad0":"# Path to trained weights file\nCOCO_WEIGHTS_PATH = os.path.join(\"<need to add to dataset>\/mask_rcnn_coco.h5\")","973662d3":"class NucleusConfig(Config):\n    \"\"\"Configuration for training on the nucleus segmentation dataset.\"\"\"\n    # Give the configuration a recognizable name\n    NAME = \"nucleus\"\n\n    # Adjust depending on your GPU memory\n    IMAGES_PER_GPU = 6\n\n    # Number of classes (including background)\n    NUM_CLASSES = 1 + 1  # Background + nucleus\n\n    # Number of training and validation steps per epoch\n    STEPS_PER_EPOCH = (657 - len(VAL_IMAGE_IDS)) \/\/ IMAGES_PER_GPU\n    VALIDATION_STEPS = max(1, len(VAL_IMAGE_IDS) \/\/ IMAGES_PER_GPU)\n\n    # Don't exclude based on confidence. Since we have two classes\n    # then 0.5 is the minimum anyway as it picks between nucleus and BG\n    DETECTION_MIN_CONFIDENCE = 0\n\n    # Backbone network architecture\n    # Supported values are: resnet50, resnet101\n    BACKBONE = \"resnet50\"\n\n    # Input image resizing\n    # Random crops of size 512x512\n    IMAGE_RESIZE_MODE = \"crop\"\n    IMAGE_MIN_DIM = 512\n    IMAGE_MAX_DIM = 512\n    IMAGE_MIN_SCALE = 2.0\n\n    # Length of square anchor side in pixels\n    RPN_ANCHOR_SCALES = (8, 16, 32, 64, 128)\n\n    # ROIs kept after non-maximum supression (training and inference)\n    POST_NMS_ROIS_TRAINING = 1000\n    POST_NMS_ROIS_INFERENCE = 2000\n\n    # Non-max suppression threshold to filter RPN proposals.\n    # You can increase this during training to generate more propsals.\n    RPN_NMS_THRESHOLD = 0.9\n\n    # How many anchors per image to use for RPN training\n    RPN_TRAIN_ANCHORS_PER_IMAGE = 64\n\n    # Image mean (RGB)\n    MEAN_PIXEL = np.array([43.53, 39.56, 48.22])\n\n    # If enabled, resizes instance masks to a smaller size to reduce\n    # memory load. Recommended when using high-resolution images.\n    USE_MINI_MASK = True\n    MINI_MASK_SHAPE = (56, 56)  # (height, width) of the mini-mask\n\n    # Number of ROIs per image to feed to classifier\/mask heads\n    # The Mask RCNN paper uses 512 but often the RPN doesn't generate\n    # enough positive proposals to fill this and keep a positive:negative\n    # ratio of 1:3. You can increase the number of proposals by adjusting\n    # the RPN NMS threshold.\n    TRAIN_ROIS_PER_IMAGE = 128\n\n    # Maximum number of ground truth instances to use in one image\n    MAX_GT_INSTANCES = 200\n\n    # Max number of final detections per image\n    DETECTION_MAX_INSTANCES = 400\n","4f04e23b":"class NucleusInferenceConfig(NucleusConfig):\n    # Set batch size to 1 to run one image at a time\n    GPU_COUNT = 1\n    IMAGES_PER_GPU = 1\n    # Don't resize imager for inferencing\n    IMAGE_RESIZE_MODE = \"pad64\"\n    # Non-max suppression threshold to filter RPN proposals.\n    # You can increase this during training to generate more propsals.\n    RPN_NMS_THRESHOLD = 0.7\n","46da18e9":"class NucleusDataset(utils.Dataset):\n\n    def load_nucleus(self, dataset_dir, subset):\n        \"\"\"Load a subset of the nuclei dataset.\n\n        dataset_dir: Root directory of the dataset\n        subset: Subset to load. Either the name of the sub-directory,\n                such as stage1_train, stage1_test, ...etc. or, one of:\n                * train: stage1_train excluding validation images\n                * val: validation images from VAL_IMAGE_IDS\n        \"\"\"\n        # Add classes. We have one class.\n        # Naming the dataset nucleus, and the class nucleus\n        self.add_class(\"nucleus\", 1, \"nucleus\")\n\n        # Which subset?\n        # \"val\": use hard-coded list above\n        # \"train\": use data from stage1_train minus the hard-coded list above\n        # else: use the data from the specified sub-directory\n        assert subset in [\"train\", \"val\", \"stage1_train\", \"test_images\", \"stage2_test\"]\n        subset_dir = \"stage1_train\" if subset in [\"train\", \"val\"] else subset\n        dataset_dir = os.path.join(dataset_dir, subset_dir)\n        if subset == \"val\":\n            image_ids = VAL_IMAGE_IDS\n        elif subset=='test_images':\n            image_ids=['f01a9742c43a69f087700a43893f713878e537bae8e44f76b957f09519601ad6',\n                        'f0a75e0322f11cead4219aa530673fe5eef67580fb6fccc254963c9fc6b58aa1',\n                        'f0c9f135c62572f3669a75b2c735e4477dc77fac85e653426ee2b3bcfbed7aaf',\n                        'f0d0ab13ff53adc3c4d57e95a5f83d80b06f2cbc0bf002b52cf7b496612e0ce4',\n                        'f113626a04125d97b27f21b45a0ce9a686d73dee7b5dbc0725d49194ba0203bd',\n                        'f20eb4592e7d3cf58d421a9c34832d33adcdcbd0e17b7bf009a013847608da27',\n                        'f26f4c2c70c38fe12e00d5a814d5116691f2ca548908126923fd76ddd665ed24',\n                        'f29fd9c52e04403cd2c7d43b6fe2479292e53b2f61969d25256d2d2aca7c6a81',\n                        'f35ab34528e3e2d2589d24cbffc0e10024dfc474a68585d0b5feb7b05aa0067f',\n                        'f43169e3d8b4f71e687945b9e72cbfdfe2e40e68842568e6a30c60d64c1378b6',\n                        'f487cc82271cf84b4414552aa8b0a9d82d902451ebe8e8bc639d4121c1672ff7',\n                        'f4b7c24baf69b8752c49d0eb5db4b7b5e1524945d48e54925bff401d5658045d',\n                        'f4c4db3df4ff0de90f44b027fc2e28c16bf7e5c75ea75b0a9762bbb7ac86e7a3',\n                        'f4faa3a409014db1865074c5f66a0255f71ae3faba03265da0b3b91f68e8a8f0',\n                        'f534b43bf37ff946a310a0f08315d76c3fb3394681cf523acef7c0682240072a',\n                        'f5effed21f671bbf4551ecebb7fe95f3be1cf09c16a60afe64d2f0b95be9d1eb',\n                        'f67e72b7fe0b1e3648ea745ffd395c80705c89b0c0c48227991fe6f5815b2a18',\n                        'f6863b83d75e5927b30e2e326405b588293283c25aaef2251b30c343296b9cb1',\n                        'f6b16c885c0b2bc0d0eb2bb2eeb0a2753ebafb5a7a91da10e89b0b0478984637',\n                        'f6cb37ebf29c225284c8415962f7287abe7007fae8fe3d8a3899b608b832d7d5',\n                        'f728de04267283f0b4daab9a840e7433b2c6034baf195fd526850439c9297687',\n                        'f73e37957c74f554be132986f38b6f1d75339f636dfe2b681a0cf3f88d2733af',\n                        'f7e5dcfc9c93183c668c5a4ab028d5faad54fb54298711f2caae0508aa978300',\n                        'f7eaaf420b5204c4a42577428b7cd897a53ef07b759ccbba3ed30a3548ca5605',\n                        'f81ca7ee25e733ff37240c34c8e3044d9937bb0166e315952ebde3f237ecb86f',\n                        'f8e74d4006dd68c1dbe68df7be905835e00d8ba4916f3b18884509a15fdc0b55',\n                        'f93ec5e683d81005ffc2a84a1c0299b2406ad14b764b824e013f7ca3a13833b5',\n                        'f952cc65376009cfad8249e53b9b2c0daaa3553e897096337d143c625c2df886',\n                        'f9ac03b0344ce8c48bc058448541f9211a1e5f4c94fdaf633dd534328d8610ab',\n                        'f9ea1a1159c33f39bbe5f18bb278d961188b40508277eab7c0b4b91219b37b5d',\n                        'fa73f24532b3667718ede7ac5c2e24ad7d3cae17b0a42ed17bbb81b15c28f4ae',\n                        'fa751ff3a6332c95cb5cb1d28563553914295e9e7d35c4b6bd267241e8a0787c',\n                        'fac507fa4d1649e8b24c195d990f1fc3ca3633d917839e1751a9d412a14ab5e3',\n                        'fadeb0ab092833f27daaeb3e24223eb090f9536b83f68cde8f49df7c544f711b',\n                        'fc22db33a2495f58f118bc182c0087e140df14ccb8dad51373e1a54381f683de',\n                        'fc345dac2205deb169bd70197f07f053bada80b61ffa69fdfb490758323ead69',\n                        'fc5452f612a0f972fe55cc677055ede662af6723b5c1615ad539b8a4bd279bdb',\n                        'fc9269fb2e651cd4a32b65ae164f79b0a2ea823e0a83508c85d7985a6bed43cf',\n                        'fd8065bcb1afdbed19e028465d5d00cd2ecadc4558de05c6fa28bea3c817aa22',\n                        'fdda64c47361b0d1a146e5b7b48dc6b7de615ea80b31f01227a3b16469589528',\n                        'fe80a2cf3c93dafad8c364fdd1646b0ba4db056cdb7bdb81474f957064812bba',\n                        'fe9adb627a6f45747c5a8223b671774791ededf9364f6544be487c540107fa4f',\n                        'fec226e45f49ab81ab71e0eaa1248ba09b56a328338dce93a43f4044eababed5',\n                        'feffce59a1a3eb0a6a05992bb7423c39c7d52865846da36d89e2a72c379e5398',\n                        'ff3407842ada5bc18be79ae453e5bdaa1b68afc842fc22fa618ac6e6599d0bb3',\n                        'ff3e512b5fb860e5855d0c05b6cf5a6bcc7792e4be1f0bdab5a00af0e18435c0']\n        else:\n            # Get image ids from directory names\n            print(dataset_dir)\n            try:\n                image_ids = next(os.walk(dataset_dir))[1]\n            except:\n                pass\n            if subset == \"train\":\n                image_ids = list(set(image_ids) - set(VAL_IMAGE_IDS))\n\n        # Add images\n        for image_id in image_ids:\n            self.add_image(\n                \"nucleus\",\n                image_id=image_id,\n                path=os.path.join(dataset_dir, image_id, \"images\/{}.png\".format(image_id)))\n\n    def load_mask(self, image_id):\n        \"\"\"Generate instance masks for an image.\n       Returns:\n        masks: A bool array of shape [height, width, instance count] with\n            one mask per instance.\n        class_ids: a 1D array of class IDs of the instance masks.\n        \"\"\"\n        info = self.image_info[image_id]\n        # Get mask directory from image path\n        mask_dir = os.path.join(os.path.dirname(os.path.dirname(info['path'])), \"masks\")\n\n        # Read mask files from .png image\n        mask = []\n        for f in next(os.walk(mask_dir))[2]:\n            if f.endswith(\".png\"):\n                m = skimage.io.imread(os.path.join(mask_dir, f)).astype(np.bool)\n                mask.append(m)\n        mask = np.stack(mask, axis=-1)\n        # Return mask, and array of class IDs of each instance. Since we have\n        # one class ID, we return an array of ones\n        return mask, np.ones([mask.shape[-1]], dtype=np.int32)\n\n    def image_reference(self, image_id):\n        \"\"\"Return the path of the image.\"\"\"\n        info = self.image_info[image_id]\n        if info[\"source\"] == \"nucleus\":\n            return info[\"id\"]\n        else:\n            super(self.__class__, self).image_reference(image_id)\n","69166ce7":"############################################################\n#  Training\n############################################################\n\ndef train(model, dataset_dir, subset):\n    \"\"\"Train the model.\"\"\"\n    # Training dataset.\n    dataset_train = NucleusDataset()\n    dataset_train.load_nucleus(dataset_dir, subset)\n    dataset_train.prepare()\n\n    # Validation dataset\n    dataset_val = NucleusDataset()\n    dataset_val.load_nucleus(dataset_dir, \"val\")\n    dataset_val.prepare()\n\n    # Image augmentation\n    # http:\/\/imgaug.readthedocs.io\/en\/latest\/source\/augmenters.html\n    augmentation = iaa.SomeOf((0, 2), [\n        iaa.Fliplr(0.5),\n        iaa.Flipud(0.5),\n        iaa.OneOf([iaa.Affine(rotate=90),\n                   iaa.Affine(rotate=180),\n                   iaa.Affine(rotate=270)]),\n        iaa.Multiply((0.8, 1.5)),\n        iaa.GaussianBlur(sigma=(0.0, 5.0))\n    ])\n\n    # *** This training schedule is an example. Update to your needs ***\n\n    # If starting from imagenet, train heads only for a bit\n    # since they have random weights\n    print(\"Train network heads\")\n    model.train(dataset_train, dataset_val,\n                learning_rate=config.LEARNING_RATE,\n                epochs=20,\n                augmentation=augmentation,\n                layers='heads')\n\n    print(\"Train all layers\")\n    model.train(dataset_train, dataset_val,\n                learning_rate=config.LEARNING_RATE,\n                epochs=40,\n                augmentation=augmentation,\n                layers='all')\n\n","e8cd997a":"############################################################\n#  RLE Encoding\n############################################################\n\ndef rle_encode(mask):\n    \"\"\"Encodes a mask in Run Length Encoding (RLE).\n    Returns a string of space-separated values.\n    \"\"\"\n    assert mask.ndim == 2, \"Mask must be of shape [Height, Width]\"\n    # Flatten it column wise\n    m = mask.T.flatten()\n    # Compute gradient. Equals 1 or -1 at transition points\n    g = np.diff(np.concatenate([[0], m, [0]]), n=1)\n    # 1-based indicies of transition points (where gradient != 0)\n    rle = np.where(g != 0)[0].reshape([-1, 2]) + 1\n    # Convert second index in each pair to lenth\n    rle[:, 1] = rle[:, 1] - rle[:, 0]\n    return \" \".join(map(str, rle.flatten()))\n\n\ndef rle_decode(rle, shape):\n    \"\"\"Decodes an RLE encoded list of space separated\n    numbers and returns a binary mask.\"\"\"\n    rle = list(map(int, rle.split()))\n    rle = np.array(rle, dtype=np.int32).reshape([-1, 2])\n    rle[:, 1] += rle[:, 0]\n    rle -= 1\n    mask = np.zeros([shape[0] * shape[1]], np.bool)\n    for s, e in rle:\n        assert 0 <= s < mask.shape[0]\n        assert 1 <= e <= mask.shape[0], \"shape: {}  s {}  e {}\".format(shape, s, e)\n        mask[s:e] = 1\n    # Reshape and transpose\n    mask = mask.reshape([shape[1], shape[0]]).T\n    return mask\n\n\ndef mask_to_rle(image_id, mask, scores):\n    \"Encodes instance masks to submission format.\"\n    assert mask.ndim == 3, \"Mask must be [H, W, count]\"\n    # If mask is empty, return line with image ID only\n    if mask.shape[-1] == 0:\n        return \"{},\".format(image_id)\n    # Remove mask overlaps\n    # Multiply each instance mask by its score order\n    # then take the maximum across the last dimension\n    order = np.argsort(scores)[::-1] + 1  # 1-based descending\n    mask = np.max(mask * np.reshape(order, [1, 1, -1]), -1)\n    # Loop over instance masks\n    lines = []\n    for o in order:\n        m = np.where(mask == o, 1, 0)\n        # Skip if empty\n        if m.sum() == 0.0:\n            continue\n        rle = rle_encode(m)\n        lines.append(\"{}, {}\".format(image_id, rle))\n    return \"\\n\".join(lines)\n\n","c6cef47a":"############################################################\n#  Detection\n############################################################\n\ndef detect(model, dataset_dir, subset):\n    \"\"\"Run detection on images in the given directory.\"\"\"\n    print(\"Running on {}\".format(dataset_dir))\n\n    # Create directory\n    if not os.path.exists(RESULTS_DIR):\n        os.makedirs(RESULTS_DIR)\n    submit_dir = \"submit_{:%Y%m%dT%H%M%S}\".format(datetime.datetime.now())\n    submit_dir = os.path.join(RESULTS_DIR, submit_dir)\n    os.makedirs(submit_dir)\n\n    # Read dataset\n    dataset = NucleusDataset()\n    dataset.load_nucleus(dataset_dir, subset)\n    dataset.prepare()\n    # Load over images\n    submission = []\n    for image_id in dataset.image_ids:\n        # Load image and run detection\n        image = dataset.load_image(image_id)\n        # Detect objects\n        r = model.detect([image], verbose=0)[0]\n        # Encode image to RLE. Returns a string of multiple lines\n        source_id = dataset.image_info[image_id][\"id\"]\n        rle = mask_to_rle(source_id, r[\"masks\"], r[\"scores\"])\n        submission.append(rle)\n        # Save image with masks\n        visualize.display_instances(\n            image, r['rois'], r['masks'], r['class_ids'],\n            dataset.class_names, r['scores'],\n            show_bbox=False, show_mask=False,\n            title=\"Predictions\")\n        plt.savefig(\"{}\/{}.png\".format(submit_dir, dataset.image_info[image_id][\"id\"]))\n\n    # Save to csv file\n    submission = \"ImageId,EncodedPixels\\n\" + \"\\n\".join(submission)\n    file_path = os.path.join(submit_dir, \"submit.csv\")\n    with open(file_path, \"w\") as f:\n        f.write(submission)\n    print(\"Saved to \", submit_dir)\n\n","1477ae9a":"############################################################\n#  Command Line\n############################################################\n\nif __name__ == '__main__':\n    import argparse\n\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(\n        description='Mask R-CNN for nuclei counting and segmentation')\n    parser.add_argument(\"command\",\n                        metavar=\"<command>\",\n                        help=\"'train' or 'detect'\")\n    parser.add_argument('--dataset', required=False,\n                        metavar=\"\/path\/to\/dataset\/\",\n                        help='Root directory of the dataset')\n    parser.add_argument('--weights', required=True,\n                        metavar=\"\/path\/to\/weights.h5\",\n                        help=\"Path to weights .h5 file or 'coco'\")\n    parser.add_argument('--logs', required=False,\n                        default=DEFAULT_LOGS_DIR,\n                        metavar=\"\/path\/to\/logs\/\",\n                        help='Logs and checkpoints directory (default=logs\/)')\n    parser.add_argument('--subset', required=False,\n                        metavar=\"Dataset sub-directory\",\n                        help=\"Subset of dataset to run prediction on\")\n    args = parser.parse_args()\n\n    # Validate arguments\n    if args.command == \"train\":\n        assert args.dataset, \"Argument --dataset is required for training\"\n    elif args.command == \"detect\":\n        assert args.subset, \"Provide --subset to run prediction on\"\n\n    print(\"Weights: \", args.weights)\n    print(\"Dataset: \", args.dataset)\n    if args.subset:\n        print(\"Subset: \", args.subset)\n    print(\"Logs: \", args.logs)\n\n    # Configurations\n    if args.command == \"train\":\n        config = NucleusConfig()\n    else:\n        config = NucleusInferenceConfig()\n    config.display()\n\n    # Create model\n    if args.command == \"train\":\n        model = modellib.MaskRCNN(mode=\"training\", config=config,\n                                  model_dir=args.logs)\n    else:\n        model = modellib.MaskRCNN(mode=\"inference\", config=config,\n                                  model_dir=args.logs)\n\n    # Select weights file to load\n    if args.weights.lower() == \"coco\":\n        weights_path = COCO_WEIGHTS_PATH\n        # Download weights file\n        if not os.path.exists(weights_path):\n            utils.download_trained_weights(weights_path)\n    elif args.weights.lower() == \"last\":\n        # Find last trained weights\n        weights_path = model.find_last()\n    elif args.weights.lower() == \"imagenet\":\n        # Start from ImageNet trained weights\n        weights_path = model.get_imagenet_weights()\n    else:\n        weights_path = args.weights\n\n    # Load weights\n    print(\"Loading weights \", weights_path)\n    if args.weights.lower() == \"coco\":\n        # Exclude the last layers because they require a matching\n        # number of classes\n        model.load_weights(weights_path, by_name=True, exclude=[\n            \"mrcnn_class_logits\", \"mrcnn_bbox_fc\",\n            \"mrcnn_bbox\", \"mrcnn_mask\"])\n    else:\n        model.load_weights(weights_path, by_name=True)\n\n    # Train or evaluate\n    if args.command == \"train\":\n        train(model, args.dataset, args.subset)\n    elif args.command == \"detect\":\n        detect(model, args.dataset, args.subset)\n    else:\n        print(\"'{}' is not recognized. \"\n              \"Use 'train' or 'detect'\".format(args.command))","8dd76b36":"# load weights\nweights_path = \"..\/input\/mrcnntools\/mask_rcnn_coco.h5\"\nmodel = modellib.MaskRCNN(mode=\"inference\", config=NucleusInferenceConfig(), model_dir='\/kaggle\/working\/logs\/')\nmodel.load_weights(weights_path, by_name=True, exclude=[\n    \"mrcnn_class_logits\", \"mrcnn_bbox_fc\",\n    \"mrcnn_bbox\", \"mrcnn_mask\"])\n\n# detect nuclei\ndetect(model, '\/kaggle\/input\/2019-fire171-asn11-image-segmentation-challenge-v2\/test_images\/', 'test_images')","4d2c5f52":"# This kernel implements a Mask R-CNN on the 2018 Data Science Challenge Data\n\nThis code is adpted from the [Matterport Github](http:\/\/) and changed to work on kaggle kernels"}}