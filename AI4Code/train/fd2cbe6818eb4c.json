{"cell_type":{"61ebc9f9":"code","8bdc66f1":"code","16a5b5fe":"code","3231fcaa":"code","375a05eb":"code","8d7d516b":"code","4f58b16d":"code","cd4ee6a4":"code","bf1fa288":"code","63832075":"code","c6a1665a":"code","0b0713c8":"code","009afd06":"code","e969a7a2":"code","42d0e341":"code","bb59fe49":"code","5d811f17":"code","6a44b761":"code","47f0d001":"code","0cba958b":"code","9557506f":"code","8f00c6e9":"markdown","ac85d026":"markdown","f249d98a":"markdown","066036f0":"markdown","469a9f1e":"markdown","603b0e48":"markdown","e76126eb":"markdown","ef36f81c":"markdown","5b8b2831":"markdown","9bfd2ef8":"markdown","4e56c4ef":"markdown"},"source":{"61ebc9f9":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","8bdc66f1":"pip install pm4py","16a5b5fe":"import pandas as pd\nfrom pm4py.objects.conversion.log import converter as log_converter\nfrom pm4py.objects.log.importer.xes import importer as xes_importer\n\n# process mining \nfrom pm4py.algo.discovery.alpha import algorithm as alpha_miner\nfrom pm4py.algo.discovery.inductive import algorithm as inductive_miner\nfrom pm4py.algo.discovery.heuristics import algorithm as heuristics_miner\nfrom pm4py.algo.discovery.dfg import algorithm as dfg_discovery\n\n# viz\nfrom pm4py.visualization.petrinet import visualizer as pn_visualizer\nfrom pm4py.visualization.process_tree import visualizer as pt_visualizer\nfrom pm4py.visualization.heuristics_net import visualizer as hn_visualizer\nfrom pm4py.visualization.dfg import visualizer as dfg_visualization\n\n# misc \nfrom pm4py.objects.conversion.process_tree import converter as pt_converter\n\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)","3231fcaa":"log = xes_importer.apply('..\/input\/process-personal-loan\/financial_log.xes')","375a05eb":"log[0]   ## Printing the first trace","8d7d516b":"log[0][0]  ## printing the first event in first trace","4f58b16d":"from pm4py.algo.filtering.log.start_activities import start_activities_filter\nfrom pm4py.algo.filtering.log.end_activities import end_activities_filter\n\nlog_start = start_activities_filter.get_start_activities(log)\nend_activities = end_activities_filter.get_end_activities(log)\nlog_start  # Printing the start activity in our log","cd4ee6a4":"end_activities  # Printing the end activity in our log","bf1fa288":"from pm4py.algo.filtering.log.variants import variants_filter\nfrom pm4py.statistics.traces.log import case_statistics\nvariants = variants_filter.get_variants(log)\nprint(f\"We have:{len(variants)} variants in our log\")","63832075":"## Let's try to understand how many cases do those variants have?\n\nvariants_count = case_statistics.get_variant_statistics(log)\nvariants_count = sorted(variants_count, key=lambda x: x['count'], reverse=True)\nvariants_count[:10] ## Printing the top 10 variants by case number","c6a1665a":"print(f\"This is very interesting! out of {len(log)} cases we have in our log, 3429 of them (i.e 26%) are in 1 variant.\\nOnly 1 variant out of {len(variants)}. And when examining the variant, it is a 3 steps one which seems for unqualified loans\")","0b0713c8":"## Let's see what activities do we have in log? including their frequencies and considering all cases(no filter)\n\nfrom pm4py.algo.filtering.log.attributes import attributes_filter\nactivities = attributes_filter.get_attribute_values(log, \"concept:name\")\nactivities","009afd06":"net, initial_marking, final_marking = alpha_miner.apply(log)\ngviz = pn_visualizer.apply(net, initial_marking, final_marking)\npn_visualizer.view(gviz)","e969a7a2":"## Adding frequency\n\nparameters = {pn_visualizer.Variants.FREQUENCY.value.Parameters.FORMAT: \"png\"}\ngviz = pn_visualizer.apply(net, initial_marking, final_marking, \n                           parameters=parameters,\n                           variant=pn_visualizer.Variants.FREQUENCY,\n                           log=log)\npn_visualizer.view(gviz)","42d0e341":"## it is difficult to see it here in notebook, so i would recommend to save it as picture - much clearer\n# pn_visualizer.save(gviz, \"alpha_miner_petri_net.png\")","bb59fe49":"tree = inductive_miner.apply_tree(log)\n\ngviz = pt_visualizer.apply(tree)\npt_visualizer.view(gviz)","5d811f17":"## In case you want to Convert the inductive miner into petri-net\n\nnet, initial_marking, final_marking = pt_converter.apply(tree, variant=pt_converter.Variants.TO_PETRI_NET)\n\ngviz = pn_visualizer.apply(net, initial_marking, final_marking)\npn_visualizer.view(gviz)","6a44b761":"heu_net = heuristics_miner.apply_heu(log, parameters={heuristics_miner.Variants.CLASSIC.value.Parameters.DEPENDENCY_THRESH: 0.5})\ngviz = hn_visualizer.apply(heu_net)\nhn_visualizer.view(gviz)","47f0d001":"## First let's take the frequency:\n\ndfg = dfg_discovery.apply(log)\n\nfrom pm4py.visualization.dfg import visualizer as dfg_visualization\ngviz = dfg_visualization.apply(dfg, log=log, variant=dfg_visualization.Variants.FREQUENCY)\ndfg_visualization.view(gviz)","0cba958b":"## Let's now take how much time it takes to travel between activities in our process\n\ndfg = dfg_discovery.apply(log, variant=dfg_discovery.Variants.PERFORMANCE)\ngviz = dfg_visualization.apply(dfg, log=log, variant=dfg_visualization.Variants.PERFORMANCE)\ndfg_visualization.view(gviz)","9557506f":"# Convert Directly-Follows Graph to a Workflow Net\n\nfrom pm4py.objects.conversion.dfg import converter as dfg_mining\nnet, im, fm = dfg_mining.apply(dfg)\ngviz = pn_visualizer.apply(net, im, fm)\npn_visualizer.view(gviz)","8f00c6e9":"With Process discovery we aim to find a suitable process model that can describe our business process and the sequence of events (traces) and activities that are performed within each trace. In addition to discovery of process model we can get statistics related such as frequency of events and time-to-execute, which help increase our understanding of the insufficiences are inherited in our process.\n\n**For references and more information please visit PM4PY page, most of the code provided below comes from PM4PY official documentation**\n\nThe data used in this tutorial are real logs obtained from https:\/\/www.win.tue.nl\/bpi\/doku.php?id=2012:challenge&redirect=1id=2012\/challenge and as it is described in their website: it is an application process for a personal loan or overdraft within a global financing organization (Dutch Financial Institute)","ac85d026":"# introduction_process_mining","f249d98a":"## 1.Alpha Miner:\n\nThe starting point for the Alpha algorithm are ordering relations (sorted by timestamp ofc) So, we do not consider the frequencies nor we consider other attributes!","066036f0":"## 2. Inductive minner\n\nAs per PM4Py documentation, The basic idea of Inductive Miner is about detecting a 'cut' in the log (e.g. sequential cut, parallel cut, concurrent cut and loop cut) and then recur on sublogs, which were found applying the cut, until a base case is found. The Directly-Follows variant avoids the recursion on the sublogs but uses the Directly Follows graph\n\n\" * \" is the loop, \"->\" is the sequence operator, \"X\" is the exclusive choice","469a9f1e":"**Process mining** is a family of techniques in the field of process management that support the analysis of business processes based on event logs. During process mining, specialized data mining algorithms are applied to event log data in order to identify trends, patterns and details contained in event logs recorded by an information system. Process mining aims to improve process efficiency and understanding of processes.\n\nIt captures the digital footprints from any number of systems throughout an organization and organizes them in a way that shows each step of the journey to complete that process, along with any deviations from the expected path.\n\nIn this tutorial I aim to show how to use an awesome open source library to perform Process mining (you don't need to wait until your org buy expensive commercial softwares)\n\nGood luck and sure get in touch if you have any question or comments","603b0e48":"Look like our process has one starting activity and multiple ends. All our 13087 cases started with \"A_submitted\" while the majority ended with either \"A_declined\" or \"W_Valideren aanvraag\"\n\n**Before applying one of the many process mining algorithms, it will be informatives if we get some statistics describing our log and process** will start by understanding how many variants we have? how many cases in each variant?\n\n*A process variant is a unique path from the very beginning to the very end of the process*","e76126eb":"In another notebook I will be performing:\n\n* Anomaly detections\n* Decision Tree (root cause analysis)\n* Other statistics such as: Dispersion ration, Cycle time and awaiting time, concurrent activities, replay fitness\n* Monte carlo simulation\n* Social network analysis","ef36f81c":"**Few activities stands out \"W_Completeren aanvraag\", \"W_Nabellen offertes\" and \"W_Nabellen incomplete dossiers\" they have a lot of actions, it could be some sort of self-loop or rework or some other reason ofc, but clearly we should do something to prevent them from becoming bottlenecks**","5b8b2831":"## 4. DFG - Direct flows graph with frequency and time between the edges","9bfd2ef8":"## 3. Heuristic Miner\n\nHeuristics Miner is an algorithm that acts on the Directly-Follows Graph. The output of the Heuristics Miner is an Heuristics Net","4e56c4ef":"# Introduction to Process mining"}}