{"cell_type":{"406f6e6d":"code","b45728e0":"code","ccc71a09":"code","60f14d2c":"code","84f74936":"code","ca1c7bd5":"code","96250835":"code","b237865b":"code","82f878d7":"code","245e63f1":"code","57f93a83":"code","6f89c2a5":"code","07acb978":"code","59ff666b":"code","55e4febc":"code","2205cd36":"code","5d3b94fd":"code","bbfeeb64":"markdown","d99fe544":"markdown"},"source":{"406f6e6d":"#!pip install pysqlite3 --upgrade","b45728e0":"# Imports and connecting to the database\nimport sqlite3\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np \nimport pylab \nimport scipy.stats as stats\nimport matplotlib\nimport matplotlib.pyplot as plt\nmatplotlib.style.use('seaborn')\n%matplotlib inline\n\nsqlite_file = '..\/input\/database.sqlite'\nconn = sqlite3.connect(sqlite_file)","ccc71a09":"# Query for a summary dataframe\nq = \"\"\"SELECT artists.reviewid,artists.artist,title,score,genre,year,best_new_music FROM artists \n                    INNER JOIN genres ON artists.reviewid=genres.reviewid \n                    INNER JOIN years on artists.reviewid=years.reviewid \n                    INNER JOIN reviews ON artists.reviewid=reviews.reviewid\"\"\"\ndf = pd.read_sql_query(q, conn)\ndf.info()","60f14d2c":"# Clean up some\ndf.dropna(axis=0,how='any',inplace=True)\ndf.reset_index(inplace=True)\ndf.drop(labels=['index'],axis=1,inplace=True)\n#df.info()\n#df.describe()\ndf.head()","84f74936":"# Count number of reviews by genre\nreviews_artist = df.groupby('artist').count().reset_index().rename(columns={'genre':'reviews'})[['artist','reviews']].set_index('artist').sort_values('reviews',ascending=False)\nreviews_genre = df.groupby('genre').count().reset_index().rename(columns={'artist':'reviews'})[['genre','reviews']].set_index('genre').sort_values('reviews',ascending=False)\nprint(reviews_genre)\ntop_genres = reviews_genre.index[:5]\n\n# Plot the data\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn')\nreviews_genre.plot(kind='bar',fontsize=14,title='Number of Reviews')\n#reviews_artist[:10].plot(kind='bar',fontsize=14)","ca1c7bd5":"# Visualize number of reviews by genre over time\ntop_genres_boolean_mask = []\nfor i in range(len(df)):\n    top_genres_boolean_mask.append(df['genre'][i] in top_genres)\nreviews_year_genre = df[(df['year']>=2000) & (df['year']<2017) & top_genres_boolean_mask].groupby(['year','genre']).count().drop(labels='reviewid',axis=1).rename(columns={'artist':'reviews'}).sort_values(['year','reviews'],ascending=False)['reviews']\nreviews_year_genre.unstack().plot(kind='line',fontsize=14,title=\"Number of Reviews\")","96250835":"# Visualize mean & std dev of scores by genre over time\ntop_genres_boolean_mask = []\nfor i in range(len(df)):\n    top_genres_boolean_mask.append(df['genre'][i] in top_genres)\ntop_genres_boolean_mask = (df['year']>=2000) & (df['year']<2017) & top_genres_boolean_mask\n\nreviews_score_mean = df[top_genres_boolean_mask].groupby(['year','genre']).mean().drop(labels='reviewid',axis=1)[['score']].sort_values(['year','score'],ascending=False)\nreviews_score_std = df[top_genres_boolean_mask].groupby(['year','genre']).std().drop(labels='reviewid',axis=1)[['score']].sort_values(['year','score'],ascending=False)\nreviews_score_mean.unstack().plot(kind='line',fontsize=14,title='Mean Scores')\nreviews_score_std.unstack().plot(kind='line',fontsize=14,title='Std Scores')","b237865b":"# Visualize frequency of best new music by genre\ntop_genres_boolean_mask = []\nfor i in range(len(df)):\n    top_genres_boolean_mask.append(df['genre'][i] in top_genres)\ntop_genres_boolean_mask = (df['year']>=2000) & (df['year']<2017) & top_genres_boolean_mask\nbnm_freq = df[top_genres_boolean_mask].groupby(['year','genre']).sum()['best_new_music']\/df.groupby('genre').count()['best_new_music']\nbnm_freq.unstack().plot(kind='line',fontsize=14,title='Best New Music Frequency')","82f878d7":"# Scatter plot of mean artist score vs best new music freq\ngrp_artist = df.groupby('artist').mean()\nsns.jointplot(\"score\", \"best_new_music\", data=grp_artist, kind=\"reg\")","245e63f1":"# Are scores normally distributed??\nstats.probplot(df['score'], dist=\"norm\", plot=pylab)\npylab.show()","57f93a83":"# Score distribution (total & by artists)\ndf['score'].hist()\ngrp_artist['score'].hist()","6f89c2a5":"# Create Dummy Variable columns for linear regression\ndf_dummies = pd.get_dummies(data=df,columns=['genre'],drop_first=True)\ndf_dummies.columns","07acb978":"# Can score be predicted from year and genre?\nimport statsmodels.api as sm\nx = df_dummies[['year','genre_experimental', 'genre_folk\/country', 'genre_global',\n       'genre_jazz', 'genre_metal', 'genre_pop\/r&b', 'genre_rap',\n       'genre_rock']]\ny = df_dummies['score']\nmodel = sm.OLS(y,x).fit()\nmodel.summary()","59ff666b":"# A slimmer model only including significant predictors\nimport statsmodels.api as sm\nx = df_dummies[['year','genre_experimental', 'genre_folk\/country', 'genre_global',\n       'genre_jazz','genre_rock']]\ny = df_dummies['score']\nmodel_2= sm.OLS(y,x).fit()\nmodel_2.summary()","55e4febc":"# Returns the average scores of a list of arists, weighted equally\n# Expand to give full artist summary\ndef score_artists(artists_list):\n    cum_score = 0\n    for artist in artists_list:\n        cum_score += df[df['artist']==artist]['score'].mean()\n    return cum_score\/len(artists_list)\n\nmy_artists = ['david bowie','prince','led zeppelin']\npop_artists = ['ariana grande','sza','justin bieber']\nprint(score_artists(my_artists),score_artists(pop_artists))","2205cd36":"# Returns a list of the top n artists in a genre by mean album score or best new music freq\n# Genres are 'electronic', 'metal', 'rock', 'rap', 'experimental', 'pop\/r&b','folk\/country', 'jazz', 'global'\n# Method is either 'best', 'score', or 'both'\ndef top_genre_artists(genre,method='both',n=5,min_albums=3,year=2000):\n    if genre not in df['genre'].unique():\n        print('Invalid genre')\n        return []\n    elif method not in ['best','score','both']:\n        print('Invalid method')\n        return []\n    print('The top '+str(n)+' artists in '+genre+' are:')\n    if method == 'score':\n        print('(Ranked by score, '+str(min_albums)+' album minimum)')\n        artist_grouped = df[(df['genre']==genre) & (df['year']>=year)].groupby('artist')\n        return artist_grouped.mean()[artist_grouped.size()>=min_albums]['score'].sort_values(ascending=False)[:n]\n    if method == 'best':\n        print('(Ranked by best new music frequency, '+str(min_albums)+' album minimum)')\n        artist_grouped = df[(df['genre']==genre) & (df['year']>=year)].groupby('artist')\n        return artist_grouped.mean()[artist_grouped.size()>=min_albums]['best_new_music'].sort_values(ascending=False)[:n]\n    if method == 'both':\n        print('(Ranked by score * best new music frequency, '+str(min_albums)+' album minimum)')\n        artist_grouped = df[(df['genre']==genre) & (df['year']>=year)].groupby('artist')\n        score = artist_grouped.mean()[artist_grouped.size()>=min_albums]['score']\n        best = artist_grouped.mean()[artist_grouped.size()>=min_albums]['best_new_music']\n        return (best*score).sort_values(ascending=False)[:n]\n\n#top_genre_artists('electronic','score')\ntop_genre_artists('rock')\n\n# THERE IS A SLIGHT PROBLEM WITH THIS METHOD BECAUSE REISSUED ALBUM REVIEWS APPEAR TWICE\n#   -> DISTORTING THE MIN ALBUM REQUIREMENT, WILL TRY TO FIND A SOLUTION\n# MULTI-GENRE REVIEWS ALSO APPEAR TWICE BUT ARE FILTERED SO NO PROBLEM","5d3b94fd":"df['year'].hist()\n# Will explore further...","bbfeeb64":"### **The regression results suggest two things about Pitchfork review scores:**\n* Over time,  reviews tend to be scored higher.  **Each year is 0.0035 higher** on average than the previous one.\n* The most favored genres in order are:\n    1. **Global [0.5278]**\n    1. **Jazz [0.4485]**\n    1. **Experimental [0.4370]**\n    1. **Folk\/Country [0.2782]**\n    1. **Rock [0.0612]**","d99fe544":"## **Pitchfork Album Review Exploration**\n_In this kernal I will perform some basic exploration of the Pitchfork dataset including:_\n* Connecting to and querying from a *sqlite* database\n* Identifying top rated genres\n* Visualizing score statistics by genre and over time\n* Using regression to identify Pitchfork's bias by towards a genre\n* Function that summarizes an artist\n* Function that gives the top artist for a genre with parameters"}}