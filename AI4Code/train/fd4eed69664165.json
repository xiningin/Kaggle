{"cell_type":{"11bded32":"code","a5cec32c":"code","54097fc2":"code","f4f8f823":"code","52ed7e18":"code","7846587f":"code","dc925ca0":"code","17cbb9d1":"code","8fb01dde":"code","abbfcfff":"code","ce9d5d64":"code","ad066cbe":"code","9f4bf35b":"code","9789f339":"code","05c1eeba":"code","a1dc38ff":"code","d0372683":"code","c770f22b":"code","df852b2d":"code","29bc0093":"code","9514d823":"code","55f7d4f7":"code","2d070bc7":"markdown","0a5b2ad8":"markdown","ae2e4fcb":"markdown","48691458":"markdown","9c9869a7":"markdown","8820549f":"markdown","7fdaba65":"markdown","498e6d84":"markdown","463cbfb2":"markdown","81042b85":"markdown","c6bf074b":"markdown","0cec164e":"markdown","ace7cdcb":"markdown","c7f86a02":"markdown","694bf99a":"markdown","740333b4":"markdown","0bb400a0":"markdown","ac374150":"markdown","7bb3988b":"markdown","39d3ae3b":"markdown","71b3ce68":"markdown","20a699ea":"markdown","b8635a09":"markdown","8d9fc689":"markdown","1bf20612":"markdown","dafe4aee":"markdown","3cf9b27b":"markdown","dc395fb0":"markdown","16bad05b":"markdown","25d18d13":"markdown","f23a2915":"markdown","8e16f54f":"markdown","4e6b3b4b":"markdown","d62146e6":"markdown","8df72025":"markdown","d1b40bad":"markdown","5fa78f79":"markdown","54bb285e":"markdown","c5a6e16c":"markdown","451b4849":"markdown","896d4041":"markdown","407a1005":"markdown","bb613bdb":"markdown","bd239817":"markdown","8aeebb31":"markdown","0e8b4f48":"markdown"},"source":{"11bded32":"# In what follows we will use igraph package. \n# Not networkx because networkx cannot plot self-loops\n\n# To install:\nnot_kaggle = 0\nif not_kaggle: # igraph is already preinstalled on kaggle, but not colab  \n  !pip install python-igraph # Pay attention: not just \"pip install igraph\" \n  !pip install cairocffi # Module required for plots \nimport igraph # On kaggle it is pre-installed , do not need to pip install \nimport numpy as np","a5cec32c":"import igraph\ng = igraph.Graph(directed=False)\ng.add_vertices(2)\ng.add_edges([[0,0],[0,1]] ) # ,[1,2],[2,0]\nmodularity1 = g.modularity([0,1])#, weights=graph.es['weight'])\nprint(\"Built-in igraph: The modularity =  {} for the partition - put  all nodes in different groups\".format(modularity1))\nprint('Calculation \"by hands\" explained in details below')\nvisual_style = {}\nvisual_style[\"margin\"] = 80\nvisual_style[\"vertex_color\"] = ['red', 'green']\nigraph.plot(g,**visual_style, bbox = [200,100])","54097fc2":"print(\"Built-in igraph: The modularity =  {} for the partition - put  all nodes in different groups\".format(modularity1))\nvisual_style = {}; visual_style[\"margin\"] = 80;  visual_style[\"vertex_color\"] = ['red', 'green']\nigraph.plot(g,**visual_style, bbox = [200,100])\n","f4f8f823":"import networkx as nx\nG = nx.Graph()\nG.add_nodes_from([0, 1])\nG.add_edges_from([(0, 1), (1,1) ] ) \nm1 = nx.algorithms.community.modularity(G, [{0}, {1}])\nprint(\"Built-in networkx: The modularity =  {} for the partition - put  all nodes in different groups\".format(m1))","52ed7e18":"# Below is simple code to calculate modularity, it is not optimized - just for better understanding of the definition\n# One may also look at networkx Python implementation - \n# nx.algorithms.community.modularity in file:  \/usr\/local\/lib\/python3.6\/dist-packages\/networkx\/algorithms\/community\/quality.py\n\ndef modularity_byhands(g,communities_membership_vector ):\n  '''\n  Modularity of graph is caculated and returned\n  # Input:\n  # g - undirected graph (igraph is supported, but easy to modify for other)\n  # communities_membership_vector -  for each node the id of its community is given\n  \n  # Pay attention on multiplier = 2 for self-loop edges contribution to adjacency matrix \n  '''\n\n  g.es['weight'] = [1,1]\n  n_nodes = g.vcount()\n\n  # Prepare symmetric  adjacency matrix,\n  # Pay attention - diagonal elements A_{uu} = 2* \"weight of  self-loop edge from u to u\" (if such exists, otherwise zero), \n  # That is somewhat unexpected, typically one do not \n  A_matrix = np.zeros( (n_nodes,n_nodes) )\n  for i in range(n_nodes): \n    for j in range(n_nodes): \n      e = g.get_eid(g.vs[i], g.vs[j], directed=False, error=False)\n      if e != -1: # Check  is there an edge \n        multiplier = 1\n        if i==j: multiplier = 2\n        if g.is_weighted():\n          A_matrix[i][j] = g.es['weight'][e]*multiplier # Multiply by 2, in case of self-loop edges \n        else:\n          A_matrix[i][j] = 1*multiplier\n      else:\n        A_matrix[i][j] = 0\n\n  vect_k_u = np.sum(A_matrix, axis = 1 ) # k_u - weighted degree of all nodes , denoted as k_u in lectures \n  normalization_2m = np.sum(A_matrix) # normalization factor denoted as 2m in lectures\n\n  modularity = 0\n  for i in range(n_nodes): \n    for j in range(n_nodes): \n      if communities_membership_vector[i] == communities_membership_vector[j]:  \n        modularity += ( A_matrix[i][j] - vect_k_u[i]*vect_k_u[j]\/ normalization_2m ) \/ normalization_2m\n\n  return modularity\n\ng = igraph.Graph(directed=False)\ng.add_vertices(2)\ng.add_edges([[0,0],[0,1]] ) # ,[1,2],[2,0]\n\n\nmodularity1 = g.modularity([0,1])#, weights=graph.es['weight'])\nprint(\"Builtin igraph: The modularity =  {} for the partition - put  all nodes in different groups\".format(modularity1))\nmodularity2 = modularity_byhands(g,[0,1]) #communities_membership_vector )\nprint(\"Our function: The modularity =  {} for the partition - put  all nodes in different groups\".format(modularity1))\n\nvisual_style = {}\nvisual_style[\"margin\"] = 80\nvisual_style[\"vertex_color\"] = ['red', 'green']\nigraph.plot(g,**visual_style, bbox = [200,100])\n","7846587f":"for i in range(10):\n  n = 100\n  m = 200\n  g = igraph.Graph.Erdos_Renyi(n,  m=m, directed=False, loops=False) # Generates a graph based on the Erdos-Renyi model.\n  # https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html\n\n  communities_membership_vector = range(g.vcount()) # all nodes in separate groups \n  modularity1 = g.modularity(communities_membership_vector)#, weights=graph.es['weight'])\n  print(\"Builtin igraph: The modularity =  {} for the partition - put nodes all in different groups\".format(modularity1))\n  modularity2 = modularity_byhands(g,communities_membership_vector) #communities_membership_vector )\n  print(\"Our function: The modularity =  {} for the partition - put nodes all in different groups\".format(modularity1))\n  if (modularity1 - modularity2) < 1e-14:\n    print('Okay. Our function gives same result as built-in')\n  else:\n    print('NOT OKAY. Out function gives different then built-in')\n    raise ValueError()","dc925ca0":"# Code below just plots the graph from the example and print the comments\n\ng = igraph.Graph()\ng.add_vertices(6)\ng.add_edges([[0,1],[1,2],[2,3], [3,0], [0,2] , [0,0],[1,1],[2,2], [3,3]  ])\ng.add_edges([  [4,4 ]  , [4,5 ], [5,5 ] ]) \n\ng.es['weight'] = [4,1,3,1,1,14,4,2,16,26,3,24]\ng.es['label'] = g.es['weight']\n\n#layout = g2.layout_circle()\nlayout = igraph.Layout([ (0, 0) , (1, 0), (1, 1), (0, 1), (1.5, 0.5), (2.5, 0.5) ])\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' , 'blue','aqua',  'red', 'green' , 'aqua',]\n#visual_style[\"vertex_label\"] = [0,1,2, 3]\nvisual_style[\"edge_label_size\"] = 30 # [2,2,2]\nvisual_style[\"margin\"] = 80\nprint('Example on phase two (aggregation) of the Louvain algorithm'); \nprint('Remark: how to read plot - weights 14,4,2,16 are weights of self-loops') ;print();\nprint('Assume that right graph  is obtained by phase two (aggregation) of the first graph ')\nprint('I.e. Green+Blue -> Green; Red+Aqua -> Aqua')\nprint('The weights 26,3,24 are obtained by following rule:')\nprint('26 = 14 + 4 + 2*4 Pay attention that weight 4 for edge between green-blue is multiplied by 2')\nprint('24 = 16 + 2 + 2*3 Pay attention that weight 3 for edge between red-aqua is multiplied by 2')\nprint('3 = 1 + 1 + 1 , when calculating weights of cross node edges - just sum up weight - no multiplication by 2 ')\n\nprint(); print();\nprint('Figure 2')\nigraph.plot(g, layout = layout, **visual_style,  bbox = (800,300))","17cbb9d1":"g2 = igraph.Graph()\ng2.add_vertices(3)\ng2.add_edges([[0,1],[1,2],[2,0], [2,2] ])\ng2.es['label'] = ['k_i - (k_i,in\/2)   ',\n  'Sigma_tot-Sigma_in-(k_i,in\/2)','k_i,in\/2','   Sigma_in'] # It is misleading to put so much unnecessary info on that graph \n\ng2.es['label'] = ['',\n  '','k_i,in\/2','   Sigma_in']\n\n#layout = g2.layout_circle()\nlayout = igraph.Layout([ (2, 0) , (3, 2), (0, 0), ])\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['red','gray','green']\nvisual_style[\"vertex_label\"] = ['i','all others','']\nvisual_style[\"edge_label_size\"] = 10 # [2,2,2]\nvisual_style[\"margin\"] = 80\n#g2.name = 'Node i - red, is joining green group'\nprint('Node i - red, is joining the green group')\nigraph.plot(g2, layout = layout, **visual_style,  bbox = (600,300))","8fb01dde":"g = igraph.Graph()\ng.add_vertices(16)\nnodes = np.array([0,1,4,5])\nfor k in [0,2,8,10]:#,2,4,6,8]:\n  for i in nodes+k:\n    for j in nodes+k:\n      if i<=j: continue \n      g.add_edge(i, j)\ng.add_edge(1, 2)\ng.add_edge(4, 8)\ng.add_edge(13, 14)\ng.add_edge(7, 11)\n\n#print(g)\nlayout = g.layout_grid( ) # reingold_tilford(root=[2])\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in g.vs]\n#visual_style[\"vertex_label\"] = range(g.vcount()) \n\nmodularity1 = g.modularity(range(g.vcount() ))# ,  weights=h.es['weight'])\nprint('Modularity of intial graph, where all nodes in separate groups', modularity1)\n\n\nigraph.plot(g, layout = layout, **visual_style, bbox = (200,200) )","abbfcfff":"h = igraph.Graph()\nh.add_vertices(4)\nh.add_edges([[0,1], [1,2],[2,3],[3,0], [0,0], [1,1], [2,2], [3,3]])\nigraph.plot(h, bbox = (400,200))","ce9d5d64":"h = igraph.Graph()\nh.add_vertices(4)\nh.add_edges([[0,1], [1,2],[2,3],[3,0], [0,0], [1,1], [2,2], [3,3]])\nh.es['weight'] = [ 1,1,1,1, 12,12,12,12]\nh.es['label'] = h.es['weight']#weights\nmodularity1 = h.modularity([0,1,2,3],  weights=h.es['weight'])\nprint('modularity', modularity1)\nvisual_style= {} ; visual_style[\"margin\"] = 40\nigraph.plot(h,**visual_style,  bbox = (400,200))","ad066cbe":"import networkx as nx\nG = nx.Graph()\nG.add_nodes_from([0, 1,2,3])\nG.add_edges_from([[0, 1],[1,2],[2,3],[3,0]])\nG.add_edge(0, 0, weight = 12)\nG.add_edge(1, 1, weight = 12)\nG.add_edge(2, 2, weight = 12)\nG.add_edge(3, 3, weight = 12)\nm1 = nx.algorithms.community.modularity(G, [{0},{1},{2},{3}])\nm1 ","9f4bf35b":"# Modularity by igraph\nj_graph = igraph.Graph()\nj_graph.add_vertices(2)\nj_graph.add_edges([[0,0], [0,1],[1,1]]) # ,[3,0], [0,0], [1,1], [2,2], [3,3]])\nvisual_style= {} ; visual_style[\"margin\"] = 40\nigraph.plot(j_graph,**visual_style,  bbox = (400,200))\n","9789f339":"# Modularity by igraph\nj_graph = igraph.Graph()\nj_graph.add_vertices(2)\nj_graph.add_edges([[0,0], [0,1],[1,1]]) # ,[3,0], [0,0], [1,1], [2,2], [3,3]])\nj_graph.es['weight'] = [ 26,2,26]# ,1, 6,6,6,6]\nj_graph.es['label'] = j_graph.es['weight']#weights\nmodularity1 = j_graph.modularity([0,1],  weights=j_graph.es['weight'])\nprint(modularity1)\nvisual_style= {} ; visual_style[\"margin\"] = 40\nigraph.plot(j_graph,**visual_style,  bbox = (400,200))\n","05c1eeba":"# Modularity by networkx\nimport networkx as nx\nG = nx.Graph()\nG.add_nodes_from([0, 1])\nG.add_edges_from([[0,0],[0, 1],[1,1]])\nG.add_edge(0, 0, weight = 26)\nG.add_edge(1, 1, weight = 26)\nG.add_edge(0, 1, weight = 2)\nm1 = nx.algorithms.community.modularity(G, [{0},{1}])\nm1","a1dc38ff":"import time \n\n########################################################################\n# Cluster by Louvain algorithm \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel\n########################################################################\nt0 = time.time()\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(louvain_partition)\n\n########################################################################\n# Cluster by optimal algorithm (applicable only for small graphs <100 nodes), it would be very slow otherwise \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_optimal_modularity\n########################################################################\nprint();\nt0 = time.time()\nv = g.community_optimal_modularity() # weights= gra.es[\"weight\"]) \nmodularity1 = g.modularity(v)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-optimal partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(v) ","d0372683":"g = igraph.Graph()\ng.add_vertices(128)\n\nnodes = np.array([0,1,4,5])\nvertical_start = 0\nfor vertical_start in range(16):# [0,16,32,48,64,80,96,112]:\n  vertical_start *= 8\n  for k in [0,2]:#,2,4,6,8]:\n    for i in nodes+k+vertical_start:\n      for j in nodes+k+vertical_start:\n        if i<=j: continue \n        g.add_edge(i, j)\n\nfor x_shift in [0,3]:\n  for y_shift in list( range(4,117,8)):\n    g.add_edge(x_shift + y_shift,x_shift + y_shift+8 )\ng.add_edge(1,2)\ng.add_edge(125,126)\n\n#print(g)\nlayout = g.layout_grid(width = 4 )# ()     ) # reingold_tilford(root=[2])\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in g.vs]\n#visual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 5\n\nmodularity1 = g.modularity(range(g.vcount() ))# ,  weights=h.es['weight'])\nprint('Modularity of intial graph, where all nodes in separate groups', modularity1)\n\nigraph.plot(g, layout = layout, **visual_style, bbox = (500,800) )","c770f22b":"h = igraph.Graph()\nn_nodes = 32\nh.add_vertices(n_nodes)\nfor i in range(n_nodes-1):\n  h.add_edge(i, i+1)\nh.add_edge(n_nodes-1, 0)\nfor i in range(n_nodes):\n  h.add_edge(i, i)\nh.es['weight'] = list(np.ones(n_nodes)) +list(12*np.ones(n_nodes)) \nh.es['label'] = h.es['weight']\n\n#layout = g.layout_grid(width = 2 )# ()     ) # reingold_tilford(root=[2])\nlayout = h.layout_circle()\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in h.vs]\nvisual_style[\"vertex_size\"] = 5\n\nmodularity1 = h.modularity(range(h.vcount() )  ,  weights=h.es['weight'])\nprint('Modularity of intial graph, where all nodes in separate groups', modularity1)\n\nigraph.plot(h, layout = layout, **visual_style, bbox = (800,500) )","df852b2d":"jbig = igraph.Graph()\nn_nodes = 16\njbig.add_vertices(n_nodes)\nfor i in range(n_nodes-1):\n  jbig.add_edge(i, i+1)\njbig.add_edge(n_nodes-1, 0)\nfor i in range(n_nodes):\n  jbig.add_edge(i, i)\njbig.es['weight'] = list(np.ones(n_nodes)) +list(26*np.ones(n_nodes)) \njbig.es['label'] = jbig.es['weight']\n\n\n#layout = g.layout_grid(width = 2 )# ()     ) # reingold_tilford(root=[2])\nlayout = jbig.layout_circle()\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in jbig.vs]\nvisual_style[\"vertex_size\"] = 5\n\nmodularity1 = jbig.modularity(range(jbig.vcount() )  ,  weights=jbig.es['weight'])\nprint('Modularity of intial graph, where all nodes in separate groups', modularity1)\n\nigraph.plot(jbig, layout = layout, **visual_style, bbox = (600,300) )","29bc0093":"import time \n\n########################################################################\n# Cluster by Louvain algorithm \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel\n########################################################################\nt0 = time.time()\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(louvain_partition)\n\n########################################################################\n# Cluster by optimal algorithm (applicable only for small graphs <100 nodes), it would be very slow otherwise \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_optimal_modularity\n########################################################################\nprint();\nt0 = time.time()\nv = g.community_optimal_modularity() # weights= gra.es[\"weight\"]) \nmodularity1 = g.modularity(v)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-optimal partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(v) ","9514d823":"g = igraph.Graph()\nn_nodes = 512\ng.add_vertices(n_nodes)\n\nnodes = np.array([0,1,4,5])\nvertical_start = 0\nfor vertical_start in range(int(n_nodes\/8)):# [0,16,32,48,64,80,96,112]:\n  vertical_start *= 8\n  for k in [0,2]:#,2,4,6,8]:\n    for i in nodes+k+vertical_start:\n      for j in nodes+k+vertical_start:\n        if i<=j: continue \n        g.add_edge(i, j)\n\nfor x_shift in [0,3]:\n  for y_shift in list( range(4,n_nodes-11,8)):\n    g.add_edge(x_shift + y_shift,x_shift + y_shift+8 )\ng.add_edge(1,2)\ng.add_edge(n_nodes-3,n_nodes-2)\n\n#print(g)\nlayout = g.layout_grid(width = 4 )# ()     ) # reingold_tilford(root=[2])\nvisual_style = {}\nvisual_style[\"vertex_color\"] = ['green' for v in g.vs]\nvisual_style[\"vertex_label\"] = range(g.vcount()) \nvisual_style[\"vertex_size\"] = 5\n\nmodularity1 = g.modularity(range(g.vcount() ))# ,  weights=h.es['weight'])\nprint('Modularity of intial graph, where all nodes in separate groups', modularity1)\n\nimport time \n\n########################################################################\n# Cluster by Louvain algorithm \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel\n########################################################################\nt0 = time.time()\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(louvain_partition)\n\nigraph.plot(g, layout = layout, **visual_style, bbox = (500,1800) )","55f7d4f7":"import time \n\n########################################################################\n# Cluster by Louvain algorithm \n# https:\/\/igraph.org\/python\/doc\/igraph.Graph-class.html#community_multilevel\n########################################################################\nt0 = time.time()\nlouvain_partition = g.community_multilevel()# weights=graph.es['weight'], return_levels=False)\nmodularity1 = g.modularity(louvain_partition)#, weights=graph.es['weight'])\nprint('Finished', time.time()-t0, 'seconds passed')\nprint(\"The modularity for igraph-Louvain partition is {}\".format(modularity1))\nprint('Pay attention this modularity is different from modularity of collapsed graph Jbig, we only check partitions are as expected')\n#print();\nprint('Partition info:')\nprint(louvain_partition)","2d070bc7":"# HW1 Part 3. Overview. Modularity and Louvain algorithm. \n\nPart 3 of HW1 is devoted to the concpet of modularity and Louvain algorithm.\n\nThe present notebook contains four parts, the first is a reminder and explanation of subtle points in the material, the next three parts are  devoted to the solution of the HW1 Part 3:\n\nThe preliminary part contains: \n\n1) Reminder on  modularity and Louvain\n\n2) Working out explicit examples of calculation of modularity and Louvain by hands. \n\n3) Explain some sublte unexpected technical points in calculations,\nwhich are related self-edges, and some unexpected multiplication by 2 in weights calculation. Pay attention you understand these detail, before you go to exercises. \n\n4) Examples how to calculate the modularity and Louvain by the igraph package (and partly by networkx)\n\nThe \"part 3.1\" contains: solution of the first exercise - what happethe explanation of the  formula for the modularity change when one node is moved from one group to another. \n\nThe \"part 3.2\" contains: solution of the second exercises-set - devoted to working out part of the Louvain on 16 node graph.\n\nThe \"part 3.3\" contains: solution of the third exercises-set - devoted to working out part of the Louvain on 128 node graph.\n\n\n\n\n\n\n\nNotebook by Alexander Chervov June 2020\n\nPS \n\nNotebook is quite big , and so it is better seen on colab or other  ide with \"Table of Contents\" option - for easy navigation between sections\n","0a5b2ad8":"## What is the modularity of Hbig (with each node in its own community)? [2 points]","ae2e4fcb":"## Check by built-in Louvain (and optimal partitioning) that they generate same partition","48691458":"## What is the weight of any self-edge in J? [2 point]\n\nAnswer: 26  = 12 + 12 + 2*1 - sum of weights in the group, where self-edges comes with factor 1, but weight of edge between distinct nodes is multiplied by 2.","9c9869a7":"## Figure 2 for exercise above","8820549f":"## Figure of graph \"J\"","7fdaba65":"### Example of modularity calculation for the simplest graph\n\nLet us consider the simplest undirected graph (see plot in the cell below) - just the two nodes: red and green connected with an edge and one additional self-loop edge from the red node to itsef. \nAnd calculate modularity for it by hands (see cell below) and compare with built-in functions in igraph and networkx ","498e6d84":"## What is the weight of any self-edge in H? [2 point]\n\nAnswer: since there are 6 edges between nodes in each group and since **we must double weights between distinct nodes** - the new weight for self-loops will be 12\n","463cbfb2":"### Modularity - brief ideas. All what you need to know, if do not want  going into technical  details \n\n(1)\nModularity - is a number for a graph and a clustering of its nodes, it says how \"good\" is your clustering. It takes values from -1 to 1 , where 1 means super-good clusters found, 0 - clustering is not better than just random, high  negative number would correspond to something like anti-clusters.\nModularity in the range 0.3-0.7 means good clusters found - that numbers people want to see in practice.\n\nFor clustering data-clouds, not graphs, one typically uses \"silhouette coefficient\" to measure clustering quality, so modularity is its kind of \"analogue\" but graph clustering. \n\n\n(2) \nThe intuition behind its caculation is the following - clusters are \"good\" \nif there are many links inside clusters and not so many between clusters. \n\n(3)\nMany graph packages have built-in functions to calculate modularity.\nFor example: \n\nnetworkx: \n\nmodularity = nx.algorithms.community.modularity(graph_instance, [{0,2,3}, {1}, {4,5}]) # Clustering is given by listing all members of clusters\n\nigraph:\n\nmodularity = graph_instance.modularity([0,1,0,0,2,2]) # Clustering is given by vector showing to what cluster i-th node belongs to.  That is different from networkx \n\n\n(4) There are algorithms which aim to produce \"good\" clustering, Louvain algo (2008) is one of them discussed here in details. More recent is Leiden (2018). Actually there many of them, but these two most popular.\n\n\nPS\n\nWhat follows below is quite long, but a kind of tecnical details,\nwhich might not be necessary to understand for practical purposes.\nIn lectures, one technical detail is not given very clearly - \nduring calculation with self-loops one should multiply its weight by 2.\nThat is somewhat unexpected. \nPlease do pay attention on it, otherwise you will spent time on same bugs as we did. It is important to understand these details if one is going to do the homeworks. \n\n\n\n","81042b85":"## What is the modularity of J (with each node in its own community)? [2 points]\n\nAs expected, the modularity of J is less than the modularity of H.","c6bf074b":"#### Calculations by hands\n\nLet us consider the simplest undirected graph (see plot in the cell above or below) - just the two nodes: red and green connected with an edge and one additional self-loop edge from the red node to itsef. The graph is \"unweighted\" which means all weights of edges equal to 1.\n\nLet us calculate the modularity for it. \n\nFirst let us consider the adjacency matrix:\n**Pay attention: here is 2  in position (1,1)** (not 1 as one would naively expect!), that is because our rule - to double weight of each self-loop edge. \nPay attention that standard adjacency matrix, both in igraph and networkx would have 1 at position (1,1). \n\n$$\nA = \\begin{pmatrix}\n0 & 1 \\\\\n1 & 2\n\\end{pmatrix}.\n$$\n\nRespectively normalization factor $2m = \\sum_{ij} A_{ij} = 4$,\n\nThe weighted degrees $k_{green} = A_{00}+A_{10} = 1 , k_{red}= A_{01}+A_{11}  = 2+1 = 3$. \n\nThe modularity is the sum of 4 summands (all pairs u,v), however two of them dissappear because of the term $\\delta(C_u,C_v)$  - the only two terms survive:\n\nu=green, v=green:  $ 1\/2m( A_{00} - k_{green}k_{green}\/2m) = 1\/4 (0 - 1\/4) = -1\/16   $\n\nu=red, v=green - does not contribute, since u,v in different groups\n\nu=green, v=red: - does not contribute, since u,v in different groups\n\nu=green, v=green:  $ 1\/2m( A_{11} - k_{green}k_{green}\/2m) = 1\/4 (2 - 3*3\/4) =  1\/4(-1\/4) = -1\/16  $\n\nSumming up we get: $ -1\/16-1\/16 = -1\/8 = -0.125 $ \nThe result exactly as igraph modularity function gives. Later we check with the networkx - gives the same. \n","0cec164e":"## What is the weight of any self-edge in Jbig? [2 point]\n\nAnswer: 26 = 2*2+12+12, edges between nodes comes with factor 2, self-loops with factor 1 ","ace7cdcb":"## Check that builtin Louvain (and optimal partitioning) will generate partition as it is expected - 4 groups. ","c7f86a02":"# Preliminary part. Modularity and Louvain algorithm - reminder and subtle points","694bf99a":"# 3.2 Louvain algorithm on a 16 node network\n\nConsider the graph \"g\" with 16 nodes plotted in the cell below. \nCurrent section contains several exercises-questions on the Louvain aglrithm for that graph. \n\nNotations are the following.\nThe first phase of modularity optimization detects each clique as a single community (giving 4 communities in all).\nAfter the community aggregation phase, the new network H will have 4 nodes.\nThe question will concern that graph H and its descendet.\n\n","740333b4":"## What is the modularity of H (with each node in its own community)? [2 points]","0bb400a0":"## Modularity - reminder","ac374150":"## What is the weight of any edge between two distinct nodes in J? [1 point]\n\nAnswer: 2  - since two nodes go from one group to another ","7bb3988b":"## What just happened? [1 point]\n\nExplain (in a few lines) why you think the algorithm behaved the way it did for the larger network (you don't need to prove anything rigorously, a rough argument will do). In other words, what might have caused modularity to be maximized with an unintuitive community grouping for the\nlarger network?\n\n\nAnswer. Well, not very clear, but less us try to say something.  First it is clear, we get nodes with high weight for self-loops, and low weight on cross-node edges - that means that such nodes are good enough clusters by themselves, but it is clear are they good enough to stop algo or not. \nHowever what seems to be reasoable - is modularity depends  on the size of the circle we get. If we get big enough circle Louvain would try to shrink in further if circle is small Louvain stops.\n\nThere is experiment below with 256 1024 ... similar graphs, for 256 we stop at the same level as 128. So we see number of final clusters grows that somewhat supports our claim. Well, it is better to do another experiment but, may be next time.... \n\n","39d3ae3b":"### Modularity - conceptual view on the definition\n\nThat is explained quite well in lectures. Please look there. In brief - comparing the real number of edges in each cluster with \"expected\" number of edges, where \"expected\" means from very very simple reasons. \n","71b3ce68":"### Louvain algo - in brief - all what you need to know, if do not want to go into technical details\n\n(1) Louvain algorithm is an algorithm to cluster nodes of graphs into some groups. It was proposed in 2008 and become extremely popular. It can process quite large graphs with reasonable speed. In 2018 new algo - Leiden has been proposed and seems to be better both in quility and speed. \n\n(2) Actually algorithm is very simple.\nBrief idea  - that one starts with each node in seperate group, than join nodes such that modularity increases , later collapse all nodes in obtained groups to get a new graph with recalculated weights. Than repeat process many times. \nIt is discussed in details later. \n\n(3) \nMany packages have its implementation.\n\nlouvain_partition = g.community_multilevel() # igraph \n\n\nPS\n\nWhat follows below is quite long, but a kind of technical details, which might not be necessary to understand for practical purposes. In lectures, one technical detail is not given very clearly - during calculation at \"phase 2\" for weight of new self-loops one should multiply weights of cross edges by 2. That is somewhat unexpected. Please do pay attention on it, otherwise you will spent time on same bugs as we did. It is important to understand these details if one is going to do the homeworks. \n","20a699ea":"### Louvain algorithm - description \n\n**Phase 1 (Modularity Optimization):** Start with each node in its own community.\nFor each node \"i\", go over all the neighbors \"j\" of \"i\". Calculate the change in modularity when \"i\" is moved from its present community to j`s community. Find the neighbor jm for which this process causes the greatest increase in modularity, and assign \"i\" to jm`s community (break ties arbitrarily). If there is no positive increase in modularity during this process, keep \"i\" in\nits original community.\n\nRepeat the above process for each node (going over nodes multiple times if required) until there is no further maximization possible (that is, each node remains in its community). This\nis the end of Phase 1. \n\n**Phase 2 (Community Aggregation)**: Once Phase 1 is done, we contract the original\ngraph G to a new graph H. Each community found in G after Phase 1 becomes a node in H. The weights of edges in between 2 nodes in H are given by the sums of the weights between the respective 2 communities in G. The weights of edges within a community in G sum up to form a self-edge of the same weight in H. \n**Pay attention** during that sum up weights of edges between distinct nodes are **multiplied by 2**, but weights of self-edges come as they are (i.e. with factor 1). (See detailed example below). This is the end of Phase 2. Phase 1 and Phase 2 together make up a single pass of the algorithm.\n\n\n**Repeat Phase 1 and Phase 2** again on H and keep proceeding this way until no further improvement is seen (you will reach a point where each node in the graph stays in its original community to maximize modularity). The final modularity value is a heuristic for the maximum modularity of the graph.\n\n-----------------------------------------------------\n\nhttps:\/\/en.wikipedia.org\/wiki\/Louvain_modularity\n\nOriginal paper \nhttps:\/\/arxiv.org\/abs\/0803.0476 Fast unfolding of communities in large networks\nVincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre\n(it is cited 11K times - increadibly great citation number):\n\n","b8635a09":"## Figure of the graph \"H\" (obtained by aggregation step from G)","8d9fc689":"## Rewriting formula for modularity. New form makes easy to see what happens when nodes change their groups.  \n\nIt is useful to make simple rewriting the modularity formula   (it is borrowed from https:\/\/en.wikipedia.org\/wiki\/Modularity_(networks)#Modularity Formula 4). \nFrom that rewritting one immediately gets the solution to the exercise below, i.e. it gives clear look on what happens when one ( or more) nodes change their group. \n\n$$\nModularity  = \\frac{1}{(2m)}\\sum_{vw} \\left[ A_{vw} - \\frac{k_v k_w}{(2m)} \\right] \\delta(c_{v}, c_{w})     = $$ \n$$  =\\sum_{i=1}^{c} (e_{ii} - a_{i}^2) \n$$\n\nWhere $e_{ii} = \\sum_{u \\in C_i, v \\in C_i} $ , $ a_{i} = \\sum_{v \\in C_i} \\frac{k_v}{2m} $, $C_i$ - the groups\/clusters, $u,v$ - nodes. So the equality above is just straight forward (use $ \\sum_{v , w } k_v k_w = (\\sum_{v } k_v)^2  $). \nDespite the rewriting above is quite simple, it is extremely useful.\n\nFirst let us observe that each term has a clear sense in the formula above: \n\n$ e_{ii} $ -  summation of  weights of \"inner\" edges in group $C_i$ (i.e. those edges having both ends in the same group $C_i$) \n\n$a_{i}$  - summation of weights of \"total\" edges of group $C_i$ (i.e. those having at least one end in $C_i$).   \n\nThus, changing notation $ e_{ii} \\to \\frac{ \\Sigma_{i,inner}}{2m} , a_{i} \\to \\frac{Sigma_{i,total}}{2m}  $ one rewrites: \n\n$$\nModularity  =\\sum_{i=1}^{c} (\\frac{ \\Sigma_{i,inner}}{2m} - (\\frac{ \\Sigma_{i,total}}{2m})^2) \n$$\n\nSuch notations are used in the exercise below and in the original paper on the Louvain algorithm. \n\nSecond: Consider the situation when there is lonely node $i$, which is joining some group $C$. How the modularity would change ? The formula consists of summation over groups, thus  we need to consider only the group C and group of solely node $i$ - the other terms in the sum would remain completely the same before join and after, and so they cancel each other ! That is the key point !\nThus we would have: \n\n$$\n\\Delta Modularity  =  (\\frac{\\Sigma_{inner  ~ C  ~ and  ~  i }}{2m} - (\\frac{\\Sigma_{ total ~  C  ~  and  ~  i}}{2m})^2) -  \n[ (\\frac{ \\Sigma_{inner~ C }}{2m} - (\\frac{ \\Sigma_{total ~ C }}{2m})^2)  +  (\\frac{ \\Sigma_{inner  ~  i }}{2m} - (\\frac{ \\Sigma_{total  ~  i } }{2m} )^2 ) ] \n$$\n\nThe first term comes from the modularity of the joined C and $i$ partition; the other terms from modularity of disjoint C and $i$ partition; all the other terms cancel each other since groups have not changed.\nNow notice that  $(\\Sigma_{inner  ~  i } = 0$ because group $i$ consits of node which assumed not to have a self-loop, so it means there is no edge from $i$ to $i$, so it is zero. The other thing to notice is that:\n$ \\Sigma_{inner  ~ C  ~ and  ~  i } = \\Sigma_{inner  ~ C} +     2*k_{i,in} $ where $k_{i,in}$ is sum weights of edges coming from node $i$ to group $C$, here factor $2$ comes from trivial reason - in definition of modularity there is summation $\\sum_{u, v}$ that means we have both pairs  ${u, v}$\nand ${v, u}$ in that summation, so each edge is summed up twice. \nThe third thing to notice is that:\n$ \\Sigma_{total  ~ C  ~ and  ~  i } = \\Sigma_{total  ~ C} +     k_{i} $ , where\n$k_i$ is the total sum of weight of edges attached to $i$, that is true more or less by defition $\\Sigma_{total} = \\sum_u k_u $ - so if one adds new node to group one adds one term to sum. \n\nAfter that remarks we arrive to: \n$$ \\Delta Modularity = \\bigg[ \\frac{\\Sigma_{inner~ C} + 2k_{i,in}}{2m} - \\bigg(\\frac{\\Sigma_{total~ C} + k_i}{2m}\\bigg)^2 \\bigg]-\\bigg[\\frac{\\Sigma_{inner~ C}}{2m} - \\bigg(\\frac{\\Sigma_{total~ C}}{2m}\\bigg)^2-\\bigg(\\frac{k_i}{2m}\\bigg)^2\\bigg] \n$$\n\nWhich is exactly the solution to exercise given below.\n","1bf20612":"## Contract H further - two adjacent nodes in first community, the other two in the second - call result graph \"J\"\nSpoiler alert: In this network, this is the maximum modularity and the algorithm will terminate here. However, assume that we wanted to contract the graph further into a two node network (call it J) by grouping two adjacent nodes in H into one community and the other two adjacent nodes into another community, and then aggregating (following the same rules of the community aggregation phase).","dafe4aee":"## What is the modularity of Jbig (with each node in its own community)? [2 points]\n\nThis particular grouping of communities corresponds to the maximum modularity in this network\n(and not the one with one clique in each community). The community grouping that maximizes the\nmodularity here corresponds to one that would not be considered intuitive based on the structure\nof the graph.","3cf9b27b":"#### check by networkx built-in - the same result -0.125","dc395fb0":"### Experiment - construct even bigger graphs with 256, 512, 1024 ... nodes, by the same pattern as \"g128\" - ring of 4-cliques. Apply Louvain and look how many groups  we get\n\nResults: \n256 - 16 groups the same as for 128  (modularity 0.901785714285714 )\n\n512 - 32 groups (modularity  0.9330357142857145)\n\n1024 - 32 groups (modularity 0.9508928571428574 )\n\n2048 - 64 groups (modularity 0.9665178571428559 )\n\n\n","16bad05b":"### Propeties of modularity \n\nProposition 1: modularity is in [-1,1] (if weights are positive). Moreover for undirected, unweighted graph it is [-1\/2 ,1 ]. \n\nProposition 2: If all nodes are in the same group, then  modularity = 0 \n\nProposition 3: If there is lonely node (i.e. not connected to any other) then joining it to any group will not change modularity ","25d18d13":"## Next step of Louvain collapse to 16 node graph\n\nAfter what we saw in the earlier example, we would expect the algorithm to terminate here.  However (spoiler alert again), that doesn't happen and the algorithm proceeds. The next phase of modularity optimization groups Hbig into 16 communities with two adjacent nodes from Hbig in  each community. Call the resultant graph (after community aggregation) Jbig.","f23a2915":"### Compare our function for modularity with built-in in igraph on random graphs - results coincide","8e16f54f":"#### Create Figure for graph","4e6b3b4b":"### Illustration for  the second phase (aggregation) of Louvain algo - pay attention on doubling of weights of non-self-loops.\n\nLet us look in details on the example presented in original article (Figure 1) (and also the lectures) for the second phase (aggregation) of the Louvain algo. \nPay attentation on the detail - the weights of non-self-edges are multiplied by 2 when aggregated to super-node. It might not be very clear from expositions above. \n\nFor the example given below we will see: \n\n26 = 14 + 4 + 2*4 Pay attention that weight 4 for edge between green-blue is multiplied by 2'\n\n24 = 16 + 2 + 2*3 Pay attention that weight 3 for edge between red-aqua is multiplied by 2\n\n3 = 1 + 1 + 1 , when calculating weights of cross node edges - just sum up weight - no multiplication by 2 \n","d62146e6":"## What is the weight of any edge between two distinct nodes in H? [1 point]\n\nAnswer: since there is only 1 edges between groups, new weight on edges between groups will be 1. ","8df72025":"# 3.3 Louvain algorithm on a 128 node network\n\nNow consider a larger version of the same network, with 32 cliques of 4 nodes each (arranged in a ring as earlier); call this network Gbig. Again, assume all the edges have same weight value 1,  and there exists exactly one edge between any two adjacent cliques. The first phase of modularity\noptimization, as expected, detects each clique as a single community. After aggregation, this forms a new network Hbig with 32 nodes.\n\n","d1b40bad":"## What is the weight of any edge between two distinct nodes in Jbig? [1 point]\n\nAnswer: 1 , since only 1 edge between groups","5fa78f79":"## Exercise ","54bb285e":"### Modularity - mathematical definition. Subtleties with self-loops.\n\nModularity for a pair: a graph and a clustering of its nodes into commnuties (groups) $C_i$ is defined by the formula:\n$$\nQ = \\frac{1}{2m} \\sum_{vw} \\left[ A_{vw} - \\frac{k_v k_w}{2m} \\right]  \\delta(C_u,C_v)           \n$$\n\nwhere  summation is going over all pairs of nodes (u,v). $\\delta(C_u,C_v)$ \nis 1 when u,v are in the same community and 0 otherwise. $A_{uv}$ adjacency matrix (see, however, subtleties below). $k_u$ is sum of weights of edges attached to $u$, i.e. $k_u = \\sum_v A_{uv}$ (for unweighted graph it is just a degree of $u$  (see, however, subtleties below) ).  $2m = \\sum_{u,v} A_{uv}$. \n\nThe definition should be seen clear. But... actually , there are certain traps hidden. They are not conceptual, but just technical.\nLet us clarify these things: \n\n**Pay attention(!) there are several subtleties in definition**:\n\n(1) If self-loops exist in the grapth they contribute  with the weight multiplied by 2 to  the adjacency matrix, i.e. $A_{uu} = 2*weight ~ of  ~ self-loop ~ from ~ u ~ to ~ u $. That multiplication by 2 is something unexpected. Actually it is just only matter of convention, but it is standard convention.\n\n(2) Respectively $k_u = \\sum_v A_{uv}$ that means weight of any self-loop is doubled here, becuase it is doubled in $A_{uu}$. For example, if graph is just one node with a self-loop, then $k_u=2$ , but not $1$ , as one would naively expect. Moreover packages like igraph and networkx would say that degree in that case equal to $2$, but snap will give $1$. \n\n(3) Adjacency matrix $A_{uv}$ for undirecrted graphs is constructed as symmetric, i.e. both $A_{vu}$ and $A_{uv}$ equal to the same $\"weight~of~edge~{uv}\"$, i.e. $A_{vu}= A_{uv}= weight~of~edge~{uv}$. (In present study we always consider only undirected graphs.)\n\n(4) Summation above contains pairs (u,v) and (v,u) and (u,u) - all of them.\nFor undirected network $A_{uv} = A_{vu}$, and so equal terms are summed-up twice. \n\n","c5a6e16c":"## Figure with 16 nodes graph \n\nCreate graph with 16 nodes from the task HW1. \n(Use igraph, since we need self-loops at latter step, and networkx **canNOT** plot self-loops by default). ","451b4849":"### Modularity of H by networkx. (Each node in its own group). Get the same result as by igraph.","896d4041":"## What is the weight of any self-edge in Hbig? [2 point]\n\nAnswer: 12, since there are 6 edges, but they counted twice, since they are between distinct nodes, only self-loops are counted with factor 2 ","407a1005":"## Louvain algorithm - reminder","bb613bdb":"### Code to calculate modularity \n\nFor the sake of better understanding let us present a code how to caclculate modularity (for undirected, but possibly weighted graphs). And check that our code gives the same results as built-in igraph function.\n","bd239817":"# 3.1 Modularity gain when an isolated node moves into a community [4 points]\n\nThere exists a simple and fast  way  to calculate modularity change for the case when one node moves from a group to another group. It is key feature of the Louvain algorirhm which makes it fast. \nThe goal of the exerices is to derive that formula. \nIt is very easy if we first slightly rewrite  the formula for modularity. \nThus we first rewrite  and then discuss the exercise itself.\n\nRemark: That exercise is somewhat mathematical technicality, one might omit it if one is looking more for the practical side. The sense of what going on should be clear without explicit formulas - modularity is defined by the huge sum over all nodes, but when one changes the group of only one node, you do not need to recalculate the huge sum - look only on those terms which are related to the group and the node  and recaculation would be much faster, moreover actually pretty nice formula exists, but you might omit it.\n","8aeebb31":"Task here  is to prove  formula below. It is immediate consequence of the consideration above. The Figure 2 mentioned here is plotted in the cell below.\n\n\n\n\nConsider a node i that is in a community all by itself. Let C represent an existing community\nin the graph. Node i feels lonely and decides to move into the community C, we will inspect the\nchange in modularity when this happens.\n\nThis situation can be modeled by a graph (Figure 2 - see below) with C being represented by a single node. C\nhas a self-edge of weight $\\Sigma_{in}$. There is an edge between i and C of weight $k_{i;in}\/2$ (to stay consistent\nwith the notation of the paper). The total degree of C is $\\Sigma_{tot}$ and the degree of i is $k_i$. As always,\n$2m = \\sum A_{ij}$ is the sum of all entries in the adjacency matrix. To begin with, C and i are in separate\ncommunities (colored green and red respectively). **Prove that** the modularity gain seen when i\nmerges with C (i.e., the change in modularity after they merge into one community) is given by\n\n$$ \\Delta Q = \\bigg[ \\frac{\\Sigma_{in} + 2k_{i,in}}{2m} - \\bigg(\\frac{\\Sigma_{tot} + k_i}{2m}\\bigg)^2 \\bigg]-\\bigg[\\frac{\\Sigma_{in}}{2m} - \\bigg(\\frac{\\Sigma_{tot}}{2m}\\bigg)^2-\\bigg(\\frac{k_i}{2m}\\bigg)^2\\bigg] \n$$\n\nHint: Using the community aggregation step of the Louvain method may make computation easier.\nIn practice, this result is used while running the Louvain algorithm (along with a similar related\nresult) to make incremental modularity computations much faster.","0e8b4f48":"## What is the weight of any edge between two distinct nodes in Hbig? [1 point]\n\nAnswer: 1 , since only 1 node between corresponding cliques "}}