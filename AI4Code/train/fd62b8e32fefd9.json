{"cell_type":{"3ab524a8":"code","98e58631":"code","d3aee8b8":"code","19fc3ef7":"code","5b0a9d7a":"code","fc2733a5":"code","d0cc8836":"code","f01b8dde":"code","c99770d6":"code","4bff7169":"code","c884db49":"code","25fa3d67":"markdown","b8f92338":"markdown","1406e78b":"markdown","12798da0":"markdown","6c4013d9":"markdown","95f93bb5":"markdown","a2a9191e":"markdown","9d3cc56d":"markdown","eb586123":"markdown","e202b4c3":"markdown","02afba1f":"markdown","06687471":"markdown","a97f68a9":"markdown","6ea9c2bd":"markdown","b3768e52":"markdown","0bc0c714":"markdown","bd91da63":"markdown"},"source":{"3ab524a8":"from IPython.display import Image\nImage(\"..\/input\/imdb-image\/Screenshot (398).png\")","98e58631":"!pip install bs4\nimport bs4\nimport requests\nimport time\nimport random as ran\nimport sys\nimport pandas as pd\n","d3aee8b8":"url = 'https:\/\/www.imdb.com\/search\/title?release_date=2018&sort=boxoffice_gross_us,desc&start=1'\n\nsource = requests.get(url).text\nsoup = bs4.BeautifulSoup(source,'html.parser')","19fc3ef7":"movie_blocks = soup.findAll('div',{'class':'lister-item-content'})\n","5b0a9d7a":"mname = movie_blocks[0].find('a').get_text() # Name of the movie\n\nm_reyear = int(movie_blocks[0].find('span',{'class': 'lister-item-year'}).contents[0][1:-1]) # Release year\n\nm_rating = float(movie_blocks[0].find('div',{'class':'inline-block ratings-imdb-rating'}).get('data-value')) #rating\n\nm_mscore = float(movie_blocks[0].find('span',{'class':'metascore favorable'}).contents[0].strip()) #meta score\n\nm_votes = int(movie_blocks[0].find('span',{'name':'nv'}).get('data-value')) # votes\n\nprint(\"Movie Name: \" + mname,\n      \"\\nRelease Year: \" + str(m_reyear),\n      \"\\nIMDb Rating: \" + str(m_rating),\n      \"\\nMeta score: \" + str(m_mscore),\n      \"\\nVotes: \" + '{:,}'.format(m_votes)\n\n)","fc2733a5":"def scrape_mblock(movie_block):\n    \n    movieb_data ={}\n  \n    try:\n        movieb_data['name'] = movie_block.find('a').get_text() # Name of the movie\n    except:\n        movieb_data['name'] = None\n\n    try:    \n        movieb_data['year'] = str(movie_block.find('span',{'class': 'lister-item-year'}).contents[0][1:-1]) # Release year\n    except:\n        movieb_data['year'] = None\n\n    try:\n        movieb_data['rating'] = float(movie_block.find('div',{'class':'inline-block ratings-imdb-rating'}).get('data-value')) #rating\n    except:\n        movieb_data['rating'] = None\n    \n    try:\n        movieb_data['m_score'] = float(movie_block.find('span',{'class':'metascore favorable'}).contents[0].strip()) #meta score\n    except:\n        movieb_data['m_score'] = None\n\n    try:\n        movieb_data['votes'] = int(movie_block.find('span',{'name':'nv'}).get('data-value')) # votes\n    except:\n        movieb_data['votes'] = None\n\n    return movieb_data\n    ","d0cc8836":"def scrape_m_page(movie_blocks):\n    \n    page_movie_data = []\n    num_blocks = len(movie_blocks)\n    \n    for block in range(num_blocks):\n        page_movie_data.append(scrape_mblock(movie_blocks[block]))\n    \n    return page_movie_data\n","f01b8dde":"def scrape_this(link,t_count):\n    \n    #from IPython.core.debugger import set_trace\n\n    base_url = link\n    target = t_count\n    \n    current_mcount_start = 0\n    current_mcount_end = 0\n    remaining_mcount = target - current_mcount_end \n    \n    new_page_number = 1\n    \n    movie_data = []\n    \n    \n    while remaining_mcount > 0:\n\n        url = base_url + str(new_page_number)\n        \n        #set_trace()\n        \n        source = requests.get(url).text\n        soup = bs4.BeautifulSoup(source,'html.parser')\n        \n        movie_blocks = soup.findAll('div',{'class':'lister-item-content'})\n        \n        movie_data.extend(scrape_m_page(movie_blocks))   \n        \n        current_mcount_start = int(soup.find(\"div\", {\"class\":\"nav\"}).find(\"div\", {\"class\": \"desc\"}).contents[1].get_text().split(\"-\")[0])\n\n        current_mcount_end = int(soup.find(\"div\", {\"class\":\"nav\"}).find(\"div\", {\"class\": \"desc\"}).contents[1].get_text().split(\"-\")[1].split(\" \")[0])\n\n        remaining_mcount = target - current_mcount_end\n        \n        print('\\r' + \"currently scraping movies from: \" + str(current_mcount_start) + \" - \"+str(current_mcount_end), \"| remaining count: \" + str(remaining_mcount), flush=True, end =\"\")\n        \n        new_page_number = current_mcount_end + 1\n        \n        time.sleep(ran.randint(0, 10))\n    \n    return movie_data","c99770d6":"base_scraping_link = \"https:\/\/www.imdb.com\/search\/title?release_date=2018-01-01,2018-12-31&sort=boxoffice_gross_us,desc&start=\"\n\ntop_movies = 150 #input(\"How many movies do you want to scrape?\")\nfilms = []\n\nmovies = scrape_this(base_scraping_link,int(top_movies))\n\nprint('\\r'+\"List of top \" + str(top_movies) +\" movies:\" + \"\\n\", end=\"\\n\")\nmovies=pd.DataFrame(movies)\nmovies","4bff7169":"movies.to_csv('movies.csv', index=False)\n","c884db49":"Image(\"..\/input\/movies-scraped\/Screenshot (399).png\")","25fa3d67":"> Let's examine one of the extracted block to identify the elements that we need to scrape.","b8f92338":"> Since above code extracts all data on the first page, below code is run only to extract movie information on it.","1406e78b":"**The below data can be worked on easily with excel or spreadsheet as shown in the picture below**","12798da0":"# Conclusion\n\nAs you can see, all you need is BeautifulSoup library and basic knowledge of python. Even though in this tutorial we are using little snippet of HTML code loaded from a local file, the routine for scraping a data from online websites is exactly the same:\n\n1. Download the HTML source code.\n2. Find under what tags is the data you want.\n3. Scrape them out of the source code.\n4. Extract the data you want from the strings.\n\nI strongly recommend you to play around with BeautifulSoup, as there is a lot more to do with it. Anyways, that's it for the introduction to python web scraping with BeautifulSoup. If you have any questions, feel free to contact me or write down a comment.","6c4013d9":"> Now we search for the for top 1000 films released in year of 2018 at imdb.com and scrape results from the first page","95f93bb5":"# Introduction to BeautifulSoup\n\n*BeautifulSoup* is a class in the BS4 library of python made for the purpose of parsing **HTML or XML** document.\n\n**How cool does that sound?**\n\nThink of any website on the internet and you want to collect only a specific detail of the subject and there are n number of categories , how long will you scroll.\nBeautifulSoup allows you to fetch that specific detail from the webpage for every category in a more structured manner.","a2a9191e":"> Then I create the below function to scrape all movie blocks within a single search result page\n","9d3cc56d":"> Finally, we have put together all functions created above to scrape the top 150 movies on the list\n\n","eb586123":"In this simple kaggle, we will illustrate how to we can use BeautifulSoup to scrape the International Movies Database (IMDB) at imdb.com for top films released in year 2018 with the highest US box office.\n\nWe will be organizing the final results as a dataframe with below elements:\n\n* name - title of the movie,\n* year - release year of the movie,\n* imdb - IMDB score of the movie,\n* m_score - meta score of the movie,\n* vote - number of votes.","e202b4c3":"# What we are trying to do?\n\nLet's say we want to fetch only the movie name , IMDB score and metascore from the IMDB website, how will we do it. Ofcourse , with the help of BeautifulSoup.\n\nSo without further ado, let's dive into it.","02afba1f":"**BeautifulSoup.find_all(arguments)** \nreturns a list of BeautifulSoup objects. These are all occurrences matching the arguments. If there are no matches, method returns empty list. This is obviously used, when you cannot identify it right away and have to do some more digging before you get to the data you want.","06687471":"# Important pointers\n\nSome websites, especially famous websites, deploy defense mechanisms to deter you from crawling\/scraping their website. Mechanisms tend to vary, but some of the most common ones are:\n1. Blocking common web scraping user agents \n2. Exceeding a connection quota \n3. Blocking you based on your behavior\n4. Captcha \u2014 Website can ask you to answer a question, which normally only human should be able to answer. The website can have this mechanism deployed when you try to access certain pages of the site.","a97f68a9":"![Alt Text](https:\/\/static.amazon.jobs\/teams\/53\/images\/IMDb_Header_Page.jpg?1501027252)","6ea9c2bd":"Stay tuned for beginner friendly notebooks!!","b3768e52":"> Once you examine the resulting pages of the imbd search that we initially did , it's obvious that by editing the html link it is possible to view all search results. Thus we will be using this feature during the scrape to iterate through all pages.\nNow since scraping the data is an iterative process, we define separate functions for each purpose.\nFirst we are going to define a function which will extract the targeted elements from a 'movie block list' (discussed above)","0bc0c714":"> Now we built functions to extract all movie data from a single page.\n\nNext function will be created to iterate the above made function through all pages of the search result untill we scrape data for the targeted number of movies","bd91da63":" **Let's import all the necessary modules**"}}