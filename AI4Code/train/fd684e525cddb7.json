{"cell_type":{"ab38bcdf":"code","564f8dde":"code","c3d8a8c2":"code","d0f1de8d":"code","d0ba2bdd":"code","efa0b7c2":"code","8207abc2":"code","fc91e421":"code","c91edd6f":"code","2e14cf94":"code","adc227fc":"code","2c0f9730":"code","46567ed1":"code","6710c6aa":"code","2893e021":"code","e090376a":"code","3d54925e":"code","ce2a1b1f":"code","fcfd38da":"code","03413b8b":"code","599780d5":"code","4f35142b":"code","904ece40":"code","a97610c4":"code","fb41add5":"code","3ca910da":"code","b27cba16":"code","090689c2":"markdown","be0fe889":"markdown","04b5f5a3":"markdown","6979972a":"markdown","d194d814":"markdown","1404c580":"markdown","0a5253d0":"markdown","e65ceefd":"markdown","9f997996":"markdown","be509b70":"markdown","936633c9":"markdown","970722aa":"markdown","71520f62":"markdown","74da61cf":"markdown","bbe7324d":"markdown","6f35d805":"markdown","24e65a37":"markdown","fd765437":"markdown","2ff36586":"markdown","6843fcc3":"markdown","c10d00a3":"markdown","ac8c6867":"markdown","3374d053":"markdown","1fbab93a":"markdown","129caaae":"markdown","b973a8b5":"markdown","f0cd0598":"markdown","44611682":"markdown","489ca349":"markdown","f13d7cad":"markdown","e0fbb3b1":"markdown","b5b6c5c2":"markdown","75d04caf":"markdown","19348db6":"markdown","2b488434":"markdown","4558cd81":"markdown"},"source":{"ab38bcdf":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input\/'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 5GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","564f8dde":"from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport csv\n\npath = \"path_to_chrome_driver\"\ndriver = webdriver.Chrome(path)\n\n# Function to scrape informations from movie\ndef scrape_movie():\n\n    try:\n        title = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.CLASS_NAME, \"title_wrapper\"))\n        )\n        movie_title = title.text\n\n        rating = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.CLASS_NAME, \"imdbRating\"))\n        )\n        movie_rating = rating.text\n\n        duration = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.XPATH, \"\/\/*[@id='title-overview-widget']\/div[1]\/div[2]\/div\/div[2]\/div[2]\/div\/time\"))\n        )\n        movie_duration = duration.text\n\n        genre = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.XPATH, \"\/\/*[@id='title-overview-widget']\/div[1]\/div[2]\/div\/div[2]\/div[2]\/div\/a[1]\"))\n        )\n        movie_genre = genre.text\n\n        summary = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.CLASS_NAME, \"summary_text\"))\n        )\n        movie_summary = summary.text\n\n        year = WebDriverWait(driver, 30).until(\n            EC.presence_of_element_located((By.ID, \"titleYear\"))\n        )\n        movie_release = year.text\n\n        credits = WebDriverWait(driver, 30).until(\n            EC.presence_of_all_elements_located((By.CLASS_NAME, \"credit_summary_item\"))\n        )\n        director = credits[0].text\n        writers = credits[1].text\n        stars = credits[2].text\n\n        keywords = WebDriverWait(driver, 30).until(\n            EC.presence_of_all_elements_located((By.CLASS_NAME, \"itemprop\"))\n        )\n        keywords_of_movie = []\n        for i in keywords:\n            keywords_of_movie.append(i.text)\n\n        movie = (movie_title,movie_rating,director,writers,stars,keywords_of_movie,movie_duration,movie_genre,movie_release,movie_summary)\n        driver.back()\n\n        return movie\n\n    except:\n        driver.quit()\n\n\ndriver.get(\"https:\/\/www.imdb.com\/search\/title\/?groups=top_1000&sort=user_rating,desc&start=0&ref_=adv_nxt\")\n\nscraped_movies = []\n\n# Start of every page is increased by 50. So, start of 1st page is 1, 2nd is 51, 3rd is 101,...\nstart_page = []\nstart_page.append(0)\nnumber = 1\nfor i in range(16):\n    number += 50\n    start_page.append(number)\n\npage = 0\nwhile page < 14:\n    for i in range(0,50): #0,50\n        try:\n            items = WebDriverWait(driver, 30).until(\n                EC.presence_of_all_elements_located((By.CLASS_NAME, \"loadlate\"))\n            )\n\n            items[i].click()\n            movie_scraped = scrape_movie()\n            scraped_movies.append(movie_scraped)\n\n        except:\n            driver.implicitly_wait(5)\n    page+=1\n    new_link = \"https:\/\/www.imdb.com\/search\/title\/?groups=top_1000&sort=user_rating,desc&start={}&ref_=adv_nxt\".format(start_page[page])\n    driver.get(new_link)\n\nwith open(\"imdb_top_800_movies_4.csv\", \"w\", newline='',encoding='utf-8') as f:\n    writer = csv.writer(f)\n    writer.writerow([\"Title\",\"Rating\",\"Director\",\"Writers\",\"Stars\",\"Keywords\",\"Movie_Duration\",\"Genre\",\"Release_Year\",\"Description\"])\n    writer.writerows(scraped_movies)","c3d8a8c2":"import pandas as pd\n\ndf = pd.read_csv('\/kaggle\/input\/imdb-top-800-moviescsv\/imdb_top_800_movies.csv', encoding='ISO-8859-1')\nprint(df.head())","d0f1de8d":"print(df.dtypes)","d0ba2bdd":"df[\"Title\"] = df[\"Title\"].apply(lambda x: x.split(\"(\")[0])\ndf[\"Director\"] = df[\"Director\"].apply(lambda x: x.split(\":\")[1])\ndf[\"Writers\"] = df[\"Writers\"].apply(lambda x: x.split(\":\")[1].split(\"|\")[0].split(\"(\")[0])\ndf[\"Stars\"] = df[\"Stars\"].apply(lambda x: x.split(\":\")[0].split(\"|\")[0])\ndf.head()","efa0b7c2":"df[\"duration\"] = df[\"Movie_Duration\"].apply(pd.Timedelta)\ndf[\"hour\"] = df[\"duration\"].apply(lambda x: str(x).split(\"days\")[1].split(\":\")[0])\ndf[\"hour\"] = pd.to_numeric(df[\"hour\"]) * 60\ndf[\"minutes\"] = df[\"duration\"].apply(lambda x: str(x).split(\"days\")[1].split(\":\")[1])\ndf[\"minutes\"] = pd.to_numeric(df[\"minutes\"])\ndf[\"Movie_Duration\"] = df[\"hour\"] + df[\"minutes\"]\ndf.drop(columns=[\"duration\",\"hour\",\"minutes\"],inplace=True)","8207abc2":"df.head(3)","fc91e421":"df[\"Num_of_ratings\"] = df[\"Rating\"].apply(lambda x: x.split(\"\\r\")[1].replace(\",\",\"\"))","c91edd6f":"df[\"Num_of_ratings\"] = pd.to_numeric(df[\"Num_of_ratings\"])","2e14cf94":"df[\"Rating\"] = df[\"Rating\"].apply(lambda x: x.split(\"\\r\")[0].split(\"\/\")[0])","adc227fc":"df[\"Rating\"] = pd.to_numeric(df[\"Rating\"])\nprint(df.dtypes)","2c0f9730":"to_convert = [\"Title\",\"Director\",\"Writers\",\"Stars\",\"Keywords\"]\ndef convert_to_lower(columns):\n    for i in columns:\n        df[i] = df[i].apply(lambda x: x.lower())\n\nconvert_to_lower(to_convert)","46567ed1":"spec_chars = [\"!\",'\"',\"#\",\"\u00e7\",\"\",\"%\",\"&\",\"'\",\"(\",\")\",\n              \"*\",\"+\",\",\",\"-\",\".\",\"\/\",\":\",\";\",\"<\",\n              \"=\",\">\",\"?\",\"@\",\"[\",\"\\\\\",\"]\",\"^\",\"_\",\n              \"`\",\"{\",\"|\",\"}\",\"~\",\"\u2013\",\",\",\"[\",\"]\",\n              \"\u00e0\",\"\u00e1\",\"\u00e2\",\"\u00e3\",\"\u00f3\", \"+\",\"\u00d9\",\"\u00db\",\n              \"\u00e4\", \"\u00a9\", \"\u00ed\", \"\u00ec\",\"\u00e7\",\"\\r\"]\n\n\nfor char in spec_chars:\n    df[\"Stars\"] = df[\"Stars\"].str.replace(char, \"\")\n    df[\"Keywords\"] = df[\"Keywords\"].str.replace(char, \"\")\n    df[\"Writers\"] = df[\"Writers\"].str.replace(char, \"\")\n    df[\"Title\"] = df[\"Title\"].str.replace(char, \"\")\n    df[\"Director\"] = df[\"Director\"].str.replace(char, \"\")","6710c6aa":"print(df.isnull().values.any())\nprint(df.isnull().sum().sum())\ndf.drop(columns=\"Description\",inplace=True)","2893e021":"df.to_csv(\"imdb_top_800_cleaned.csv\", index=False,header=True)","e090376a":"from sklearn.metrics.pairwise import cosine_similarity\nfrom sklearn.feature_extraction.text import CountVectorizer","3d54925e":"df_cleaned = pd.read_csv(\"\/kaggle\/input\/cleaned\/imdb_top_800_cleaned.csv\")\ndf_cleaned.reset_index(inplace=True)\ndf_cleaned.rename(columns={\"index\" : \"Id\"},inplace=True)","ce2a1b1f":"df_cleaned.head()","fcfd38da":"features = [\"Title\", \"Director\", \"Writers\", \"Stars\", \"Keywords\", \"Genre\"]","03413b8b":"def combine_features(features):\n    features_combined = []\n    for i in range(features.shape[0]):\n        features_combined.append(features[\"Director\"][i] + \" \" +\n                                 features[\"Writers\"][i] + \" \" +\n                                 features[\"Stars\"][i] + \" \" +\n                                 features[\"Keywords\"][i] + \" \" +\n                                 features[\"Genre\"][i].lower())\n\n    return features_combined","599780d5":"df_cleaned[\"features\"] = combine_features(df_cleaned)\ndf_cleaned.head(3)","4f35142b":"cv = CountVectorizer()\nvectorized = cv.fit_transform(df_cleaned[\"features\"])","904ece40":"cs = cosine_similarity(vectorized)\nprint(cs)\nprint(cs.shape)","a97610c4":"movie_title = \"the godfather \" # User's choice of move - can be any movie from df\n\nmovie_id = df_cleaned[df_cleaned[\"Title\"] == movie_title][\"Id\"].values[0] # finding Id of movie","fb41add5":"scores = list(enumerate(cs[movie_id]))\nsorted_scores = sorted(scores,key = lambda x: x[1], reverse=True)","3ca910da":"counter = 0\nsimilar_movies = []\nfor i in sorted_scores:\n    similar_movie = df_cleaned[df_cleaned[\"Id\"] == i[0]][\"Id\"].values[0]\n    similar_movies.append(similar_movie)\n    counter+=1\n    if(counter == 6):\n        break","b27cba16":"similar_movies_expanded = []\nfor id in similar_movies:\n    movie_to_append = df_cleaned[df_cleaned[\"Id\"] == id][[\"Title\",\"Genre\",\"Release_Year\",\"Rating\"]].values[0]\n    similar_movies_expanded.append(movie_to_append)\n    \nprint(\"Similar movies to the movie '{}' are: \"\n      \"\\n1)Title:{} | Genre:{} | Year:{} | Rating: {} \"\n      \"\\n2)Title:{} | Genre:{} | Year:{} | Rating: {}\"\n      \"\\n3)Title:{} | Genre:{} | Year:{} | Rating: {}\"\n      \"\\n4)Title:{} | Genre:{} | Year:{} | Rating: {}\"\n      \"\\n5)Title:{} | Genre:{} | Year:{} | Rating: {}\".format(movie_title,\n          similar_movies_expanded[1][0], similar_movies_expanded[1][1], similar_movies_expanded[1][2], similar_movies_expanded[1][3],\n          similar_movies_expanded[2][0], similar_movies_expanded[2][1], similar_movies_expanded[2][2], similar_movies_expanded[2][3],\n          similar_movies_expanded[3][0], similar_movies_expanded[3][1], similar_movies_expanded[3][2], similar_movies_expanded[3][3],\n          similar_movies_expanded[4][0], similar_movies_expanded[4][1], similar_movies_expanded[4][2], similar_movies_expanded[4][3],\n          similar_movies_expanded[5][0], similar_movies_expanded[5][1], similar_movies_expanded[5][2], similar_movies_expanded[5][3],\n      ))","090689c2":"# <span style=\"color:DarkCyan\">**Movie Recommendation Model**<span>","be0fe889":"Now we will access the row corresponding to this movie Id in the similarity matrix. \n\nWe will get the similarity scores of all other movies from the current movie. Then we will enumerate through all the similarity scores of that movie to make a tuple of movie index and similarity score.","04b5f5a3":"So, now we have cleaned DataFrame ready for modeling. \n\nLet's load our new DataFrame and think about features for our model.\n\nBefore that I will import new libraries for our model.","6979972a":"So, I searched Google for similar movies to \u201cGodfather\u201d and here is what I got.\n\nOutput is very similar to our model recommendations. In our DataFrame there are no movies such as Scarface and Goodfellas, so that's the reason why we didn't get those two.\n\nThere can be further improvments with many other factors such as:\n* other members with similar tastes and preferences on specific streaming service  \n* user's interaction with streaming's service (history, how user rated other titles,...) \n\nBut, for small DataFrame our model is working very good. :)\n\n\n\n","d194d814":"# <span style=\"color:DarkCyan\">**<a id='Loading-Data'>Loading Data<\/a>**<span>","1404c580":"The dataset we\u2019ll use in this project is scraped from imdb.com.\n\nMy choice of web scraper tool for this project is Selenium.\n\nI can't run the script on Kaggle. But I'll leave the script for you to see how I got the data.","0a5253d0":"For the features of the model I will use: \"Title\", \"Director\", \"Writers\", \"Stars\", \"Keywords\", \"Genre\" columns.","e65ceefd":"# <span style=\"color:DarkCyan\">**<a id='Web-Scraping'>Web Scraping<\/a>**<span>","9f997996":"**As you can see, we'll have to deal with special characters in data, data types(converting object to int\/float), creating new columns in data such as 'Number_Of_Ratings'(extract from column Rating) and change the format of 'Movie_Duration' to minutes. Because, we can't use format of '2h30min' in our model, so '2h30min' would be 150(min).**\n\n**I'll start with cleaning Title, Directors, Writers and Stars columns. Because those columns have similar format problem. They all have unnecessary brackets, dots, etc ...**","be509b70":"Recommendation Systems in the world of machine learning have become very popular and are a huge advantage to tech giants like Netflix, Amazon and many more to target their content to a specific audience. \n\nThese recommendation engines are so strong in their predictions that they can dynamically alter the state of what the user sees on their page based on the user\u2019s interaction with the app","936633c9":"*Basically, it goes to imdb top 1000 movies. Every page has 50 movies. It goes in every movie individually, scrape the data about Title, Duration, Rating, Writers, Stars, Directors, Keywords and Description. After finising 50 movies, link is automatically being changed for the next page, and same process happens again and again until the end of while loop.*\n\n**NOTE: I can't scrape data from Kaggle. I left this code here so you can see how I got the data.**","970722aa":"![](https:\/\/www.codeheroku.com\/static\/blog\/images\/pid14_find_cos_theta.png)","71520f62":"Now, we need to obtain the cosine similarity matrix from the count matrix.","74da61cf":"**I will now convert every column to lower-letter.**","bbe7324d":"# <span style=\"color:DarkCyan\">**<a id='Model'>Model<\/a>**<span>","6f35d805":"# <span style=\"color:DarkCyan\">**<a id='Introduction'>Introduction<\/a>**<span>","24e65a37":"# <span style=\"color:DarkCyan\">**<a id='Conclusion'>Conclusion<\/a>**<span>","fd765437":"**Let's extract number of ratings from column Rating and store it in new column Num_of_ratings**\n\n**Number of ratings is located in new Row in column \"Rating\", I will use lambda function with split on new row and take second element(Number of Ratings).**\n\n**After that we will remove number of ratings from column Ratings and leave just single number(rate) there.**","2ff36586":"# <span style=\"color:DarkCyan\">**<a id='Data'>Data<\/a>**<span>","6843fcc3":"![](https:\/\/www.reliancedigital.in\/wp-content\/uploads\/2019\/02\/netflix_movies_cover.jpg)","c10d00a3":"**As you can see the name of the entered movie is \"Godfather\" and the two most similar movies to Godfather are Godfather Part 3 and Godfather Part 2. That makes sense because the movie is from the same director, similar actors, same genre and very similar keywords.**","ac8c6867":"Our next task is to create a function for combining the values of these columns into a single string.","3374d053":"Our work is basically done. Now, let's just take Id of 5 most similar movies from our sorted_scores. Remember, first movie is the movie of user's choice, so we will take 6 movies and ignore first one.","1fbab93a":"**I've noticed that most columns have special characters such as \"@#$\/_-+,...\", so I will remove those by creating list with all special characters. I will loop through list and replace special characters from DataFrame with blank.**","129caaae":"**Now let's save our new cleaned DataFrame to new csv.**","b973a8b5":"Now, we have Id's of similar movies. Let's just take more informations about those movies from our DataFrame and print it to user.","f0cd0598":"Now that we have obtained the combined strings, we can now feed these strings to a CountVectorizer() object for getting the count matrix.","44611682":"# <span style=\"color:DarkCyan\">**Content**<span>\n- [Introduction](#Introduction) <a href = '#Introduction'><\/a>\n- [Web Scraping](#Web-Scraping) <a href = '#Web-Scraping'><\/a>   \n- [Data](#Data) <a href = '#Data'><\/a>\n- [Loading Data](#Loading-Data) <a href = '#Loading-Data'><\/a>\n- [Model](#Model) <a href = '#Model'><\/a>\n- [Features](#Features) <a href = '#Features'><\/a>\n- [Conclusion](#Conclusion) <a href = '#Conclusion'><\/a>","489ca349":"### Data contains columns such as: \n* Title\n* Rating\n* Director\n* Writers\n* Stars\n* Keywords\n* Movie duration\n* Genre\n* Release Year\n* Description\n\n**For now the data is raw. We will focus on data cleansing first.**","f13d7cad":"Now let's take user's choice of movie and find it's Id.","e0fbb3b1":"These two texts(1-London Paris London, 2-Paris London Paris) are represented as vectors. So, we can say that two vectors are similar if the distance between them is small. By distance, we mean the angular distance between two vectors, which is represented by \u03b8 (theta). By thinking further from the machine learning perspective, we can understand that the value of cos \u03b8 makes more sense to us rather than the value of \u03b8 (theta) because, the cosine(or \u201ccos\u201d) function will map the value of \u03b8 in the first quadrant between 0 to 1.\n\nI will use the same principle for my model. I will turn my features to numbers with CountVectorizer and measure the distance between vectors.","b5b6c5c2":"# <span style=\"color:DarkCyan\">**<a id='Features'>Features<\/a>**<span>","75d04caf":"**Let's check for NaN Values now**\n\nI also decided to drop \"Description\" column, because I will not use it for features.","19348db6":"**Now we will change column \"Movie_Duration\" format to minutes.(example: 1h30min would be just 90)**","2b488434":"Loading cleaned DataFrame","4558cd81":"![Screen%20Shot%202020-10-22%20at%2011.49.59%20PM.png](attachment:Screen%20Shot%202020-10-22%20at%2011.49.59%20PM.png)"}}