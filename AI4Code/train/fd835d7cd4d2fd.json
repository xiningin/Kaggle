{"cell_type":{"90d07c52":"code","c84d758a":"code","c29242d8":"code","631acc83":"code","9cc79a30":"code","6769fdda":"code","51cd2af8":"code","292f00dc":"code","fdd53fe0":"code","b0a018ef":"code","a122d391":"code","08133db8":"code","02d3cf86":"markdown","bf7ee6d8":"markdown","7bb1a877":"markdown","9e2fb233":"markdown","08e90229":"markdown","ea90c5b1":"markdown","6934e641":"markdown","f1e774da":"markdown","9e18e057":"markdown","54debd85":"markdown","4da17946":"markdown","4eb9b7d8":"markdown","e61a2062":"markdown"},"source":{"90d07c52":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","c84d758a":"df_cities = pd.read_csv('..\/input\/tsp-citiesds\/cities.csv')\ndf_cities.head(10)","c29242d8":"def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)] # Start assuming all numbers are primes\n    primes[0] = False # 0 is not a prime\n    primes[1] = False # 1 is not a prime\n    for i in range(2,int(np.sqrt(n)) + 1):\n        if primes[i]:\n            k = 2\n            while i*k <= n:\n                primes[i*k] = False\n                k += 1\n    return(primes)\nprime_cities = sieve_of_eratosthenes(max(df_cities.CityId))\n\ndef total_distance(dfcity,path):\n    prev_city = path[0]\n    total_distance = 0\n    step_num = 1\n    for city_num in path[1:]:\n        next_city = city_num\n        total_distance = total_distance + \\\n            np.sqrt(pow((dfcity.X[city_num] - dfcity.X[prev_city]),2) + pow((dfcity.Y[city_num] - dfcity.Y[prev_city]),2)) * \\\n            (1+ 0.1*((step_num % 10 == 0)*int(not(prime_cities[prev_city]))))\n        prev_city = next_city\n        step_num = step_num + 1\n    return total_distance\n\ndumbest_path = list(df_cities.CityId[:].append(pd.Series([0])))\nprint('Total distance with the dumbest path is '+ \"{:,}\".format(total_distance(df_cities,dumbest_path)))\n","631acc83":"df_path = pd.merge_ordered(pd.DataFrame({'CityId':dumbest_path}),df_cities,on=['CityId'])\nfig, ax = plt.subplots(figsize=(10,10))\nax.plot(df_path.iloc[0:50,]['X'], df_path.iloc[0:50,]['Y'],marker = 'o')\nfor i, txt in enumerate(df_path.iloc[0:50,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:50,]['X'][i], df_path.iloc[0:50,]['Y'][i]),size = 25)","9cc79a30":"sorted_cities = list(df_cities.iloc[1:,].sort_values(['X','Y'])['CityId'])\nsorted_cities = [0] + sorted_cities + [0]\nprint('Total distance with the sorted city path is '+ \"{:,}\".format(total_distance(df_cities,sorted_cities)))","6769fdda":"df_path = pd.DataFrame({'CityId':sorted_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(15,15))\nax.set_xlim(0,10)\nax.plot(df_path.iloc[0:50,]['X'], df_path.iloc[0:50,]['Y'],marker = 'o')\nfor i, txt in enumerate(df_path.iloc[0:50,]['CityId']):\n    ax.annotate(txt, (df_path.iloc[0:50,]['X'][i], df_path.iloc[0:50,]['Y'][i]),size = 15)","51cd2af8":"df_cities['Ycuts'] = pd.cut(df_cities.Y,300)\ndf_cities['Xcuts'] = pd.cut(df_cities.X,300)\ngrid_sorted_cities = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\ngrid_sorted_cities =  [0] + grid_sorted_cities + [0]\nprint('Total distance with the sorted cities with a grid path is '+ \"{:,}\".format(total_distance(df_cities,grid_sorted_cities)))","292f00dc":"df_path = pd.DataFrame({'CityId':grid_sorted_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(15,15))\nax.plot(df_path.iloc[0:150,]['X'], df_path.iloc[0:150,]['Y'],marker = 'o')","fdd53fe0":"zigzag_sorted_cities1 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\nzigzag_sorted_cities2 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'], ascending = [True,False,True,True])['CityId'])\nchooser_pattern = list(df_cities.iloc[1:].sort_values(['Xcuts']).groupby(['Xcuts']).ngroup()%2)\n\nzigzag_cities = [zigzag_sorted_cities1[i] if chooser_pattern[i] == 0 else zigzag_sorted_cities2[i] for i in range(len(chooser_pattern))]\nzigzag_cities =  [0] + zigzag_cities + [0]\nprint('Total distance with the Zig-Zag with grid city path is '+ \"{:,}\".format(total_distance(df_cities,zigzag_cities)))","b0a018ef":"df_path = pd.DataFrame({'CityId':zigzag_cities}).merge(df_cities,how = 'left')\nfig, ax = plt.subplots(figsize=(20,20))\nax.plot(df_path.iloc[0:1000,]['X'], df_path.iloc[0:1000,]['Y'],marker = 'o')","a122d391":"for i in range(100,800,100):\n    for j in range(100,800,100):\n        df_cities['Ycuts'] = pd.cut(df_cities.Y,j)\n        df_cities['Xcuts'] = pd.cut(df_cities.X,i)\n        zigzag_sorted_cities1 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'])['CityId'])\n        zigzag_sorted_cities2 = list(df_cities.iloc[1:].sort_values(['Xcuts','Ycuts','X','Y'], ascending = [True,False,True,True])['CityId'])\n        chooser_pattern = list(df_cities.iloc[1:].sort_values(['Xcuts']).groupby(['Xcuts']).ngroup()%2)\n\n        zigzag_cities = [zigzag_sorted_cities1[i] if chooser_pattern[i] == 0 else zigzag_sorted_cities2[i] for i in range(len(chooser_pattern))]\n        zigzag_cities =  [0] + zigzag_cities + [0]\n        print('Total distance with the Zig-Zag with grid city path with grid size (' + str(i) + ',' + str(j) + \") is {:,}\".format(total_distance(df_cities,zigzag_cities)))","08133db8":"%time\n# Function from XYZT's Kernel on the same topic. \ndef nearest_neighbour():\n    cities = pd.read_csv(\"..\/input\/tsp-citiesds\/cities.csv\")\n    ids = cities.CityId.values[1:]\n    xy = np.array([cities.X.values, cities.Y.values]).T[1:]\n    path = [0,]\n    while len(ids) > 0:\n        last_x, last_y = cities.X[path[-1]], cities.Y[path[-1]]\n        dist = ((xy - np.array([last_x, last_y]))**2).sum(-1)\n        nearest_index = dist.argmin()\n        path.append(ids[nearest_index])\n        ids = np.delete(ids, nearest_index, axis=0)\n        xy = np.delete(xy, nearest_index, axis=0)\n    path.append(0)\n    return path\n\nnnpath = nearest_neighbour()\nprint('Total distance with the Nearest Neighbor path '+  \"is {:,}\".format(total_distance(df_cities,nnpath)))","02d3cf86":"# 1.Simplest Path: Go in the order of CityIDs: 0, 1, 2.. etc. and come back to zero when you reach the end.","bf7ee6d8":"We  randomly chose the grid size of 300x300 grid size. Next let us see if the grid size makes a difference","7bb1a877":"# 4. Grid of Squares + Zig Zag Scanning","9e2fb233":"Let's draw the the previous path to see the change ","08e90229":"Let's draw the the previous path to see the change ","ea90c5b1":"Let's draw the the previous path to see the change ","6934e641":"#  The (CityId = 0) indicates the North Pole and All we have to a do a is a find a path that goes from the (CityId = 0), touches all the other dots, and comes back to the (CityId = 0), with minimum total distance travelled by the follwing 6 Methods :\n","f1e774da":"# 6. Nearest Neighbor Algorithm:","9e18e057":"# 5. Optimizing for grid-size:","54debd85":"Let's draw the first 50 steps (as a sample) of the previous path","4da17946":"# 3. Sorted cities within a grid of squares","4eb9b7d8":"# 2.Another better path: sort the cities in X,Y coordinate order","e61a2062":"# Load and Read the file and look at the data."}}