{"cell_type":{"f3c4fbe2":"code","2974f64e":"code","e0146c81":"code","71d3bc46":"code","89c8e79f":"code","7c21a53b":"code","f4cec636":"code","9c855908":"code","90439faf":"code","39b17e37":"code","e1b62888":"code","2bcc2334":"code","b90deab3":"code","d31f3857":"code","bc42f0b7":"code","96a7d02a":"code","d0500466":"code","c2b887f4":"code","053f5e9b":"code","48391475":"code","e84201d2":"code","2c972b4b":"code","73e7cec8":"code","eb422eea":"code","55a94cca":"code","21799b6d":"code","8bc4c0ce":"code","d4d87ee8":"code","abef2ba5":"code","e9361a4d":"code","966940b8":"code","75616c67":"code","8a58950a":"code","920c25fb":"code","a8bc06e2":"code","d4123034":"code","79064e11":"code","b4ba7fc4":"code","d0583c49":"code","7e71c312":"code","1887159e":"code","3f6162a2":"code","5c179da9":"code","f19bcfdf":"markdown","c7450ea6":"markdown","b5f51cd8":"markdown","dd1c5666":"markdown","347afdaf":"markdown","5e8d58e8":"markdown","a5f7d4f9":"markdown"},"source":{"f3c4fbe2":"import tensorflow as tf\nimport numpy as np\n\ntf.debugging.set_log_device_placement(True)","2974f64e":"#tf.executing_eagerly()\nprint(tf.executing_eagerly()) # True\nprint(tf.__version__) ","e0146c81":"x0 = tf.constant(3) # tf.Tensor has no shape attribute\n\nx0","71d3bc46":"print(x0)  # Tensor(\"Const:0\", shape=(), dtype=int32)","89c8e79f":"x0.shape ","7c21a53b":"#Scalar Tensors - Are tensors containing a single value and no axes (0-dimension)\nx0.dtype    # x0 holds a scalar value","f4cec636":"x0.numpy() # Scalar 3","9c855908":"result0 = x0 + 5 # tf.Tensor add operation (3+5)\n\nresult0","90439faf":"#Constants are immutable tensors, while variables are mutable tensors\nx1 = tf.constant([1.1, 2.2, 3.3, 4.4]) # 1-Dimensional Array Tensor = vector\n\nx1","39b17e37":"#Broadcasted addition of x1 and 5 - added to every element of x1\nresult1 = x1 + 5 # tf.Tensor([6.1, 7.2, 8.3, 9.4], shape=(4,), dtype=float32)\n\nresult1","e1b62888":"#Addition of x1 and x2 both are 1-Dimensional Array Tensors\nresult1 = x1 + tf.constant(5.0) # tf.Tensor([6.1, 7.2, 8.3, 9.4], shape=(4,), dtype=float32)\n\nresult1","2bcc2334":"#Tensors are immutable - cannot be changed. Addition of x1 and x2 results in a new Tensor\nresult1 = tf.add(x1, tf.constant(5.0)) # tf.Tensor([6.1, 7.2, 8.3, 9.4], shape=(4,), dtype=float32)\n\nresult1","b90deab3":"#instantiate a 2-Dimensional Array Tensor 2 rows and 4 columns containing integers\nx2 = tf.constant([[1, 2, 3, 4], [5, 6, 7, 8]]) # tf.Tensor([[1, 2, 3, 4], [5, 6, 7, 8]], shape=(2, 4), dtype=int32)\n\nx2","d31f3857":"#Changing the type of x2 to float32 using tf.cast, now containing floats instead of integers\nx2 = tf.cast(x2, tf.float32) # tf.Tensor([[1., 2., 3., 4.], [5., 6., 7., 8.]], shape=(2, 4), dtype=float32)\n\nx2","bc42f0b7":"result3 = tf.multiply(x1, x2) # tf.Tensor([[  1.1,   4.4,   9.9,  16.4], [ 25.,  36.,  49.,  64.]], shape=(2, 4), dtype=float32)\n\nresult3","96a7d02a":"#x1 is a Tensor shape=(4,), dtype=float32\nx1","d0500466":"#arr_x1 has been converted into numpy array type of shape=(4,)\narr_x1 = x1.numpy() # np.array([1.1, 2.2, 3.3, 4.4])\n\narr_x1","c2b887f4":"arr_x4 = np.array([[10, 20], [30, 40], [50, 60]]) # np.array([[10, 20], [30, 40], [50, 60]])\n\narr_x4","053f5e9b":"#Converting numpy array to back to type Tensor\nx4 = tf.convert_to_tensor(arr_x4) # tf.Tensor([[10, 20], [30, 40], [50, 60]], shape=(3, 2), dtype=int32) \n\nx4","48391475":"#numpy operations are not recommended in TensorFlow not part of the Tensorflow computation graph\n#and this can cause problems when you set up your computation graph to train your neural networks.\nnp.square(x2) # np.array([[ 1.,  4.,  9., 16.], [25., 36., 49., 64.]])","e84201d2":"np.sqrt(x2) # np.array([[ 1.        ,  1.41421356,  1.73205081,  2.        ], [2.23606798,  2.44948974,  2.64575131,  2.82842712]])","2c972b4b":"#Checking if arr_x4 is a tensor or not using is instance\ntf.is_tensor(arr_x4) # False","73e7cec8":"#x4 is a Tensor shape=(3, 2), dtype=int32\ntf.is_tensor(x4) # True","eb422eea":"#Instantiate a tensor filled with zeros of shape=(3 rows, 5 cols)\nt0 = tf.zeros([3, 5], tf.int32) # tf.Tensor([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], shape=(3, 5), dtype=int32)\n\nt0","55a94cca":"#Instantiate a tensor filled with ones of shape=(2 rows, 3 cols)\nt1 = tf.ones([2, 3], tf.int32)  # tf.Tensor([[1, 1, 1], [1, 1, 1]], shape=(2, 3), dtype=int32)\n\nt1","21799b6d":"#Reshape works only when the number of elements in your original tensor matches the number of elements in your reshape tensor.\nt0_reshaped = tf.reshape(t0, (5, 3)) # tf.Tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], shape=(5, 3), dtype=int32)\n\nt0_reshaped","8bc4c0ce":"#Variables is a mutable container holding tensors that can be updated by the optimizer.\nv1 = tf.Variable([[1.5, 2, 5], [2, 6, 8]]) # tf.Variable([[1.5, 2, 5], [2, 6, 8]], dtype=float32, trainable=True)\n\nv1","d4d87ee8":"v2 = tf.Variable([[1, 2, 3], [4, 5, 6]]) # tf.Variable([[1, 2, 3], [4, 5, 6]], dtype=int32, trainable=True)\n\nv2","abef2ba5":"#You can explicitly choose to specify a data type when you instantiate your tf variables. Here dtype is equal to float32, and you can see that in the result as well\nv2 = tf.Variable([[1, 2, 3], [4, 5, 6]], dtype=tf.float32) # tf.Variable([[1, 2, 3], [4, 5, 6]], dtype=float32, trainable=True)\n\nv2","e9361a4d":"tf.add(v1, v2) # tf.Tensor([[ 2.5,  4.,  8.], [ 6., 10., 12.]], shape=(2, 3), dtype=float32)","966940b8":"\ntf.convert_to_tensor(v1) # tf.Tensor([[1.5, 2, 5], [2, 6, 8]], shape=(2, 3), dtype=float32)","75616c67":"v1.numpy() # [[1.5, 2, 5], [2, 6, 8]]","8a58950a":"#Assign method will assign elements to the tensor underlying this variable.\nv1 = tf.Variable([[1.5, 2, 5], [2, 6, 8]]) # tf.Variable([[1.5, 2, 5], [2, 6, 8]], dtype=float32, trainable=True)","920c25fb":"v1.assign([[10, 20, 30], [40, 50, 60]]) # tf.Variable([[10, 20, 30], [40, 50, 60]], dtype=float32, trainable=True)\n\nv1","a8bc06e2":"\nv1[0, 0].assign(100) # tf.Variable([[100, 20, 30], [40, 50, 60]], dtype=float32, trainable=True)\n\nv1","d4123034":"v1.assign_add([[1, 1, 1], [1, 1, 1]])   # tf.Variable([[101, 21, 31], [41, 51, 61]], dtype=float32, trainable=True)\n\nv1","79064e11":"v1.assign_sub([[2, 2, 2], [2, 2, 2]])  # tf.Variable([[99., 19., 29.], [39., 49., 59.]], dtype=float32, trainable=True)\n\nv1","b4ba7fc4":"var_a = tf.Variable([2.0, 3.0]) # tf.Variable([2.0, 3.0], dtype=float32, trainable=True)\n\nvar_a","d0583c49":"#we can instantiate another variable, var_b, using var_a. The tensor associated with var_a will be duplicated, and a new copy will be assigned to var_b\nvar_b = tf.Variable(var_a) # tf.Variable([2., 3.], dtype=float32, trainable=True)\n\nvar_b","7e71c312":"#We may perform an operation to mutate the tensor associated with var_b. Using var_b.assign, the tensor backing var_b now has the value 200, 300   \nvar_b.assign([200, 300]) # tf.Variable([200., 300.], dtype=float32, trainable=True)\n\nvar_b","1887159e":"#Value of var_a is unchanged and remains 2.0, 3.0 while var_b is now 200, 300\nvar_a # tf.Variable([2.0, 3.0], dtype=float32, trainable=True)","3f6162a2":"#Variables are not trainable by default and do not share the same memory space. \nprint(var_a.numpy()) # [2. 0.]\nprint(var_b.numpy()) # [200. 300.]","5c179da9":"#End of Code","f19bcfdf":"### Tensor creation methods","c7450ea6":"### Operations on Variables result in a Tensor\n\nAll operations that you perform on a tensor can be perfomed on variables. These operations are actually performed on the backing tensor","b5f51cd8":"### Variables\n\nA TensorFlow variable is the recommended way to represent shared, persistent state your program manipulates. \n\nVariables are created and tracked via the tf.Variable class. A tf.Variable represents a tensor whose value can be changed by running ops on it. Specific ops allow you to read and modify the values of this tensor. Higher level libraries like tf.keras use tf.Variable to store model parameters.\n\nA variable looks and acts like a tensor, and, in fact, is a data structure backed by a tf.Tensor. Like tensors, they have a dtype and a shape, and can be exported to NumPy.","dd1c5666":"### Constant tensors","347afdaf":"### Convert from Tensors to NumPy arrays and back","5e8d58e8":"### Creating variables duplicates the backing Tensors\n\nTwo variables will not share the same memory.","a5f7d4f9":"### Assigning Tensors to Variables"}}