{"cell_type":{"d2ffc928":"code","19332877":"code","35c6c476":"code","44533522":"code","9b7cb6d6":"code","41236867":"code","921bc675":"code","944a17e1":"code","7be94bc0":"code","d9fd1eb1":"code","d73e83d7":"code","9bcf61f2":"code","9c0664cd":"code","4f942f2f":"code","edaf8f97":"code","29e41ecf":"code","6fdfcd04":"code","6450d52b":"code","5dbec5b8":"code","f017af74":"code","c8f9aea8":"code","f1d9cf81":"code","11f72500":"code","ae7276db":"code","45e6c60a":"code","aae28457":"code","3d730bf4":"code","f02a0e62":"code","fcde03a2":"code","294a3182":"code","15224374":"markdown","18a37676":"markdown","39311182":"markdown","ec0200ff":"markdown","6d407f20":"markdown","391baccb":"markdown","0750b6db":"markdown","ba018077":"markdown","b056bcf9":"markdown","0c86453f":"markdown","ebcd4eca":"markdown","55364a17":"markdown","08ec5e0a":"markdown","9eb73653":"markdown","28100538":"markdown","a0ac62af":"markdown","81e3c2c4":"markdown","1ee6fcf9":"markdown","8a6e89d2":"markdown","3b762816":"markdown","4eec0d0f":"markdown"},"source":{"d2ffc928":"import numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nimport keras\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D\n\nimport os\nimport cv2\nfrom sklearn import preprocessing\nfrom pathlib import Path\nfrom PIL import Image","19332877":"symbols_list = ['zero','one','two','three','four','five','six','seven','eight','nine','minus','plus','equal','div','decimal','times']","35c6c476":"dataset_path = \"..\/input\/handwritten-math-symbol-dataset\/train\"\ntrain_image = []\ntrain_label = []\n\nfor symbols_dir in os.listdir(dataset_path):\n    if symbols_dir.split()[0] in symbols_list:\n        for image in os.listdir(dataset_path + \"\/\" + symbols_dir):\n            train_label.append(symbols_dir.split()[0])\n            train_image.append(dataset_path + \"\/\" + symbols_dir + \"\/\" + image)","44533522":"eval_path = \"..\/input\/handwritten-math-symbol-dataset\/eval\"\ntest_image = []\ntest_label = []\n\nfor symbols_dir in os.listdir(eval_path):\n    if symbols_dir.split()[0] in symbols_list:\n        for image in os.listdir(eval_path + \"\/\" + symbols_dir):\n            test_label.append(symbols_dir.split()[0])\n            test_image.append(eval_path + \"\/\" + symbols_dir + \"\/\" + image)","9b7cb6d6":"print(\"Length of train_image : \" , len(train_image) , \" , length of labels list : \" ,len(train_label))\nprint(\"Length of test_image : \" , len(test_image) , \" , length of labels list : \" ,len(test_label))","41236867":"unique_test = list(set(test_label))\nunique_train = list(set(train_label))\nprint(\"Length of test unique labels: \" , len(unique_test) , \" : \" , unique_test)\nprint(\"Length of train unique labels: \" , len(unique_train) , \" : \" , unique_train)","921bc675":"image = cv2.imread(train_image[140])\nplt.imshow(image)\nplt.title(\"Label: \" + train_label[140])\nplt.show()","944a17e1":"image = cv2.imread(train_image[500])\nplt.imshow(image)\nplt.title(\"Label: \" + train_label[500])\nplt.show()","7be94bc0":"test = np.array(cv2.imread(train_image[20]))\ntest.shape","d9fd1eb1":"X_train = []\nX_test = []\n\n# laoding the images from the path\nfor path in train_image:    \n    img = cv2.imread(path)\n    img = cv2.resize(img, (100, 100))\n    img = np.array(img)\n    X_train.append(img)\n\nfor path in test_image:    \n    img = cv2.imread(path)\n    img = cv2.resize(img, (100, 100))\n    img = np.array(img)     \n    X_test.append(img)\n\n# creating numpy array from the images\nX_train = np.array(X_train)\nX_test = np.array(X_test)","d73e83d7":"X_train.shape","9bcf61f2":"# normalizing the data\nX_train = X_train.astype('float32')\nX_test = X_test.astype('float32')\nX_train \/= 255\nX_test \/= 255\n\nprint(\"X_train shape: \", X_train.shape)\nprint(\"X_test shape: \", X_test.shape)","9c0664cd":"# label encoding the 16 symbols\nlabel_encoder = preprocessing.LabelEncoder()\ny_train_temp = label_encoder.fit_transform(train_label)\ny_test_temp = label_encoder.fit_transform(test_label)","4f942f2f":"print(\"y_train_temp shape: \", y_train_temp.shape)\nprint(\"y_test_temp shape: \", y_test_temp.shape)","edaf8f97":"# creating matrix labels list\ny_train = keras.utils.to_categorical(y_train_temp, 16)\ny_test = keras.utils.to_categorical(y_test_temp, 16)\n\n\nprint(\"y_train shape: \", y_train.shape)\nprint(\"y_test shape: \", y_test.shape)","29e41ecf":"# using sequential model for training\nmodel = Sequential()\n\n# 1st layer and taking input in this of shape 100x100x3 ->  100 x 100 pixles and 3 channels\nmodel.add(Conv2D(32, (3, 3), padding='same', input_shape=(100, 100, 3), activation=\"relu\"))\nmodel.add(Conv2D(32, (3, 3), activation=\"relu\"))\n\n# maxpooling will take highest value from a filter of 2*2 shape\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\n# it will prevent overfitting by making it hard for the model to idenify the images\nmodel.add(Dropout(0.25))\n\nmodel.add(Conv2D(64, (3, 3), padding='same', activation=\"relu\"))\nmodel.add(Conv2D(64, (3, 3), activation=\"relu\"))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\n\nmodel.add(Flatten())\nmodel.add(Dense(512, activation=\"relu\"))\nmodel.add(Dropout(0.5))\n\n# last layer predicts 16 labels\nmodel.add(Dense(16, activation=\"softmax\"))\n\n# Compile the model\nmodel.compile(\n    loss='categorical_crossentropy',\n    optimizer=\"adam\",\n    metrics=['accuracy']\n)\n\nmodel.summary()\n","6fdfcd04":"# displaying the model\nkeras.utils.plot_model(model, \"model.png\", show_shapes=True)","6450d52b":"# training the model\nhistory = model.fit(\n    X_train,\n    y_train,\n    batch_size=50,\n    epochs=200,\n    validation_split=0.2,\n    shuffle=True\n)","5dbec5b8":"# displaying the model accuracy\nplt.plot(history.history['accuracy'], label='train', color=\"red\")\nplt.plot(history.history['val_accuracy'], label='validation', color=\"blue\")\nplt.title('Model accuracy')\nplt.legend(loc='upper left')\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.show()","f017af74":"# displaying the model loss\nplt.plot(history.history['loss'], label='train', color=\"red\")\nplt.plot(history.history['val_loss'], label='validation', color=\"blue\")\nplt.title('Model loss')\nplt.legend(loc='upper left')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.show()","c8f9aea8":"score, acc = model.evaluate(X_test, y_test)\nprint('Test score:', score)\nprint('Test accuracy:', acc)","f1d9cf81":"score, acc = model.evaluate(X_train, y_train)\nprint('Train score:', score)\nprint('Train accuracy:', acc)","11f72500":"pred = model.predict(X_test)\npred","ae7276db":"fig, axs= plt.subplots(2,5, figsize=[24,12])\n\ncount=0\n\nfor i in range(2):    \n    for j in range(5):  \n        \n        image = cv2.imread(test_image[count + count*100])\n        img = cv2.resize(image, (100, 100))        \n        img = np.array(img)\n        img = np.expand_dims(img, axis=0)\n        img = img.astype('float32')\n        img \/= 255\n        \n        \n        pred = model.predict(img)        \n        result = np.argsort(pred)  \n        result = result[0][::-1]\n\n        final_label = label_encoder.inverse_transform(np.array(result))\n                        \n        axs[i][j].imshow(image)\n        axs[i][j].set_title(str(\"Prediction: \" + final_label[0]), fontsize = 14)        \n        \n        count += 1\n        \nplt.suptitle(\"All predictions are shown in title\", fontsize = 18)        \nplt.show()","45e6c60a":"def strToSymbol(pred):\n    \n    if pred == \"zero\":\n        return 0    \n    elif pred == \"one\":\n        return 1\n    elif pred == \"two\":\n        return 2\n    elif pred == \"three\":\n        return 3\n    elif pred == \"four\":\n        return 4\n    elif pred == \"five\":\n        return 5\n    elif pred == \"six\":\n        return 6\n    elif pred == \"seven\":\n        return 7\n    elif pred == \"eight\":\n        return 8\n    elif pred == \"nine\":\n        return 9\n    elif pred == \"plus\":\n        return '+'\n    elif pred == \"minus\":\n        return '-'\n    elif pred == \"div\":\n        return '\/'\n    elif pred == \"equal\":\n        return '='\n    elif pred == \"decimal\":\n        return '.'\n    elif pred == \"times\":\n        return '*'\n\n    \ndef calculate(par1, sym, par2):\n    if sym == \"plus\":\n        return strToSymbol(par1) + strToSymbol(par2)\n    elif sym == \"minus\":\n        return strToSymbol(par1) - strToSymbol(par2)\n    elif sym == \"div\":\n        return strToSymbol(par1) \/ strToSymbol(par2)\n    elif sym == \"decimal\":\n        return str(par1 + sym + par2)\n    elif sym == \"times\":\n        return strToSymbol(par1) * strToSymbol(par2)\n    ","aae28457":"image = Image.open(\"..\/input\/dbscan-image\/2exp.png\")\nequation = []\n\nwidth, height = image.size \nprint(\"Width : \" , width, \" , Height : \", height)\nplt.imshow(image)\nplt.axis('off')\nplt.show()\n\nfig, axs= plt.subplots(1,3)\ndiv = int(width\/3)\n\nfor i in range(0,3):\n    left = i * div\n    top = 0\n    right = (i+1) * div\n    bottom = height \n    \n    temp_img = image.crop((left, top, right, bottom))\n    \n    temp_img = temp_img.resize((100,100)) \n    img = np.array(temp_img)\n    img = np.expand_dims(img, axis=0)\n    img = img.astype('float32')\n    img \/= 255\n\n\n    pred = model.predict(img)        \n    result = np.argsort(pred)  \n    result = result[0][::-1]\n\n    final_label = label_encoder.inverse_transform(np.array(result))\n    \n    equation.append(final_label[0])\n    \n    axs[i].imshow(temp_img)\n    axs[i].set_title(str(\"Prediction: \" + final_label[0]), fontsize = 14)   \n\nplt.show()\nprint(strToSymbol(equation[0]), strToSymbol(equation[1]) , strToSymbol(equation[2]), \" = \", calculate(equation[0], equation[1] , equation[2]))","3d730bf4":"image = Image.open(\"..\/input\/dbscan-image\/3exp.png\")\n\nequation = []\n\nwidth, height = image.size \nprint(\"Width : \" , width, \" , Height : \", height)\nplt.imshow(image)\nplt.axis('off')\nplt.show()\n\nfig, axs= plt.subplots(1,3)\ndiv = int(width\/3)\n\nfor i in range(0,3):\n    left = i * div\n    top = 0\n    right = (i+1) * div\n    bottom = height \n    \n    temp_img = image.crop((left, top, right, bottom))\n    \n    temp_img = temp_img.resize((100,100)) \n    img = np.array(temp_img)\n    img = np.expand_dims(img, axis=0)\n    img = img.astype('float32')\n    img \/= 255\n\n\n    pred = model.predict(img)        \n    result = np.argsort(pred)  \n    result = result[0][::-1]\n\n    final_label = label_encoder.inverse_transform(np.array(result))\n    \n    equation.append(final_label[0])\n\n    axs[i].imshow(temp_img)\n    axs[i].set_title(str(\"Prediction: \" + final_label[0]), fontsize = 14)   \n\nplt.show()\nprint(strToSymbol(equation[0]), strToSymbol(equation[1]) , strToSymbol(equation[2]), \" = \", calculate(equation[0], equation[1] , equation[2]))","f02a0e62":"image = Image.open(\"..\/input\/dbscan-image\/7exp.png\")\n\nequation = []\n\nwidth, height = image.size \nprint(\"Width : \" , width, \" , Height : \", height)\nplt.imshow(image)\nplt.axis('off')\nplt.show()\n\nfig, axs= plt.subplots(1,3)\ndiv = int(width\/3)\n\nfor i in range(0,3):\n    left = i * div\n    top = 0\n    right = (i+1) * div\n    bottom = height \n    \n    temp_img = image.crop((left, top, right, bottom))\n    \n    temp_img = temp_img.resize((100,100)) \n    img = np.array(temp_img)\n    img = np.expand_dims(img, axis=0)\n    img = img.astype('float32')\n    img \/= 255\n\n\n    pred = model.predict(img)        \n    result = np.argsort(pred)  \n    result = result[0][::-1]\n\n    final_label = label_encoder.inverse_transform(np.array(result))\n    \n    equation.append(final_label[0])\n\n    axs[i].imshow(temp_img)\n    axs[i].set_title(str(\"Prediction: \" + final_label[0]), fontsize = 14)   \n\nplt.show()\nprint(strToSymbol(equation[0]), strToSymbol(equation[1]) , strToSymbol(equation[2]), \" = \", calculate(equation[0], equation[1] , equation[2]))","fcde03a2":"!pip install keract","294a3182":"from keract import get_activations, display_heatmaps\n\nkeract_inputs = X_test[:1]\nkeract_targets = y_test[:1]\n\nactivations = get_activations(model, keract_inputs)\n\ndisplay_heatmaps(activations, keract_inputs, save=False)","15224374":"Creating the X_train and X_test","18a37676":"Liked the notebook? Please leave an upvote. Thank you !! And feel free to leave a comment.\n\n\n## Thank you","39311182":"Creating functions to perform calcualtions on our own equation images","ec0200ff":"# Verifying the data #","6d407f20":"Loading the paths of all testing and training images","391baccb":"# Visualising the outcome #","0750b6db":"Loading the images and label and checking correctness","ba018077":"Let's see that we have 16 unique labels for both test and train","b056bcf9":"**Pretty Cool right ? \ud83d\ude0e**","0c86453f":"# Creating train test and validation set #","ebcd4eca":"Let's see the model performance on the test set","55364a17":"# Training the model #","08ec5e0a":"# Model performance on equations #","9eb73653":"Verifying the shape","28100538":"Creating the y_train and y_test","a0ac62af":"Visualising the model","81e3c2c4":"# Reading the data #\n\nImporting all the libraries","1ee6fcf9":"# Keract for seeing inside the model #\n\n[Keract](https:\/\/pypi.org\/project\/keract\/) is used to see what happens at each layer of the Keras Sequential model","8a6e89d2":"# Making simple equation solver #\n\n\n**Goal** : Making a simple equation solver to perform `+` , `-` , `\/` and `*` based on images of the equation. Everything is build from stratch and we are using Keras Sequential Model for this.  \n\n\n1. [Reading the data](#Reading-the-data)\n2. [Verifying the data](#Verifying-the-data)\n3. [Creating train test and validation set](#Creating-train-test-and-validation-set)\n4. [Creating Sequential model](#Creating-Sequential-model)\n5. [Training the model](#Training-the-model)\n6. [Visualising the outcome](#Visualising-the-outcome)\n7. [Model performance on equations](#Model-performance-on-equations)\n8. [Keract for seeing inside the model](#Keract-for-seeing-inside-the-model)","3b762816":"# Creating Sequential model #","4eec0d0f":"Creating a list of symbols which we are going to use for training "}}