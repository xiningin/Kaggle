{"cell_type":{"be3eec37":"code","e6eee62a":"code","006d4fc2":"code","51cf3814":"code","14d41262":"code","278bca08":"code","2be01ca6":"code","19bb1d5a":"code","4dedac2a":"code","66b5a0a8":"code","12521900":"code","9c06d333":"code","6d556346":"code","3bdef49c":"code","73dfd666":"markdown","b87901e9":"markdown","fe0f7279":"markdown","df9245f4":"markdown","9aa451f8":"markdown","9ff125c4":"markdown","852218bc":"markdown","d3f3b8ec":"markdown","189a5467":"markdown"},"source":{"be3eec37":"import sys\nsys.path.append('..\/input\/timm-pytorch-image-models\/pytorch-image-models-master') ## Importing Timm Library","e6eee62a":"import os\n\n\nimport fastai \nimport os\nimport warnings\nfrom pprint import pprint\nfrom glob import glob\nfrom tqdm import tqdm\nfrom fastai.vision.all import *\nimport torch\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom timm import create_model\n\n#Importing Dataloaders\n\nfrom sklearn.model_selection import StratifiedKFold\nfrom torchvision.io import read_image\nfrom torch.utils.data import DataLoader, Dataset\n\n#Augmentation & Preprocessing Modules  \n\nimport albumentations\nfrom albumentations.pytorch import ToTensorV2 \nfrom albumentations import ImageOnlyTransform\nimport random\nimport timm\nimport cv2\n\n#For enabling fp16\n\nfrom torch.cuda.amp import autocast, GradScaler  \n\nimport warnings \nwarnings.filterwarnings('ignore')    ##ignore warning\n\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu') ### Enabling use of cuda","006d4fc2":"class Config: \n    model_name='swin_base_patch4_window12_384'  # which model to use\n    pretrained = False # enable pretrained weights\n    train_dir = '..\/input\/petfinder-pawpularity-score\/train' # Train Image Directory\n    train_csv = '..\/input\/abhi-folds-petfinder\/train_10folds.csv' # Train Csv Location\n    \n    test_dir = '..\/input\/petfinder-pawpularity-score\/test' # Test Image Directory\n    test_csv = '..\/input\/petfinder-pawpularity-score\/test.csv' # Test Csv Location\n    sample_csv = '..\/input\/petfinder-pawpularity-score\/sample_submission.csv' # Sample Submission\n    \n    image_size= 384   # Image Size for training \/ inference\n    num_workers=4  #number of worker\n    targets = 1  # number of targets\n    batch_size=6 # Batch size\n    weight_decay=1e-4  #Weight decay for optimizer \n    seed=42 # SEED\n    n_fold=10  #No of folds\n    trn_fold=[0, 1, 2, 3,4,5,6,7,8,9]  #Folds to be used in training \/ inference\n    train=False  \n    model_dir = '..\/input\/petfinder-v0-models\/exp0'  # Saved models directory","51cf3814":"def seed_torch(seed=42):\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n\nseed_torch(seed=Config.seed)","14d41262":"class PetDataset:\n    def __init__(self, df,image_path, augmentations):\n        self.image_path = image_path\n        self.df = df\n        self.augmentations = augmentations\n        \n    def __len__(self):\n        return len(self.df)\n    \n    def __getitem__(self, item):\n        id_ = self.df.Id.iloc[item] \n        path = f'{self.image_path}\/{id_}.jpg' # Getting Image paths for samples\n\n        targets = self.df.Pawpularity.iloc[item] # Target value for samples\n        image = cv2.imread(path)  # Reading Image\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Converting BGR to RGB images\n        \n        if self.augmentations is not None:\n            augmented = self.augmentations(image=image)  # Apply Augmentations\n            image = augmented[\"image\"]\n            \n        image = np.transpose(image, (2, 0, 1)).astype(np.float32)    \n        image = torch.tensor(image, dtype=torch.float) \n        \n        targets = torch.tensor(targets, dtype=torch.float) \/ 100  # For classification\n        return image, targets\n            ","278bca08":"def get_transforms(*, data):\n\n    if data == 'valid':\n        return albumentations.Compose([\n            albumentations.Resize(Config.image_size, Config.image_size),   # Resize all images to 384 image size.\n            albumentations.Normalize(     \n            mean=[0.485, 0.456, 0.406],\n            std=[0.229, 0.224, 0.225],\n            max_pixel_value=255.0,\n            p=1.0,\n        ),           \n\n        ])\n\n","2be01ca6":"class RMSELoss(nn.Module):\n    def __init__(self, eps=1e-6):\n        super().__init__()\n        self.mse = nn.MSELoss()\n        self.eps = eps\n\n    def forward(self, yhat, y):\n        loss = torch.sqrt(self.mse(yhat, y) + self.eps)\n        return loss","19bb1d5a":"# Cell\nimport gc\ndef mse(inp,targ):\n    \"Mean squared error between `inp` and `targ`.\"\n    return F.mse_loss(*flatten_check(inp,targ))\n\n# Cell\n\ndef _rmse(inp, targ): return 100*torch.sqrt(F.mse_loss(inp, targ))\nrmse = AccumMetric(_rmse)\nrmse.__doc__ = \"rrr\"","4dedac2a":"def petfinder_rmse(input,target):\n    return 100*torch.sqrt(F.mse_loss(F.sigmoid(input.flatten()), target))","66b5a0a8":"class PetModel(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.backbone = timm.create_model(self.config.model_name, pretrained=self.config.pretrained)\n        self.n_features = self.backbone.head.in_features\n        self.backbone.head = nn.Identity()\n        self.fc = nn.Linear(self.n_features, self.config.targets)\n        \n    def forward(self, image):\n#         print('done')\n        feature = self.backbone(image)\n        output = self.fc(feature)\n\n\n        return output","12521900":"def run(Config):\n    for fold_num in Config.trn_fold:    \n        print('*****************************************')\n        print(f'Training Fold {fold_num}')\n        print('*****************************************')\n        bs = Config.batch_size\n\n\n        kernel_type = Config.model_dir\n        df = pd.read_csv(Config.train_csv)[['Id', 'Pawpularity', 'kfold']]\n        df['is_valid'] = df.kfold.apply(lambda x: x==fold_num)\n        \n        validation_fold = df.query('is_valid==True').reset_index(drop=True, inplace=False)\n        valid_ds = PetDataset(validation_fold,Config.train_dir,augmentations = get_transforms(data='valid'))\n        valid_dl = torch.utils.data.DataLoader(valid_ds, batch_size=bs, num_workers=4,pin_memory=True)\n\n        dls = valid_dl\n        print(f'- Validation Samples : {len(valid_ds)}')\n\n        print(pd.read_csv(f'..\/input\/petfinder-v0-models\/exp0\/{fold_num}logs.csv'))\n\n        model = PetModel(Config)\n        learn = Learner(dls, model, loss_func=BCEWithLogitsLossFlat(), metrics=[petfinder_rmse])#.to_fp16()\n\n        model_path = f'{kernel_type}\/fold_{fold_num}.pth'  # trained models path\n        learn.model.load_state_dict(torch.load(model_path)['model']) # Loading trained model weights\n        learn.model.eval()\n        learn.model.cuda()\n\n        \n\n        \n        test_df = pd.read_csv(Config.test_csv)   \n        test_df['Pawpularity'] = 0\n        test_ds = PetDataset(test_df,Config.test_dir,augmentations = get_transforms(data='valid'))  \n        inds = list(test_df.index)\n        test_dl = torch.utils.data.DataLoader(test_ds, batch_size=bs, num_workers=4, shuffle=False,pin_memory=True) #test loader\n\n        preds = []\n        for xb, _ in progress_bar(test_dl):\n            with torch.no_grad(): \n                output = learn.model(xb.cuda())    # Making predictions\n            preds.append(torch.sigmoid(output.float()).squeeze().cpu()) # storing predictions in list\n        preds = torch.cat(preds).numpy().flatten()\n        \n        if fold_num == 0:\n            sample_df = pd.read_csv(Config.sample_csv)\n            sample_df['Pawpularity'] = 0\n        sample_df.loc[inds,'Pawpularity'] += 100 * preds \/ len(Config.trn_fold)  # ensemble multiple folds predictions\n        \n        del df,model,learn,test_ds,test_dl,valid_dl,preds\n        gc.collect()\n        \n    return sample_df\n\n        \n","9c06d333":"sub = run(Config)","6d556346":"sub.to_csv('submission.csv',index=False)","3bdef49c":"sub","73dfd666":"## Model Class","b87901e9":"# Refrences","fe0f7279":"https:\/\/www.kaggle.com\/phalanx\/train-swin-t-pytorch-lightning \nFolds used are the same that Abhishek thakur posted: https:\/\/www.kaggle.com\/abhishek\/same-old-creating-folds\n\nfastai is used in training and inference code along with custom datasets, models and metric.","df9245f4":"#### **Models are trained on [JarvisLabs.ai](https:\/\/cloud.jarvislabs.ai) (a GPU cloud based platform offering modern and extremely easy to launch GPU instances) with a large batch size(~24). I will clean up and release the training code soon. Stay tuned **","9aa451f8":"## Generating Predictions","9ff125c4":"## Augmentations","852218bc":"## Defining Dataset","d3f3b8ec":"Defining Regression loss","189a5467":" ### Adding Modules"}}