{"cell_type":{"b2244217":"code","f364da09":"code","dbe9a526":"code","8ece70eb":"code","0e193dbb":"code","90f97a68":"code","3e3c7877":"code","86437d22":"code","3422b289":"code","78fcfe00":"code","5bcc629c":"code","3f69e99c":"code","99ee6e83":"code","557d1f36":"code","a58af43a":"code","1cb3bd70":"code","36ab67dc":"code","5d3d124c":"markdown","ef1509cc":"markdown","2bfb24a6":"markdown","c0b6572a":"markdown","d4bcce68":"markdown","eeb1fe17":"markdown","e749e51c":"markdown","6473c79a":"markdown","17dab9b7":"markdown","29c822a2":"markdown","5d86a0a8":"markdown","8c29e1f6":"markdown","1ee0d52e":"markdown","c25f4e91":"markdown","da95b12c":"markdown"},"source":{"b2244217":"import numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom datetime import datetime\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import train_test_split\n# logging in INFO mode let us see the training feedback.\ntf.logging.set_verbosity(tf.logging.INFO)","f364da09":"def clean(df):\n    # Delimiter lats and lons to NY only\n    df = df[(-76 <= df['pickup_longitude']) & (df['pickup_longitude'] <= -72)]\n    df = df[(-76 <= df['dropoff_longitude']) & (df['dropoff_longitude'] <= -72)]\n    df = df[(38 <= df['pickup_latitude']) & (df['pickup_latitude'] <= 42)]\n    df = df[(38 <= df['dropoff_latitude']) & (df['dropoff_latitude'] <= 42)]\n    # Remove possible outliers\n    df = df[(0 < df['fare_amount']) & (df['fare_amount'] <= 250)]\n    # Remove inconsistent values\n    df = df[(df['dropoff_longitude'] != df['pickup_longitude'])]\n    df = df[(df['dropoff_latitude'] != df['pickup_latitude'])]\n    \n    return df","dbe9a526":"def late_night (row):\n    if (row['hour'] <= 6) or (row['hour'] >= 20):\n        return 1\n    else:\n        return 0\n\n\ndef night (row):\n    if ((row['hour'] <= 20) and (row['hour'] >= 16)) and (row['weekday'] < 5):\n        return 1\n    else:\n        return 0\n    \n    \ndef manhattan(pickup_lat, pickup_long, dropoff_lat, dropoff_long):\n    return np.abs(dropoff_lat - pickup_lat) + np.abs(dropoff_long - pickup_long)\n\n\ndef add_time_features(df):\n    df['pickup_datetime'] =  pd.to_datetime(df['pickup_datetime'], format='%Y-%m-%d %H:%M:%S %Z')\n    df['year'] = df['pickup_datetime'].apply(lambda x: x.year)\n    df['month'] = df['pickup_datetime'].apply(lambda x: x.month)\n    df['day'] = df['pickup_datetime'].apply(lambda x: x.day)\n    df['hour'] = df['pickup_datetime'].apply(lambda x: x.hour)\n    df['weekday'] = df['pickup_datetime'].apply(lambda x: x.weekday())\n    df['pickup_datetime'] =  df['pickup_datetime'].apply(lambda x: str(x))\n    df['night'] = df.apply (lambda x: night(x), axis=1)\n    df['late_night'] = df.apply (lambda x: late_night(x), axis=1)\n    # Drop 'pickup_datetime' as we won't need it anymore\n    df = df.drop('pickup_datetime', axis=1)\n    \n    return df\n\n\ndef add_coordinate_features(df):\n    lat1 = df['pickup_latitude']\n    lat2 = df['dropoff_latitude']\n    lon1 = df['pickup_longitude']\n    lon2 = df['dropoff_longitude']\n    \n    # Add new features\n    df['latdiff'] = (lat1 - lat2)\n    df['londiff'] = (lon1 - lon2)\n\n    return df\n\n\ndef add_distances_features(df):\n    # Add distances from airpot and downtown\n    ny = (-74.0063889, 40.7141667)\n    jfk = (-73.7822222222, 40.6441666667)\n    ewr = (-74.175, 40.69)\n    lgr = (-73.87, 40.77)\n    \n    lat1 = df['pickup_latitude']\n    lat2 = df['dropoff_latitude']\n    lon1 = df['pickup_longitude']\n    lon2 = df['dropoff_longitude']\n    \n    df['euclidean'] = (df['latdiff'] ** 2 + df['londiff'] ** 2) ** 0.5\n    df['manhattan'] = manhattan(lat1, lon1, lat2, lon2)\n    \n    df['downtown_pickup_distance'] = manhattan(ny[1], ny[0], lat1, lon1)\n    df['downtown_dropoff_distance'] = manhattan(ny[1], ny[0], lat2, lon2)\n    df['jfk_pickup_distance'] = manhattan(jfk[1], jfk[0], lat1, lon1)\n    df['jfk_dropoff_distance'] = manhattan(jfk[1], jfk[0], lat2, lon2)\n    df['ewr_pickup_distance'] = manhattan(ewr[1], ewr[0], lat1, lon1)\n    df['ewr_dropoff_distance'] = manhattan(ewr[1], ewr[0], lat2, lon2)\n    df['lgr_pickup_distance'] = manhattan(lgr[1], lgr[0], lat1, lon1)\n    df['lgr_dropoff_distance'] = manhattan(lgr[1], lgr[0], lat2, lon2)\n    \n    return df","8ece70eb":"def build_estimator(nbuckets, hidden_units, optimizer, input_columns, run_config=None):\n    # Input columns\n    (plon, plat, dlon, dlat, year, month, day, hour, weekday, night, late_night, \n     latdiff, londiff, euclidean, manhattan, downtown_pickup_distance, downtown_dropoff_distance, \n     jfk_pickup_distance, jfk_dropoff_distance, ewr_pickup_distance, ewr_dropoff_distance, \n     lgr_pickup_distance, lgr_dropoff_distance) = input_columns\n\n    # Bucketize the lats & lons\n    latbuckets = np.linspace(38.0, 42.0, nbuckets).tolist()\n    lonbuckets = np.linspace(-76.0, -72.0, nbuckets).tolist()\n    b_plat = tf.feature_column.bucketized_column(plat, latbuckets)\n    b_dlat = tf.feature_column.bucketized_column(dlat, latbuckets)\n    b_plon = tf.feature_column.bucketized_column(plon, lonbuckets)\n    b_dlon = tf.feature_column.bucketized_column(dlon, lonbuckets)\n\n    # Feature cross\n    ploc = tf.feature_column.crossed_column([b_plat, b_plon], nbuckets ** 2)\n    dloc = tf.feature_column.crossed_column([b_dlat, b_dlon], nbuckets ** 2)\n    pd_pair = tf.feature_column.crossed_column([ploc, dloc], nbuckets ** 4)\n    day_hr = tf.feature_column.crossed_column([weekday, hour], 24 * 7)\n\n    # Wide columns and deep columns\n    wide_columns = [\n        # Sparse columns\n        night, late_night,\n\n        # Anything with a linear relationship\n        month, hour, weekday, year\n    ]\n\n    deep_columns = [\n        # Embedding columns to \"group\" together\n        tf.feature_column.embedding_column(pd_pair, nbuckets),\n        tf.feature_column.embedding_column(day_hr, nbuckets),\n        tf.feature_column.embedding_column(ploc, nbuckets),\n        tf.feature_column.embedding_column(dloc, nbuckets),\n\n        # Numeric columns\n        latdiff, londiff,\n        euclidean, manhattan,\n        downtown_pickup_distance, downtown_dropoff_distance,\n        jfk_pickup_distance, jfk_dropoff_distance,\n        ewr_pickup_distance, ewr_dropoff_distance,\n        lgr_pickup_distance, lgr_dropoff_distance\n    ]\n\n    estimator = tf.estimator.DNNLinearCombinedRegressor(\n        linear_feature_columns=wide_columns,\n        dnn_feature_columns=deep_columns,\n        dnn_hidden_units=hidden_units,\n        dnn_optimizer=optimizer,\n        config=run_config)\n\n    return estimator","0e193dbb":"def pandas_train_input_fn(df, label):\n    return tf.estimator.inputs.pandas_input_fn(\n        x=df,\n        y=label,\n        batch_size=128,\n        num_epochs=100,\n        shuffle=True,\n        queue_capacity=1000\n    )\n\n\ndef pandas_test_input_fn(df):\n    return tf.estimator.inputs.pandas_input_fn(\n        x=df,\n        y=None,\n        batch_size=128,\n        num_epochs=1,\n        shuffle=False,\n        queue_capacity=1000\n    )","90f97a68":"def output_submission(df, prediction_df, id_column, prediction_column, file_name):\n    df[prediction_column] = prediction_df['predictions'].apply(lambda x: x[0])\n    df[[id_column, prediction_column]].to_csv((file_name), index=False)\n    print('Output complete')","3e3c7877":"TRAIN_PATH = '..\/input\/train.csv'\nTEST_PATH = '..\/input\/test.csv'\nSUBMISSION_NAME = 'submission.csv'\n\n# Model parameters\nBATCH_SIZE = 512\nSTEPS = 400000\nLEARNING_RATE = 0.001\nDATASET_SIZE = 8000000\nHIDDEN_UNITS = [256, 128, 64, 32]","86437d22":"INPUT_COLUMNS = [\n    # raw data columns\n    tf.feature_column.numeric_column('pickup_longitude'),\n    tf.feature_column.numeric_column('pickup_latitude'),\n    tf.feature_column.numeric_column('dropoff_longitude'),\n    tf.feature_column.numeric_column('dropoff_latitude'),\n\n    # engineered columns\n    tf.feature_column.numeric_column('year'),\n    tf.feature_column.categorical_column_with_identity('month', num_buckets=13),\n    tf.feature_column.categorical_column_with_identity('day', num_buckets=32),\n    tf.feature_column.categorical_column_with_identity('hour', num_buckets=24),\n    tf.feature_column.categorical_column_with_identity('weekday', num_buckets=7),\n    tf.feature_column.categorical_column_with_identity('night', num_buckets=2),\n    tf.feature_column.categorical_column_with_identity('late_night', num_buckets=2),\n    tf.feature_column.numeric_column('latdiff'),\n    tf.feature_column.numeric_column('londiff'),\n    tf.feature_column.numeric_column('euclidean'),\n    tf.feature_column.numeric_column('manhattan'),\n    tf.feature_column.numeric_column('downtown_pickup_distance'),\n    tf.feature_column.numeric_column('downtown_dropoff_distance'),\n    tf.feature_column.numeric_column('jfk_pickup_distance'),\n    tf.feature_column.numeric_column('jfk_dropoff_distance'),\n    tf.feature_column.numeric_column('ewr_pickup_distance'),\n    tf.feature_column.numeric_column('ewr_dropoff_distance'),\n    tf.feature_column.numeric_column('lgr_pickup_distance'),\n    tf.feature_column.numeric_column('lgr_dropoff_distance')\n]","3422b289":"# Load data in a more compact form\ndatatypes = {'key': 'str', \n              'fare_amount': 'float32',\n              'pickup_datetime': 'str', \n              'pickup_longitude': 'float32',\n              'pickup_latitude': 'float32',\n              'dropoff_longitude': 'float32',\n              'dropoff_latitude': 'float32',\n              'passenger_count': 'uint8'}\n\n# Only a fraction of the data\ntrain = pd.read_csv(TRAIN_PATH, nrows=DATASET_SIZE, dtype=datatypes, usecols=[1,2,3,4,5,6])\ntest = pd.read_csv(TEST_PATH)","78fcfe00":"train = clean(train)\n\ntrain = add_time_features(train)\ntest = add_time_features(test)\n\nadd_coordinate_features(train)\nadd_coordinate_features(test)\n\ntrain = add_distances_features(train)\ntest = add_distances_features(test)\n\ntrain.head(5)","5bcc629c":"train_df, validation_df = train_test_split(train, test_size=0.1, random_state=1)","3f69e99c":"# Scale data\n# Note: i'm doing this here with sklearn scaler but on the Coursera code the scaling is done with Dataflow and Tensorflow\n# Selecting only columns that will be scaled\nwanted_columns = ['pickup_longitude', 'pickup_latitude','dropoff_longitude', \n                  'dropoff_latitude','year', 'latdiff', 'londiff', \n                  'euclidean', 'manhattan', 'downtown_pickup_distance', \n                  'downtown_dropoff_distance', 'jfk_pickup_distance', 'jfk_dropoff_distance', \n                  'ewr_pickup_distance', 'ewr_dropoff_distance', 'lgr_pickup_distance', \n                  'lgr_dropoff_distance']\n\n# One-hot encodded features (e.g. weekday) won't be scaled, this is arguable, but in my opinion when you scale one-hot encoded features they may lose it's purpose (true or false).\none_hot_columns = ['month', 'day', 'hour', 'weekday', 'night', 'late_night']\n\ntrain_df_scaled = train_df[wanted_columns]\nvalidation_df_scaled = validation_df[wanted_columns]\ntest_scaled = test[wanted_columns]\n\n# Normalize using Min-Max scaling\n# Just a quick note: i use the same object to fit and transform all the data sets, because data should be normalized using a single data set(distribution) as parameter.\nscaler = preprocessing.MinMaxScaler()\ntrain_df_scaled[wanted_columns] = scaler.fit_transform(train_df_scaled[wanted_columns])\nvalidation_df_scaled[wanted_columns] = scaler.transform(validation_df_scaled[wanted_columns])\ntest_scaled[wanted_columns] = scaler.transform(test_scaled[wanted_columns])\n\n# Add one-hot encoded features\ntrain_df_scaled[one_hot_columns] = train_df[one_hot_columns]\nvalidation_df_scaled[one_hot_columns] = validation_df[one_hot_columns]\ntest_scaled[one_hot_columns] = test[one_hot_columns]\n\ntrain_df_scaled.head(5)","99ee6e83":"# optimizer = tf.train.AdamOptimizer(learning_rate=LEARNING_RATE)\noptimizer = tf.train.ProximalAdagradOptimizer(learning_rate=0.1, l1_regularization_strength=0.001, l2_regularization_strength=0.001)\nestimator = build_estimator(16, HIDDEN_UNITS, optimizer, INPUT_COLUMNS)\n\ntrain_spec = tf.estimator.TrainSpec(input_fn=pandas_train_input_fn(train_df_scaled, train_df['fare_amount']), max_steps=STEPS)\neval_spec = tf.estimator.EvalSpec(input_fn=pandas_train_input_fn(validation_df_scaled, validation_df['fare_amount']), steps=500, throttle_secs=300)","557d1f36":"print('Dataset size: %s' % DATASET_SIZE)\nprint('Steps: %s' % STEPS)\nprint('Learning rate: %s' % LEARNING_RATE)\nprint('Batch size: %s' % BATCH_SIZE)\nprint('Input dimension: %s' % train_df_scaled.shape[1])\nprint('Features used: %s' % train_df.columns)","a58af43a":"tf.estimator.train_and_evaluate(estimator, train_spec=train_spec, eval_spec=eval_spec)","1cb3bd70":"# Make prediction\nprediction = estimator.predict(pandas_test_input_fn(test_scaled))","36ab67dc":"# output prediction\nprediction_df = pd.DataFrame(prediction)\noutput_submission(test, prediction_df, 'key', 'fare_amount', SUBMISSION_NAME)","5d3d124c":"### Define model and parameters\n* Currently i'm using Adam optimizer, it seems to be the better default optimizer for DNN.\n* Tensorflow estimator API accepts train and evaluation spec (Specifications), that are classes with some of the information needed for the model training and evaluation, like the input function, labels and many more.","ef1509cc":"### Parameters\n* One thing this API of Tensorflow have different from other ml models is that it does not have an epochs number, this API uses number of steps, this is because Tensorflow can be also used for distributed training, so it's easier to distribute training if clusters don't need do synchronize epochs with each other, with steps they simply train x steps and send the results back to the main core.\n    * Each step feeds the model with data equal to the batch size.","2bfb24a6":"### Train model\n* I'm training using the 'train_and_evaluate' function that allows me to train and evaluate the model at the same time.","c0b6572a":"#### Clean and process data","d4bcce68":"## Estimator\n#### Here is where most of the important Tensorflow stuff happens. \n* I get a list of input columns, theses columns comes from the csv data, so they are supposed to match each other in size.\n* First we need a lists with the buckets for the latitudes and longitudes values, we give the limits and number of buckets we want.\n* Then i'll bucktize (create bins) for the values (the number of buckets is nbuckets, which is a hyperparameter).\n* Tensorflow allows us to cross categorical data, we will do it to create ploc (pickup location) and dloc (dropout location), in practice this will get categorical features and make combinations with another categorical feature, creating all possible combinations with the columns (this probably will create a very sparse column).\nWe will create sparse features for \"pickup location\" (pickup lat with lon), \"dropout location\" (dropout lat with lon), \"pickup and dropout location\" (pickup location with dropout location) and \"day_hour ride\" (weekday with hour), these features are supposed to give the model a better understanding of the data by us giving our insights.\n* The wide columns list will go to the linear model, these are features that may have a linear relation, or are a sparse feature (Tensorflow DNN models do note accept sparse data).\n* The deep columns list will go to the DNN model\n\n#### On embeddings\n* Here is very important the embedding features, as \"pd_pair\" and \"day_hr\" are sparse data, we need a way reduce it's dimension, and we do it by using a embedding, embeddings also helps mapping features to a more \"compact form\", as we try to find a way to represent a number of features in a lower dimension, e.g. in the \"day_hr\" feature i have a cross of one-hot encoded features, weekdays (7 features [one for each day]) and hour (24 features [1 for each hour]), so crossing these two would give me an additional 168 features (24 x 7), this would be a lot of input data, it would have a chance to disrupt the model learning, but by using embeddings i can lower it's dimension (168) to a smaller number, in this case i use 10, this way during training my model will also learn a way to map this 168 features to only 10 features.\n* As you can see embeddings are a very powerful tool that Tensorflow give to us, on a very easy to use API.\n* This image may help the understanding: <img src=\"https:\/\/www.tensorflow.org\/images\/feature_columns\/embedding_vs_indicator.jpg\" width=\"450\">\n* In this model i use both linear and DNN models, to try to take advantage on both based on the features i have, luckily Tensorflow has that already implemented on it's high level API, so i just have to call tf.estimator.DNNLinearCombinedRegressor passing all the parameters i need.","eeb1fe17":"#### Inputting columns to the Tensorflow model\n* This list is basically the columns read from the csv file converted to a Tensorflow feature column type, in this case i use only 2, but there are [many more.](https:\/\/www.tensorflow.org\/guide\/feature_columns)\n    * tf.feature_column.numeric_column, just a normal numeric feature.\n    * tf.feature_column.categorical_column_with_identity, this one is a categorical feature with a number of buckets (it's essentially a one-hot encoded column, but the number of buckets must be >= than the number of possible values, e.g. for week day i need at least 7 buckets).","e749e51c":"## Feature engineering\n*  Now i'll do some feature engineering and process the data, i'm basically creating 3 kinds of features.\n    *  **Time features**\n        * Year, Month, Day, Hour, Weekday\n        * Night (between 16h and 20h, from monday to friday)\n        * Late night (between 20h and and 6h)\n    * **Coordinate features**\n        * Latitude difference (difference from pickup and dropout latitudes)\n        * Longitude difference (difference from pickup and dropout longitudes)\n    * **Distances features**\n        * Euclidean (Euclidean distance from pickup and dropout)\n        * Manhattan (Manhattan distance from pickup and dropout)\n        * Manhattan distances from pickup location and downtown, JFK, EWR and LGR airports (see if the ride started at one of these locations).\n        * Manhattan distances from dropout location and downtown, JFK, EWR and LGR airports (see if the ride ended at one of these locations).","6473c79a":"<center><h2>Taxi fare predictions with deep learning and Tensorflow<\/h2><\/center>\n\n### In this version of the code i use pandas to load the data and the Tensorflow input pandas function to feed the model.\n\n#### Notes: \n* [Link for a Keras version](https:\/\/www.kaggle.com\/dimitreoliveira\/taxi-fare-prediction-with-keras-deep-learning)\n* [Link for a more complete version on Github](https:\/\/github.com\/dimitreOliveira\/NewYorkCityTaxiFare)\n* I'm not using \"passenger count\" because it something that is not supposed to really matter in this case.\n* I've created two features derived from \"hour\" (night and late night), according to some research i did it's added an additional value if it's a business day (mon ~ fri) and it's night, also there's another added value if it's dawn (late night).\n* I'm binning latitudes and longitudes to make it easier to work with.\n* Even tough deep learning is robust enough to deal with noisy data, i'm removing outliers (it may save some memory).\n* Currently i'm using both Euclidean and Manhattan distances, it may be a bit redundant, but they have a different meaning and i'm still not sure of witch one is better(if you have some insights about this please let me know)","17dab9b7":"## Dependencies","29c822a2":"## Data clean\n### Here i'm removing some outliers, and noisy data.\n* Lats and lons that do not belong to New York.\n* Negative fare.\n* Fare greater than 250 (this seems to be noisy data).\n* Rides that begin and end in the same location.","5d86a0a8":"#### Split data in train and validation (90% ~ 10%)","8c29e1f6":"### Tensorflow pandas data input functions\n#### These functions are responsible for feeding data both for model training and prediction.\n* Note: both functions feed data by batch using generators.\n* Shuffle in the test function must be 'False' or else it will shuffle the predicted data.","1ee0d52e":"### Output function","c25f4e91":"### Load data","da95b12c":"### Model parameters"}}