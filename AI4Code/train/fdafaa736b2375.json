{"cell_type":{"32c6ffd5":"code","9daeb306":"code","a380755d":"code","cc52bf5a":"code","2304d008":"code","7a525884":"code","c9a9b562":"code","571173a2":"code","1cdf4992":"code","ca95baec":"code","b19824a8":"code","cfc27b23":"code","7bec9a77":"code","5cc060e1":"code","f288094c":"code","afb35a0e":"code","85587236":"code","f132b626":"code","5822edcb":"code","4d080a85":"code","de914e3a":"code","5076e5b9":"code","08936212":"code","69f1b7ed":"code","44c3e622":"code","51df9996":"code","8571f4a2":"code","dea00509":"code","7aac0a0c":"code","75a04e35":"code","467c01df":"code","76441336":"code","ebf81e9f":"code","ce4e5f3c":"code","b06555e3":"code","a136dba0":"code","9e8b8a7a":"code","2a533a04":"code","cf0d202c":"code","9f5ad540":"code","9796a15c":"markdown","0cb430c0":"markdown","3bd1f757":"markdown","834a2e89":"markdown","28f5e044":"markdown","2745d7b8":"markdown","61a356fb":"markdown","9f4e4660":"markdown","93b7f028":"markdown","3da5931e":"markdown","0445a66d":"markdown","e1cb634e":"markdown","a59884d1":"markdown"},"source":{"32c6ffd5":"import pandas as pd\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\ncolor = sns.color_palette()\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.offline as offline\noffline.init_notebook_mode()\nimport cufflinks as cf\ncf.go_offline()\nimport os\nimport gc","9daeb306":"application_train = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/application_train.csv')\nPOS_CASH_balance = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/POS_CASH_balance.csv')\nbureau_balance = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/bureau_balance.csv')\nprevious_application = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/previous_application.csv')\ninstallments_payments = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/installments_payments.csv')\ncredit_card_balance = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/credit_card_balance.csv')\nbureau = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/bureau.csv')\napplication_test = pd.read_csv('\/kaggle\/input\/home-credit-default-risk\/application_test.csv')","a380755d":"application_train.head()","cc52bf5a":"application_train.shape","2304d008":"POS_CASH_balance.head()","7a525884":"bureau_balance.head()","c9a9b562":"previous_application.head()","571173a2":"installments_payments.head()","1cdf4992":"credit_card_balance.head()","ca95baec":"bureau.head()","b19824a8":"application_train.isnull().mean().sort_values(ascending = False)","cfc27b23":"POS_CASH_balance.isnull().mean().sort_values(ascending = False)","7bec9a77":"bureau_balance.isnull().mean().sort_values(ascending = False)","5cc060e1":"previous_application.isnull().mean().sort_values(ascending = False)","f288094c":"installments_payments.isnull().mean().sort_values(ascending = False)","afb35a0e":"credit_card_balance.isnull().mean().sort_values(ascending = False)","85587236":"bureau.isnull().mean().sort_values(ascending = False)","f132b626":"plt.figure(figsize=(10,5))\nplt.title(\"Distribution of AMT_CREDIT\")\nsns.distplot(application_train[\"AMT_CREDIT\"])\nplt.show()","5822edcb":"plt.figure(figsize=(10,5))\nplt.title(\"Distribution of AMT_INCOME_TOTAL\")\nsns.distplot(application_train[\"AMT_INCOME_TOTAL\"].dropna())\nplt.show()","4d080a85":"plt.figure(figsize=(10,5))\nplt.title(\"Distribution of AMT_GOODS_PRICE\")\nsns.distplot(application_train[\"AMT_GOODS_PRICE\"].dropna())\nplt.show()","de914e3a":"temp = pd.DataFrame({'labels': application_train[\"TARGET\"].value_counts().index,\n                   'values': application_train[\"TARGET\"].value_counts().values})\ntemp.iplot(kind='bar',labels='labels',values='values', title='Loan Repayed or not')","5076e5b9":"temp = application_train[\"OCCUPATION_TYPE\"].value_counts()\ntemp.iplot(kind='bar', xTitle = 'Occupation', yTitle = \"Count\", title = 'Occupation of Applicants', color = 'red')","08936212":"temp = application_train[\"ORGANIZATION_TYPE\"].value_counts()\ntemp.iplot(kind='bar', xTitle = 'Organization Name', yTitle = \"Count\", title = 'Types of Organizations who applied for loan ', color = 'green')","69f1b7ed":"temp = previous_application[\"NAME_CONTRACT_TYPE\"].value_counts()\nfig = { \"data\": [{\"values\": temp.values,\"labels\": temp.index,\"domain\": {\"x\": [0, .48]},\n      \"hole\": .6, \"type\": \"pie\"},], \n       \"layout\": {\"title\":\"Contract product type\",\n        \"annotations\": [{\"font\": {\"size\": 20},\"showarrow\": False,\"text\": \"Contract product type\",\"x\": 0.12,\"y\": 0.5}]}}\niplot(fig)","44c3e622":"temp = pd.DataFrame({'labels': previous_application[\"NAME_CLIENT_TYPE\"].value_counts().index,\n                   'values': previous_application[\"NAME_CLIENT_TYPE\"].value_counts().values})\ntemp.iplot(kind='pie',labels='labels',values='values', title='New or Old Client?', hole = 0.5)","51df9996":"temp = pd.DataFrame({'labels': previous_application[\"NFLAG_INSURED_ON_APPROVAL\"].value_counts().index,\n                   'values': previous_application[\"NFLAG_INSURED_ON_APPROVAL\"].value_counts().values\n                  })\ntemp.iplot(kind='bar',labels='labels',values='values', title='Did the client requested insurance? (YES : 1, NO : 0)')","8571f4a2":"cor = application_train.drop('SK_ID_CURR',axis=1).corr()\nsns.heatmap(cor)\nplt.show()","dea00509":"from sklearn.preprocessing import LabelEncoder\nfor c in application_train.columns:\n    if (c!='SK_ID_CURR') & (application_train[c].dtypes==object):\n        LE = LabelEncoder()\n        LE.fit(list(application_train[c].values.astype('str')) + list(application_test[c].values.astype('str')))\n        application_train[c] = LE.transform(list(application_train[c].values.astype('str')))\n        application_test[c] = LE.transform(list(application_test[c].values.astype('str')))\napplication_train.head()","7aac0a0c":"application_train.fillna(-1, inplace = True)","75a04e35":"from xgboost import XGBClassifier\nfrom xgboost import plot_importance\nX = application_train.drop(['SK_ID_CURR', 'TARGET'],axis=1)\nY = application_train.TARGET\nxgb = XGBClassifier(n_estimators=500, max_depth=8, random_state=2018)\nxgb.fit(X, Y)","467c01df":"plot_importance(xgb)\nplt.rcParams[\"figure.figsize\"] = (10, 30)\nplt.show()","76441336":"df = application_train.append(application_test).reset_index()\n# df = df[df['CODE_GENDER'] != 'XNA']\n\ndf['DAYS_EMPLOYED'].replace(365243, -1, inplace= True)\ndf['DAYS_EMPLOYED_PERC'] = df['DAYS_EMPLOYED'] \/ df['DAYS_BIRTH']\ndf['INCOME_CREDIT_PERC'] = df['AMT_INCOME_TOTAL'] \/ df['AMT_CREDIT']\ndf['INCOME_PER_PERSON'] = df['AMT_INCOME_TOTAL'] \/ df['CNT_FAM_MEMBERS']\ndf['ANNUITY_INCOME_PERC'] = df['AMT_ANNUITY'] \/ df['AMT_INCOME_TOTAL']\ndf['PAYMENT_RATE'] = df['AMT_ANNUITY'] \/ df['AMT_CREDIT']\n\nprevious_application['DAYS_FIRST_DRAWING'].replace(365243, -1, inplace= True)\nprevious_application['DAYS_FIRST_DUE'].replace(365243, -1, inplace= True)\nprevious_application['DAYS_LAST_DUE_1ST_VERSION'].replace(365243, -1, inplace= True)\nprevious_application['DAYS_LAST_DUE'].replace(365243, -1, inplace= True)\nprevious_application['DAYS_TERMINATION'].replace(365243, -1, inplace= True)\nprevious_application['APP_CREDIT_PERC'] = previous_application['AMT_APPLICATION'] \/ previous_application['AMT_CREDIT']\n\ninstallments_payments['PAYMENT_PERC'] = installments_payments['AMT_PAYMENT'] \/ installments_payments['AMT_INSTALMENT']\ninstallments_payments['PAYMENT_DIFF'] = installments_payments['AMT_INSTALMENT'] - installments_payments['AMT_PAYMENT']\ninstallments_payments['DPD'] = installments_payments['DAYS_ENTRY_PAYMENT'] - installments_payments['DAYS_INSTALMENT']\ninstallments_payments['DBD'] = installments_payments['DAYS_INSTALMENT'] - installments_payments['DAYS_ENTRY_PAYMENT']\ninstallments_payments['DPD'] = installments_payments['DPD'].apply(lambda x: x if x > 0 else 0)\ninstallments_payments['DBD'] = installments_payments['DBD'].apply(lambda x: x if x > 0 else 0)","ebf81e9f":"bb_aggregations = {'MONTHS_BALANCE': ['min', 'max', 'size']}\n# for c in bureau_balance.columns:\n#     if bureau_balance[c].dtypes==object:\n#         bb_aggregations[c] = ['mean']\nbb_agg = bureau_balance.groupby('SK_ID_BUREAU').agg(bb_aggregations)\nbb_agg.columns = pd.Index([col[0] + \"_\" + col[1].upper() for col in bb_agg.columns.tolist()])\nbureau = bureau.join(bb_agg, how='left', on='SK_ID_BUREAU')\nbureau.drop(['SK_ID_BUREAU'], axis=1, inplace= True)\ndel bb_agg\ngc.collect()\n\naggregations = {\n    'DAYS_CREDIT': ['min', 'max', 'mean', 'var'],\n    'DAYS_CREDIT_ENDDATE': ['mean','var'],\n    'DAYS_CREDIT_UPDATE': ['mean'],\n    'CREDIT_DAY_OVERDUE': ['mean','var'],\n    'AMT_CREDIT_MAX_OVERDUE': ['mean'],\n    'AMT_CREDIT_SUM': ['max', 'mean', 'var'],\n    'AMT_CREDIT_SUM_DEBT': ['max', 'mean', 'var'],\n    'AMT_CREDIT_SUM_OVERDUE': ['mean'],\n    'AMT_CREDIT_SUM_LIMIT': ['mean', 'var'],\n    'AMT_ANNUITY': ['max', 'mean'],\n    'CNT_CREDIT_PROLONG': ['sum'],\n    'MONTHS_BALANCE_MIN': ['min'],\n    'MONTHS_BALANCE_MAX': ['max'],\n    'MONTHS_BALANCE_SIZE': ['mean', 'var']\n}\n\nbureau_agg = bureau.groupby('SK_ID_CURR').agg({**aggregations})\nbureau_agg.columns = pd.Index(['BURO_' + col[0] + \"_\" + col[1].upper() for col in bureau_agg.columns.tolist()])\n\ndel bureau, bureau_balance\ngc.collect()\ndf = pd.merge(df, bureau_agg, how='left', on='SK_ID_CURR')\ndel bureau_agg\ngc.collect()","ce4e5f3c":"for c in previous_application.columns:\n    if previous_application[c].dtypes==object:\n        LE = LabelEncoder()\n        previous_application[c] = LE.fit_transform(list(previous_application[c].values.astype('str')))\naggregations = {\n        'AMT_ANNUITY': ['min', 'max', 'mean'],\n        'AMT_APPLICATION': ['min', 'max', 'mean'],\n        'AMT_CREDIT': ['min', 'max', 'mean'],\n        'APP_CREDIT_PERC': ['min', 'max', 'mean', 'var'],\n        'AMT_DOWN_PAYMENT': ['min', 'max', 'mean'],\n        'AMT_GOODS_PRICE': ['min', 'max', 'mean'],\n        'HOUR_APPR_PROCESS_START': ['min', 'max', 'mean'],\n        'RATE_DOWN_PAYMENT': ['min', 'max', 'mean'],\n        'DAYS_DECISION': ['min', 'max', 'mean'],\n        'CNT_PAYMENT': ['mean', 'var'],\n    }\nprev_agg = previous_application.groupby('SK_ID_CURR').agg({**aggregations})\nprev_agg.columns = pd.Index(['PREV_' + col[0] + \"_\" + col[1].upper() for col in prev_agg.columns.tolist()])\n\ndel previous_application\ngc.collect()\ndf = pd.merge(df,prev_agg, how='left', on='SK_ID_CURR')\n# df = df.join(bureau, how='left', on='SK_ID_CURR')\n\ndel prev_agg\ngc.collect()","b06555e3":"for c in POS_CASH_balance.columns:\n    if POS_CASH_balance[c].dtypes==object:\n        LE = LabelEncoder()\n        POS_CASH_balance[c] = LE.fit_transform(list(POS_CASH_balance[c].values.astype('str')))\naggregations = {\n        'MONTHS_BALANCE': ['max', 'mean', 'size'],\n        'SK_DPD': ['max', 'mean', 'var'],\n        'SK_DPD_DEF': ['max', 'mean', 'var']\n    }\npos_agg = POS_CASH_balance.groupby('SK_ID_CURR').agg(aggregations)\npos_agg.columns = pd.Index(['POS_' + col[0] + \"_\" + col[1].upper() for col in pos_agg.columns.tolist()])\npos_agg['POS_COUNT'] = POS_CASH_balance.groupby('SK_ID_CURR').size()\ndel POS_CASH_balance\ngc.collect()\ndf = pd.merge(df,pos_agg, how='left', on='SK_ID_CURR')\ndel pos_agg\ngc.collect()","a136dba0":"for c in installments_payments.columns:\n    if installments_payments[c].dtypes==object:\n        LE = LabelEncoder()\n        installments_payments[c] = LE.fit_transform(list(installments_payments[c].values.astype('str')))\n\naggregations = {\n        'NUM_INSTALMENT_VERSION': ['nunique'],\n        'DPD': ['max', 'mean', 'sum'],\n        'DBD': ['max', 'mean', 'sum'],\n        'PAYMENT_PERC': ['max', 'mean', 'sum', 'var'],\n        'PAYMENT_DIFF': ['max', 'mean', 'sum', 'var'],\n        'AMT_INSTALMENT': ['max', 'mean', 'sum'],\n        'AMT_PAYMENT': ['min', 'max', 'mean', 'sum'],\n        'DAYS_ENTRY_PAYMENT': ['max', 'mean', 'sum']\n    }\nins_agg = installments_payments.groupby('SK_ID_CURR').agg(aggregations)\nins_agg.columns = pd.Index(['INSTAL_' + col[0] + \"_\" + col[1].upper() for col in ins_agg.columns.tolist()])\n\nins_agg['INSTAL_COUNT'] = installments_payments.groupby('SK_ID_CURR').size()\ndel installments_payments\ngc.collect()        \ndf = pd.merge(df,ins_agg, how='left', on='SK_ID_CURR')\ndel ins_agg\ngc.collect()","9e8b8a7a":"for c in credit_card_balance.columns:\n    if credit_card_balance[c].dtypes==object:\n        LE = LabelEncoder()\n        credit_card_balance[c] = LE.fit_transform(list(credit_card_balance[c].values.astype('str')))\ncredit_card_balance.drop(['SK_ID_PREV'], axis= 1, inplace = True)\ncc_agg = credit_card_balance.groupby('SK_ID_CURR').agg(['min', 'max', 'mean', 'sum', 'var'])\ncc_agg.columns = pd.Index(['CC_' + col[0] + \"_\" + col[1].upper() for col in cc_agg.columns.tolist()])\ncc_agg['CC_COUNT'] = credit_card_balance.groupby('SK_ID_CURR').size()\n\ndf = pd.merge(df,cc_agg, how='left', on='SK_ID_CURR')\ndel credit_card_balance, cc_agg\ngc.collect()","2a533a04":"df_train, df_test = df.iloc[:len(application_train)], df.iloc[len(application_train):]\ndel application_train, application_test, df\ngc.collect()","cf0d202c":"from sklearn.model_selection import StratifiedKFold\nfrom lightgbm import LGBMClassifier\nfolds = StratifiedKFold(n_splits= 10, shuffle=True, random_state=2020)\nsub_preds = np.zeros(df_test.shape[0])\nfeats = [f for f in df_train.columns if f not in ['TARGET','SK_ID_CURR','SK_ID_BUREAU','SK_ID_PREV','index']]\n\nfor n_fold, (train_idx, valid_idx) in enumerate(folds.split(df_train[feats], df_train['TARGET'])):\n    train_x, train_y = df_train[feats].iloc[train_idx], df_train['TARGET'].iloc[train_idx]\n    valid_x, valid_y = df_train[feats].iloc[valid_idx], df_train['TARGET'].iloc[valid_idx]\n\n    lgb = LGBMClassifier(nthread=4, n_estimators=12000, learning_rate=0.02, num_leaves=31,\n        colsample_bytree=0.85,subsample=0.9, max_depth=8, reg_alpha=0.0415, reg_lambda=0.073,\n        min_split_gain=0.022, min_child_weight=39.32, silent=-1, verbose=-1)\n\n    lgb.fit(train_x, train_y, eval_set=[(train_x, train_y), (valid_x, valid_y)], \n        eval_metric= 'auc', verbose= 200, early_stopping_rounds= 100)\n\n    sub_preds += lgb.predict_proba(df_test[feats], num_iteration=lgb.best_iteration_)[:, 1] \/ folds.n_splits\n\n    del lgb, train_x, train_y, valid_x, valid_y\n    gc.collect()\n\ndf_test['TARGET'] = sub_preds","9f5ad540":"df_test[['SK_ID_CURR', 'TARGET']].to_csv('submission', index= False)","9796a15c":"# Correlation","0cb430c0":"# KFold cross validation lgb modeling","3bd1f757":"# Did the client requested insurance?","834a2e89":"# Old or New Client","28f5e044":"# Contract product type","2745d7b8":"# Feature Importance using xgboost","61a356fb":"# Preprocessing and Feature Engineering","9f4e4660":"# Distribution of AMT_INCOME_TOTAL","93b7f028":"# Distribution of AMT_GOODS_PRICE","3da5931e":"# Distribution of Occupaiton Type","0445a66d":"# Distribution of AMT_CREDIT","e1cb634e":"# Types of Organizations","a59884d1":"# Distribution of target (balanced or imbalanced)"}}