{"cell_type":{"abf2c9ef":"code","6478a10f":"code","ffa7d58f":"code","4e5118ce":"code","66f0a615":"code","8d30d349":"code","6641df06":"code","2419c0e8":"code","65c5e18e":"code","8b57db10":"code","7afdea52":"code","eb352720":"code","70bf0b39":"code","0404e00e":"code","778a4102":"code","c3a787b2":"code","43143da1":"code","fe3093c6":"code","ea657683":"code","1f72714e":"code","c3248bfb":"code","1fd5427e":"code","3c743c81":"code","42decc08":"code","90cc2399":"code","22a7d99f":"code","7d8b3d16":"code","98df909e":"code","264b5ea9":"code","fcdfb8ed":"markdown","6023c122":"markdown","d40ebbf2":"markdown","fc9c8870":"markdown","a7615054":"markdown","b6f30ed5":"markdown"},"source":{"abf2c9ef":"import pandas as pd \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n%matplotlib inline","6478a10f":"df = pd.read_csv('..\/input\/new-york-city-airbnb-open-data\/AB_NYC_2019.csv')\ndf = df[['latitude','longitude','minimum_nights','number_of_reviews','reviews_per_month','calculated_host_listings_count','availability_365','price']]\ndf.info()","ffa7d58f":"# question 1. check for missing values\ndf.isnull().sum()","4e5118ce":"print(\"reviews_per_month has {0} missing values\".format(df['reviews_per_month'].isnull().sum()))","66f0a615":"# question 2. what's the median (50% percentile) for the variable 'minimum_nights'?\nprint(\"The median for minimum_nights is {}\".format(df['minimum_nights'].median()))","8d30d349":"# split the data 60\/20\/20 \nnp.random.seed(42)\n\nn = len(df)\n\nn_val = int(0.2 * n)\nn_test = int(0.2 * n)\nn_train = n - (n_val + n_test)\n\nidx = np.arange(n)\nnp.random.shuffle(idx)\n\ndf_shuffled = df.iloc[idx]\n\ndf_train = df_shuffled.iloc[:n_train].copy()\ndf_val = df_shuffled.iloc[n_train:n_train+n_val].copy()\ndf_test = df_shuffled.iloc[n_train+n_val:].copy()\n\n# separate price from the original dataframe\ny_train_orig = df_train.price.values\ny_val_orig = df_val.price.values\ny_test_orig = df_test.price.values\n\ny_train = np.log1p(df_train.price.values)\ny_val = np.log1p(df_val.price.values)\ny_test = np.log1p(df_test.price.values)\n\ndel df_train['price']\ndel df_val['price']\ndel df_test['price']","6641df06":"def train_linear_regression(X, y):\n    ones = np.ones(X.shape[0])\n    X = np.column_stack([ones, X])\n\n    XTX = X.T.dot(X)\n    XTX_inv = np.linalg.inv(XTX)\n    w = XTX_inv.dot(X.T).dot(y)\n    \n    return w[0], w[1:]","2419c0e8":"# independent variables in the regression\nbase = ['latitude', 'longitude', 'minimum_nights', 'number_of_reviews', 'reviews_per_month', 'calculated_host_listings_count', 'availability_365']","65c5e18e":"def prepare_X_0(df):\n    df_num = df[base]\n    df_num = df_num.fillna(0)\n    X = df_num.values\n    return X","8b57db10":"def prepare_X_mean(df):\n    df_num = df[base]\n    df_num = df_num.fillna(df[base].mean())\n    X = df_num.values\n    return X","7afdea52":"def rmse(y, y_pred):\n    error = y_pred - y\n    mse = (error ** 2).mean()\n    return np.sqrt(mse)","eb352720":"# question 3. handle missing values - fill with 0\nX_train = prepare_X_0(df_train)\nw_0, w = train_linear_regression(X_train, y_train)\ny_pred = w_0 + X_train.dot(w)","70bf0b39":"plt.figure(figsize=(6, 4))\n\nsns.histplot(y_train, label='target', color='#222222', alpha=0.6, bins=40)\nsns.histplot(y_pred, label='prediction', color='#aaaaaa', alpha=0.8, bins=40)\n\nplt.legend()\n\nplt.ylabel('Frequency')\nplt.xlabel('Log(Price + 1)')\nplt.title('AirBnB Predictions vs actual distribution filling missing values with 0')\n\nplt.show()","0404e00e":"print('RMSE on the training set when filling missing values with 0 {}'.format(round(rmse(y_train, y_pred), 2)))","778a4102":"X_val = prepare_X_0(df_val)\ny_pred = w_0 + X_val.dot(w)","c3a787b2":"print('RMSE on the validation set when filling missing values with 0 {}'.format(round(rmse(y_val, y_pred), 2)))","43143da1":"# question 3. handle missing values - fill with mean\n#df_train['reviews_per_month'].fillna(df_train[\"reviews_per_month\"].mean())\nX_train = prepare_X_mean(df_train)\nw_0, w = train_linear_regression(X_train, y_train)\ny_pred = w_0 + X_train.dot(w)","fe3093c6":"plt.figure(figsize=(6, 4))\n\nsns.histplot(y_train, label='target', color='#222222', alpha=0.6, bins=40)\nsns.histplot(y_pred, label='prediction', color='#aaaaaa', alpha=0.8, bins=40)\n\nplt.legend()\n\nplt.ylabel('Frequency')\nplt.xlabel('Log(Price + 1)')\nplt.title('AirBnB Predictions vs actual distribution filling missing values with the mean')\n\nplt.show()","ea657683":"print('RMSE on the training set when filling missing values with the mean {}'.format(round(rmse(y_train, y_pred), 2)))","1f72714e":"X_val = prepare_X_mean(df_val)\ny_pred = w_0 + X_val.dot(w)","c3248bfb":"print('RMSE on the validation set when filling missing values with mean {}'.format(round(rmse(y_val, y_pred), 2)))","1fd5427e":"print(\"Got the same results on the training set when filling missing values with 0 and rounding to 2 decimal places, RMSE=0.64, and when filling missing values with the mean and rounding to 2 decimal places, RMSE=0.64\")","3c743c81":"print(\"Got the same results on the validation set when filling missing values with 0 and rounding to 2 decimal places, RMSE=0.64, and when filling missing values with the mean and rounding to 2 decimal places, RMSE=0.64\")","42decc08":"def train_linear_regression_reg(X, y, r=0.0):\n    ones = np.ones(X.shape[0])\n    X = np.column_stack([ones, X])\n\n    XTX = X.T.dot(X)\n    reg = r * np.eye(XTX.shape[0])\n    XTX = XTX + reg\n\n    XTX_inv = np.linalg.inv(XTX)\n    w = XTX_inv.dot(X.T).dot(y)\n    \n    return w[0], w[1:]","90cc2399":"# question 4,. which r gives the best RMSE?\n# fill missing values with 0\nX_train = prepare_X_0(df_train)\nX_val = prepare_X_0(df_val)\n\nr_values = [0, 0.000001, 0.0001, 0.001, 0.01, 0.1, 1, 5, 10]\ntrain_rmses = []\nval_rmses = []\n\nfor r in r_values:\n    w_0, w = train_linear_regression_reg(X_train, y_train, r=r)\n    y_pred_train = w_0 + X_train.dot(w)\n    y_pred_val = w_0 + X_val.dot(w)\n    print('r = {0}, w_0 = {1}, w[1:]= {2}'.format(r, w_0, w[1:]))\n    train_rmses.append(round(rmse(y_train, y_pred_train),2))\n    print('train RMSE = {0}'.format(round(rmse(y_train, y_pred_train),2)))\n    val_rmses.append(round(rmse(y_val, y_pred_val),2))\n    print('val RMSE = {0}'.format(round(rmse(y_val, y_pred_val),2)))","22a7d99f":"print('The lowest training RMSE = {0} was produced by r = {1}'.format(min(train_rmses), r_values[train_rmses.index(min(train_rmses))]))\nprint('The lowest validation RMSE = {0} was produced by r = {1}'.format(min(val_rmses), r_values[val_rmses.index(min(val_rmses))]))\nprint('Note: When rounding to 2 decimal places, we get the same results on the validation RMSE for r=0, r=0.000001, r=0.0001, and r=0.01 of 0.64')","7d8b3d16":"# question 5. try changing the seed\n\nseed_lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ntrain_rmses = []\nval_rmses = []\n\nfor i in seed_lst:\n    \n    np.random.seed(i)\n    \n    n = len(df)\n\n    n_val = int(0.2 * n)\n    n_test = int(0.2 * n)\n    n_train = n - (n_val + n_test)\n\n    idx = np.arange(n)\n    np.random.shuffle(idx)\n\n    df_shuffled = df.iloc[idx]\n\n    df_train = df_shuffled.iloc[:n_train].copy()\n    df_val = df_shuffled.iloc[n_train:n_train+n_val].copy()\n    df_test = df_shuffled.iloc[n_train+n_val:].copy()\n\n    # separate price from the original dataframe\n    y_train_orig = df_train.price.values\n    y_val_orig = df_val.price.values\n    y_test_orig = df_test.price.values\n\n    y_train = np.log1p(df_train.price.values)\n    y_val = np.log1p(df_val.price.values)\n    y_test = np.log1p(df_test.price.values)\n\n    del df_train['price']\n    del df_val['price']\n    del df_test['price']\n    \n    X_train = prepare_X_0(df_train)\n    w_0, w = train_linear_regression(X_train, y_train)\n    y_pred_train = w_0 + X_train.dot(w)\n    \n    train_rmses.append(rmse(y_train, y_pred_train))\n    \n    X_val = prepare_X_0(df_val)\n    y_pred_val = w_0 + X_val.dot(w)\n    \n    val_rmses.append(rmse(y_val, y_pred_val))\n    \n    print('Using seed = {0}, Train RMSE = {1}, Validation RMSE = {2}'.format(i, rmse(y_train, y_pred_train), rmse(y_val, y_pred_val)))","98df909e":"print('The standard deviation of the Validation RMSEs is {0}'.format(round(np.std(val_rmses),3)))","264b5ea9":"# question 6. Split the data set 60\/20\/20, use seed=9, fill missing values with 0, combine the training and validation datasets, and train the model with r=0.001\n\nnp.random.seed(9)\n\n# split the data 60\/20\/20 \n\nn = len(df)\n\nn_val = int(0.2 * n)\nn_test = int(0.2 * n)\nn_train = n - (n_val + n_test)\n\nidx = np.arange(n)\nnp.random.shuffle(idx)\n\ndf_shuffled = df.iloc[idx]\n\ndf_train = df_shuffled.iloc[:n_train].copy()\ndf_val = df_shuffled.iloc[n_train:n_train+n_val].copy()\ndf_test = df_shuffled.iloc[n_train+n_val:].copy()\n\n# separate price from the original dataframe\ny_train_orig = df_train.price.values\ny_val_orig = df_val.price.values\ny_test_orig = df_test.price.values\n\ny_train = np.log1p(df_train.price.values)\ny_val = np.log1p(df_val.price.values)\ny_test = np.log1p(df_test.price.values)\n\ndel df_train['price']\ndel df_val['price']\ndel df_test['price']\n\n# combine training and validation datasets\ndf_train_val = pd.concat([df_train, df_val])\ny_train_val = np.concatenate([y_train, y_val])\n\nX_train_val = prepare_X_0(df_train_val)\nw_0, w = train_linear_regression_reg(X_train_val, y_train_val, r=0.001)\ny_train_val_pred = w_0 + X_train_val.dot(w)\n\nprint('RMSE on the combined training\/validation set is {0}'.format(round(rmse(y_train_val, y_train_val_pred),3)))\n\nX_test = prepare_X_0(df_test)\ny_test_pred = w_0 + X_test.dot(w)\n\nprint('RMSE on the test set is {0}'.format(round(rmse(y_test, y_test_pred),3)))","fcdfb8ed":"# Fill missing values with the mean","6023c122":"Read in New York City Airbnb Open Data from 2019","d40ebbf2":"# Fill missing values with 0","fc9c8870":"# Linear Regression from Class","a7615054":"# Calculate RMSE","b6f30ed5":"# Regularization"}}