{"cell_type":{"8e75fe30":"code","2329b0d8":"code","ec1896a7":"code","a6ab7001":"code","3f173ea1":"code","93368591":"code","b47e64f7":"code","999e7f79":"code","4e801260":"code","0a32ed3d":"code","c5f20657":"code","2b976577":"code","f4f9d923":"code","e87ad318":"code","470c3953":"code","3aaad706":"code","7b1ad70b":"code","b2bb155e":"code","f3faf0c4":"code","6972ca45":"code","5832819f":"code","13a333d1":"code","d9c9c474":"code","3fb2a1f6":"code","43db3e2e":"code","261df2a2":"code","7575e23b":"code","350c6338":"code","314ab499":"code","013bf42d":"code","bb6f0e62":"code","b3e4dc91":"code","c3d71009":"code","2e7b82b1":"code","98445b57":"code","4cd48054":"code","fac3f76c":"code","fec8803b":"code","08a28002":"code","4c5670f4":"code","7e076202":"markdown","3f4062ba":"markdown","fc680616":"markdown","9f97e918":"markdown","6972dc66":"markdown","c58848ee":"markdown","bea47250":"markdown","5419dee9":"markdown","c8dbd239":"markdown","5fcc21ef":"markdown","4ed7dc11":"markdown","16d986d2":"markdown","dd29f9eb":"markdown","1f338d67":"markdown","6aaeb254":"markdown","ecd970d6":"markdown","2cb6ab79":"markdown","13ef71fc":"markdown","f5cc86ce":"markdown","c8e700d5":"markdown","505bd080":"markdown","e3dd4326":"markdown","c4f6ee79":"markdown","be2d43f0":"markdown","421a046a":"markdown","6bd7ce99":"markdown","90b0e97a":"markdown","69c4f2e8":"markdown","f8008c93":"markdown","fe54630f":"markdown","83865f76":"markdown","cced84b2":"markdown","66259bf6":"markdown","726a6fcd":"markdown","6bd0770c":"markdown","5f330c78":"markdown","695ece77":"markdown","e52e27e5":"markdown","00d39648":"markdown","f57d6c8c":"markdown","6a540ae4":"markdown","707bdf44":"markdown","faf2f2b3":"markdown","20c9461b":"markdown","1e7ce257":"markdown","8e8357ab":"markdown","0fae63a6":"markdown","a7982ad3":"markdown"},"source":{"8e75fe30":"!pip install segmentation-models-pytorch","2329b0d8":"import os\nimport numpy as np\nimport pandas as pd\nimport torch\nimport cv2\nimport collections\nimport segmentation_models_pytorch as smp\nimport albumentations as albu\nimport torch\nimport seaborn as sns\n\nfrom torch.utils.data import DataLoader\nfrom sklearn.model_selection import train_test_split\nfrom glob import glob\nfrom os import path\nfrom PIL import Image\nfrom tqdm import tqdm\nfrom matplotlib import pyplot as plt\n\n%matplotlib inline","ec1896a7":"ROOT_PATH_TRAIN = '\/kaggle\/input\/imaterialist-fashion-2019-FGVC6\/train'\nDF_PATH_TRAIN = '\/kaggle\/input\/imaterialist-fashion-2019-FGVC6\/train.csv'\nPATH_TO_MODEL_WEIGHTS = '\/kaggle\/input\/za-cho-takoe-testovoe\/best_model.pth'\n\nIMAGE_SIZE = (512, 512)\nIAMGE_PREDICTION_SIZE = (256, 256)","a6ab7001":"def rle_decode(mask_rle, shape):\n    '''\n    mask_rle: run-length as string formated: [start0] [length0] [start1] [length1]... in 1d array\n    shape: (height,width) of array to return\n    Returns numpy array according to the shape, 1 - mask, 0 - background\n    '''\n    shape = (shape[1], shape[0])\n    s = mask_rle.split()\n    # gets starts & lengths 1d arrays\n    starts, lengths = [np.asarray(x, dtype=int) for x in (s[0::2], s[1::2])]\n    starts -= 1\n    # gets ends 1d array\n    ends = starts + lengths\n    # creates blank mask image 1d array\n    img = np.zeros(shape[0] * shape[1], dtype=np.uint8)\n    # sets mark pixles\n    for lo, hi in zip(starts, ends):\n        img[lo:hi] = 1\n    # reshape as a 2d mask image\n    return img.reshape(shape).T","3f173ea1":"def rle_to_string(runs):\n    return ' '.join(str(x) for x in runs)\n\ndef rle_encode(mask):\n    pixels = mask.T.flatten()\n    # We need to allow for cases where there is a '1' at either end of the sequence.\n    # We do this by padding with a zero at each end when needed.\n    use_padding = False\n    if pixels[0] or pixels[-1]:\n        use_padding = True\n        pixel_padded = np.zeros([len(pixels) + 2], dtype=pixels.dtype)\n        pixel_padded[1:-1] = pixels\n        pixels = pixel_padded\n    rle = np.where(pixels[1:] != pixels[:-1])[0] + 2\n    if use_padding:\n        rle = rle - 1\n    rle[1::2] = rle[1::2] - rle[:-1:2]\n    return rle_to_string(rle)","93368591":"def visualise_masks(image_name, real_df, predicted_df=None, r_p=ROOT_PATH_TRAIN, im_class=None):\n    # get image\n    img_path = os.path.join(r_p, image_name)\n    img = cv2.imread(img_path)\n    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)\n    img = cv2.resize(img, IMAGE_SIZE)\n    \n    # get original mask\n    if im_class is not None:\n        original_raws = real_df[(real_df['ImageId'] == image_name) & (real_df['ClassId'] == im_class)]\n    else:\n        original_raws = real_df[real_df['ImageId'] == image_name]\n                \n    o_h, o_w = int(original_raws['Height'].mean()), int(original_raws['Width'].mean())\n    \n    o_mask = np.zeros(IMAGE_SIZE)        \n        \n    for annotation in original_raws['EncodedPixels']:\n        o_mask += cv2.resize(rle_decode(annotation, (o_h, o_w)), IMAGE_SIZE)\n        \n    o_mask = (o_mask > 0.5).astype(np.uint8)\n    \n    if predicted_df is not None:\n        # get predicted mask\n        if im_class is not None:\n            predicted_raws = predicted_df[(predicted_df['ImageId'] == image_name) & (predicted_df['ClassId'] == im_class)]\n        else:\n            predicted_raws = predicted_df[predicted_df['ImageId'] == image_name]\n                \n        p_mask = np.zeros(IMAGE_SIZE)\n        \n        for annotation in predicted_raws['EncodedPixels']:\n            p_mask += rle_decode(annotation, IMAGE_SIZE)\n        \n        p_mask = (p_mask > 0.5).astype(np.uint8)\n    \n    fig=plt.figure(figsize=(20, 20))\n    fig.add_subplot(1, 3, 1)\n    plt.title('image')\n    plt.imshow(img)\n    fig.add_subplot(1, 3, 2)\n    plt.title('original_mask')\n    plt.imshow(o_mask)\n    \n    if predicted_df is not None:\n        fig.add_subplot(1, 3, 3)\n        plt.title('predicted_mask')\n        plt.imshow(p_mask)\n        plt.show()","b47e64f7":"train_df = pd.read_csv(DF_PATH_TRAIN)\ntrain_df.head()","999e7f79":"train_df['CategoryId'] = train_df.ClassId.apply(lambda x: str(x).split(\"_\")[0])","4e801260":"plt.figure(figsize=(20, 7))\nsns.countplot(train_df['CategoryId']);","0a32ed3d":"train_df[train_df['ImageId'] == '00000663ed1ff0c4e0132b9b9ac53f6e.jpg']","c5f20657":"visualise_masks('00000663ed1ff0c4e0132b9b9ac53f6e.jpg', train_df, im_class='31')","2b976577":"def get_unique_class_id_df(inital_df):\n    temp_df = inital_df.groupby(['ImageId','ClassId'])['EncodedPixels'].agg(lambda x: ' '.join(list(x))).reset_index()\n    size_df = inital_df.groupby(['ImageId','ClassId'])['Height', 'Width'].mean().reset_index()\n    temp_df = temp_df.merge(size_df, on=['ImageId','ClassId'], how='left')\n    \n    return temp_df","f4f9d923":"train_df = get_unique_class_id_df(train_df)","e87ad318":"train_df[train_df['ImageId'] == '00000663ed1ff0c4e0132b9b9ac53f6e.jpg']","470c3953":"visualise_masks('00000663ed1ff0c4e0132b9b9ac53f6e.jpg', train_df, im_class='31')","3aaad706":"def create_one_represent_class(df_param):\n    v_c_df = df_param['CategoryId'].value_counts().reset_index()\n    one_represent = v_c_df.loc[v_c_df['CategoryId'] == 1, 'index'].tolist()\n    df_param.loc[df_param['CategoryId'].isin(one_represent), 'CategoryId'] = 'one_represent'\n    return df_param\n\ndef custom_train_test_split(df_param):\n    \n    df_param['CategoryId'] = df_param.ClassId.apply(lambda x: str(x).split(\"_\")[0])\n    \n    img_categ = train_df.groupby('ImageId')['CategoryId'].apply(list).reset_index()\n    img_categ['CategoryId'] = img_categ['CategoryId'].apply(lambda x: ' '.join(sorted(x)))\n    \n    img_categ = create_one_represent_class(img_categ)\n    \n    img_train, img_val  = train_test_split(img_categ, test_size=0.2, random_state=42, stratify=img_categ['CategoryId'])\n    \n    df_param = df_param.drop(columns='CategoryId')\n    \n    df_train = df_param[df_param['ImageId'].isin(img_train['ImageId'])].reset_index(drop=True)\n    df_val = df_param[df_param['ImageId'].isin(img_val['ImageId'])].reset_index(drop=True)\n    \n    return df_train, df_val","7b1ad70b":"train_df = pd.read_csv(DF_PATH_TRAIN)\ntrain_df, val_df = custom_train_test_split(train_df)\n\ntrain_df = get_unique_class_id_df(train_df)\nval_df = get_unique_class_id_df(val_df)","b2bb155e":"plt.figure(figsize=(20, 7))\nplt.title('Train')\nsns.countplot(train_df['ClassId'].apply(lambda x: str(x).split(\"_\")[0]));","f3faf0c4":"plt.figure(figsize=(20, 7))\nplt.title('Validation')\nsns.countplot(val_df['ClassId'].apply(lambda x: str(x).split(\"_\")[0]));","6972ca45":"class UnetDataset(torch.utils.data.Dataset):\n    def __init__(self, image_dir, df, height, width, augmentation=None, preprocessing=None):\n        \n        self.preprocessing = preprocessing\n        self.augmentation = augmentation\n        \n        self.image_dir = image_dir\n        self.df = df\n        \n        self.height = height\n        self.width = width\n        \n        self.image_info = collections.defaultdict(dict)\n        \n        self.df['CategoryId'] = self.df.ClassId.apply(lambda x: str(x).split(\"_\")[0])\n        self.num_classes = self.df['CategoryId'].nunique()\n        \n        temp_df = self.df.groupby('ImageId')['EncodedPixels', 'CategoryId'].agg(lambda x: list(x)).reset_index()\n        size_df = self.df.groupby('ImageId')['Height', 'Width'].mean().reset_index()\n        temp_df = temp_df.merge(size_df, on='ImageId', how='left')\n        \n        for index, row in tqdm(temp_df.iterrows(), total=len(temp_df)):\n            image_id = row['ImageId']\n            image_path = os.path.join(self.image_dir, image_id)\n            self.image_info[index][\"image_id\"] = image_id\n            self.image_info[index][\"image_path\"] = image_path\n            self.image_info[index][\"width\"] = self.width\n            self.image_info[index][\"height\"] = self.height\n            self.image_info[index][\"labels\"] = row[\"CategoryId\"]\n            self.image_info[index][\"orig_height\"] = row[\"Height\"]\n            self.image_info[index][\"orig_width\"] = row[\"Width\"]\n            self.image_info[index][\"annotations\"] = row[\"EncodedPixels\"]\n\n    def __getitem__(self, idx):\n        \n        img_path = self.image_info[idx][\"image_path\"]\n        \n        img = cv2.imread(img_path)\n        img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)\n        img = cv2.resize(img, (self.width, self.height))\n        \n        # apply preprocessing\n        if self.preprocessing is not None:\n            img = self.preprocessing(image=img)['image']\n            \n        return img, os.path.basename(img_path)\n\n    def __len__(self):\n        return len(self.image_info)","5832819f":"def to_tensor(x, **kwargs):\n    return x.transpose(2, 0, 1).astype('float32')\n\ndef get_preprocessing(preprocessing_fn):\n    \"\"\"Construct preprocessing transform\n    \n    Args:\n        preprocessing_fn (callbale): data normalization function \n            (can be specific for each pretrained neural network)\n    Return:\n        transform: albumentations.Compose\n    \n    \"\"\"\n    \n    _transform = [\n        albu.Lambda(image=preprocessing_fn),\n        albu.Lambda(image=to_tensor, mask=to_tensor),\n    ]\n    return albu.Compose(_transform)","13a333d1":"ENCODER = 'mobilenet_v2'\nENCODER_WEIGHTS = 'imagenet'\nDEVICE = 'cuda'\n\nACTIVATION = 'sigmoid'","d9c9c474":"model = smp.Unet(\n    encoder_name=ENCODER, \n    encoder_weights=ENCODER_WEIGHTS, \n    classes=46, \n    activation=ACTIVATION,\n)\n\npreprocessing_fn = smp.encoders.get_preprocessing_fn(ENCODER, ENCODER_WEIGHTS)","3fb2a1f6":"model.load_state_dict(torch.load(PATH_TO_MODEL_WEIGHTS, \n                                 map_location=torch.device(DEVICE)))","43db3e2e":"model = model.to(DEVICE)\nmodel.eval();","261df2a2":"test_dataset = UnetDataset(\n    ROOT_PATH_TRAIN,\n    val_df,\n    IAMGE_PREDICTION_SIZE[0],\n    IAMGE_PREDICTION_SIZE[0], \n    preprocessing=get_preprocessing(preprocessing_fn),\n)\n\ntest_loader = DataLoader(test_dataset, batch_size=32, shuffle=False, num_workers=2)","7575e23b":"def create_final_df(result_dict):\n    final_df = {'ImageId':[], 'EncodedPixels':[], 'ClassId':[]}\n    for im_name, im_dict in result_dict.items():\n        final_df['ImageId'] += [im_name]*len(im_dict)\n        for cls_id, enc_p in im_dict.items():\n            final_df['EncodedPixels'].append(enc_p)\n            final_df['ClassId'].append(cls_id)\n            \n    return pd.DataFrame(final_df)\n\nclass InfernceModel(object):\n    def __init__(self, nn_model, device, output_size=(512,512), threshold=0.5, size_min_mask=250):\n        self.nn_model = nn_model\n        self.output_size = output_size\n        self.threshold = threshold\n        self.size_min_mask = size_min_mask\n        self.device = device\n        \n    def __call__(self, inf_dataloader):\n        result = {}\n        with torch.no_grad():\n            for batch in tqdm(inf_dataloader, \n                              total=len(inf_dataloader.dataset) \/\/ inf_dataloader.batch_size):\n                names = batch[1]\n                batch = model(batch[0].to(self.device)).detach().cpu().numpy()\n                for idx in range(batch.shape[0]):\n                    cur_result = self.post_process(batch[idx])\n                    if len(cur_result) > 0:\n                        result[names[idx]] = cur_result\n                        \n        final_df = create_final_df(result) \n        final_df['Height'] = self.output_size[0]\n        final_df['Width'] = self.output_size[1]\n        final_df['ClassId'] = final_df['ClassId'].astype(str)\n                    \n        return final_df\n        \n    def post_process(self, mask):\n        rle_mask = {}\n        for idx in range(mask.shape[0]):\n            item_mask = mask[idx]\n            \n            item_mask = (item_mask > self.threshold).astype(np.uint8)\n            item_mask = cv2.resize(item_mask, self.output_size)\n            \n            if item_mask.sum() < self.size_min_mask:\n                continue\n            else:\n                rle_mask[str(idx)] = rle_encode(item_mask)\n            \n        return rle_mask","350c6338":"inf_model = InfernceModel(nn_model=model, device=DEVICE)","314ab499":"predicted_df = inf_model(test_loader)","013bf42d":"predicted_df.head()","bb6f0e62":"visualise_masks('000b3a87508b0fa185fbd53ecbe2e4c6.jpg', val_df, predicted_df)","b3e4dc91":"visualise_masks('fffc631acce2e28e1628de685d40c980.jpg', val_df, predicted_df)","c3d71009":"visualise_masks('ffec8295f37df6ea12eecbb60d2c23d4.jpg', val_df, predicted_df)","2e7b82b1":"visualise_masks('001039acb67251508b1b32fd37a49f43.jpg', val_df, predicted_df, im_class='31')","98445b57":"visualise_masks('005ccdb239e2d6cfe62506dd6eb5693e.jpg', val_df, predicted_df, im_class='10')","4cd48054":"visualise_masks('000cd2e13d1bdd28f480304d7bb9e1ca.jpg', val_df, predicted_df, im_class='23')","fac3f76c":"visualise_masks('05e6ef19957d43524d972de6d2f41b57.jpg', val_df, predicted_df, im_class='45')","fec8803b":"# mainly from here https:\/\/www.kaggle.com\/kyazuki\/calculate-evaluation-score\n\ndef IoU(A,B):\n    AorB = np.logical_or(A,B).astype('int')\n    AandB = np.logical_and(A,B).astype('int')\n    IoU = AandB.sum() \/ AorB.sum()\n    return IoU\n\ndef IoU_threshold(data):\n    # Note: This rle_to_mask should be called before loop below for speed-up! We currently implement here to reduse memory usage.\n    mask_gt = rle_decode(data['EncodedPixels_true'], (int(data['Height_true']), int(data['Width_true'])))\n    mask_pred = rle_decode(data['EncodedPixels_pred'], (int(data['Height_pred']), int(data['Width_pred'])))\\\n    \n    if (int(data['Height_true']), int(data['Width_true'])) != IMAGE_SIZE:\n        mask_gt = cv2.resize(mask_gt, IMAGE_SIZE)\n    if (int(data['Height_pred']), int(data['Width_pred'])) != IMAGE_SIZE:\n        mask_pred = cv2.resize(mask_pred, IMAGE_SIZE)\n    \n    mask_gt = mask_gt > 0.5\n    mask_pred = mask_pred > 0.5\n    \n    return IoU(mask_gt, mask_pred)\n\ndef best_metric(true_df, pred_df):\n    eval_df = pd.merge(true_df, pred_df, how='outer', on=['ImageId', 'ClassId'], suffixes=['_true', '_pred'])\n\n    # IoU for True Positive\n    idx_ = eval_df['EncodedPixels_true'].notnull() & eval_df['EncodedPixels_pred'].notnull()\n    IoU = eval_df[idx_].apply(IoU_threshold, axis=1)\n\n    # False Positive\n    fp = (eval_df['EncodedPixels_true'].isnull() & eval_df['EncodedPixels_pred'].notnull()).sum()\n\n    # False Negative\n    fn = (eval_df['EncodedPixels_true'].notnull() & eval_df['EncodedPixels_pred'].isnull()).sum()\n\n    threshold_IoU = np.arange(0.5, 1.0, 0.05)\n    scores = []\n    for th in threshold_IoU:\n        # True Positive\n        tp = (IoU > th).sum()\n        iou_fp = (IoU <= th).sum()\n\n        # False Positive (not Ground Truth) + False Positive (under IoU threshold)\n        fp = fp + iou_fp\n\n        # Calculate evaluation score\n        score = tp \/ (tp + fp + fn)\n        scores.append(score)\n\n    mean_score = sum(scores) \/ len(threshold_IoU)\n    return mean_score","08a28002":"images_to_count_metric = val_df['ImageId'].unique()[:100]\n\nbest_metric(val_df[val_df['ImageId'].isin(images_to_count_metric)], val_df[val_df['ImageId'].isin(images_to_count_metric)])","4c5670f4":"best_metric(val_df, predicted_df)","7e076202":"Moreover in our dataframe we have to have unique pair (ImageId, ClassId) but in our initial dataframe we have each pair for each mask segment.\nIn the following example we have duplicates with ClassId - 31, 32","3f4062ba":"* Use MaskRCNN or other appropriate architecture for biag amount of classes\n* Use bigger backbone\n* Train until Net converged\n* Use bigger augmentations\n* Tune net hyperparams\n* Use TwoHead Net\n* Use Test Time Augmentations\n* Use Blending\n\nAnd so on ....","fc680616":"Why we did not do all this stuff\n\nBecause\n\n* 30 hours per week of railway\n* one GPU per account\n* execution - up to 6 hours","9f97e918":"# DL part","6972dc66":"![](https:\/\/pbs.twimg.com\/media\/CnN1pRvUAAA0lWq.jpg)","c58848ee":"## Dataset","bea47250":"Firstly, on all classes together","5419dee9":"## Preprocessing","c8dbd239":"![Unet](https:\/\/i.stack.imgur.com\/DjXVU.png)","5fcc21ef":"# Imports","4ed7dc11":"We will use classical Unet architecture with mobilenet backbone, pretrained on ImageNet. Why ?\n* Unet is classic\n* Backbone is light enough to train it in Kaggle Kernel","16d986d2":"# Constants","dd29f9eb":"Got it. Also these masks are huge enough for our week net","1f338d67":"Not very good results for these masks","6aaeb254":"Now lets look at different CategoryID","ecd970d6":"## Model","2cb6ab79":"# Inference","13ef71fc":"# Final thoughts or kozaki pishut pismo BESTu","f5cc86ce":"In our Classid we have Category id and it's attributes. Predicting attributes is a really hard stuff and competion best practises showed that in most cases it will only harm the perfomence of your Neural Net. So we will lets get Category id","c8e700d5":"But as for smaller masks and less frequent","505bd080":"We have images with different cloth parts and we have to identify cloth id and attributes","e3dd4326":"# Utils fucntions","c4f6ee79":"So lets fix it","be2d43f0":"EVERYTHING","421a046a":"Lets test it","6bd7ce99":"And now evaluate our prediction","90b0e97a":"## What can be improved","69c4f2e8":"We think that such format of test task is one of the worst variants. Why ?\n* This task requires Deep Learning background, which is overkill for contest, where most participants are students \n* Even if participant has Deep Learning background, he\/she will need a lot of computational resources (GPUs), which cost money or use his\/her GPU Quota on Kaggle\n* Metric and Train\/Test were not provided. So all participants will have hardly biased results. It is important, because evaluating DL\/ML\/DS tasks by 'beautiful code' or 'interesting approach' or something like this is not the best practice. Of course, these criteria should be taken into account, but main criteria is target metric !","f8008c93":"We will use classical deep learning approach. We will use this [awesome framework](https:\/\/github.com\/qubvel\/segmentation_models.pytorch)","fe54630f":"We will make train\/test split on Classid combinations ","83865f76":"So now we are ready for DEEEEEEEEEEEEEEEEEEEEEEEEEEEEEep Learning","cced84b2":"## Evaluate results","66259bf6":"Firstly, on some frequent","726a6fcd":"# Dataloader","6bd0770c":"We have trained our Net only for 2 epochs (Kaggle Kernel limitation on time)\n* With Dice Loss\n* With Horizontal and Vertical flip augmentations\n* With Adam optimizer\n* Data was normalized by ImageNet stats","5f330c78":"### Metric","695ece77":"# Train\/Test split","e52e27e5":"Lets take a look on our categoryid distribution","00d39648":"![](http:\/\/static.issue.life\/Content\/img\/17-03-2019\/636884100747932656.png)","f57d6c8c":"# Starting points","6a540ae4":"# Data exploration","707bdf44":"### Visualize","faf2f2b3":"Awesome matching !!!","20c9461b":"# Power Rangers Solution","1e7ce257":"So we get some main cloth parts","8e8357ab":"# pip installs","0fae63a6":"![](https:\/\/zaxid.net\/resources\/photos\/news\/640x360_DIR\/201511\/1371769.jpg?201805281755)","a7982ad3":"Of course, it is better to have train\/validation\/test datasets. But now we will stop on train\/test. Why?\n* We do not have Early Stopping and other stuff, that will overfit us\n* Orgs did not clarify this point properly "}}