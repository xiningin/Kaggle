{"cell_type":{"5bdf6a93":"code","cf12cc25":"code","ecee2ad6":"code","8c124121":"code","bce9143f":"code","40eee090":"code","4cbbc806":"code","92082735":"code","de13e8d9":"code","08fed4f9":"code","5ae997bd":"code","1d5f5d92":"code","32fbc1cb":"code","61ab656e":"code","9dd27e7c":"code","427a7e8d":"code","97f63b52":"code","37b00acc":"code","36ea8cfa":"code","5f6b8400":"code","42b672a6":"code","16b8487f":"code","66ee5b59":"code","a41b9779":"code","a1549667":"code","432935f0":"code","3ef16c4c":"code","8b7b7623":"code","bf03cf47":"code","671afd79":"code","f3e15574":"code","31f287c7":"code","9c8b398d":"code","c5cd61dc":"code","3c1f9d9a":"code","b8b5a7c1":"code","937ddf0a":"code","aead970f":"code","d2296602":"code","cf5f0775":"code","ace33f70":"code","69c06ddf":"code","d39a02e3":"code","5a62e49f":"code","5eaf3e55":"code","2ae4308d":"code","250a91a8":"code","1caf27a3":"code","d5bf7038":"code","9d87a079":"code","0fe3c4a4":"markdown","a36ac84f":"markdown","ab78370a":"markdown","c99e53db":"markdown","cd2e52fe":"markdown","d5743b5a":"markdown","dd801fbe":"markdown","b10b8c29":"markdown","697233df":"markdown","2ab46e00":"markdown","f976294e":"markdown","d6fb4f8b":"markdown","7a7a0e86":"markdown","6c17de12":"markdown","9b4cf975":"markdown","e8f61884":"markdown"},"source":{"5bdf6a93":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt # visualization data\nimport math\n\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","cf12cc25":"raw_data = pd.read_csv(\"..\/input\/bitcoin-historical-data\/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv\")","ecee2ad6":"raw_data","8c124121":"raw_data.info()","bce9143f":"raw_data.shape","40eee090":"raw_data.isna().sum()","4cbbc806":"# Except for the time_step column, we delete these rows because the other columns are NAN.","92082735":"raw_data = raw_data.dropna()","de13e8d9":"raw_data.isna().sum()","08fed4f9":"raw_data['date'] = pd.to_datetime(raw_data['Timestamp'],unit='s').dt.date\nraw_data","5ae997bd":"raw_data.info()","1d5f5d92":"grouped_data = raw_data.groupby('date', as_index = False).mean()\ngrouped_data","32fbc1cb":"# We divide the data by Training %95, Test %5 ","61ab656e":"train_size = int(len(grouped_data) * 0.95)\ntest_size = len(grouped_data) - train_size\ndf_train = grouped_data.iloc[0:train_size, :]\ndf_test = grouped_data.iloc[train_size:len(grouped_data), :]\nprint(\"Train size: {}, Test size: {}\". format(len(df_train), len(df_test)))","9dd27e7c":"df_train","427a7e8d":"df_test","97f63b52":"data_plot = grouped_data.loc[:, [\"Close\"]].values\nplt.plot(data_plot)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Values of Close\")\nplt.title(\"Bitcoin Close Prices\")\nplt.show()","37b00acc":"#we will predict Close values","36ea8cfa":"dataset = df_train.loc[:, [\"Close\"]].values\ndataset.shape","5f6b8400":"#reshape\ndataset = dataset.reshape(-1, 1)\n\n#change type\ndataset = dataset.astype(\"float32\")\ndataset.shape","42b672a6":"# Feature Scaling\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler(feature_range = (0, 1))\ndata_scaled = scaler.fit_transform(dataset)\ndata_scaled","16b8487f":"plt.plot(data_scaled)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Values of Close\")\nplt.title(\"Bitcoin Close Price (Scaled)\")\nplt.show()","66ee5b59":"# Creating a data structure with 10 time_step and 1 output\nX_train = []\ny_train = []\ntime_step = 10\nfor i in range(time_step, data_scaled.shape[0]):\n    X_train.append(data_scaled[i-time_step:i, 0])\n    y_train.append(data_scaled[i, 0])\nX_train, y_train = np.array(X_train), np.array(y_train)\n\nprint(\"X_train shape: \", X_train.shape)\nprint(\"y_train shape: \", y_train.shape)","a41b9779":"# Reshaping to 3D\nX_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))","a1549667":"print(\"X_train shape: \",X_train.shape)\nprint(\"y_train shape: \",y_train.shape)","432935f0":"### Importing the Keras libraries and packages\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import SimpleRNN\nfrom keras.layers import Dropout","3ef16c4c":"# Initialising the RNN ( with four layers)\nregressor = Sequential()\nfunction = \"relu\"\n\n# Adding the first RNN layer and some Dropout regularization\nregressor.add(SimpleRNN(units = 50, activation=function, return_sequences = True, input_shape = (X_train.shape[1], 1)))\nregressor.add(Dropout(0.2))\n\n# Adding a second RNN layer and some Dropout regularization\nregressor.add(SimpleRNN(units = 50, activation=function, return_sequences = True))\nregressor.add(Dropout(0.2))\n\n# Adding a third RNN layer and some Dropout regularization\nregressor.add(SimpleRNN(units = 50, activation=function, return_sequences = True))\nregressor.add(Dropout(0.2))\n\n# Adding a fourth RNN layer and some Dropout regularization\nregressor.add(SimpleRNN(units = 50))\nregressor.add(Dropout(0.2))\n\n# Adding the output layer\nregressor.add(Dense(units = 1))\n\n# Compiling the RNN\nregressor.compile(optimizer = 'adam', loss = 'mean_squared_error')\n\n# Fitting the RNN to the Training set\nregressor.fit(X_train, y_train, epochs = 100, batch_size = 32)\n# epoch= 100","8b7b7623":"real_bitcoin_price = df_test.loc[:, [\"Close\"]].values","bf03cf47":"real_bitcoin_price.shape","671afd79":"df_total = pd.concat((df_train['Close'], df_test['Close']), axis = 0)\ninputs = df_total[len(df_total) - len(df_test) - time_step:].values.reshape(-1,1)\ninputs = scaler.transform(inputs)  # min max scaler","f3e15574":"X_test = []\nfor i in range(time_step, inputs.shape[0]):\n    X_test.append(inputs[i-time_step:i, 0])\nX_test = np.array(X_test)\nX_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))\npredicted_bitcoin_price = regressor.predict(X_test)\npredicted_bitcoin_price = scaler.inverse_transform(predicted_bitcoin_price)\n\n# Visualising the results\nplt.plot(real_bitcoin_price, color = 'red', label = 'Real Bitcoin Price')\nplt.plot(predicted_bitcoin_price, color = 'blue', label = 'Predicted Bitcoin Price')\nplt.title('Bitcoin Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('Bitcoin Price')\nplt.legend()\nplt.show()","31f287c7":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport math\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","9c8b398d":"# We divide the data by Training %10, Test %10","c5cd61dc":"train_size = int(len(grouped_data) * 0.90)\ntest_size = len(grouped_data) - train_size\ndf_train = grouped_data.iloc[0:train_size, :]\ndf_test = grouped_data.iloc[train_size:len(grouped_data), :]\nprint(\"DF_Train size: {}, DF_Test size: {}\". format(len(df_train), len(df_test)))","3c1f9d9a":"data_plot = df_train.loc[:, [\"Close\"]].values\nplt.plot(data_plot)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Values of Close\")\nplt.title(\"Bitcoin Close Prices\")\nplt.show()","b8b5a7c1":"#we will predict Close values","937ddf0a":"dataset = df_train.loc[:, [\"Close\"]].values\ndataset.shape","aead970f":"#reshape\ndataset = dataset.reshape(-1, 1)\n\n#change type\ndataset = dataset.astype(\"float32\")\ndataset.shape","d2296602":"# Feature Scaling\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler(feature_range = (0, 1))\ndata_scaled = scaler.fit_transform(dataset)","cf5f0775":"plt.plot(data_scaled)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Values of Close\")\nplt.title(\"Bitcoin Close Price (Scaled)\")\nplt.show()","ace33f70":"# We divide the DATA_SCALED by Training %50, Test %50\ntrain_size = int(len(data_scaled) * 0.50)\ntest_size = len(data_scaled) - train_size\ndata_scaled_train = data_scaled[0:train_size, :]\ndata_scaled_test = data_scaled[train_size:len(data_scaled), :]\n\nprint(\"data_scaled_train size: {}\\ndata_scaled_test size: {}\". format(len(data_scaled_train), len(data_scaled_test)))\nprint(\"data_scaled_train shape: {}\\ndata_scaled_test shape: {}\". format(data_scaled_train.shape, data_scaled_test.shape))","69c06ddf":"# Creating a data structure with 10 time_step and 1 output (TRAIN)\ntime_step = 10\ndataX = []\ndataY = []\nfor i in range(len(data_scaled_train) - time_step - 1):\n    a = data_scaled_train[i:(i + time_step), 0]\n    dataX.append(a)\n    dataY.append(data_scaled_train[i + time_step, 0])\ntrainX = np.array(dataX)\ntrainY = np.array(dataY)\n\nprint(\"trainX shape: {}\\ntrainY shape: {}\". format(trainX.shape, trainY.shape))","d39a02e3":"# Creating a data structure with 10 time_step and 1 output (TEST)\ndataX = []\ndataY = []\nfor i in range(len(data_scaled_test) - time_step -1):\n    a = data_scaled_test[i:(i + time_step), 0]\n    dataX.append(a)\n    dataY.append(data_scaled_test[i + time_step, 0])\ntestX = np.array(dataX)\ntestY = np.array(dataY)\n\nprint(\"testX shape: {}\\ntestY shape: {}\". format(testX.shape, testY.shape))","5a62e49f":"# Reshaping to 3D\ntrainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))\ntestX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))\n\nprint(\"X_train shape: \",trainX.shape)\nprint(\"X_test shape: \",testX.shape)","5eaf3e55":"# Importing the Keras libraries and packages\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import LSTM\nfrom keras.layers import Dropout\nfrom keras.layers import Activation","2ae4308d":"# model\nmodel = Sequential()\nmodel.add(LSTM(256, input_shape = (1, time_step))) # 256 LSTM neuron(block)\nmodel.add(Dropout(0.2))\nmodel.add(Dense(1))\nmodel.compile(loss= \"mean_squared_error\", optimizer = \"adam\")\nmodel.fit(trainX, trainY, epochs=100, batch_size=50)","250a91a8":"model.summary()","1caf27a3":"trainPredict = model.predict(trainX)\ntestPredict = model.predict(testX)\n\n# invert predictions\ntrainPredict = scaler.inverse_transform(trainPredict)\ntrainY_ = scaler.inverse_transform([trainY])\ntestPredict = scaler.inverse_transform(testPredict)\ntestY_ = scaler.inverse_transform([testY])\n\n# calculate root mean squared error\ntrainscore = math.sqrt(mean_squared_error(trainY_[0], trainPredict[:, 0]))\nprint(\"Train Score: %.2f RMSE\" % (trainscore))\ntestscore = math.sqrt(mean_squared_error(testY_[0], testPredict[:, 0]))\nprint(\"Test Score: %.2f RMSE\" % (testscore))","d5bf7038":"# shifting train\ntrainPredictPlot = np.empty_like(data_scaled)\ntrainPredictPlot[:, :] = np.nan\ntrainPredictPlot[time_step:len(trainPredict) + time_step, :] = trainPredict\n# shifting test predictions for plotting\ntestPredictPlot = np.empty_like(data_scaled)\ntestPredictPlot[:, :] = np.nan\ntestPredictPlot[len(trainPredict) + (time_step * 2) + 1:len(data_scaled) - 1, :] = testPredict\n# plot baseline and predictions\nplt.plot(scaler.inverse_transform(data_scaled))\nplt.plot(trainPredictPlot)\nplt.plot(testPredictPlot)\n#plt.xlim(2500,3200)\nplt.legend()\nplt.show()","9d87a079":"# Visualising the results\nplt.plot(scaler.inverse_transform(data_scaled), color = 'red', label = 'Real Bitcoin Price')\nplt.plot(testPredictPlot, color = 'blue', label = 'Predicted Bitcoin Price')\nplt.title('Bitcoin Price Prediction')\nplt.xlabel('Time')\nplt.ylabel('Bitcoin Price')\nplt.legend()\nplt.show()","0fe3c4a4":"## Importing Libraries","a36ac84f":"## Modeling (LSTM)","ab78370a":"## Loading Data","c99e53db":"## Visualizing Data","cd2e52fe":"## Scaling Data","d5743b5a":"## Visualizing Data","dd801fbe":"# Long Short Time Memory (LSTM)","b10b8c29":"## Data Preparation","697233df":"## Prediction and Visulazation","2ab46e00":"## Scaling Data","f976294e":"## Train and Test Split","d6fb4f8b":"# Recurrent Neural Network (RNN) and Long Short Term Memory (LSTM)","7a7a0e86":"## Train and Test Split","6c17de12":"## Prediction and Visualising RNN MOdel","9b4cf975":"## Modeling (RNN)","e8f61884":"## Importing Libraries"}}