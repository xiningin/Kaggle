{"cell_type":{"1db9fb30":"code","dbbcbeeb":"markdown","9151f685":"markdown"},"source":{"1db9fb30":"import pandas as pd\nimport matplotlib.pyplot as plt\n\nimport random\nimport operator\nimport copy\n\n\ndef enter():\n    for k in temp.keys():\n        coord = input(f\"Please input a desired coordinate for {k}: \")\n        x = int(coord[0])\n        y = int(coord[2])\n\n        temp[k] = (x, y)\n\ndef check1(k):\n    important = [k]\n    for key, value in temp.items():\n        if temp[k][0] == value[0] and k != key and temp[k][1] < value[1]:\n            important.append(key)\n    return important\n\n\ndef check2(futurex):  # futurex=>4\n    stack = 0\n    for k in temp.values():\n        if k[0] == futurex:\n            stack += 1\n    return stack\n\n\ndef drop(imp):\n    imp.sort(key=lambda x: temp[x][1])\n    for k in imp:\n        temp[k] = (temp[k][0], imp.index(k) + 1)\n    return imp\n\n\ndef move(p):\n    imp = drop(check1(p))\n    dice = random.randint(1, 3)\n    futurex = dice + temp[p][0]\n    ystack = check2(futurex)\n    for k in imp:  # check for 4\n        x = temp[k][0]\n        y = temp[k][1]\n        newx = x + dice\n        newy = y + ystack\n        temp[k] = (newx, newy)\n\n\n# ================================================\ntemp = {\"Orange\": (0,0), \"Blue\": (0,0), \"Purple\": (0,0), \"Red\": (0,0), \"Green\": (0,0)}\n\nenter()\ndicegen = random.SystemRandom()\norder_list = list(temp.keys())\nbiglist = []\n\nfor i in range(10000):\n    random.shuffle(order_list)\n    reset = copy.deepcopy(temp)\n    for x in order_list:\n        move(x)\n    biglist.append(temp)\n\n    temp = reset\n\nalist = []\nblist = []\nclist = []\ndlist = []\nelist = []\n\n\ndef biglist1():\n    for dictionary in biglist:\n        alist.append(dictionary[\"Orange\"])\n        blist.append(dictionary[\"Blue\"])\n        clist.append(dictionary[\"Purple\"])\n        dlist.append(dictionary[\"Red\"])\n        elist.append(dictionary[\"Green\"])\n\n\nbiglist1()\n\ndef unique(xlist):\n    unique_list = []\n    for x in xlist:\n        if x not in unique_list:\n            unique_list.append(x)\n    return unique_list\n\n\nnewalist = unique(alist)\nnewblist = unique(blist)\nnewclist = unique(clist)\nnewdlist = unique(dlist)\nnewelist = unique(elist)\n\nnewalist.sort(key=lambda x: x[0])\nnewblist.sort(key=lambda x: x[0])\nnewclist.sort(key=lambda x: x[0])\nnewdlist.sort(key=lambda x: x[0])\nnewelist.sort(key=lambda x: x[0])\n\n\n\ndef cumua():\n    jupyterlist = []\n    for x in newalist:\n        jupyterlist.append((x, alist.count(x)))\n    return (jupyterlist)\n\n\ndef cumub():\n    jupyterlist2 = []\n    for x in newblist:\n        jupyterlist2.append((x, blist.count(x)))\n    return (jupyterlist2)\n\n\ndef cumuc():\n    jupyterlist3 = []\n    for x in newclist:\n        jupyterlist3.append((x, clist.count(x)))\n    return (jupyterlist3)\n\n\ndef cumud():\n    jupyterlist4 = []\n    for x in newdlist:\n        jupyterlist4.append((x, dlist.count(x)))\n    return (jupyterlist4)\n\n\ndef cumue():\n    jupyterlist5 = []\n    for x in newelist:\n        jupyterlist5.append((x, elist.count(x)))\n    return (jupyterlist5)\n\n\ncumua()\ncumub()\ncumuc()\ncumud()\ncumue()\n\ndf1 = pd.DataFrame(cumua(), columns=['word', 'Orange'])\ndf2 = pd.DataFrame(cumub(), columns=['word', 'Blue'])\ndf3 = pd.DataFrame(cumuc(), columns=['word', 'Purple'])\ndf4 = pd.DataFrame(cumud(), columns=['word', 'Red'])\ndf5 = pd.DataFrame(cumue(), columns=['word', 'Green'])\n\ndf1.plot(kind='bar', x='word', color='Orange')\ndf2.plot(kind='bar', x='word', color= 'Blue')\ndf3.plot(kind='bar', x='word', color='Purple')\ndf4.plot(kind='bar', x='word', color='Red')\ndf5.plot(kind='bar', x='word', color='Green')\n\n\nplt.show()","dbbcbeeb":"**Analysis**\n\nOut of 10,000 simulations, Purple lands on (6,1) ~3,000 times. A conservative player would bet on Purple Camel.\n\nRed lands on (6,1) and (7,1) ~1,300 times. The chances of Red winning is lower than Purple, but it also can surpass Purple. A risky player would bet on Red.\n\nGreen has a similar distrubtion to Red, but has a lower probability of landing on (6,1) and (7,1). Player should choose Green if another player chose Red first.","9151f685":"Welcome to my Camel Up Project!\n\n**The Game**\n\nCamel Up is a board game in which players bet on five racing camels. The objective of the game is to win the most money from betting correctly on 5 camels and the space they land on. It is similar to Monopoly where the orange properties get landed more often than dark blue properties. In the game, there are 5 colored dice and 5 colored camels. Each turn, a player can bet on the camel that they think will go furthest or roll the pyramid, where the 5 die are held and one comes out. The number rolled and the order in which the color are rolled gives us the final spot for the turn and the player get money for betting correctly for the camel in the front. However, the camels do not move neatly!\n\nMechanics of Camels: \n\nSuppose there are three camels on the first space: Green on bottom (1,1), Red on middle (1,2), and Blue on top (1,3). \n\nScenerio 1: Player rolls the pyramid and Green Dice comes out with value 3. Since Red and Blue are on top, the Green will carry both of them. \n\nPositions of camel after roll: Green on bottom (4,1), Red on middle (4,2), and Blue on top (4,3).\n\nScenerio 2: Player rolls the pyramid and Red dice comes out with value 3. Since Green is on bottom, Red cannot carry it. However, Blue is on top so Red will carry. \n\nPositions of camel after roll: Green on bottom (1,1), Red on bottom (4,1), and Blue on top (4,2).\n\nScenerio 3: Player rolls the pyramid and Blue dice comes out with value 3. Since Green and Red are beneath Blue, Blue will go alone. Positions of camel after roll: Green on bottom (1,1), Red on middle (1,2), and Blue on bottom (4,1). \n\nContinuation of Scenerio 3: Suppose the Green dice comes out with value 3. Since Red is on top of Green, Green will carry it. Positions of camels after roll: Green on middle (4,2), Red on top (4,3), and Blue on bottom (4,1).\n\nFurther continuation of Scenario 3: Suppose the Red dice come out with value 1. There is no camels on top of Red so it moves alone. Positions of camels after roll: Green on top (4,2), Red on bottom (5,1), and Blue on bottom (4,1).\n\nRed is the winner since it is the furthest.\n\nThe carrying effect is what makes betting correctly on the \"winning\" camel difficult. The colors and the value of the dice that come out is random, and the turn ends when all 5 die come out the pyramid. The player that bet correctly on the furthest camel will earn the most money.\n\n**Python Code**\n\nMy project visualizes the distribution of each camel and their final landing space. I applied the Monte Carlo Simutation and simulated 10,000 turns. By the Law of Large Numbers, the results should reflect its true probability.\n1. Each turn starts with the initial positions(see below). \n2. The 5 colors and the values are randomized.\n3. Before every camel moves, the check function checks if there are camels on top. If there is, the first camel will carry those on top.\n4. After all the camels move, each camel's coordinates are added to their respective color list.\n5. Return to inital positions and the code runes for 9,999 more times to collect ending coordinates.\n\nAfter 10,000 runs, their ending coordinates are collected and graphed on a histogram. It shows the the likelihood of which camel will land on what space.\nPlayer can use the histogram to decide bet aggressively or conservatively.\n\n\n\n\n\n"}}