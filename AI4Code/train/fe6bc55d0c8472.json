{"cell_type":{"9de46416":"code","f4dd5068":"code","861a1a32":"code","eda983e8":"code","4ab9ea4a":"code","8b283918":"code","f5c95b1c":"code","7c543745":"code","aee4920e":"code","cdb2663a":"code","96b2c48b":"code","7b9d819a":"code","17a7b29d":"code","4991557a":"code","37b550b7":"code","8822467a":"code","d3ad5bb8":"code","50124a15":"code","30c21e90":"code","40a37587":"code","3b24d4a5":"code","56872484":"code","ab9b0db3":"code","6f3b84cc":"code","490cca69":"code","7f2ab517":"markdown","a03627f9":"markdown","5cf98629":"markdown","08741551":"markdown","d7e1ef61":"markdown","84856ed6":"markdown","837cb0af":"markdown","84ad3e60":"markdown","0341a92c":"markdown","588c75b5":"markdown","ba484cb8":"markdown","e57b1806":"markdown","f1034dc6":"markdown","74c5ea04":"markdown","be709be8":"markdown","c087178f":"markdown","cec0e8ca":"markdown","5b219582":"markdown","258aab97":"markdown","89468fb1":"markdown","1cc62efa":"markdown","2302d514":"markdown","23f3273b":"markdown","79898455":"markdown","1e3a1f85":"markdown","279b9891":"markdown","b3fc7077":"markdown","f482aaae":"markdown","1adb4404":"markdown","6d81dd70":"markdown","a45f6335":"markdown","71ec4077":"markdown","15f0f8cb":"markdown","ff414b44":"markdown","c7a3a221":"markdown"},"source":{"9de46416":"# This Python 3 environment comes with many helpful analytics libraries installed\n# It is defined by the kaggle\/python Docker image: https:\/\/github.com\/kaggle\/docker-python\n# For example, here's several helpful packages to load\n\nimport numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\n\n# Input data files are available in the read-only \"..\/input\/\" directory\n# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n\n# You can write up to 20GB to the current directory (\/kaggle\/working\/) that gets preserved as output when you create a version using \"Save & Run All\" \n# You can also write temporary files to \/kaggle\/temp\/, but they won't be saved outside of the current session","f4dd5068":"import re\nfrom collections import Counter\nimport numpy as np\nimport pandas as pd","861a1a32":"from nltk.tokenize import word_tokenize\n\ndef process_data(file_name):\n    \"\"\"\n    Input: \n        A file_name which is found in our current Kaggle directory. We just have to read it in. \n    Output: \n        words: a list containing all the words in the corpus in lower case. \n    \"\"\"\n    words = [] \n\n    with open(file_name, 'r') as file:\n        file_read = file.read()\n        pre_process_file = re.findall(r\"\\w+\", file_read)\n        word_list = pre_process_file\n        for word in word_list:\n            words.append(word.lower())\n    \n    return words","eda983e8":"word_list = process_data('\/kaggle\/input\/vocabulary\/shakespeare.txt')\nvocab = set(word_list)  # this will be our new vocabulary","4ab9ea4a":"def get_count(word_list):\n    '''\n    Input:\n        word_l: a set of words representing the corpus. \n    Output:\n        word_count_dict: The wordcount dictionary where key is the word and value is its frequency.\n    '''\n    \n    word_count_dict = {}  # create word_count dictionary\n    word_count_dict = Counter(word_list)\n            \n    return word_count_dict","8b283918":"word_count_dict = get_count(word_list)\nprint(f\"There are {len(word_count_dict)} key values pairs\")\nprint(f\"The count for the word 'thee' is {word_count_dict.get('thee',0)}\")","f5c95b1c":"def get_probs(word_count_dict):\n    '''\n    Input:\n        word_count_dict: The wordcount dictionary where key is the word and value is its frequency.\n    Output:\n        probs: A dictionary where keys are the words and the values are the probability that a word will occur. \n    '''\n    probs = {}  # initalize the probability dictionary\n    total_words = sum(word_count_dict.values()) # variable M\n\n    for word, word_count in word_count_dict.items():\n        word_prob = word_count\/total_words\n        probs[word] = word_prob\n    \n    return probs","7c543745":"print(word_count_dict['thee'])\nprobs = get_probs(word_count_dict)\nprint(f\"Length of probs is {len(probs)}\")\nprint(f\"P('thee') is {probs['thee']:.4f}\")","aee4920e":"def delete_letter(word, verbose=False):\n    '''\n    Input:\n        word: the string\/word for which we will generate all possible words \n                in the vocabulary which have 1 missing character\n    Output:\n        delete_list: a list of all possible strings obtained by deleting 1 character from word\n    '''\n    \n    delete_list = []\n    split_list = []\n    \n    # split_list will generate: [('', 'cans'), ('c', 'ans'), ('ca', 'ns'), ('can', 's')]\n    split_list = [(word[:i], word[i:]) for i in range(len(word))]\n    \n    # delete_list will generate: ['ans', 'cns', 'cas', 'can']\n    # deletes one char from the word\n    delete_list = [L+R[1:] for L, R in split_list]\n    \n\n    if verbose: print(f\"input word {word}, \\nsplit_list = {split_list}, \\ndelete_list = {delete_list}\")\n\n    return delete_list","cdb2663a":"delete_word_list = delete_letter(word=\"cans\",verbose=True)","96b2c48b":"def switch_letter(word, verbose=False):\n    '''\n    Input:\n        word: input string\n     Output:\n        switches: a list of all possible strings with one adjacent charater switched\n    ''' \n    \n    switch_list = []\n    split_list = []\n\n    split_list = [(word[:i], word[i:]) for i in range(len(word))]\n    #.  a.    b. \n    # ('e', 'ta') => L + R[1] + R[0] + R[2:] => eat\n    switch_list = [L + R[1] + R[0] + R[2:] for L, R in split_list if len(R)>=2]\n    \n    if verbose: print(f\"Input word = {word} \\nsplit_list = {split_list} \\nswitch_list = {switch_list}\") \n\n    return switch_list","7b9d819a":"switch_word_list = switch_letter(word=\"eta\",verbose=True)","17a7b29d":"def replace_letter(word, verbose=False):\n    '''\n    Input:\n        word: the input string\/word \n    Output:\n        replaces: a list of all possible strings where we replaced one letter from the original word. \n    ''' \n    \n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    replace_list = []\n    split_list = []\n    \n    split_list = [(word[0:i], word[i:]) for i in range(len(word))]\n    \n    replace_list = [L + letter + (R[1:] if len(R)>1 else '') for L, R in split_list if R for letter in letters]\n    \n    replace_set = set(replace_list)\n    \n    # turn the set back into a list and sort it, for easier viewing\n    replace_list = sorted(list(replace_set))\n\n    \n    if verbose: print(f\"Input word = {word} \\nsplit_list = {split_list} \\nreplace_list {replace_list}\")   \n    \n    return replace_list","4991557a":"replace_list = replace_letter(word='can', verbose=True)","37b550b7":"def insert_letter(word, verbose=False):\n    '''\n    Input:\n        word: the input string\/word \n    Output:\n        inserts: a set of all possible strings with one new letter inserted at every offset\n    ''' \n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    insert_list = []\n    split_list = []\n    \n    # adding extra 1 because for insertion, we want that empty tuple!\n    split_list = [(word[0:i], word[i:]) for i in range(len(word)+1)]\n    insert_list = [L + letter + R for L, R in split_list for letter in letters]\n\n    if verbose: print(f\"Input word {word} \\nsplit_list = {split_list} \\ninsert_list = {insert_list}\")\n    \n    return insert_list","8822467a":"insert_list = insert_letter('at', True)\nprint(f\"Number of strings output by insert_letter('at') is {len(insert_list)}\")","d3ad5bb8":"def edit_one_letter(word, allow_switches = True):\n    \"\"\"\n    Input:\n        word: the string\/word for which we will generate all possible wordsthat are one edit away.\n    Output:\n        edit_one_set: a set of words with one possible edit. Returning a set to avoid duplicates.\n    \"\"\"\n    \n    edit_one_set = set()\n    \n    edit_one_set.update(delete_letter(word))\n    if allow_switches:\n        edit_one_set.update(switch_letter(word))\n    edit_one_set.update(replace_letter(word))\n    edit_one_set.update(insert_letter(word))\n    \n    if word in edit_one_set:\n        edit_one_set.remove(word)\n\n\n    return edit_one_set","50124a15":"tmp_word = \"at\"\ntmp_edit_one_set = edit_one_letter(tmp_word)\n\n# turn this into a list to sort it, in order to view it\ntmp_edit_one_list = sorted(list(tmp_edit_one_set))\n\nprint(f\"input word {tmp_word} \\nedit_one_l \\n{tmp_edit_one_list}\\n\")\nprint(f\"The type of the returned object should be a set {type(tmp_edit_one_set)}\")\nprint(f\"Number of outputs from edit_one_letter('at') is {len(edit_one_letter('at'))}\")","30c21e90":"def edit_two_letters(word, allow_switches = True):\n    '''\n    Input:\n        word: the input string\/word \n    Output:\n        edit_two_set: a set of strings with all possible two edits\n    '''\n    \n    edit_two_set = set()\n    edit_one = edit_one_letter(word, allow_switches=allow_switches)\n    for word in edit_one:\n        if word:\n            edit_two = edit_one_letter(word, allow_switches=allow_switches)\n            edit_two_set.update(edit_two)\n    \n    return edit_two_set","40a37587":"insert_list_with_2_edits = []\ninsertion_list_with_1_edit = insert_letter(\"a\")\nfor word in insertion_list_with_1_edit:\n    insert_list_with_2_edits += insert_letter(word)\n\nprint(len(set(insert_list_with_2_edits)))","3b24d4a5":"tmp_edit_two_set = edit_two_letters(\"a\")\ntmp_edit_two_list = sorted(list(tmp_edit_two_set))\nprint(f\"Number of strings with edit distance of two: {len(tmp_edit_two_list)}\")\nprint(f\"First 10 strings {tmp_edit_two_list[:10]}\")\nprint(f\"Last 10 strings {tmp_edit_two_list[-10:]}\")\nprint(f\"The data type of the returned object should be a set {type(tmp_edit_two_set)}\")\nprint(f\"Number of strings that are 2 edit distances from 'at' is {len(edit_two_letters('at'))}\")","56872484":"def get_spelling_suggestions(word, probs, vocab, n=2, verbose = False):\n    '''\n    Input: \n        word: a user entered string to check for suggestions\n        probs: a dictionary that maps each word to its probability in the corpus\n        vocab: a set containing all the vocabulary\n        n: number of possible word corrections you want returned in the dictionary\n    Output: \n        n_best: a list of tuples with the most probable n corrected words and their probabilities.\n    '''\n    \n    suggestions = []\n    top_n_suggestions = []\n    \n    # [] or [] or [\"least\",\"of\",\"all\"] # continues evaluation until there is a non-empty list\n    suggestions = list((word in vocab and word) or edit_one_letter(word).intersection(vocab) or edit_two_letter(word).intersection(vocab))\n    top_n_suggestions = [[s, probs[s]] for s in list(suggestions)]\n    \n    if verbose: print(\"entered word = \", word, \"\\nsuggestions = \", suggestions)\n\n    return top_n_suggestions","ab9b0db3":"my_word = 'dys' \ntmp_corrections = get_spelling_suggestions(my_word, probs, vocab, 3, verbose=True) # keep verbose=True\nfor i, word_prob in enumerate(tmp_corrections):\n    print(f\"word {i}: {word_prob[0]}, probability {word_prob[1]:.6f}\")","6f3b84cc":"def min_edit_distance(source, target, ins_cost = 1, del_cost = 1, rep_cost = 2):\n    '''\n    Input: \n        source: a string corresponding to the string we are starting with\n        target: a string corresponding to the string we want to end with\n        ins_cost: an integer setting the insert cost\n        del_cost: an integer setting the delete cost\n        rep_cost: an integer setting the replace cost\n    Output:\n        D: a matrix of len(source)+1 by len(target)+1 containing minimum edit distances\n        med: the minimum edit distance (med) required to convert the source string to the target\n    '''\n    # use deletion and insert cost as  1\n    m = len(source) \n    n = len(target) \n    \n    #initialize cost matrix with zeros and dimensions (m+1,n+1) \n    D = np.zeros((m+1, n+1), dtype=int) \n    \n    # Fill in column 0, from row 1 to row m, both inclusive\n    for row in range(1,m+1): \n        D[row,0] = D[row-1, 0]+del_cost\n        \n    # Fill in row 0, for all columns from 1 to n, both inclusive\n    for col in range(1,n+1): \n        D[0,col] = D[0, col-1]+ins_cost\n        \n    # Loop through row 1 to row m, both inclusive\n    for row in range(1,m+1): \n        \n        # Loop through column 1 to column n, both inclusive\n        for col in range(1,n+1):\n            \n            # Intialize r_cost to the 'replace' cost that is passed into this function\n            r_cost = rep_cost\n            \n            # Check to see if source character at the previous row\n            # matches the target character at the previous column, \n            # (source) 'TAY' (target) 'SAY': Check if 'T'=='S'\n            if source[row-1] == target[col-1]:\n                # Update the replacement cost to 0 if source and target are the same\n                r_cost = 0\n                \n            # Update the cost at row, col based on previous entries in the cost matrix\n            # Refer to the equation calculate for D[i,j] (the minimum of three calculated costs)\n\n            cost_del = D[row-1, col] + del_cost\n            cost_ins = D[row, col-1] + ins_cost\n            cost_replace = D[row-1, col-1] + r_cost\n            \n            D[row,col] = min(cost_del, cost_ins, cost_replace)\n          \n    # Set the minimum edit distance with the cost found at row m, column n\n    med = D[m, n]\n    \n    return D, med","490cca69":"source =  'eer'\ntarget = 'near'\nmatrix, min_edits = min_edit_distance(source, target)\nprint(\"minimum edits: \",min_edits, \"\\n\")\nidx = list('#' + source)\ncols = list('#' + target)\ndf = pd.DataFrame(matrix, index=idx, columns= cols)\nprint(df)","7f2ab517":"<h1 style=\"background: #ea97ad;text-align:center\">Word Count<\/h1>","a03627f9":"<h1 style=\"background: #ea97ad;text-align:center\">References<\/h1>","5cf98629":"Here, we will implement a function, `delete_letter()` which, given a word, returns a list of strings with one character deleted. For example:\nGiven the word **nice**, it would return the set: {'ice', 'nce', 'nic', 'nie'}. ","08741551":"![image.png](attachment:image.png)","d7e1ef61":"<h2 style=\"background: #ea97ad;text-align:center\">Edit One Letter<\/h2>","84856ed6":"Here, we will implement a function that switches two letters in a word. It takes in a word and returns a list of all the possible switches of two letters **that are adjacent to each other.**\n\nFor example, given the word 'eta', it returns {'eat', 'tea'}, but does not return 'ate'.","837cb0af":"In this task, we will read a file, **shakespeare.txt** and perform the following preprocessing steps:\n1. Read the corpus (txt) file.\n2. Change everything to lowercase\n3. Return a list of words","84ad3e60":"We can leverage the `word_count_dict` to calculate the probability that each word will appear if randomly selected from the corpus of words. The probability can be calculate using the equation (1).\n\n\n$$P(w_i) = \\frac{C(w_i)}{M} \\tag{1}$$\nwhere \n\n$C(w_i)$ is the total number of times $w_i$ appears in the corpus.\n\n$M$ is the total number of words in the corpus.\n\nFor example, in the sentence: \"**I am running because I am happy**\", the probability of the word '**running**' is:\n\n$$P('running') = \\frac{C(w_i)}{M} = \\frac {1}{7} \\tag{2}.$$\n","0341a92c":"Now, how do we efficiently find the shortest path to go from the word, 'waht' to the word 'what'?\nIn this section, we will implement a [dynamic programming](https:\/\/www.geeksforgeeks.org\/dynamic-programming\/) system that will tell us the minimum number of edits required to convert a string into another string.","588c75b5":"Now we will use our `edit_two_letters` function to get a set of all the possible 2 edits on our word. We will then use those strings to get the most probable word that we meant to type aka our typing suggestion. For generating suggestions for a supplied word: We'll use the edit functions we have developed. The '`suggestion algorithm`' follows the below logic:\n\n1. If the word is in the vocabulary, suggest the word.\n2. Otherwise, if there are suggestions from edit_one_letter that are in the vocabulary, use those.\n3. Otherwise, if there are suggestions from edit_two_letters that are in the vocabulary, use those.\n4. Otherwise, suggest the input word.\n\nThe idea is that words generated from fewer edits are more likely than words with more edits.","ba484cb8":"We use the autocorrect functionality everyday on our laptops, cell phones, computers etc. In this notebook, I aim to create a basic auto-correct tool and explore what goes on behind the scenes. One example of autocorrect is, if you type the word **rnunnuing**, chances are very high that you meant to write **running** as shown in Figure 1.","e57b1806":"<h1 style=\"background: #ea97ad;text-align:center\">Data Preprocessing<\/h1>","f1034dc6":"Now that we have implemented a number of string manipulations functions *(insert, delete, switch and replace)*, we will now create two functions that, given a string, will return all the possible single and double edits on that string. These will be `edit_one_letter()` and `edit_two_letters()`.","74c5ea04":"Dynamic Programming breaks a problem down into subproblems which can be combined to form the final solution. Here, given a string source[0..i] and a string target[0..j], we will compute all the combinations of substrings[i, j] and calculate their edit distance. To do this efficiently, we will use a table to maintain the previously computed substrings and use those to calculate larger substrings. We can update each element in the matrix as follows:\n\n$$\\text{Matrix Initialization}$$\n\n\\begin{align}\nD[0,0] &= 0 \\\\\nD[i,0] &= D[i-1,0] + del\\_cost(source[i]) \\tag{3}\\\\\nD[0,j] &= D[0,j-1] + ins\\_cost(target[j]) \\\\\n\\end{align}\n\n\n\n$$\\text{Per Cell Operations}$$\n\\begin{align}\n \\\\\nD[i,j] =min\n\\begin{cases}\nD[i-1,j] + del\\_cost\\\\\nD[i,j-1] + ins\\_cost\\\\\nD[i-1,j-1] + \\left\\{\\begin{matrix}\nrep\\_cost; & if src[i]\\neq tar[j]\\\\\n0 ; & if src[i]=tar[j]\n\\end{matrix}\\right.\n\\end{cases}\n\\tag{4}\n\\end{align}","be709be8":"<h2 style=\"background: #ea97ad;text-align:center\">String Manipulation: Delete Letter<\/h2>","c087178f":"<h1 style=\"background: #ea97ad;text-align:center\">Performing String Manipulations<\/h1>","cec0e8ca":"<h1 style=\"background: #ea97ad;text-align:center\">Minimum Edit Distance<\/h1>","5b219582":"<h2 style=\"background: #ea97ad;text-align:center\">String Manipulation: Switch Letter<\/h2>","258aab97":"<h2 style=\"background: #ea97ad;text-align:center\">String Manipulation: Replace Letter<\/h2>","89468fb1":"<h2 style=\"background: #ea97ad;text-align:center\">Edit Two Letters<\/h2>","1cc62efa":"<h1 style=\"background: #ea97ad;text-align:center\">Autocorrect Tool via Minimum Distance Edit<\/h1>","2302d514":"<h2 style=\"background: #ea97ad;text-align:center\">String Manipulation: Insert Letter<\/h2>","23f3273b":"Here, we will implement a function that takes in a word and returns a list of strings with one replaced letter from the original word.\n","79898455":"Now, that we have computed $P(w_i)$ for all the words in the corpus, we will write a few functions to manipulate strings so that we can edit the erroneous strings and return the right spellings of the words. In this section, we will implement four functions: \n\n* `delete_letter`: given a word, it returns all the possible strings that have **one character removed**. \n* `switch_letter`: given a word, it returns all the possible strings that have **two adjacent letters switched**.\n* `replace_letter`: given a word, it returns all the possible strings that have **one character replaced by another different letter**.\n* `insert_letter`: given a word, it returns all the possible strings that have an **additional character inserted**. ","1e3a1f85":"Now, we can generalize `edit_one_letter()` to implement to get two edits on a word. To do so, we would have to get all the possible edits on a single word and then, for each modified word, we would have to modify it again.","279b9891":"<h1 style=\"background: #ea97ad;text-align:center\">Combining the Edits<\/h1>","b3fc7077":"In this notebook, I aimed to develop a simple auto-correction tool using Dynamic Programming. Below are the links that I referred while working on the same:\n1. [Natural Language Processing using Probabilistic Models](https:\/\/www.coursera.org)\n2. [Dynamic Programming](https:\/\/www.geeksforgeeks.org\/dynamic-programming\/)\n\nPlease feel free to provide suggestions on how to further improve this notebook in the comments section! \ud83d\ude0a","f482aaae":"In this part, we will implement a `get_count` function that returns a dictionary where:\n1. Dictionary's keys are words.\n2. The value for each word is the number of times that word appears in the corpus.\n\nExample, given the following sentence: \"**I am running because I am happy**\", our dictionary should return the following:\n\n| **Key** | **Value** |\n|---------|-----------|\n| I       | 2         |\n| am      | 2         |\n| happy   | 1         |\n| because | 1         |\n| running | 1         |","1adb4404":"<h1 style=\"background: #ea97ad;text-align:center\">Spelling Suggestions<\/h1>","6d81dd70":"In this notebook, I aim to build a basic *auto-correction tool* using Dynamic Programming. The rest of the notbook is organized as follows:\n\n1. Brief Overview\n2. Data Preprocessing\n3. Word Count\n4. Computing Word Probability\n5. Performing String Manipulations:\n    1. Replace\n    2. Insert\n    3. Delete\n    4. Switch\n6. Combining the Edits\n    1. Edit One Letter\n    2. Edit Two Letters\n7. Spelling Suggestions\n8. Minimum Edit Distance\n    1. Dynamic Programming","a45f6335":"<h2 style=\"background: #ea97ad;text-align:center\">Dynamic Programming<\/h2>","71ec4077":"<h1 style=\"background: #ea97ad;text-align:center\">Computing the Word Probability<\/h1>","15f0f8cb":"<h1 style=\"background: #ea97ad;text-align:center\">Overview<\/h1>","ff414b44":"Here, we will implement a function that takes in a word and returns a list with a letter inserted at every offset. ","c7a3a221":"Here, we will implement the `edit_one_letter` function to get all the possible edits that are one edit away from a word. The edits consist of the *replace, insert, delete, and optionally the switch operation*. We'll employ the previous functions that we have already implemented to complete this function. The '`switch`' function is a less common edit function, so its use will be selected by an \"`allow_switches`\" input argument."}}