{"cell_type":{"aa66d36f":"code","8837d7f8":"code","7e9007fa":"code","72998a8d":"code","f52cb4b8":"code","dd32360d":"code","bd4a10e5":"code","5c2cf471":"code","99f5895e":"code","6c2741eb":"code","2db6a659":"code","62606f77":"code","ee788292":"code","db96d9e4":"code","da16655a":"code","4f64a096":"code","ad2525f2":"code","250c81bc":"code","3d898027":"code","d4cda389":"code","e47a3b0e":"code","b109365b":"code","e27e7e0d":"code","6cb397cc":"code","69a7738f":"code","ab04ac97":"code","0da0398b":"code","457398d2":"code","43edcc28":"code","1b13ea60":"code","2c67e370":"code","98bfb527":"code","6f708236":"code","d7fe9e2a":"code","4c84d77e":"code","bce2b32b":"code","5064acb7":"code","22dcae3f":"code","a03c3880":"code","563a682b":"code","296e0a05":"code","be07b0f7":"code","7d08940a":"code","61696fbb":"code","71f2737a":"code","2162064a":"code","39256eaf":"code","c205b0ba":"code","4b2233c6":"code","1283e939":"code","431a3711":"code","2265caad":"code","f33fb307":"code","a12d6fbc":"code","db7a6c12":"code","d036d611":"code","e4a9e62e":"code","30554d84":"markdown","be49f460":"markdown","23599fd2":"markdown","e6a4d3e2":"markdown","868d6bd3":"markdown","466f42cf":"markdown","9f0f3464":"markdown","1cd9b72e":"markdown","dfd73701":"markdown","c01fa624":"markdown","249e5569":"markdown","bea499bc":"markdown","5cd2ed41":"markdown","04b91ce3":"markdown","677ac797":"markdown","95c27d9c":"markdown","6361d994":"markdown","9502326a":"markdown","20121286":"markdown","2e8f7b86":"markdown","f22cd1dc":"markdown","a56249e1":"markdown","1d39b777":"markdown","d5ca5f4f":"markdown","be67ca16":"markdown","51175a01":"markdown","fb6bd8de":"markdown","45f41d78":"markdown","ad1faf13":"markdown","30cd09e0":"markdown","96a79745":"markdown","7f39369b":"markdown","c3f02c67":"markdown","104f6e4c":"markdown","49e159d8":"markdown","ab5837fd":"markdown","cc98870e":"markdown","f3035248":"markdown","53aa4f25":"markdown","075324d9":"markdown","5700dab1":"markdown","6534d960":"markdown","a7034678":"markdown","e0ad1443":"markdown","7a480540":"markdown","28cbc6cd":"markdown","c91cad3e":"markdown","41c1a280":"markdown","4e97a3a8":"markdown","19c69c95":"markdown","775056c5":"markdown"},"source":{"aa66d36f":"# Uncomment and run the appropriate command for your operating system, if required\n\n# Linux \/ Binder\n# !pip install numpy matplotlib torch==1.7.0+cpu torchvision==0.8.1+cpu torchaudio==0.7.0 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html\n\n# Windows\n# !pip install numpy matplotlib torch==1.7.0+cpu torchvision==0.8.1+cpu torchaudio==0.7.0 -f https:\/\/download.pytorch.org\/whl\/torch_stable.html\n\n# MacOS\n# !pip install numpy matplotlib torch torchvision torchaudio","8837d7f8":"import torch\nimport torchvision\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom torchvision.datasets import MNIST\nfrom torchvision.transforms import ToTensor\nfrom torchvision.utils import make_grid\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.data import random_split\n%matplotlib inline\n\n# Use a white background for matplotlib figures\nmatplotlib.rcParams['figure.facecolor'] = '#ffffff'","7e9007fa":"dataset = MNIST(root='data\/', download=True, transform=ToTensor())","72998a8d":"image, label = dataset[0]\nprint('image.shape:', image.shape)\nplt.imshow(image.permute(1, 2, 0),cmap='gray' )\nprint('Label:', label)","f52cb4b8":"image, label = dataset[0]\nprint('image.shape:', image.shape)\nplt.imshow(image.permute(1, 2, 0), cmap='gray')\nprint('Label:', label)","dd32360d":"val_size = 10000\ntrain_size = len(dataset) - val_size\n\ntrain_ds, val_ds = random_split(dataset, [train_size, val_size])\nlen(train_ds), len(val_ds)","bd4a10e5":"batch_size=128\nprint(\"Our batch size is:\", batch_size)","5c2cf471":"train_loader = DataLoader(train_ds, batch_size, shuffle=True, num_workers=4, pin_memory=True)\nval_loader = DataLoader(val_ds, batch_size*2, num_workers=4, pin_memory=True)","99f5895e":"for images, _ in train_loader:\n    print('images.shape:', images.shape)\n    plt.figure(figsize=(16,8))\n    plt.axis('off')\n    plt.imshow(make_grid(images, nrow=16).permute((1, 2, 0)))\n    break","6c2741eb":"for images, labels in train_loader:\n    print('images.shape:', images.shape)\n    inputs = images.reshape(-1, 784)\n    print('inputs.shape:', inputs.shape)\n    break\n    ","2db6a659":"input_size = inputs.shape[-1]\nhidden_size = 32","62606f77":"layer1 = nn.Linear(input_size, hidden_size)","ee788292":"inputs.shape","db96d9e4":"layer1_outputs = layer1(inputs)\nprint('layer1_outputs.shape:', layer1_outputs.shape)","da16655a":"layer1_outputs_direct = inputs @ layer1.weight.t() + layer1.bias\nlayer1_outputs_direct.shape","4f64a096":"torch.allclose(layer1_outputs, layer1_outputs_direct, 1e-3)","ad2525f2":"F.relu(torch.tensor([[1, -1, 0], \n                     [-0.1, .2, 3]]))","250c81bc":"relu_outputs = F.relu(layer1_outputs)\nprint('min(layer1_outputs):', torch.min(layer1_outputs).item())\nprint('min(relu_outputs):', torch.min(relu_outputs).item())","3d898027":"output_size = 10\nlayer2 = nn.Linear(hidden_size, output_size)","d4cda389":"layer2_outputs = layer2(relu_outputs)\nprint(layer2_outputs.shape)","e47a3b0e":"inputs.shape","b109365b":"F.cross_entropy(layer2_outputs, labels)","e27e7e0d":"# Expanded version of layer2(F.relu(layer1(inputs)))\noutputs = (F.relu(inputs @ layer1.weight.t() + layer1.bias)) @ layer2.weight.t() + layer2.bias","6cb397cc":"torch.allclose(outputs, layer2_outputs, 1e-3)","69a7738f":"# Same as layer2(layer1(inputs))\noutputs2 = (inputs @ layer1.weight.t() + layer1.bias) @ layer2.weight.t() + layer2.bias","ab04ac97":"# Create a single layer to replace the two linear layers\ncombined_layer = nn.Linear(input_size, output_size)\n\ncombined_layer.weight.data = layer2.weight @ layer1.weight\ncombined_layer.bias.data = layer1.bias @ layer2.weight.t() + layer2.bias","0da0398b":"# Same as combined_layer(inputs)\noutputs3 = inputs @ combined_layer.weight.t() + combined_layer.bias","457398d2":"torch.allclose(outputs2, outputs3, 1e-3)","43edcc28":"class MnistModel(nn.Module):\n    \"\"\"Feedfoward neural network with 1 hidden layer\"\"\"\n    def __init__(self, in_size, hidden_size, out_size):\n        super().__init__()\n        # hidden layer\n        self.linear1 = nn.Linear(in_size, hidden_size)\n        # output layer\n        self.linear2 = nn.Linear(hidden_size, out_size)\n        \n    def forward(self, xb):\n        # Flatten the image tensors\n        xb = xb.view(xb.size(0), -1)\n        # Get intermediate outputs using hidden layer\n        out = self.linear1(xb)\n        # Apply activation function\n        out = F.relu(out)\n        # Get predictions using output layer\n        out = self.linear2(out)\n        return out\n    \n    def training_step(self, batch):\n        images, labels = batch \n        out = self(images)                  # Generate predictions\n        loss = F.cross_entropy(out, labels) # Calculate loss\n        return loss\n    \n    def validation_step(self, batch):\n        images, labels = batch \n        out = self(images)                    # Generate predictions\n        loss = F.cross_entropy(out, labels)   # Calculate loss\n        acc = accuracy(out, labels)           # Calculate accuracy\n        return {'val_loss': loss, 'val_acc': acc}\n        \n    def validation_epoch_end(self, outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses\n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies\n        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}\n    \n    def epoch_end(self, epoch, result):\n        print(\"Epoch [{}], val_loss: {:.4f}, val_acc: {:.4f}\".format(epoch, result['val_loss'], result['val_acc']))","1b13ea60":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1)\n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds))","2c67e370":"input_size = 784\nhidden_size = 32 # you can change this\nnum_classes = 10","98bfb527":"model = MnistModel(input_size, hidden_size=32, out_size=num_classes)","6f708236":"for t in model.parameters():\n    print(t.shape)","d7fe9e2a":"for images, labels in train_loader:\n    outputs = model(images)\n    loss = F.cross_entropy(outputs, labels)\n    print('Loss:', loss.item())\n    break\n\nprint('outputs.shape : ', outputs.shape)\nprint('Sample outputs :\\n', outputs[:2].data)","4c84d77e":"torch.cuda.is_available()","bce2b32b":"def get_default_device():\n    \"\"\"Pick GPU if available, else CPU\"\"\"\n    if torch.cuda.is_available():\n        return torch.device('cuda')\n    else:\n        return torch.device('cpu')","5064acb7":"device = get_default_device()\ndevice","22dcae3f":"def to_device(data, device):\n    \"\"\"Move tensor(s) to chosen device\"\"\"\n    if isinstance(data, (list,tuple)):\n        return [to_device(x, device) for x in data]\n    return data.to(device, non_blocking=True)","a03c3880":"for images, labels in train_loader:\n    print(images.shape)\n    images = to_device(images, device)\n    print(images.device)\n    break","563a682b":"class DeviceDataLoader():\n    \"\"\"Wrap a dataloader to move data to a device\"\"\"\n    def __init__(self, dl, device):\n        self.dl = dl\n        self.device = device\n        \n    def __iter__(self):\n        \"\"\"Yield a batch of data after moving it to device\"\"\"\n        for b in self.dl: \n            yield to_device(b, self.device)\n\n    def __len__(self):\n        \"\"\"Number of batches\"\"\"\n        return len(self.dl)","296e0a05":"def some_numbers():\n    yield 10\n    yield 20\n    yield 30\n\nfor value in some_numbers():\n    print(value)","be07b0f7":"train_loader = DeviceDataLoader(train_loader, device)\nval_loader = DeviceDataLoader(val_loader, device)","7d08940a":"for xb, yb in val_loader:\n    print('xb.device:', xb.device)\n    print('yb:', yb)\n    break","61696fbb":"def evaluate(model, val_loader):\n    \"\"\"Evaluate the model's performance on the validation set\"\"\"\n    outputs = [model.validation_step(batch) for batch in val_loader]\n    return model.validation_epoch_end(outputs)\n\ndef fit(epochs, lr, model, train_loader, val_loader, opt_func=torch.optim.SGD):\n    \"\"\"Train the model using gradient descent\"\"\"\n    history = []\n    optimizer = opt_func(model.parameters(), lr)\n    for epoch in range(epochs):\n        # Training Phase \n        for batch in train_loader:\n            loss = model.training_step(batch)\n            loss.backward()\n            optimizer.step()\n            optimizer.zero_grad()\n        # Validation phase\n        result = evaluate(model, val_loader)\n        model.epoch_end(epoch, result)\n        history.append(result)\n    return history","71f2737a":"# Model (on GPU)\nmodel = MnistModel(input_size, hidden_size=hidden_size, out_size=num_classes)\nto_device(model, device)","2162064a":"history = [evaluate(model, val_loader)]\nhistory","39256eaf":"history += fit(5, 0.5, model, train_loader, val_loader)","c205b0ba":"history += fit(5, 0.1, model, train_loader, val_loader)","4b2233c6":"losses = [x['val_loss'] for x in history]\nplt.plot(losses, '-x')\nplt.xlabel('epoch')\nplt.ylabel('loss')\nplt.title('Loss vs. No. of epochs');","1283e939":"accuracies = [x['val_acc'] for x in history]\nplt.plot(accuracies, '-x')\nplt.xlabel('epoch')\nplt.ylabel('accuracy')\nplt.title('Accuracy vs. No. of epochs');","431a3711":"# Define test dataset\ntest_dataset = MNIST(root='data\/', \n                     train=False,\n                     transform=ToTensor())","2265caad":"def predict_image(img, model):\n    xb = to_device(img.unsqueeze(0), device)\n    yb = model(xb)\n    _, preds  = torch.max(yb, dim=1)\n    return preds[0].item()","f33fb307":"img, label = test_dataset[0]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","a12d6fbc":"img, label = test_dataset[1839]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","db7a6c12":"img, label = test_dataset[193]\nplt.imshow(img[0], cmap='gray')\nprint('Label:', label, ', Predicted:', predict_image(img, model))","d036d611":"test_loader = DeviceDataLoader(DataLoader(test_dataset, batch_size=256), device)\nresult = evaluate(model, test_loader)\nresult","e4a9e62e":"torch.save(model.state_dict(), 'mnist-feedforward.pth')","30554d84":"Can you figure out the purpose of the arguments `num_workers` and `pin_memory`? Try looking into the documentation: https:\/\/pytorch.org\/docs\/stable\/data.html .\n\nLet's visualize a batch of data in a grid using the `make_grid` function from `torchvision`. We'll also use the `.permute` method on the tensor to move the channels to the last dimension, as expected by `matplotlib`.","be49f460":"The `yield` keyword in Python is used to create a generator function that can be used within a `for` loop, as illustrated below.","23599fd2":"Finally, we define a `DeviceDataLoader` class to wrap our existing data loaders and move batches of data to the selected device. Interestingly, we don't need to extend an existing class to create a PyTorch datal oader. All we need is an `__iter__` method to retrieve batches of data and an `__len__` method to get the number of batches.","e6a4d3e2":"Let's see how the model performs on the validation set with the initial set of weights and biases.","868d6bd3":"We also need to define an `accuracy` function which calculates the accuracy of the model's prediction on an batch of inputs. It's used in `validation_step` above.","466f42cf":"Next, let's use the `random_split` helper function to set aside 10000 images for our validation set.","9f0f3464":"We expect this to be similar to the accuracy\/loss on the validation set. If not, we might need a better validation set that has similar data and distribution as the test set (which often comes from real world data).","1cd9b72e":"Before we train the model, we need to ensure that the data and the model's parameters (weights and biases) are on the same device (CPU or GPU). We can reuse the `to_device` function to move the model's parameters to the right device. ","dfd73701":"Let's try and generate some outputs using our model. We'll take the first batch of 128 images from our dataset and pass them into our model.","c01fa624":"We'll create a model that contains a hidden layer with 32 activations.","249e5569":"96% is pretty good! Let's train the model for five more epochs at a lower learning rate of 0.1 to improve the accuracy further.","bea499bc":"The initial accuracy is around 10%, as one might expect from a randomly initialized model (since it has a 1 in 10 chance of getting a label right by guessing randomly).\n\nLet's train the model for five epochs and look at the results. We can use a relatively high learning rate of 0.5.","5cd2ed41":"Identifying where our model performs poorly can help us improve the model, by collecting more training data, increasing\/decreasing the complexity of the model, and changing the hypeparameters.\n\nAs a final step, let's also look at the overall loss and accuracy of the model on the test set.","04b91ce3":"The image vectors of size `784` are transformed into intermediate output vectors of length `32` by performing a matrix multiplication of `inputs` matrix with the transposed weights matrix of `layer1` and adding the bias. We can verify this using `torch.allclose`. For a more detailed explanation, review the tutorial on [linear regression](https:\/\/jovian.ai\/aakashns\/02-linear-regression).","677ac797":"## Hidden Layers, Activation Functions and Non-Linearity\n\nWe'll create a neural network with two layers: a _hidden layer_ and an _output layer_. Additionally, we'll use an _activation function_ between the two layers. Let's look at a step-by-step example to learn how hidden layers and activation functions can help capture non-linear relationships between inputs and outputs.\n\nFirst, let's create a batch of inputs tensors. We'll flatten the `1x28x28` images into vectors of size `784`, so they can be passed into an `nn.Linear` object.","95c27d9c":"## Model\n\nWe are now ready to define our model. As discussed above, we'll create a neural network with one hidden layer. Here's what that means:\n\n* Instead of using a single `nn.Linear` object to transform a batch of inputs (pixel intensities) into outputs (class probabilities), we'll use two `nn.Linear` objects. Each of these is called a _layer_ in the network. \n\n* The first layer (also known as the hidden layer) will transform the input matrix of shape `batch_size x 784` into an intermediate output matrix of shape `batch_size x hidden_size`. The parameter `hidden_size` can be configured manually (e.g., 32 or 64).\n\n* We'll then apply a non-linear *activation function* to the intermediate outputs. The activation function transforms individual elements of the matrix.\n\n* The result of the activation function, which is also of size `batch_size x hidden_size`, is passed into the second layer (also known as the output layer).  The second layer transforms it into a matrix of size `batch_size x 10`. We can use this output to compute the loss and adjust weights using gradient descent.\n\n\nAs discussed above, our model will contain one hidden layer. Here's what it looks like visually:\n\n<img src=\"https:\/\/i.imgur.com\/eN7FrpF.png\" width=\"480\">\n\n\nLet's define the model by extending the `nn.Module` class from PyTorch.","6361d994":"Now that we've applied a non-linear activation function, `relu_outputs` and `inputs` do not have a linear relationship. We refer to `ReLU` as the _activation function_, because for each input certain outputs are activated (those with non-zero values) while others turned off (those with zero values)\n\nNext, let's create an output layer to convert vectors of length `hidden_size` in `relu_outputs` into vectors of length 10, which is the desired output of our model (since there are 10 target labels).","9502326a":"## Summary and Further Reading\n\nHere is a summary of the topics covered in this tutorial:\n\n* We created a neural network with one hidden layer to improve upon the logistic regression model from the previous tutorial. We also used the ReLU activation function to introduce non-linearity into the model, allowing it to learn more complex relationships between the inputs (pixel densities) and outputs (class probabilities).\n\n* We defined some utilities like `get_default_device`, `to_device` and `DeviceDataLoader` to leverage a GPU if available, by moving the input data and model parameters to the appropriate device.\n\n* We were able to use the exact same training loop: the `fit` function we had define earlier to train out model and evaluate it using the validation dataset.\n\nThere's a lot of scope to experiment here, and I encourage you to use the interactive nature of Jupyter to play around with the various parameters. Here are a few ideas:\n\n* Try changing the size of the hidden layer, or add more hidden layers and see if you can achieve a higher accuracy.\n\n* Try changing the batch size and learning rate to see if you can achieve the same accuracy in fewer epochs.\n\n* Compare the training times on a CPU vs. GPU. Do you see a significant difference. How does it vary with the size of the dataset and the size of the model (no. of weights and parameters)?\n\n* Try building a model for a different dataset, such as the [CIFAR10 or CIFAR100 datasets](https:\/\/www.cs.toronto.edu\/~kriz\/cifar.html).\n\nHere are some references for further reading:\n\n* [A visual proof that neural networks can compute any function](http:\/\/neuralnetworksanddeeplearning.com\/chap4.html), also known as the Universal Approximation Theorem.\n\n* [But what *is* a neural network?](https:\/\/www.youtube.com\/watch?v=aircAruvnKk) - A visual and intuitive introduction to what neural networks are and what the intermediate layers represent\n\n* [Stanford CS229 Lecture notes on Backpropagation](http:\/\/cs229.stanford.edu\/notes\/cs229-notes-backprop.pdf) - for a more mathematical treatment of how gradients are calculated and weights are updated for neural networks with multiple layers.\n\n\nYou are now ready to move on to the next tutorial: [Image Classification using Convolutional Neural Networks](https:\/\/jovian.ai\/aakashns\/05-cifar10-cnn).","20121286":"Let's apply the activation function to `layer1_outputs` and verify that negative values were replaced with 0.","2e8f7b86":"Next, let's define a function that can move data and model to a chosen device.","f22cd1dc":"Tensors moved to the GPU have a `device` property which includes that word `cuda`. Let's verify this by looking at a batch of data from `valid_dl`.","a56249e1":"### Using a GPU for faster training\n\nYou can use a [Graphics Processing Unit](https:\/\/en.wikipedia.org\/wiki\/Graphics_processing_unit) (GPU) to train your models faster if your execution platform is connected to a GPU manufactured by NVIDIA. Follow these instructions to use a GPU on the platform of your choice:\n\n* _Google Colab_: Use the menu option \"Runtime > Change Runtime Type\" and select \"GPU\" from the \"Hardware Accelerator\" dropdown.\n* _Kaggle_: In the \"Settings\" section of the sidebar, select \"GPU\" from the \"Accelerator\" dropdown. Use the button on the top-right to open the sidebar.\n* _Binder_: Notebooks running on Binder cannot use a GPU, as the machines powering Binder aren't connected to any GPUs.\n* _Linux_: If your laptop\/desktop has an NVIDIA GPU (graphics card), make sure you have installed the [NVIDIA CUDA drivers](https:\/\/docs.nvidia.com\/cuda\/cuda-installation-guide-linux\/index.html).\n* _Windows_: If your laptop\/desktop has an NVIDIA GPU (graphics card), make sure you have installed the [NVIDIA CUDA drivers](https:\/\/docs.nvidia.com\/cuda\/cuda-installation-guide-microsoft-windows\/index.html).\n* _macOS_: macOS is not compatible with NVIDIA GPUs\n\n\nIf you do not have access to a GPU or aren't sure what it is, don't worry, you can execute all the code in this tutorial just fine without a GPU.","1d39b777":"We can now create PyTorch data loaders for training and validation.","d5ca5f4f":"Let's look at a couple of images from the dataset. The images are converted to PyTorch tensors with the shape `1x28x28` (the dimensions represent color channels, width and height). We can use `plt.imshow` to display the images. However, `plt.imshow` expects channels to be last dimension in an image tensor, so we use the `permute` method to reorder the dimensions of the image.","be67ca16":"## Exercises\n\nTry out the following exercises to apply the concepts and techniques you have learned so far:\n\n* Coding exercises on end-to-end model training: https:\/\/jovian.ai\/aakashns\/03-cifar10-feedforward\n* Starter notebook for deep learning models:  https:\/\/jovian.ai\/aakashns\/fashion-feedforward-minimal\n\nTraining great machine learning models reliably takes practice and experience. Try experimenting with different datasets, models and hyperparameters, it's the best way to acquire this skill.","51175a01":"In the two code-cells above we defined 2 layers first one is the input layer which is a 1 * 784 (flattened from 1 * 28 * 28 image tensor), the second layer which is the hidden layer is the output. Hidden layer is set to have 32 values (which are outputs of calculation on input layer and will be the input of final (second neural layer) output layer which will be acted upon by activation function. ","fb6bd8de":"Thus, our model transforms `inputs` into `layer2_outputs` by applying a linear transformation (using `layer1`), followed by a non-linear activation (using `F.relu`), followed by another linear transformation (using `layer2`). Let's verify this by re-computing the output using basic matrix operations.","45f41d78":"## Training the Model\n\nWe'll define two functions: `fit` and `evaluate` to train the model using gradient descent and evaluate its performance on the validation set. For a detailed walkthrough of these functions, check out the [previous tutorial](https:\/\/jovian.ai\/aakashns\/03-logistic-regression).","ad1faf13":"### How to run the code\n\nThis tutorial is an executable [Jupyter notebook](https:\/\/jupyter.org) hosted on [Jovian](https:\/\/www.jovian.ai). You can _run_ this tutorial and experiment with the code examples in a couple of ways: *using free online resources* (recommended) or *on your computer*.\n\n#### Option 1: Running using free online resources (1-click, recommended)\n\nThe easiest way to start executing the code is to click the **Run** button at the top of this page and select **Run on Colab**. [Google Colab](https:\/\/colab.research.google.com) is a free online platform for running Jupyter notebooks using Google's cloud infrastructure. You can also select \"Run on Binder\" or \"Run on Kaggle\" if you face issues running the notebook on Google Colab. \n\n\n#### Option 2: Running on your computer locally\n\nTo run the code on your computer locally, you'll need to set up [Python](https:\/\/www.python.org), download the notebook and install the required libraries. We recommend using the [Conda](https:\/\/docs.conda.io\/projects\/conda\/en\/latest\/user-guide\/install\/) distribution of Python. Click the **Run** button at the top of this page, select the **Run Locally** option, and follow the instructions.\n\n>  **Jupyter Notebooks**: This tutorial is a [Jupyter notebook](https:\/\/jupyter.org) - a document made of _cells_. Each cell can contain code written in Python or explanations in plain English. You can execute code cells and view the results, e.g., numbers, messages, graphs, tables, files, etc., instantly within the notebook. Jupyter is a powerful platform for experimentation and analysis. Don't be afraid to mess around with the code & break things - you'll learn a lot by encountering and fixing errors. You can use the \"Kernel > Restart & Clear Output\" or \"Edit > Clear Outputs\" menu option to clear all outputs and start again from the top.","30cd09e0":"We can now compute intermediate outputs for the batch of images by passing `inputs` through `layer1`.","96a79745":"Let's define a helper function to ensure that our code uses the GPU if available and defaults to using the CPU if it isn't. ","7f39369b":"Let's take a look at the model's parameters. We expect to see one weight and bias matrix for each of the layers.","c3f02c67":" This tutorial covers the following topics:\n \n * Creating a deep neural network with hidden layers\n * Using a non-linear activation function\n * Using a GPU (when available) to speed up training\n * Experimenting with hyperparameters to improve the model","104f6e4c":"Wait, nn.linear forms the basis of linear and logistic regression as this performs the **input * weight transpose + bias** calculation.\n\nTo improve the logistic regression model from the previous notebook, we will create a neural network with one hidden layer and an activation function. In logistic regression we used a single nn.linear to transform the batch of inputs (the inputs are pixel intensities between 0 & 1 giving various numbers) and outputs were class probabilities meaning each each input gave out 10 probabilities each referring to a certain number between 0 & 9 maximum probability was the correct number label of that input.\n\nThus each of the nn.linear is called a layer  in the network.\n","49e159d8":"The above output shows that 784 input vectrs were given which were consequently converted to 32 hidden outputs.\nThen 32 bias vector added.\nThen in the second layer, 32 hidden outputs become output for second layer converted to 10.\nAnother 10 bias was added.","ab5837fd":"As expected, `layer2_outputs` contains a batch of vectors of size 10. We can now use this output to compute the loss using `F.cross_entropy` and adjust the weights of `layer1` and `layer2` using gradient descent.","cc98870e":"We can now plot the losses & accuracies to study how the model improves over time.","f3035248":"Layers of the neural network.\n\nThe first layer (also known as the hidden layer) will transform the input matrix of shape **batch_size x 784** into an intermediate output matrix of shape batch_size x hidden_size, where hidden_size is a preconfigured parameter (e.g. 32 pr 64).\n\nThe intermediate outputs are then passed into a non-linear activation function, which operates on individual elements of the output matrix.\n\nThe result of the activation function, which is also of size batch_size x hidden_size, is passed into the second layer (also knowns as the output layer), which transforms it into a matrix of size batch_size x 10, identical to the output of the logistic regression model.","53aa4f25":"Thus, `layer1_outputs` and `inputs` have a linear relationship, i.e., each element of `layer_outputs` is a weighted sum of elements from `inputs`. Thus, even as we train the model and modify the weights, `layer1` can only capture linear relationships between `inputs` and `outputs`.\n\n<img src=\"https:\/\/i.imgur.com\/inXsLuq.png\" width=\"360\">\n","075324d9":"Let's try it out with a few images.","5700dab1":"Next, we'll use the Rectified Linear Unit (ReLU) function as the activation function for the outputs. It has the formula `relu(x) = max(0,x)` i.e. it simply replaces negative values in a given tensor with the value 0. ReLU is a non-linear function, as seen here visually:\n\n<img src=\"https:\/\/i.imgur.com\/yijV4xF.png\" width=\"420\">\n\nWe can use the `F.relu` method to apply ReLU to the elements of a tensor.","6534d960":"## Preparing the Data\n\nIn [the previous tutorial](https:\/\/jovian.ai\/aakashns\/03-logistic-regression), we trained a logistic regression model to identify handwritten digits from the MNIST dataset with an accuracy of around 86%. The dataset consists of 28px by 28px grayscale images of handwritten digits (0 to 9) and labels for each image indicating which digit it represents. Here are some sample images from the dataset:\n\n![mnist-sample](https:\/\/i.imgur.com\/CAYnuo1.jpg)\n\nWe noticed that it's quite challenging to improve the accuracy of a logistic regression model beyond 87%, since the model assumes a linear relationship between pixel intensities and image labels. In this post, we'll try to improve upon it  using a *feed-forward neural network* which can capture non-linear relationships between inputs and targets.\n\nLet's begin by installing and importing the required modules and classes from `torch`, `torchvision`, `numpy`, and `matplotlib`.","a7034678":"Our current model outperforms the logistic regression model (which could only achieve around 86% accuracy) by a considerable margin! It quickly reaches an accuracy of 97% but doesn't improve much beyond this. To improve accuracy further, we need to make the model more powerful by increasing the hidden layer's size or adding more hidden layers with activations. I encourage you to try out both these approaches and see which one works better.","e0ad1443":"# Training Deep Neural Networks on a GPU with PyTorch\n\n### Part 4 of \"Deep Learning with Pytorch: Zero to GANs\"\n\nThis tutorial series is a hands-on beginner-friendly introduction to deep learning using [PyTorch](https:\/\/pytorch.org), an open-source neural networks library. These tutorials take a practical and coding-focused approach. The best way to learn the material is to execute the code and experiment with it yourself. Check out the full series here:\n\n1. [PyTorch Basics: Tensors & Gradients](https:\/\/jovian.ai\/aakashns\/01-pytorch-basics)\n2. [Gradient Descent & Linear Regression](https:\/\/jovian.ai\/aakashns\/02-linear-regression)\n3. [Working with Images & Logistic Regression](https:\/\/jovian.ai\/aakashns\/03-logistic-regression) \n4. [Training Deep Neural Networks on a GPU](https:\/\/jovian.ai\/aakashns\/04-feedforward-nn)\n5. [Image Classification using Convolutional Neural Networks](https:\/\/jovian.ai\/aakashns\/05-cifar10-cnn)\n6. [Data Augmentation, Regularization and ResNets](https:\/\/jovian.ai\/aakashns\/05b-cifar10-resnet)\n7. [Generating Images using Generative Adversarial Networks](https:\/\/jovian.ai\/aakashns\/06b-anime-dcgan\/)\n","7a480540":"We can now wrap our data loaders using `DeviceDataLoader`.","28cbc6cd":"Next, let's create a `nn.Linear` object, which will serve as our _hidden_ layer. We'll set the size of the output from the hidden layer to 32. This number can be increased or decreased to change the _learning capacity_ of the model.","c91cad3e":"We can download the data and create a PyTorch dataset using the `MNIST` class from `torchvision.datasets`. ","41c1a280":"Note that `outputs` and `inputs` do not have a linear relationship due to the non-linear activation function `F.relu`. As we train the model and adjust the weights of `layer1` and `layer2`, we can now capture non-linear relationships between the images and their labels. In other words, introducing non-linearity makes the model more powerful and versatile. Also, since `hidden_size` does not depend on the dimensions of the inputs or outputs, we vary it to increase the number of parameters within the model. We can also introduce new hidden layers and apply the same non-linear activation after each hidden layer.\n\nThe model we just created is called a neural network. A _deep neural network_ is simply a neural network with one or more hidden layers. In fact, the [Universal Approximation Theorem](http:\/\/neuralnetworksanddeeplearning.com\/chap4.html) states that a sufficiently large & deep neural network can compute any arbitrary function i.e. it can _learn_ rich and complex non-linear relationships between inputs and targets. Here are some examples:\n\n* Identifying if an image contains a cat or a dog (or [something else](https:\/\/machinelearningmastery.com\/introduction-to-the-imagenet-large-scale-visual-recognition-challenge-ilsvrc\/))\n* Identifying the genre of a song using a 10-second sample\n* Classifying movie reviews as positive or negative based on their content\n* Navigating self-driving cars using a video feed of the road\n* Translating sentences from English to French (and hundreds of other languages)\n* Converting a speech recording to text and vice versa\n* And many more...\n\nIt's hard to imagine how the simple process of multiplying inputs with randomly initialized matrices, applying non-linear activations, and adjusting weights repeatedly using gradient descent can yield such astounding results. Deep learning models often contain millions of parameters, which can together capture far more complex relationships than the human brain can comprehend.\n\nIf we hadn't included a non-linear activation between the two linear layers, the final relationship between inputs and outputs would still be linear. A simple refactoring of the computations illustrates this.","4e97a3a8":"Let's define a helper function `predict_image`, which returns the predicted label for a single image tensor.","19c69c95":"## Testing with individual images\n\nWhile we have been tracking the overall accuracy of a model so far, it's also a good idea to look at model's results on some sample images. Let's test out our model with some images from the predefined test dataset of 10000 images. We begin by recreating the test dataset with the `ToTensor` transform.","775056c5":"## Using a GPU\n\nAs the sizes of our models and datasets increase, we need to use GPUs to train our models within a reasonable amount of time. GPUs contain hundreds of cores optimized for performing expensive matrix operations on floating-point numbers quickly, making them ideal for training deep neural networks. You can use GPUs for free on [Google Colab](https:\/\/colab.research.google.com\/) and [Kaggle](https:\/\/www.kaggle.com\/kernels) or rent GPU-powered machines on services like [Google Cloud Platform](https:\/\/cloud.google.com\/gpu\/), [Amazon Web Services](https:\/\/docs.aws.amazon.com\/dlami\/latest\/devguide\/gpu.html), and [Paperspace](https:\/\/www.paperspace.com\/).\n\nWe can check if a GPU is available and the required NVIDIA CUDA drivers are installed using `torch.cuda.is_available`."}}