{"cell_type":{"874f804e":"code","6acb6233":"code","b254e909":"code","feb098be":"code","87385bb5":"code","965f56d8":"code","ca8f2c94":"code","77c56ca6":"code","68f48c4d":"code","3f48594b":"code","54183313":"code","22f8d377":"code","08a8f5c3":"code","7510ac3d":"code","06178e42":"code","649f7ffb":"code","f22cfd13":"code","aa6edb23":"code","feff156e":"code","e2437f8c":"code","6388fbe1":"code","cf652d67":"code","761fe6e9":"code","5a3cbea9":"code","a8608b64":"code","c81f2d75":"code","2445dee2":"code","560b044d":"code","b77b9c78":"code","63b78276":"code","02321565":"code","28c53e73":"code","c107d738":"code","98e43ad6":"code","c41a67df":"code","189b084b":"code","0f8b26ca":"code","60343a96":"code","cbe75936":"code","a07d92e7":"code","6fe7148a":"code","c3bdbf23":"code","73b2bad8":"code","76418b16":"code","85e03a32":"code","4893bc84":"code","bb6a6bc9":"code","abdf2995":"code","018e19c8":"code","e8903190":"code","0f464854":"code","b36fc8a8":"code","327537d0":"code","92e46f5d":"code","04e799b4":"code","8c3b6b03":"code","8f277125":"code","49d8294a":"code","fd4c62ca":"code","a8fe3e09":"code","f9a06604":"code","147a96a9":"code","79cfc848":"code","ea1575fb":"code","ea6e6294":"code","f67ba03d":"code","6651ec20":"code","a142a3c6":"code","421adf1f":"code","6f041e5d":"code","93a93967":"code","f381faa3":"code","6f7af18d":"code","f9023f47":"code","c2491d65":"markdown","f64de2d1":"markdown","81805a6a":"markdown","70e2b1c0":"markdown","474dcd0b":"markdown","82e59199":"markdown","2331de03":"markdown","90bc3579":"markdown","1679ad88":"markdown","f0a125b4":"markdown","1733a82e":"markdown","741a93a9":"markdown"},"source":{"874f804e":"%%time\n! nvidia-smi\n#! rm -rf resnet_324.pth\n#!echo c.ExecutePreprocessor.timeout","6acb6233":"from fastai import *\nfrom fastai.vision import *\nfrom fastai.callbacks import *\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","b254e909":"! ls -l ..\/input\/","feb098be":"#path = Path('.\/data\/')\npath_t=Path('..\/input\/humpback-whale-identification\/')\npath_b=Path('..\/input\/')\npath1='.'\ndf = pd.read_csv(path_t\/'train.csv'); \n\n#!pip install fastai=='1.0.44'\n\nimport fastai\nfastai.__version__","87385bb5":"#df = pd.read_csv(LABELS).set_index('Image')\nexclude_list=['0b1e39ff.jpg',\n'0c11fa0c.jpg',\n'1b089ea6.jpg',\n'2a2ecd4b.jpg',\n'2c824757.jpg',\n'3e550c8a.jpg',\n'56893b19.jpg',\n'613539b4.jpg',\n'6530809b.jpg',\n'6b753246.jpg',\n'6b9f5632.jpg',\n'75c94986.jpg',\n'7f048f21.jpg',\n'7f7702dc.jpg',\n'806cf583.jpg',\n'95226283.jpg',\n'a3e9070d.jpg',\n'ade8176b.jpg',\n'b1cfda8a.jpg',\n'b24c8170.jpg',\n'b7ea8be4.jpg',\n'b9315c19.jpg',\n'b985ae1e.jpg',\n'baf56258.jpg',\n'c4ad67d8.jpg',\n'c5da34e7.jpg',\n'c5e3df74.jpg',\n'ced4a25c.jpg',\n'd14f0126.jpg',\n'e0b00a14.jpg',\n'e6ce415f.jpg',\n'e9bd2e9c.jpg',\n'f4063698.jpg',\n'f9ba7040.jpg']\nnew_whale_df = df[df.Id == \"new_whale\"] # only new_whale dataset\ntrain_df = df[~(df.Id == \"new_whale\")] # no new_whale dataset, used for training\nunique_labels = np.unique(train_df.Id.values)\ntrn_imgs=train_df.copy().reset_index(drop=True)\ncnter = Counter(trn_imgs.Id.values)\ntrn_imgs['cnt']=trn_imgs['Id'].apply(lambda x: cnter[x])\n#trn_imgs['target'] = 1\ntrn_imgs['target'] = 0 # 0 for same images\ntrn_imgs1 = trn_imgs.copy()\n#trn_imgs1['target'] = 0\ntrn_imgs1['target'] = 1 # 1 for dissimilar images\n#trn_imgs = trn_imgs.append(trn_imgs1)\ntarget_col = 3\ntrn_imgs.head(1)\ntrn_imgs=trn_imgs[~trn_imgs.Image.isin(exclude_list)]","965f56d8":"def read_img(fname,box_df,img,sz=224):\n    \n             \n    x0,y0,x1,y1 = tuple(box_df.loc[fname,['x0','y0','x1','y1']].tolist())\n    #print(img.shape)\n    l1,l0  = img.shape[1],img.shape[2]\n    b0,b1 = x1-x0, y1-y0\n        #padding\n    x0n,x1n = max(int(x0 - b0*0.05),0), min(int(x1 + b0*0.05),l0-1)\n    y0n,y1n = max(int(y0 - b1*0.05),0), min(int(y1 + b1*0.05),l1-1)\n    img=to_np(img)\n    \n    #print(img.shape,x0,y0,x1,y1)\n    if not (x0 >= x1 or y0 >= y1):\n        None\n        \n        #img = img[:,y0n:y1n, x0n:x1n]\n        #print(img.shape,'img')\n        #if self.tfms_g != None: img = self.tfms_g.augment_image(img)\n    img = img[:,y0n:y1n, x0n:x1n]\n    #print(img.T.shape)\n    #img = cv2.resize(img.T, (sz,sz))\n    return Image(pil2tensor(img.astype(np.float)\/255, np.float32).float())","ca8f2c94":"def crop_loose_bbox(img,area, val=0.2):\n    #img=np.asarray(img)\n    #print(img.shape)\n    l1, l0,_ = img.shape\n    #print(img.shape)\n    b0 = area[2] - area[0]\n    b1 = area[3] - area[1]\n    x0n,x1n = max(int(area[0] - b0*0.05),0), min(int(area[2] + b0*0.05),l0-1)\n    y0n,y1n = max(int(area[1] - b1*0.05),0), min(int(area[3] + b1*0.05),l1-1)\n   \n    #print(img[y0n:y1n,x0n:x1n,:].shape )\n    #img = cv2.resize(img[y0n:y1n,x0n:x1n,:], (224,224))\n    \"\"\"\n    area2 = (max(0, int(area[0] - 0.5*val*w)),\n             max(0, int(area[1] - 0.5*val*h)),\n             min(img_w, int(area[2] + 0.5*val*w)),\n             min(img_h, int(area[3] + 0.5*val*h)))\n    \"\"\"\n    return img[y0n:y1n,x0n:x1n,:] #img.crop(area2)\n","77c56ca6":"  \"\"\"\n    def __call__(self, fname):\n        fname = os.path.basename(fname)\n        #x0,y0,x1,y1 = tuple(self.boxes.loc[fname,['x0','y0','x1','y1']].tolist())\n        img = open_image(os.path.join(self.path,fname))\n        l1,l0,_ = img.shape\n        b0,b1 = x1-x0, y1-y0\n        #padding\n        x0n,x1n = max(int(x0 - b0*0.05),0), min(int(x1 + b0*0.05),l0-1)\n        y0n,y1n = max(int(y0 - b1*0.05),0), min(int(y1 + b1*0.05),l1-1)\n         \n        if self.tfms_g != None: img = self.tfms_g.augment_image(img)\n        img = cv2.resize(img[y0n:y1n,x0n:x1n,:], (sz,sz))\n        if self.tfms_px != None: img = self.tfms_px.augment_image(img)\n        return img.astype(np.float)\/255\n    \"\"\"","68f48c4d":"#bbox_df = pd.read_csv(path_b\/'cropped-img'\/'bounding_boxes.csv').set_index('Image')","3f48594b":"def open_4_channel2(fname):\n    fname = str(fname)\n    bbox_df = pd.read_csv(path_b\/'cropped-img'\/'bounding_boxes.csv').set_index('Image')\n    #print(fname)\n    # strip extension before adding color\n    x0,y0,x1,y1=bbox_df.loc[fname[fname.rfind('\/')+1:]]\n    area=(x0,y0,x1,y1)                        \n    #print(fname)\n    img     = cv2.imread(fname)\n    #PIL.Image.open(fname)\n    #print(img.size)\n                            \n    img=crop_loose_bbox(img,area)\n    \n    #img=np.asarray(img)\n    #print(img.shape)\n    #print(img.shape)\n   \n    #import time\n    #a=time.time()\n   \n    \n    return Image(pil2tensor(img\/255, np.float32).float())","54183313":"trn_imgs=trn_imgs.append(trn_imgs.loc[trn_imgs.cnt==2],ignore_index=True) \ntrn_imgs=trn_imgs.append(trn_imgs.loc[trn_imgs.cnt==1],ignore_index=True) ","22f8d377":"\nval_idx=[]\nimport random\nfor i in trn_imgs[trn_imgs.cnt>5].Id.unique():\n  tmp=list(trn_imgs.loc[trn_imgs.Id==i].index.values)\n  #print(tmp)\n  val_idx=val_idx+(random.sample(tmp,1))\nlen(val_idx)\n#since images less than 5 are less in number we dont select much from them \nfor i in trn_imgs[(trn_imgs.cnt<5) &( trn_imgs.cnt>2)].Id.unique():\n  \n  tmp=list(trn_imgs.loc[trn_imgs.Id==i].index.values)\n  #print(type(tmp))\n  \n  if len(val_idx) < 1300 :\n        \n        val_idx=val_idx+(random.sample(tmp,1))\nlen(val_idx)\n","08a8f5c3":"#val_idx[0:5]\n#train_idx=\n#trn_imgs[trn_imgs.Id=='w_f48451c']\n","7510ac3d":"#bbox_df = pd.read_csv(path\/'bounding_boxes.csv').set_index('Image')\n#x0,y0,x1,y1=bbox_df.loc['72c3ce75c.jpg']\n#crop_loo\n\n#open_4_channel(path\/'train'\/'0001f9222.jpg')\n #crop_loose_bbox(img,area, val=0.2)\nlen(trn_imgs.Id.unique())\n\n#trn_imgs[trn_imgs.cnt<3].Id.unique().shape","06178e42":"val_idx=list(trn_imgs.iloc[val_idx].index.values)\ntrn_idx=set(list(trn_imgs.index.values))-set(val_idx) # generating only trn idx to run\ndf_i=trn_imgs.iloc[list(trn_idx)].reset_index(drop=True) # this will be used latter on to run CV loop\n#fn2label = {row[1].Image: row[1].Id for row in df.iterrows()}\n#path2fn = lambda path: re.search('\\w*\\.jpg$', path).group(0)","649f7ffb":"#df_i.index.size 0000e88ab.jpg w_f48451c\n#df_i.Id.nunique()\n#trn_imgs.to_csv() \n#trn_imgs[trn_imgs.Image=='0001f9222.jpg']#w_c3d896a\t\n#df_i.head(2)","f22cfd13":"src1= (ImageList.from_df(trn_imgs[['Image','Id']],path_t, folder='train') #ImageList\n       .split_by_idx(val_idx)\n       .label_from_df( cols=1))","aa6edb23":"#trn_imgs.head(2)\n","feff156e":"\"\"\"\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import OneHotEncoder\nmlb = OneHotEncoder([i for i in range(5004)],sparse=False)\n#MultiLabelBinarizer([i for i in range(5004)],sparse_output=False)\n#y=mlb.fit_transform(np.array(list(1) ).reshape(-1,1))\n#trn_imgs['hot']=trn_imgs.Image.apply(lambda i : y[trn_imgs[trn_imgs.Image==i].index.values])\n#y[0]\n#trn_imgs.head(1)\n\n#np.array([1,2])\na=[one_hot(i,5004 )for i in range(5)]\n\nnp.array(a).reshape(5,-1).shape\n\"\"\"\n","e2437f8c":"test_ids = list(sorted({fname for fname in os.listdir(path_t\/'test')}))\n\n\n#protein_stats = ([0.16258, 0.13877, 0.10067, 0.16358], [0.21966, 0.18559, 0.25573,0.22066])\ntest_fnames = [path_t\/'test'\/test_id for test_id in test_ids]\n\ntest_fnames[:3]","6388fbe1":"#np.where(list(trn_imgs.hot.values)[1]==[1])[1]\n\n","cf652d67":"import cv2\nsrc1.train.x.create_func = open_4_channel2\nsrc1.train.x.open = open_4_channel2\n\nsrc1.valid.x.create_func = open_4_channel2\nsrc1.valid.x.open = open_4_channel2\nsrc1.add_test(test_fnames);\nsrc1.test.x.create_func = open_4_channel2\nsrc1.test.x.open = open_4_channel2\n# combine dataset\/transform\/dataloader into one dataobject called databunch in fastai\ntrn_tfms,_ = get_transforms(do_flip=False, flip_vert=True, max_rotate=5., max_zoom=1.08,\n                      max_lighting=0.15, max_warp=0. )\n\ndata1 = (src1.transform((trn_tfms,trn_tfms), size=224,resize_method=ResizeMethod.SQUISH)\n        .databunch(bs=64,num_workers=0).normalize(imagenet_stats))\n\ndata2 = (src1.transform((trn_tfms,trn_tfms), size=484,resize_method=ResizeMethod.SQUISH)\n        .databunch(bs=36,num_workers=0).normalize(imagenet_stats))","761fe6e9":"\n#a=[one_hot(i.unsqueeze(-1),5004 ) for i in tensor(data1.train_ds.y.items[0:5])]\n#listify(x)\n#np.where(a[0]==[1])\n#tensor(data1.train_ds.y.items[0:5])\n#type(a)\n#torch.from_numpy(np.array(a)).size()\n\n#data1.show_batch(2)\n#import pylot as plt\n#i=PIL.Image('data\/train\/3ece2140f.jpg')\n#print(i.shape)\n#plt.imshow(i)","5a3cbea9":"#data1.c\n#data1.show_batch(2)\n#!cp *.csv .\/data\/","a8608b64":"from fastai.metrics import accuracy","c81f2d75":"from torchvision import models as m\ndef dense(pre):\n    \n    #model=nn.Sequential(body, head)\n    model = m.densenet121(pretrained=pre)\n  \n    model.classifier = (nn.Linear(1024, 5004))\n\n   \n    return model\ndef _densenet_split(m): return   (m[0][0][6],m[1]) ","2445dee2":"#dense(True)","560b044d":"def acc (input:Tensor, targs:Tensor)->Rank0Tensor:\n  \n    \"Compute accuracy with `targs` when `input` is bs * n_classes.\"\n    n = targs.shape[0]\n    input = input.argmax(dim=-1).view(n,-1)\n    targs = targs.view(n,-1)\n    return (input==targs).float().mean()","b77b9c78":"i=torch.rand(3,2)\n#j=torch.ones(48,1)\nprint(i)\n#acc(i,j)\n#F.softmax(i,1) \n#torch.empty(5004, 1024)\n#nn.init.kaiming_normal_(torch.FloatTensor(5004, 1024))\n#torch.randint(4, (3,), dtype=torch.int64)","63b78276":"class ArcMarginProduct(nn.Module):\n    r\"\"\"Implement of large margin arc distance: :\n        Args:\n            in_features: size of each input sample\n            out_features: size of each output sample\n            s: norm of input feature\n            m: margin\n            cos(theta + m)\n        \"\"\"\n    def __init__(self, in_features, out_features=5004):\n        \n      \n        super(ArcMarginProduct, self).__init__()\n        self.weight = nn.Parameter(torch.FloatTensor(out_features, in_features))\n        self.reset_parameters()\n        #nn.init.kaiming_uniform_(self.weight)\n\n    def reset_parameters(self):\n        stdv = 1. \/ math.sqrt(self.weight.size(1)) # eq to input . This is more or less like Kaiming normal .\n        #we use this to ensure values remain between 0 and 1 . Since std deviation reduces to almost half every layer\n        # we can try some trick  multiplying it by 2 \n        self.weight.data.uniform_(-stdv, stdv)\n    \n    def forward(self, features):\n        #x=self.head(features)\n        #print(self.weight.shape)\n        #self.fc1.weight=nn.Parameter(F.normalize(self.fc1.weight)).cuda()\n        cosine = F.linear(F.normalize(features), F.normalize(self.weight.cuda()))\n        #cosine = cosine.clamp(-1, 1)\n        #self.fc1(F.normalize(x))\n        #F.linear(F.normalize(x), F.normalize(self.weight.cuda()))\n        return cosine   \n\nclass Customhead(nn.Module):\n    r\"\"\"Implement of large margin arc distance: :\n        Args:\n            in_features: size of each input sample\n            out_features: size of each output sample\n            s: norm of input feature\n            m: margin\n            cos(theta + m)\n        \"\"\"\n    def __init__(self, in_features, out_features=5004):\n        super(Customhead, self).__init__()\n        #self.weight = nn.Parameter(torch.FloatTensor(out_features, in_features))\n        #self.register_parameter('normweights',self.weight)\n        # nn.init.xavier_uniform_(self.weight)\n        #body = create_body(m.densenet121, True, -1)\n        body = create_body(m.resnet50, True, -2)\n#body = create_head(ArcMarginProduct, pretrained, 0)\n        nf = num_features_model(nn.Sequential(*body.children())) * 2\n        #head = \n        self.head=create_head(nf, 1024,[2048],  ps=0.5, bn_final=False) # 1024 no of classes\n        self.arc_margin=ArcMarginProduct(in_features,out_features)\n        #self.fc1=nn.Linear(1024,5004,bias=False)\n        #self.custom=nn.Sequential(self.head,self.fc1)\n        #self.reset_parameters()\n\n   # def reset_parameters(self):\n        #stdv = 1. \/ math.sqrt(self.weight.size(1))\n        #self.weight.data.uniform_(-stdv, stdv)\n       \n\n    def forward(self, features):\n        x=self.head(features)\n        #w=self.fc1.weight\n        #self.fc1.weight=nn.Parameter(F.normalize(self.fc1.weight)).cuda()\n        cosine = self.arc_margin(x)\n        #F.linear(F.normalize(x), F.normalize(w))\n        #self.arc_margin(x)\n        #F.linear(F.normalize(x), F.normalize(self.weight.cuda()))\n        cosine = cosine.clamp(-1, 1)\n        #self.fc1(F.normalize(x))\n        #F.linear(F.normalize(x), F.normalize(self.weight.cuda()))\n        return cosine","02321565":"#for i in Customhead(1024,5004).parameters():\n   #print( i.size())\n#Customhead(1024,5004)\n\nclass CustomheadRes(nn.Module):\n    r\"\"\"Implement of large margin arc distance: :\n        Args:\n            in_features: size of each input sample\n            out_features: size of each output sample\n            s: norm of input feature\n            m: margin\n            cos(theta + m)\n        \"\"\"\n    def __init__(self, in_features, out_features=5004):\n        super(CustomheadRes, self).__init__()\n        #self.weight = nn.Parameter(torch.FloatTensor(out_features, in_features))\n        #self.register_parameter('normweights',self.weight)\n        # nn.init.xavier_uniform_(self.weight)\n        body = create_body(m.densenet121, True, -1)\n        #body = create_body(m.resnet50, True, -2)\n#body = create_head(ArcMarginProduct, pretrained, 0)\n        nf = num_features_model(nn.Sequential(*body.children())) * 2\n        #head = \n        self.head=create_head(nf, 1024,  ps=0.5, bn_final=False) # 1024 no of classes\n        self.arc_margin=ArcMarginProduct(in_features,out_features)\n        #self.fc1=nn.Linear(1024,5004,bias=False)\n        #self.custom=nn.Sequential(self.head,self.fc1)\n        #self.reset_parameters()\n\n   # def reset_parameters(self):\n        #stdv = 1. \/ math.sqrt(self.weight.size(1))\n        #self.weight.data.uniform_(-stdv, stdv)\n       \n\n    def forward(self, features):\n        x=self.head(features)\n        #w=self.fc1.weight\n        #self.fc1.weight=nn.Parameter(F.normalize(self.fc1.weight)).cuda()\n        cosine = self.arc_margin(x)\n        #F.linear(F.normalize(x), F.normalize(w))\n        #self.arc_margin(x)\n        #F.linear(F.normalize(x), F.normalize(self.weight.cuda()))\n        cosine = cosine.clamp(-1, 1)\n        #self.fc1(F.normalize(x))\n        #F.linear(F.normalize(x), F.normalize(self.weight.cuda()))\n        return cosine","28c53e73":"#data1.show_batch(2)\n#src1.xtra.Id\nclass ArcFaceLoss(nn.modules.Module):\n    def __init__(self,s=30.0,m=0.5):\n        super(ArcFaceLoss, self).__init__()\n        self.classify_loss = nn.CrossEntropyLoss()\n        self.s = s\n        self.easy_margin = False\n        self.cos_m = math.cos(m) \n        self.sin_m = math.sin(m) \n        self.th = math.cos(math.pi - m)\n        self.mm = math.sin(math.pi - m) * m\n\n    def forward(self, inputs, labels, epoch=0,reduction=None):\n        cosine = inputs\n        sine = torch.sqrt(1.0 - torch.pow(cosine, 2))\n        phi = cosine * self.cos_m - sine * self.sin_m\n        if self.easy_margin:\n            phi = torch.where(cosine > 0, phi, cosine)\n        else:\n            phi = torch.where(cosine > self.th, phi, cosine - self.mm)\n\n        one_hot = torch.zeros(cosine.size(), device='cuda')\n        one_hot.scatter_(1, labels.view(-1, 1).long(), 1)\n        # -------------torch.where(out_i = {x_i if condition_i else y_i) -------------\n        output = (one_hot * phi) + ((1.0 - one_hot) * cosine)\n        output *= self.s\n        loss1 = self.classify_loss(output, labels) # this is as per paper what is missing here is centralized features\n        loss2 = self.classify_loss(cosine, labels)\n        gamma=1\n        loss=(loss1+gamma*loss2)\/(1+gamma)\n        return loss.mean()","c107d738":"\ndef resnet501(pre):\n    \n    model = m.resnet50(pretrained=pre)\n    #w=model.features[0].weight\n    #model.features[0]=nn.Conv2d(4, 64, kernel_size=7, stride=2, padding=3, bias=False)\n    #model.fc = (nn.Linear(1024, 5004))\n\n    #print(w.shape)\n   # model.features[0].weight=torch.nn.Parameter(torch.cat((w, w[:,:1,:,:]),dim=1))\n    #print(model.features[0].weight.shape)\n    return model\ndef _resnet_split(m): return (m[0][6],m[1])","98e43ad6":"ar=ArcFaceLoss().cuda() # this may not be needed just try it out","c41a67df":"\n#m1=nn.Sequential(body, head)\n#m1[:-1]\n\n#custom_head","189b084b":"f1_score = partial(fbeta, thresh=0.4, beta=1)\nacc_02 = partial(accuracy_thresh, thresh=0.2)\n\ncustom_head=Customhead(1024,5004)\ncustom_headres=CustomheadRes(1024,5004)\nar=ArcFaceLoss().cuda()\nfrom fastai.torch_core import *\nfrom fastai.callbacks import *\nfrom fastai.basic_train import *\nfrom torch.autograd import Variable\n\n#callbacks=[partial(GradientClipping, clip=1),partial(SaveModelCallback,monitor='trn_loss',mode='min')\n#           ,ReduceLROnPlateauCallback(learn, min_delta=1e-5, patience=3)]\nimport gc\ngc.collect()\nlearn1 = create_cnn(\n    data2,\n    #dense,\n    resnet501,\n    #dense,\n    #cut=-1,\n    cut=-2,\n    split_on=_resnet_split,\n    #_densenet_split,\n    lin_ftrs=[1024],\n    custom_head=custom_head,\n   \n    #lambda m: (m[0][11], m[1]),\n    loss_func=ar,\n    #torch.nn.MultiLabelSoftMarginLoss(),\n    #F.binary_cross_entropy_with_logits,\n    #FocalLoss(),\n    #F.binary_cross_entropy_with_logits,\n    path=path1,    \n    metrics=[accuracy], callback_fns= partial(GradientClipping, clip=1))\n \n#learn1 = Learner(data1, dense(), loss_func=torch.nn.MultiLabelSoftMarginLoss(),path=path,\n               #metrics=[acc_02,f1_scorestd], callback_fns= partial(GradientClipping, clip=1))\nlearn1.callback_fns.append(partial(SaveModelCallback,monitor='val_loss',mode='min'))\nlearn1.callback_fns.append(partial(ReduceLROnPlateauCallback, min_delta=1e-5, patience=3))\n\n# dense net used for building CNN.\nlearn2 = create_cnn(\n    data2,\n    dense,\n    #resnet501,\n    #dense,\n    cut=-1,\n    #cut=-2,\n    #split_on=_resnet_split,\n    split_on=_densenet_split,\n    lin_ftrs=[512],\n    custom_head=custom_headres,\n    #lambda m: (m[0][11], m[1]),\n    loss_func=ar,\n    #torch.nn.MultiLabelSoftMarginLoss(),\n    #F.binary_cross_entropy_with_logits,\n    #FocalLoss(),\n    #F.binary_cross_entropy_with_logits,\n    path=path1,    \n    metrics=[accuracy], callback_fns= partial(GradientClipping, clip=1))\n \n#learn1 = Learner(data1, dense(), loss_func=torch.nn.MultiLabelSoftMarginLoss(),path=path,\n               #metrics=[acc_02,f1_scorestd], callback_fns= partial(GradientClipping, clip=1))\n#learn2.callback_fns.append(partial(SaveModelCallback,monitor='val_loss',mode='min'))\nlearn2.callback_fns.append(partial(ReduceLROnPlateauCallback, min_delta=1e-5, patience=3))\n#learn2=learn2.to_fp16()","0f8b26ca":"#learn1.model[1]\n#data1.c\n#!cp dens* .\/data\/models\/\n#learn2.model#[6].weight.shape\n#learn2.save('save')\n#learn2.model\n#torch.FloatTensor(2,3)\n! mkdir \/kaggle\/working\/models\n#! ls -l \/kaggle\/input\/\n#!cp \/kaggle\/input\/dense324\/*.pth \/kaggle\/working\/models\/\n#!cp \/kaggle\/input\/arcface-humpback-customhead-fastai-score919\/models\/resnet_ar_c384.pth  \/kaggle\/working\/models\/\n#!cp \/kaggle\/input\/arcface-humpback-customhead-fastai\/models\/dense_ar_c1284.pth  \/kaggle\/working\/models\/\n#!cp \/kaggle\/input\/arcface-humpback-customhead-fastai-score919\/models\/resnet_ar_c484.pth  \/kaggle\/working\/models\/\n!cp \/kaggle\/input\/arcface-humpback-customhead-fastai-score919\/models\/dense_ar_c424_1.pth  \/kaggle\/working\/models\/\n\n#!cp \/kaggle\/input\/arcface-humpback-customhead-fastai-score919\/models\/resnet_ar_c424_2.pth  \/kaggle\/working\/models\/\n!cp \/kaggle\/input\/arcface-humpback-customhead-fastai-score919\/models\/resnet_ar_c424_1.pth  \/kaggle\/working\/models\/\n#!mv \/kaggle\/working\/models\/dense_ar_c324 \/kaggle\/working\/models\/dense_ar_c324.pth\n! ls -l   \/kaggle\/working\/models","60343a96":"import gc\ngc.collect()\n#learn2.lr_find()\n#learn2.recorder.plot()\n#!rm -rf .\/data\/models\/\n#len(data1.train_dl)\n#learn1.loss_func\n#data1.show_batch(2)\n#learn1.save('dense_224')\n#for i in learn2.model[1].parameters():\n    #print(i.size())","cbe75936":"#learn2.recorder.plot()\n#push\n#learn2.model[1]","a07d92e7":"#x,y=next(iter(learn1.data.train_dl))\n#! rm -rf .\/models\n#learn1.recorder.plot()\n#for i in trainable_params(learn2.model[1]):\n    #print(i.size())\n#push","6fe7148a":"#learn2.unfreeze()\n#learn2.load('dense_arc1')\n#learn2.fit_one_cycle(2,3e-2)","c3bdbf23":"#!ls -l\n#!cp  .\/data\/models\/dense_arc1.pth .\/\n\n#learn1.save('dense_arc1')\nfor i in learn1.model[1].parameters():\n  print(i.shape)\n#learn2.model[1]\nlearn2.model[1]","73b2bad8":"\"\"\"\nlr=1e-2 # ran stratified 224,284*2,now ffull\nlearn2.unfreeze()\n#learn2.load('save')\n#learn2.load('dense_ar_c324') #0.026030\t0.656774\t0.892308\nlearn2.fit_one_cycle(14,slice(2e-4,lr\/2))\nlearn2.save('dense_ar_c324')\n\"\"\"","76418b16":"#learn2.fit_one_cycle(8,slice(2e-4,lr\/2)) # run for 30 epochs \nlr=2e-2 # ran stratified 224,284*2,now ffull\n#learn2.unfreeze()\n#learn2.load('save')\n#learn2.load('dense_ar_c56') #0.026030\t0.656774\t0.892308\n#learn1.fit_one_cycle(2,slice(2e-4,lr\/2))\n#learn1.save('resnet_ar_c224')","85e03a32":"\"\"\"\nlr=2e-2 # ran stratified 224,284*2,now ffulls\n\nlearn1.unfreeze()\n#learn2.load('save')\nlearn1.load('resnet_ar_c424') #0.026030\t0.656774\t0.892308\nlearn1.fit_one_cycle(7,slice(2e-4,lr\/2))\nlearn1.save('resnet_ar_c424_1')\n\"\"\"\nlr=3e-2\nlearn1.unfreeze()\n#learn2.load('save')\nlearn1.load('resnet_ar_c424_1') #0.026030\t0.656774\t0.892308\nlearn1.fit_one_cycle(9,slice(2e-5,lr\/2))\nlearn1.save('resnet_ar_c424_2')\n\n ","4893bc84":"\"\"\" \nlr=1e-2 # ran stratified 224,284*2,now ffulls\nlearn2.unfreeze()\n#learn2.load('save')\nlearn2.load('dense_ar_c384') #0.026030\t0.656774\t0.892308\nlearn2.fit_one_cycle(11,slice(2e-5,lr\/2))\nlearn2.save('dense_ar_c424_1')\n \n\"\"\"","bb6a6bc9":"\nprint('Train_loss',learn1.recorder.losses[-1])\nprint('Val loss',learn1.recorder.val_losses)\n\nprint('Accuracy',learn1.recorder.metrics)\n ","abdf2995":"print('Train_loss',learn2.recorder.losses[-1])\nprint('Val loss',learn2.recorder.val_losses)\n\nprint('Accuracy',learn2.recorder.metrics)","018e19c8":"learn1.recorder.plot_losses()","e8903190":"#learn2.recorder.plot_losses()\n#w=tensor([0,1,0])\n#torch.nonzero(w == 0)\n#y1t[487]\n\n#len(set(data2.train_ds.y.items))","0f464854":"\"\"\" \nlearn2.model.eval()\n#!cp unfreeze_284_1.pth .\/data\/models\/\nlearn2.load('dense_ar_c424_1')\npreds2,y = learn2.TTA(ds_type=DatasetType.Test,beta=0.30,with_loss=False,scale=1.08)\n\"\"\"\nlearn1.load('resnet_ar_c424_2')\npreds1,y = learn1.get_preds(ds_type=DatasetType.Test)","b36fc8a8":"\n \n\nlearn1.model.eval()\nlearn1.load('resnet_ar_c424_2')\npreds1,y1 = learn1.TTA(ds_type=DatasetType.Test,beta=0.30,with_loss=False,scale=1.1)\n\n#preds1,y = learn1.get_preds(ds_type=DatasetType.Test)\n ","327537d0":"\"\"\" \nlearn1.model.eval()\nlearn1.load('resnet_ar_c424_1')\npreds1t,y1t = learn1.TTA(ds_type=DatasetType.Train,beta=0.30,with_loss=False,scale=1.1)\n\"\"\" ","92e46f5d":"\"\"\" \n# intra class mean\nl=[]\nfor c in list(set(data2.train_ds.y.items)):\n     l.append(torch.mean(preds1t[torch.nonzero(y1t == c)],dim=0))\n\ntrn_centre=torch.cat(l)\ntrn_centre.size()\n \"\"\"","04e799b4":"preds1.size()","8c3b6b03":"\"\"\"\n#learn1.load('resnet_ar_c424_1')\nlearn1.model.eval()\n#%%time\nsims = []\nwith torch.no_grad():\n    \n    for feat in preds1:\n        dists = F.cosine_similarity(trn_centre, feat.unsqueeze(0).repeat(5004, 1))\n        predicted_similarity = dists.cuda()#learn.model.head(dists.cuda())\n        sims.append(predicted_similarity.squeeze().detach().cpu())\n \"\"\"","8f277125":"#sims[20][sims[20].argsort(descending=True)[:5]]","49d8294a":"#! cp \/kaggle\/working\/models\/resnet_ar_c356.pth \/kaggle\/working\/\n#!ls -l .\/models\/\n#! cd models\n#torch.max(preds1,preds2).shape\n\n#torch.mean(preds1,preds2)\n#FileLink('resnet_ar_c356.pth')\n\"\"\"\nlearn1.model.eval()\nlearn1.load('resnet_ar_c356_1')\npredsv,y_v = learn1.TTA(ds_type=DatasetType.Valid,beta=0.30,with_loss=False,scale=1.08)\n\"\"\"","fd4c62ca":"def apk(actual, predicted, k=10):\n    if len(predicted)>k:\n        predicted = predicted[:k]\n\n    score = 0.0\n    num_hits = 0.0\n\n    for i,p in enumerate(predicted):\n        if p in actual and p not in predicted[:i]:\n            num_hits += 1.0\n            score += num_hits \/ (i+1.0)\n\n    if not actual:\n        return 0.0\n\n    return score \/ min(len(actual), k)\n\ndef mapk(actual, predicted, k=10):\n    return np.mean([apk(a,p,k) for a,p in zip(actual, predicted)])\ndef sigmoid_np(x):\n    return 1.0\/(1.0 + np.exp(-x))\n#preds_t = np.stack(preds1[0], axis=-1)\n#print(preds_t.shape)\npreds_tv = sigmoid_np(predsv )","a8fe3e09":"#np.linspace(0.5, 1, 10)\ni=preds_tv[99,:].argsort(descending=True)\nprobs = preds_tv[0,i]\nprobs[:5] \nnp.stack(top_5s_v).shape\nlabels_list[2]\n#y_v[0]","f9a06604":"\"\"\"\nclasses = df.Id.unique()\nnew_whale_idx = np.where(classes == 'new_whale')[0][0]\n#top_5s = []\nfor thresh in np.linspace(0.5, 1, 20):\n    top_5s_v = []\n    for sim in preds_tv:\n        idxs = sim.argsort(descending=True)\n        probs = sim[idxs]\n        top_5 = []\n        for i, p in zip(idxs, probs):\n            #if 'new_whale' not in top_5 and p <thresh and len(top_5) < 5: \n              #top_5.append('new_whale')\n            if len(top_5) == 5: break\n            if i == new_whale_idx: continue\n            predicted_class =idzxs #labels_list[i]\n            if predicted_class not in top_5: top_5.append(predicted_class)\n        top_5s_v.append(top_5)\n    print(thresh, mapk(data2.valid_ds.y.items.reshape(-1,1), np.stack(top_5s_v), 5))\n\"\"\"","147a96a9":" \ndef sigmoid_np(x):\n    return 1.0\/(1.0 + np.exp(-x))\n#preds_t = np.stack(preds1[0], axis=-1)\n#print(preds_t.shape)\npreds_t = sigmoid_np(preds1)\n#preds_t1 = sigmoid_np(preds1 )\n#preds_t2 = sigmoid_np(preds2 )\n#preds_t = sigmoid_np((preds1+preds2)\/2)\n#sigmoid_np(torch.max(preds1,preds2)) # ensembling part\n#preds_t = torch.max(preds_t1,preds_t2)\n\n\n#preds_t[90,i]\n ","79cfc848":"#((preds1+preds2)\/2).shape\n! nvidia -smi","ea1575fb":"#preds1[:,0:10]\ni=preds_t[99,:].argsort(descending=True)\nprobs = preds_t[99,i]\nprobs[:5] #0.7307, 0.5002, 0.5001, 0.5000, 0.5000])","ea6e6294":"unique_labels = np.unique(trn_imgs.Id.values)\n\nlabels_dict = dict()\nlabels_list = []\nfor i in range(len(unique_labels)):\n    labels_dict[unique_labels[i]] = i\n    labels_list.append(unique_labels[i])\nlabels_list[0]","f67ba03d":"#learn1.data\n#data1.xtra.Id.values","6651ec20":" \nclasses = df.Id.unique()\nnew_whale_idx = np.where(classes == 'new_whale')[0][0]\ntop_5s = []\nfor sim in preds_t:\n    idxs = sim.argsort(descending=True)\n    probs = sim[idxs]\n    top_5 = []\n    for i, p in zip(idxs, probs):\n        if 'new_whale' not in top_5 and p <0.585 and len(top_5) < 5: #615#575 res,.58 63 for dense .39\n          top_5.append('new_whale')\n        if len(top_5) == 5: break\n        if i == new_whale_idx: continue\n        predicted_class = labels_list[i]\n        if predicted_class not in top_5: top_5.append(predicted_class)\n    top_5s.append(top_5)\n ","a142a3c6":" \n\n#top_5_classes\n#top_5s","421adf1f":"from IPython.display import FileLink\n\ntop_5_classes = []\nfor top_5 in top_5s:\n    top_5_classes.append(' '.join([t for t in top_5]))\nsub = pd.DataFrame({'Image': [path.name for path in data1.test_ds.x.items]})\nsub['Id'] = top_5_classes\n\n#sub.head(10)\nsub.to_csv('pred_res484.csv',index=False)\nFileLink('pred_res484.csv')\n \n#!nvdia - smi","6f041e5d":"#sub.to_csv('resnetpred6.csv',index=False)\n#sub.head(10)\n#!kaggle competitions submit -c humpback-whale-identification -f 'resnetpred6.csv' -m \"bestresnet324_525\"","93a93967":"#df_i.head(2)\nX = list(df_i.index.values)\nset(df_i.iloc[X].Id)-set(trn_imgs.iloc[X].Id)\n\n#(df_i.iloc[X].Id,df_i.Id.values)\nlen(trn_imgs)\n#len(learn2.get_layer_group)","f381faa3":"\"\"\" \nlr=1e-2\n#learn1.fit_one_cycle(2,lr)\n#learn1.summary\n#learn1.save('freeez1')\n\n# Go through folds\n#for trn_idx, val_idx in folds.split(target, target):\n\n#!pip install iterative-stratification\n#from iterstrat.ml_stratifiers import MultilabelStratifiedKFold\nimport numpy as np\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom fastai.torch_core import *\nfrom fastai.callbacks import *\nfrom fastai.basic_train import *\nfrom torchvision import models\nimport gc\ngc.collect()\nfrom sklearn.model_selection import KFold, StratifiedKFold\n#df1=df.copy()\n#train_labels = df1.apply(fill_targets, axis=1) # convert comma separated targets into list\n#!cp *.pth .\/data\/models\/\nX = list(df_i.index.values)\ny=list(df_i.Id.values)\n#mlb = MultiLabelBinarizer( )\n#y=mlb.fit_transform(df_i.Id.values)\n#df['labels_v']=df.labels.apply(lambda x: mlb.fit_transform( x  )\n\n#y=df.Target.values\n#print(X.shape)\n#np.array([[1,2], [3,4], [1,2], [3,4], [1,2], [3,4], [1,2], [3,4]])\n#y = np.array([[0,0], [0,0], [0,1], [0,1], [1,1], [1,1], [1,0], [1,0]])\n\nmskf = StratifiedKFold(n_splits=9, random_state=2)\n\n#MultilabelStratifiedKFold(n_splits=9, random_state=2)\n#val_idx= df.loc[df.Id.isin(val_n)].index\ni=0\n#!cp *.pth .\/data\/models\/\n#stage-1-rn50-f\n#learn.load('stage-1-rn50-f')\n#protein_stats =([0.08069, 0.05258, 0.05487, 0.08282],[0.13704, 0.10145, 0.15313, 0.13814])\nfor train_index, test_index in mskf.split(X, y):\n    val_i=test_index\n\n#ImageItemList.from_csv( path, 'train.csv',folder='train', suffix='.png')\n\n    src= (ImageList.from_df(df_i[['Image','Id']],path_t, folder='train') #ImageList\n       .split_by_idx(val_i)\n       #..split_by_valid_func(lambda path: path2fn(path) in val_fns)\n        #.label_from_func(lambda path: fn2label[path2fn(path)]))\n       .label_from_df( cols=1))\n    \n   \n    src.train.x.create_func = open_4_channel2\n    src.train.x.open = open_4_channel2\n\n    src.valid.x.create_func = open_4_channel2\n    src.valid.x.open = open_4_channel2\n    \n    src.add_test(test_fnames);\n    src.test.x.create_func = open_4_channel2\n    src.test.x.open = open_4_channel2\n   \n    #data.c=5004\n    \n    if i>=0:\n        \n      \n        \n        trn_tfms,_ = get_transforms(do_flip=False, flip_vert=True, max_rotate=5., max_zoom=1.08,\n                              max_lighting=0.15, max_warp=0. )\n        #protein_stats = ([0.16258, 0.13877, 0.10067 ], [0.21966, 0.18559, 0.25573 ])\n        \n\n        data = (src.transform((trn_tfms,trn_tfms), size=484,resize_method=ResizeMethod.SQUISH)\n        .databunch(bs=32,num_workers=0).normalize(imagenet_stats)) #40\n        #data.c=5004\n        learn = create_cnn(\n                      data,\n                      resnet501,\n                     split_on=_resnet_split,\n                      cut=-2,\n                     # dense,\n                      \n                      #cut=-1,\n                     # split_on=_densenet_split,\n                    \n                      lin_ftrs=[1024],\n                       \n                      #lambda m: (m[0][11], m[1]),\n                      loss_func=ar,\n                      #custom_head=custom_headres,\n                       custom_head=custom_head,\n            #custom_head,\n                      #torch.nn.MultiLabelSoftMarginLoss(),\n                      #F.binary_cross_entropy_with_logits,\n                      #FocalLoss(),\n                      #F.binary_cross_entropy_with_logits,\n                      path=path1,    \n                      metrics=[accuracy], callback_fns= partial(GradientClipping, clip=1))\n        #learn.callback_fns.append(partial(SaveModelCallback,monitor='val_loss',mode='min'))\n        learn.callback_fns.append(partial(ReduceLROnPlateauCallback, min_delta=1e-5, patience=3))\n        #learn.to_fp16()\n        #learn.load('stage-1-rn50')\n        #print('load')\n        \n        lr=1e-2\n        #4e-4 # every 3-4 epocs reduce by 1 2e-3,1e-3.slice (lr\/10,lr )\n        #learn.load('stage-1-rn50-u7datablocks')\n        #learn.load('stage-1-rn50-u11_512')\n        if i==0:\n            \n            learn.load('resnet_ar_c424_1')\n            print('x')\n        else :\n\n            learn.load('resnet_ar_c484')  \n        print(i)  \n        learn.unfreeze()\n        learn.fit_one_cycle(1, slice(2e-5,lr\/2))\n        learn.save('resnet_ar_c484')\n    i=i+1\n#re\n \"\"\"","6f7af18d":"#learn.recorder.losses\n\"\"\" \nlr=2e-2 # ran stratified 224,284*2,now ffulls\n\nlearn2.unfreeze()\n#learn2.load('save')\nlearn2.load('dense_ar_c424') #0.026030\t0.656774\t0.892308\nlearn2.fit_one_cycle(7,slice(2e-4,lr\/2))\nlearn2.save('dense_ar_c424')\n\"\"\"\n\"\"\" \nlr=1e-2 # ran stratified 224,284*2,now ffulls\n\nlearn1.unfreeze()\n#learn2.load('save')\nlearn1.load('resnet_ar_c484') #0.026030\t0.656774\t0.892308\nlearn1.fit_one_cycle(7,slice(2e-5,lr\/2))\nlearn1.save('resnet_ar_c484_2')\n\"\"\"","f9023f47":"#print('Train_loss',learn2.recorder.losses[-1])\n#print('Val loss',learn2.recorder.val_losses)\n\n#print('Accuracy',learn2.recorder.metrics)","c2491d65":"**Training Process**\n1) Resnet 50 \n*    1) Starting with 224 Number of Epochs 10-12 . We should not train for more epoch on a single image size to avoid overfitting .This should get a score 70+\n*    2) Change the image to 284 and run the stratified CV loop with 9 folds\n*    3) Run the complete Training set with number of epoch around 10 - At the end of epoch we should toch the score of 80 or 80 plus . Threshold at ths time .52 to .535\n*    4) Change the image size to 324  ,run the stratified loop \n*    5) Train with compelte Training set with image size  324  for 8 to 9 epochs.By this time score should be hovering around 84 to 85 \n*    6) Change the image size to 384  and repeat the process . As model gets better threshold will have to be increased \n\n2) Dense 121 \n   Repeat the same way as above\n  \nCurrent score with Image size 424  stands out to be .92942 and ensemble of Resnet 50 and dense121.\n\nI am expecting to hit 93 to 94 as i gradually increase the image size to 512. One more thing  I want to try at the end is Averaging the Intraclass predictions using training set predictions  to produce matrix of 5004 * 5004 and then use this embedding to find cosine similarity between  Test prediction and matrix to generate the classes\nThanks @lafoss for helping me understand this.","f64de2d1":"CV loop using Training set. This is useful when we are running with different image size. Strategy i follow is  Run for one size say 224  2 times with 9 fold loop followed by running with all . again increase size to say 284 ,run the CV loop 2 times then like wise. \nRemember Arcface is slow converging loss .","81805a6a":"Doing the oversampling of those species which are having only a single image and 2 images","70e2b1c0":"Arface loss getting normalized output from Fc1","474dcd0b":"Get LR using best lf find . 1e-2  to 3e-2 is the suitable LR.","82e59199":"Generate the dataset using FAI datablock ","2331de03":"Prediction Part using TTA . TTA helps scoring better . In the base line model where in i used pure classification . I was able to get a score 82 in Private leader board.Using ArcFace loss on Pure classification able to reach to 87 on Private LB image sz-324","90bc3579":"This notebook is using latest Fastai version to implement ArcfFace loss using Custom Head for whale species identification using Humpback . ArcFace loss has been used by many top rankers following paper\nhttps:\/\/arxiv.org\/pdf\/1801.07698.pdf\nIm able to implement only a part of it following the solutions of Top3 rankers but not able to implement  Feature centre part for which I need help from the suggestions . Please give your input how i can implement the Feature centralization part which will major boost to this solution. ","1679ad88":"Custom open program to read the bounding boxes  and crop the image to remove the unwanted background. Bounding boxes provided in public kernels are exteremely important in getting a high score. ","f0a125b4":"BUilding a balanced validation set to ensure we are having all type of species for validation based on the count of the image for species","1733a82e":"Custom Head building . THis will be responsibly for generating the normalized features\/weights which are needed as per ArcFace paper. ","741a93a9":"Build dense 121 network . We can also use similarly Resnet50"}}