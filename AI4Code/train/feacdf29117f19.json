{"cell_type":{"967fdd11":"code","1f111a1c":"code","dd0e541b":"code","759a11a0":"code","8264d0cd":"code","5899ea13":"code","a286b12f":"code","39fb84c0":"code","e8e8250e":"code","7384edf8":"code","d5d5afdc":"code","7fdaa948":"code","13296d31":"code","f18ed268":"code","18e24b32":"code","813f2d6e":"code","fbb84bd0":"markdown","c3a840ea":"markdown","508e88e6":"markdown","63676b43":"markdown","4a6b9de4":"markdown","372bea04":"markdown","4ea126e0":"markdown","a1741915":"markdown","ef7f0aa7":"markdown","f5cf5cb3":"markdown","9e907334":"markdown"},"source":{"967fdd11":"# \u505a\u4e00\u4e9b\u51c6\u5907\u6027\u7684\u5de5\u4f5c\uff0cprint_function\u76ee\u7684\u662f\u4e3a\u4e86\u8981\u517c\u5bb9py2\uff0cpy3\u7684\u8f93\u51fa\u3002\nfrom __future__ import print_function\nimport sys\nsys.path.append('\/kaggle\/input\/ms326-knn')\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# \u8ba9\u56fe\u7247\u751f\u6210\u5728notebook\u4e2d\u800c\u4e0d\u662f\u751f\u6210\u65b0\u7684\u7a97\u53e3\n%matplotlib inline\nplt.rcParams['figure.figsize'] = (10.0, 8.0) # set default size of plots\nplt.rcParams['image.interpolation'] = 'nearest'\nplt.rcParams['image.cmap'] = 'gray'\n\n\n#\u4f5c\u7528\uff1a\u5728\u8c03\u8bd5\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5982\u679c\u4ee3\u7801\u53d1\u751f\u66f4\u65b0\uff0c\u5b9e\u73b0ipython\u4e2d\u5f15\u7528\u7684\u6a21\u5757\u4e5f\u80fd\u81ea\u52a8\u66f4\u65b0\u3002\n# see http:\/\/stackoverflow.com\/questions\/1907993\/autoreload-of-modules-in-ipython\n%load_ext autoreload\n%autoreload 2","1f111a1c":"# Load the raw Fashion_mnist data.\nimport os\nimport pandas\nwith open(\"..\/input\/fashionmnist\/fashion-mnist_test.csv\", \"r\") as f:\n    test_data = pandas.read_csv(f).values\nwith open(\"..\/input\/fashionmnist\/fashion-mnist_train.csv\", \"r\") as f:\n    train_data = pandas.read_csv(f).values\n    \nX_train = train_data[:, 1:].astype(np.float32)\ny_train = train_data[:, 0]\n\nX_test = train_data[:, 1:].astype(np.float32)\ny_test = train_data[:, 0]\n\n# As a sanity check, we print out the size of the training and test data.\nprint('Training data shape: ', X_train.shape)\nprint('Training labels shape: ', y_train.shape)\nprint('Test data shape: ', X_test.shape)\nprint('Test labels shape: ', y_test.shape)","dd0e541b":"# np.flatnonzero \u77e9\u9635\u6241\u5e73\u5316\u540e\u8fd4\u56de\u975e\u96f6\u5143\u7d20\u7684\u4f4d\u7f6e\n# numpy.random.choice(a, size=None, replace=True, p=None) \u968f\u673a\u9009\u53d6a\u4e2d\u7684\u503c\nclasses = ['T-shirt', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Boot']\nnum_classes = len(classes)\nsamples_per_class = 7\nfor y, cls in enumerate(classes):\n    idxs = np.flatnonzero(y_train == y)\n    idxs = np.random.choice(idxs, samples_per_class, replace=False)\n    for i, idx in enumerate(idxs):\n        plt_idx = i * num_classes + y + 1\n        plt.subplot(samples_per_class, num_classes, plt_idx)\n        plt.subplots_adjust(left=0, bottom=None, right=None, top=None,\n                wspace=0.1, hspace=0.1)\n        plt.imshow(X_train[idx].reshape((28,28)),cmap=plt.cm.gray)\n        plt.axis('off')\n        if i == 0:\n            plt.title(cls)\nplt.show()","759a11a0":"# Subsample the data for more efficient code execution in this exercise\nnum_training = 5000\nmask = list(range(num_training))\nX_train = X_train[mask]\ny_train = y_train[mask]\n\nnum_test = 500\nmask = list(range(num_test))\nX_test = X_test[mask]\ny_test = y_test[mask]","8264d0cd":"# Reshape the image data into rows\nX_train = np.reshape(X_train, (X_train.shape[0], -1))\nX_train = np.array(X_train, dtype = np.int32)\nX_test = np.reshape(X_test, (X_test.shape[0], -1))\nX_test = np.array(X_test, dtype = np.int32)\nprint(X_train.shape, X_test.shape)","5899ea13":"from k_nearest_neighbor import KNearestNeighbor\n\n# Create a kNN classifier instance. \n# Remember that training a kNN classifier is a noop: \n# the Classifier simply remembers the data and does no further processing \nclassifier = KNearestNeighbor()\nclassifier.train(X_train, y_train)\n# While encounter 'No module named 'past'' : run pip install future","a286b12f":"# Open MS326\/classifiers\/k_nearest_neighbor.py and implement\n# compute_distances_two_loops.\ndef compute_distances_two_loops(self, X):\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train))\n    for i in xrange(num_test):\n        for j in xrange(num_train):\n            dists[i][j] = np.sqrt(np.sum(np.square(X[i] - self.X_train[j])))\n    return dists\n\n\n# Test your implementation:\ndists = classifier.compute_distances_two_loops(X_test)\nprint(dists.shape)","39fb84c0":"# We can visualize the distance matrix: each row is a single test example and\n# its distances to training examples\nplt.imshow(dists, interpolation='none')\nplt.show()","e8e8250e":"# Now implement the function predict_labels and run the code below:\n# We use k = 1 (which is Nearest Neighbor).\ny_test_pred = classifier.predict_labels(dists, k=1)\n\n# Compute and print the fraction of correctly predicted examples\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) \/ num_test\nprint('Got %d \/ %d correct => accuracy: %f' % (num_correct, num_test, accuracy))","7384edf8":"y_test_pred = classifier.predict_labels(dists, k=5)\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) \/ num_test\nprint('Got %d \/ %d correct => accuracy: %f' % (num_correct, num_test, accuracy))","d5d5afdc":"# Now lets speed up distance matrix computation by using partial vectorization\n# with one loop. Implement the function compute_distances_one_loop and run the\n# code below:\n\n# python Broadcasting\u673a\u5236\ndef compute_distances_one_loop(self, X):\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train))\n    for i in xrange(num_test):\n        dists[i] = np.sqrt(np.sum(np.square(self.X_train - X[i]), axis = 1))\n    return dists\n\ndists_one = classifier.compute_distances_one_loop(X_test)\n\n# \u6211\u4eec\u53ef\u4ee5\u7528 Frobenius \u8303\u6570\u53bb\u5224\u65ad\u6211\u4eec\u662f\u5426\u6c42\u89e3\u6b63\u786e\u4e86. \n# In case you haven't seen it before, the Frobenius norm of two matrices is the square\n# root of the squared sum of differences of all elements; in other words, reshape\n# the matrices into vectors and compute the Euclidean distance between them.\ndifference = np.linalg.norm(dists - dists_one, ord='fro')\nprint('Difference was: %f' % (difference, ))\nif difference < 0.001:\n    print('Good! The distance matrices are the same')\nelse:\n    print('Uh-oh! The distance matrices are different')","7fdaa948":"# Now implement the fully vectorized version inside compute_distances_no_loops\n# and run the code\ndef compute_distances_no_loops(self, X):\n    num_test = X.shape[0]\n    num_train = self.X_train.shape[0]\n    dists = np.zeros((num_test, num_train)) \n    #########################################################################\n    # HINT: Try to formulate the l2 distance using matrix multiplication    #\n    #       and two broadcast sums                                          #\n    # Attention: square(x1-x2) = square(x1) + square(x2) - 2 * x1 * x2      #\n    #########################################################################\n    x1_x2 = np.dot(X, self.X_train.T)  # num_test * num_train\n    test_square = np.sum(np.square(X), axis=1).reshape(-1,1) # num_test * 1\n    train_square = np.sum(np.square(self.X_train.T), axis=0).reshape(1,-1) # 1 * num_trian\n    dists = np.sqrt(-2 * x1_x2 + test_square + train_square) #broadcast\n    return dists\n\n\ndists_two = classifier.compute_distances_no_loops(X_test)\n# check that the distance matrix agrees with the one we computed before:\ndifference = np.linalg.norm(dists - dists_two, ord='fro')\nprint('Difference was: %f' % (difference, ))\nif difference < 0.001:\n    print('Good! The distance matrices are the same')\nelse:\n    print('Uh-oh! The distance matrices are different')","13296d31":"# Let's compare how fast the implementations are\ndef time_function(f, *args):\n    \"\"\"\n    Call a function f with args and return the time (in seconds) that it took to execute.\n    \"\"\"\n    import time\n    tic = time.time()\n    f(*args)\n    toc = time.time()\n    return toc - tic\n\ntwo_loop_time = time_function(classifier.compute_distances_two_loops, X_test)\nprint('Two loop version took %f seconds' % two_loop_time)\n\none_loop_time = time_function(classifier.compute_distances_one_loop, X_test)\nprint('One loop version took %f seconds' % one_loop_time)\n\nno_loop_time = time_function(classifier.compute_distances_no_loops, X_test)\nprint('No loop version took %f seconds' % no_loop_time)\n\n# you should see significantly faster performance with the fully vectorized implementation","f18ed268":"num_folds = 5\nk_choices = [1, 3, 5, 8, 10, 12, 15, 20, 50, 100]\n\nX_train_folds = []\ny_train_folds = []\n################################################################################                                                                       #\n# Split up the training data into folds. After splitting, X_train_folds and    #\n# y_train_folds should each be lists of length num_folds, where                #\n# y_train_folds[i] is the label vector for the points in X_train_folds[i].     #\n# Hint: Look up the numpy array_split function.                                #\n################################################################################\ny_train_ = y_train.reshape(-1, 1)\nX_train_folds , y_train_folds = np.array_split(X_train, num_folds), np.array_split(y_train_, num_folds)\n\n# A dictionary holding the accuracies for different values of k that we find\n# when running cross-validation. After running cross-validation,\n# k_to_accuracies[k] should be a list of length num_folds giving the different\n# accuracy values that we found when using that value of k.\nk_to_accuracies = {}\n\n################################################################################\n# Perform k-fold cross validation to find the best value of k. For each        #\n# possible value of k, run the k-nearest-neighbor algorithm num_folds times,   #\n# where in each case you use all but one of the folds as training data and the #\n# last fold as a validation set. Store the accuracies for all fold and all     #\n# values of k in the k_to_accuracies dictionary.                               #\n################################################################################\nfor k in k_choices:\n    k_to_accuracies.setdefault(k, [])\n\nfor i in range(num_folds):\n    classifier = KNearestNeighbor()\n    X_val_train = np.vstack(X_train_folds[0:i] + X_train_folds[i+1:])\n    y_val_train = np.vstack(y_train_folds[0:i] + y_train_folds[i+1:])[:,0]\n    classifier.train(X_val_train, y_val_train)\n    for k in k_choices:\n        y_val_pred = classifier.predict(X_train_folds[i], k=k)\n        num_correct = np.sum(y_val_pred == y_train_folds[i][:,0])\n        accuracy = float(num_correct) \/ len(y_val_pred)\n        k_to_accuracies[k] = k_to_accuracies[k] + [accuracy]\n    \n# Print out the computed accuracies\nfor k in sorted(k_to_accuracies):\n    for accuracy in k_to_accuracies[k]:\n        print('k = %d, accuracy = %f' % (k, accuracy))","18e24b32":"# plot the raw observations\nfor k in k_choices:\n    accuracies = k_to_accuracies[k]\n    plt.scatter([k] * len(accuracies), accuracies)\n\n# plot the trend line with error bars that correspond to standard deviation\naccuracies_mean = np.array([np.mean(v) for k,v in sorted(k_to_accuracies.items())])\naccuracies_std = np.array([np.std(v) for k,v in sorted(k_to_accuracies.items())])\nplt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)\nplt.title('Cross-validation on k')\nplt.xlabel('k')\nplt.ylabel('Cross-validation accuracy')\nplt.show()","813f2d6e":"# Based on the cross-validation results above, choose the best value for k,   \n# retrain the classifier using all the training data, and test it on the test\n# data. You should be able to get above 83% accuracy on the test data.\nbest_k = 15\n\nclassifier = KNearestNeighbor()\nclassifier.train(X_train, y_train)\ny_test_pred = classifier.predict(X_test, k=best_k)\n\n# Compute and display the accuracy\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) \/ num_test\nprint('Got %d \/ %d correct => accuracy: %f' % (num_correct, num_test, accuracy))","fbb84bd0":"# Fashion-MNIST\n  Fashion-MNIST \u662f\u2f00\u4e2a10 \u7c7b\u670d\u9970\u5206\u7c7b\u6570\u636e\u96c6\u3002Fashion-MNIST \u4e2d\u2f00\u5171\u5305\u62ec\u4e8610 \u4e2a\u7c7b\u522b\uff0c\u5206\u522b\u4e3a\uff1at-shirt\uff08T \u6064\uff09\u3001trouser\uff08\u88e4\u2f26\uff09\u3001pullover\uff08\u5957\u886b\uff09\u3001dress\uff08\u8fde\u2f90\u88d9\uff09\u3001coat\uff08\u5916\u5957\uff09\u3001sandal\uff08\u51c9\u978b\uff09\u3001shirt\uff08\u886c\u886b\uff09\u3001sneaker\uff08\u8fd0\u52a8\u978b\uff09\u3001bag\uff08\u5305\uff09\u548cankle boot\uff08\u77ed\u9774\uff09\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u53ef\u89c6\u5316\u6765\u5f88\u597d\u7684\u4e86\u89e3\u6570\u636e\u96c6","c3a840ea":"We would now like to classify the test data with the kNN classifier. Recall that we can break down this process into two steps: \n\n1. First we must compute the distances between all test examples and all train examples. \n2. Given these distances, for each test example we find the k nearest examples and have them vote for the label\n\nLets begin with computing the distance matrix between all training and test examples. For example, if there are **Ntr** training examples and **Nte** test examples, this stage should result in a **Nte x Ntr** matrix where each element (i,j) is the distance between the i-th test and j-th train example.\n\n**Note: For the three distance computations that we require you to implement in this notebook, you may not use the np.linalg.norm() function that numpy provides.**\n\nFirst, open `MS326\/classifiers\/k_nearest_neighbor.py` and implement the function `compute_distances_two_loops` that uses a (very inefficient) double loop over all pairs of (test, train) examples and computes the distance matrix one element at a time.","508e88e6":"**Your Answer**: \n*1.If the ith test data is similar to a large number of train data, the ith row would be black. Otherwise,the ith row would be white.*\n*2 .If the jth train data is similar to a large number of test data, the jth column would be black. Otherwise,the jth column would be white.*\n\n\n","63676b43":"**Inline Question 3**\n\nWhich of the following statements about $k$-Nearest Neighbor ($k$-NN) are true in a classification setting, and for all $k$? Select all that apply.\n1. The decision boundary of the k-NN classifier is linear.\n2. The training error of a 1-NN will always be lower than that of 5-NN.\n3. The test error of a 1-NN will always be lower than that of a 5-NN.\n4. The time needed to classify a test example with the k-NN classifier grows with the size of the training set.\n5. None of the above.\n\n$\\color{blue}{\\textit Your Answer:}$ 2\uff0c4\n\n\n$\\color{blue}{\\textit Your Explanation:}$ \n1. The decision boundary is not linear because it calculates the distance to the vertex. Suppose a class has a vertex x in the center and the other class has lots of vertexs with distance 2 to vertex. And we use 1-NN. We can see the boundary is nearly a circle with the radius 1.\n2. When k=1, it means that only the nearest point can be judged, so there is no error in training. When k=5, there will be different training errors according to the rule of vote.\n3. It is decided by the data distribution and can be easily constructed in small dataset.\n4. Because the method should compare each test data with each training set. The larger the training set, the larger the distance matrix, the bigger the running time.\n\n\n\n\n","4a6b9de4":"You should expect to see approximately `80%` accuracy. Now lets try out a larger `k`, say `k = 5`:","372bea04":"### Cross-validation\n\nWe have implemented the k-Nearest Neighbor classifier but we set the value k = 5 arbitrarily. We will now determine the best value of this hyperparameter with cross-validation.","4ea126e0":"**Inline Question 2**\n\nWe can also use other distance metrics such as L1 distance.\nFor pixel values $p_{ij}^{(k)}$ at location $(i,j)$ of some image $I_k$, \n\nthe mean $\\mu$ across all pixels over all images is $$\\mu=\\frac{1}{nhw}\\sum_{k=1}^n\\sum_{i=1}^{h}\\sum_{j=1}^{w}p_{ij}^{(k)}$$\nAnd the pixel-wise mean $\\mu_{ij}$ across all images is \n$$\\mu_{ij}=\\frac{1}{n}\\sum_{k=1}^np_{ij}^{(k)}.$$\nThe general standard deviation $\\sigma$ and pixel-wise standard deviation $\\sigma_{ij}$ is defined similarly.\n\nWhich of the following preprocessing steps will not change the performance of a Nearest Neighbor classifier that uses L1 distance? Select all that apply.\n1. Subtracting the mean $\\mu$ ($\\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\\mu$.)\n2. Subtracting the per pixel mean $\\mu_{ij}$  ($\\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\\mu_{ij}$.)\n3. Subtracting the mean $\\mu$ and dividing by the standard deviation $\\sigma$.\n4. Subtracting the pixel-wise mean $\\mu_{ij}$ and dividing by the pixel-wise standard deviation $\\sigma_{ij}$.\n5. Rotating the coordinate axes of the data.\n\n$\\color{blue}{\\textit Your Answer:}$ \n1,3\n\n\n$\\color{blue}{\\textit Your Explanation:}$\n1. Each pixel subtracts the same average value, so the $L1$ loss will not change.\n2. Each pixel subtracts the different average value, so the $L1$ loss will change.\n3. Like 1, $\\|(x1 - \\mu)\/\\sigma - (x2 - \\mu)\/\\sigma\\| = \\|x1 - x2\\|\/\\sigma$, The ratio of distance is the same, so the performance of $L1$ is not affected.\n4. Like 2,so the $L1$ loss will change.\n5. Rotating the coordinate axes of the data will influence the $L1$ loss, however $L2$ loss will not change. Just like $(0,0)$,$(2,2)$. If we rotate the coordinate axes to make them $(0,2\\sqrt{2})$,$(0,0)$\n","a1741915":"**Compute_distances_no_loops**\n\n$\u539f\u7406\uff1a\u5047\u8bbeX\u662f\u6d4b\u8bd5\u96c6(m*d),\u8bad\u7ec3\u96c6Y\u662f(n*d),\u5176\u4e2dm\u662f\u6d4b\u8bd5\u6570\u636e\u6570\u91cf\uff0cn\u662f\u8bad\u7ec3\u6570\u636e\u6570\u91cf\uff0cd\u662f\u7ef4\u5ea6\u3002\u8ba1\u7b97\u4e24\u8005\u516c\u5f0f\u5982\u4e0b\uff1a$\n\\begin{equation}\n\\sum_{i=0}^{m} \\sum_{j=0}^{n}\\sqrt{(P_i - C_j)^2} = \\sum_{i=0}^{m} \\sum_{j=0}^{n}\\sqrt{\\|P_i\\|^2 + \\|C_j\\|^2 - 2 * p_ic_j}\n\\end{equation}\n","ef7f0aa7":"**Inline Question #1:** Notice the structured patterns in the distance matrix, where some rows or columns are visible brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.)\n\n- What in the data is the cause behind the distinctly bright rows?\n- What causes the columns?","f5cf5cb3":"# k-Nearest Neighbor (kNN) exercise\n\nThe kNN classifier consists of two stages:\n\n- During training, the classifier takes the training data and simply remembers it\n- During testing, kNN classifies every test image by comparing to all training images and transfering the labels of the k most similar training examples\n- The value of k is cross-validated\n\nIn this exercise you will implement these steps and understand the basic Image Classification pipeline, cross-validation, and gain proficiency in writing efficient, vectorized code.","9e907334":"You should expect to see a slightly better performance than with `k = 1`."}}