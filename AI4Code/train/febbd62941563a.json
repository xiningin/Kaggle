{"cell_type":{"ea9021a8":"code","03f3bc0a":"code","b058b477":"code","266b76cc":"code","06340b1a":"code","f9298a53":"code","3790e006":"code","ebc19499":"code","031f5ba2":"code","8c6d1571":"code","87e652ec":"code","f347a911":"code","20701f03":"code","64b70040":"code","59ab1f29":"code","ccbc1918":"code","60222929":"code","f05640da":"code","4b23221f":"code","78ddb9b7":"code","957d3533":"code","e40c191d":"code","bf094756":"code","bde9d732":"code","502b4316":"code","c22fe059":"code","2d0d02d9":"code","bbdd285d":"code","856e3b3c":"code","eebdb498":"code","323e68ee":"code","45f525d2":"code","2b638c43":"code","4d60bc5a":"code","704737e0":"code","90724d33":"code","c3f3438d":"code","f67a1bc5":"code","b02c0201":"code","7ee209c6":"code","7342ff09":"code","964a1a29":"code","b5eaa415":"code","4a0d3d3c":"code","56854d11":"code","14813ba6":"code","b09f8384":"code","c81a3365":"code","39ad3f1b":"code","27f135fd":"code","ebf0e964":"code","13fa9318":"code","e172d2e7":"code","6ba13448":"code","00b086de":"code","9c446c56":"code","24769849":"code","26b3cfe0":"code","120932ba":"code","ff376af9":"code","77f785ad":"code","beeb9757":"code","e5f96551":"code","70ead407":"code","0cc4f04c":"code","6f921186":"code","8ec5c5b5":"code","3ee6e57d":"markdown","d5d7404b":"markdown","472bf419":"markdown","1db63db4":"markdown","9a8207da":"markdown","6ba59bfb":"markdown","7eb74d94":"markdown","191fb4fe":"markdown","11464075":"markdown","fa4f8292":"markdown","3f1ec824":"markdown","074708e4":"markdown","96f6af86":"markdown","b075ffff":"markdown","cc98b4e4":"markdown","cc2db735":"markdown","d503d256":"markdown","543cb228":"markdown","04506241":"markdown","041182eb":"markdown","b38a6fc3":"markdown","aa6aec1f":"markdown","db993d73":"markdown","2de25ab9":"markdown","b4d53a1e":"markdown","c2c94020":"markdown","ec626ac7":"markdown","8e9bef9a":"markdown","ea39edc9":"markdown","a49109b9":"markdown","7620eb99":"markdown","80860966":"markdown","1b43b197":"markdown","1f6d2c15":"markdown","cf97f593":"markdown","946eb283":"markdown","9b52911e":"markdown","8bd63bf1":"markdown","418e03f1":"markdown","4b89aae7":"markdown","a6da4ec4":"markdown","2bc4f232":"markdown"},"source":{"ea9021a8":"import tensorflow as tf\nfrom tensorflow.keras.callbacks import CSVLogger, EarlyStopping\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\nimport pandas as pd\nimport seaborn as sns\nimport time\nimport gc\nimport sys\n\nprint(f\"Tensorflow Version: {tf.__version__}\")\nprint(f\"Pandas Version: {pd.__version__}\")\nprint(f\"Numpy Version: {np.__version__}\")\nprint(f\"System Version: {sys.version}\")\n\nmpl.rcParams['figure.figsize'] = (17, 5)\nmpl.rcParams['axes.grid'] = False\nsns.set_style(\"whitegrid\")\n\nnotebookstart= time.time()","03f3bc0a":"# Data Loader Parameters\nBATCH_SIZE = 256\nBUFFER_SIZE = 10000\nTRAIN_SPLIT = 300000\n\n# LSTM Parameters\nEVALUATION_INTERVAL = 200\nEPOCHS = 4\nPATIENCE = 5\n\n# Reproducibility\nSEED = 13\ntf.random.set_seed(SEED)","b058b477":"zip_path = tf.keras.utils.get_file(\n    origin='https:\/\/storage.googleapis.com\/tensorflow\/tf-keras-datasets\/jena_climate_2009_2016.csv.zip',\n    fname='jena_climate_2009_2016.csv.zip',\n    extract=True)\ncsv_path, _ = os.path.splitext(zip_path)\n\ndf = pd.read_csv(csv_path)\nprint(\"DataFrame Shape: {} rows, {} columns\".format(*df.shape))\ndisplay(df.head())","266b76cc":"def univariate_data(dataset, start_index, end_index, history_size, target_size):\n    data = []\n    labels = []\n\n    start_index = start_index + history_size\n    if end_index is None:\n        end_index = len(dataset) - target_size\n\n    for i in range(start_index, end_index):\n        indices = range(i-history_size, i)\n        # Reshape data from (history_size,) to (history_size, 1)\n        data.append(np.reshape(dataset[indices], (history_size, 1)))\n        labels.append(dataset[i+target_size])\n        \n    return np.array(data), np.array(labels)","06340b1a":"uni_data = df['T (degC)']\nuni_data.index = df['Date Time']\nuni_data.head()","f9298a53":"uni_data.plot(subplots=True)\nplt.show()\nuni_data = uni_data.values","3790e006":"uni_train_mean = uni_data[:TRAIN_SPLIT].mean()\nuni_train_std = uni_data[:TRAIN_SPLIT].std()","ebc19499":"uni_data = (uni_data-uni_train_mean)\/uni_train_std","031f5ba2":"univariate_past_history = 20\nunivariate_future_target = 0\n\nx_train_uni, y_train_uni = univariate_data(dataset=uni_data,\n                                           start_index=0,\n                                           end_index=TRAIN_SPLIT,\n                                           history_size=univariate_past_history,\n                                           target_size=univariate_future_target)\nx_val_uni, y_val_uni = univariate_data(dataset=uni_data,\n                                       start_index=TRAIN_SPLIT,\n                                       end_index=None,\n                                       history_size=univariate_past_history,\n                                       target_size=univariate_future_target)","8c6d1571":"print(\"In:\")\nprint(uni_data.shape)\nprint(uni_data[:5])\n\nprint(\"\\nOut\")\nprint(x_train_uni.shape)\n\n\nprint(x_train_uni.shape[0] \/ uni_data.shape[0])","87e652ec":"print ('Single window of past history. Shape: {}'.format(x_train_uni[0].shape))\nprint (x_train_uni[0])\nprint ('\\n Target temperature to predict. Shape: {}'.format(y_train_uni[0].shape))\nprint (y_train_uni[0])","f347a911":"def create_time_steps(length):\n    return list(range(-length, 0))","20701f03":"def show_plot(plot_data, delta, title):\n    labels = ['History', 'True Future', 'Model Prediction']\n    marker = ['.-', 'rx', 'go']\n    time_steps = create_time_steps(plot_data[0].shape[0])\n    if delta:\n        future = delta\n    else:\n        future = 0\n\n    plt.title(title)\n    for i, x in enumerate(plot_data):\n        if i:\n            plt.plot(future, plot_data[i], marker[i], markersize=10,\n                   label=labels[i])\n        else:\n            plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])\n        plt.legend()\n        plt.xlim([time_steps[0], (future+5)*2])\n        plt.xlabel('Time-Step')\n    \n    return plt","64b70040":"show_plot([x_train_uni[0], y_train_uni[0]], 0, 'Sample Example')","59ab1f29":"def baseline(history):\n    return np.mean(history)","ccbc1918":"show_plot([x_train_uni[0], y_train_uni[0], baseline(x_train_uni[0])], 0,\n           'Baseline Prediction Example')","60222929":"train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))\ntrain_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))\nval_univariate = val_univariate.batch(BATCH_SIZE).repeat()","f05640da":"x_train_uni.shape","4b23221f":"simple_lstm_model = tf.keras.models.Sequential([\n    tf.keras.layers.LSTM(8, input_shape=x_train_uni.shape[-2:]),\n    tf.keras.layers.Dense(1)\n])\n\nsimple_lstm_model.compile(optimizer='adam', loss='mae')","78ddb9b7":"for x, y in val_univariate.take(1):\n    print(simple_lstm_model.predict(x).shape)","957d3533":"early_stopping = EarlyStopping(monitor='val_loss', patience = 3, restore_best_weights=True)\nsimple_lstm_model.fit(train_univariate,\n                      epochs=EPOCHS,\n                      steps_per_epoch=EVALUATION_INTERVAL,\n                      validation_data=val_univariate,\n                      callbacks=[early_stopping],\n                      validation_steps=50)","e40c191d":"for x, y in val_univariate.take(3):\n    plot = show_plot([x[0].numpy(), y[0].numpy(),\n                    simple_lstm_model.predict(x)[0]], 0, 'Simple LSTM model')\n    plot.show()","bf094756":"del simple_lstm_model, val_univariate, train_univariate","bde9d732":"features_considered = ['p (mbar)', 'T (degC)', 'rho (g\/m**3)']","502b4316":"features = df[features_considered]\nfeatures.index = df['Date Time']\nfeatures.head()","c22fe059":"features.plot(subplots=True)","2d0d02d9":"dataset = features.values\ndata_mean = dataset[:TRAIN_SPLIT].mean(axis=0)\ndata_std = dataset[:TRAIN_SPLIT].std(axis=0)\ndataset = (dataset-data_mean)\/data_std","bbdd285d":"display(pd.DataFrame(dataset, columns = features.columns, index= features.index).head())","856e3b3c":"def multivariate_data(dataset, target, start_index, end_index, history_size,\n                      target_size, step, single_step=False):\n    data = []\n    labels = []\n\n    start_index = start_index + history_size\n    if end_index is None:\n        end_index = len(dataset) - target_size\n\n    for i in range(start_index, end_index):\n        indices = range(i-history_size, i, step)\n        data.append(dataset[indices])\n\n        if single_step:\n            labels.append(target[i+target_size])\n        else:\n            labels.append(target[i:i+target_size])\n\n    return np.array(data), np.array(labels)","eebdb498":"past_history = 720\nfuture_target = 72\nSTEP = 6\n\nx_train_single, y_train_single = multivariate_data(dataset, dataset[:, 1], 0,\n                                                   TRAIN_SPLIT, past_history,\n                                                   future_target, STEP,\n                                                   single_step=True)\nx_val_single, y_val_single = multivariate_data(dataset, dataset[:, 1],\n                                               TRAIN_SPLIT, None, past_history,\n                                               future_target, STEP,\n                                               single_step=True)","323e68ee":"print(x_train_single.shape)\nprint ('Single window of past history : {}'.format(x_train_single[0].shape))\nprint(x_train_single.shape[-2:])","45f525d2":"train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))\ntrain_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))\nval_data_single = val_data_single.batch(BATCH_SIZE).repeat()","2b638c43":"single_step_model = tf.keras.models.Sequential()\nsingle_step_model.add(tf.keras.layers.LSTM(32,\n                                           input_shape=x_train_single.shape[-2:]))\nsingle_step_model.add(tf.keras.layers.Dense(1))\n\nsingle_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss='mae')","4d60bc5a":"for x, y in val_data_single.take(1):\n    print(single_step_model.predict(x).shape)","704737e0":"print(f\"Evaluation Threshold: {EVALUATION_INTERVAL}\",\n      f\"Epochs: {EPOCHS}\", sep=\"\\n\")\n\nearly_stopping = EarlyStopping(monitor='val_loss', patience = 3, restore_best_weights=True)\nsingle_step_history = single_step_model.fit(train_data_single,\n                                            epochs=EPOCHS,\n                                            steps_per_epoch=EVALUATION_INTERVAL,\n                                            validation_data=val_data_single,\n                                            callbacks=[early_stopping],\n                                            validation_steps=50)","90724d33":"def plot_train_history(history, title):\n    loss = history.history['loss']\n    val_loss = history.history['val_loss']\n\n    epochs = range(len(loss))\n\n    plt.figure()\n\n    plt.plot(epochs, loss, 'b', label='Training loss')\n    plt.plot(epochs, val_loss, 'r', label='Validation loss')\n    plt.title(title)\n    plt.legend()\n\n    plt.show()","c3f3438d":"plot_train_history(single_step_history,\n                   'Single Step Training and validation loss')","f67a1bc5":"for x, y in val_data_single.take(3):\n    plot = show_plot([x[0][:, 1].numpy(), y[0].numpy(),\n                    single_step_model.predict(x)[0]], 12,\n                   'Single Step Prediction')\n    plot.show()","b02c0201":"del single_step_history, val_data_single, train_data_single","7ee209c6":"past_history = 720\nfuture_target = 72\nSTEP = 6\n\nx_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, 1], 0,\n                                                 TRAIN_SPLIT, past_history,\n                                                 future_target, STEP)\nx_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, 1],\n                                             TRAIN_SPLIT, None, past_history,\n                                             future_target, STEP)","7342ff09":"print (x_train_multi.shape,\n       y_train_multi.shape,\n       'Single window of past history : {}'.format(x_train_multi[0].shape),\n       'Target temperature to predict : {}'.format(y_train_multi[0].shape),\n       sep='\\n')","964a1a29":"train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))\ntrain_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))\nval_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()","b5eaa415":"def multi_step_plot(history, true_future, prediction):\n    plt.figure(figsize=(18, 6))\n    num_in = create_time_steps(len(history))\n    num_out = len(true_future)\n\n    plt.plot(num_in, np.array(history[:, 1]), label='History')\n    plt.plot(np.arange(num_out)\/STEP, np.array(true_future), 'bo',\n           label='True Future')\n    if prediction.any():\n        plt.plot(np.arange(num_out)\/STEP, np.array(prediction), 'ro',\n                 label='Predicted Future')\n    plt.legend(loc='upper left')\n    plt.show()","4a0d3d3c":"for x, y in train_data_multi.take(1):\n    multi_step_plot(x[0], y[0], np.array([0]))","56854d11":"multi_step_model = tf.keras.models.Sequential()\nmulti_step_model.add(tf.keras.layers.LSTM(32,\n                                          return_sequences=True,\n                                          input_shape=x_train_multi.shape[-2:]))\nmulti_step_model.add(tf.keras.layers.LSTM(16, activation='relu'))\nmulti_step_model.add(tf.keras.layers.Dense(72))\n\nmulti_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=1.0), loss='mae')\nprint(multi_step_model.summary())","14813ba6":"for x, y in val_data_multi.take(1):\n    print (multi_step_model.predict(x).shape)","b09f8384":"early_stopping = EarlyStopping(monitor='val_loss', patience = 3, restore_best_weights=True)\nmulti_step_history = multi_step_model.fit(train_data_multi,\n                                          epochs=EPOCHS,\n                                          steps_per_epoch=EVALUATION_INTERVAL,\n                                          validation_data=val_data_multi,\n                                          validation_steps=EVALUATION_INTERVAL,\n                                          callbacks=[early_stopping])","c81a3365":"plot_train_history(multi_step_history, 'Multi-Step Training and validation loss')","39ad3f1b":"for x, y in val_data_multi.take(3):\n    multi_step_plot(x[0], y[0], multi_step_model.predict(x)[0])","27f135fd":"del multi_step_model, val_data_multi, train_data_multi\n_ = gc.collect()","ebf0e964":"from tensorflow.keras.layers import *\nfrom tensorflow.keras.models import Sequential","13fa9318":"def multivariate_multioutput_data(dataset, target, start_index, end_index, history_size,\n                      target_size, step, single_step=False):\n    data = []\n    labels = []\n\n    start_index = start_index + history_size\n    if end_index is None:\n        end_index = len(dataset) - target_size\n\n    for i in range(start_index, end_index):\n        indices = range(i-history_size, i, step)\n        data.append(dataset[indices])\n\n        if single_step:\n            labels.append(target[i+target_size])\n        else:\n            labels.append(target[i:i+target_size])\n\n    return np.array(data)[:,:,:,np.newaxis,np.newaxis], np.array(labels)[:,:,:,np.newaxis,np.newaxis]\n\ndef multi_step_output_plot(history, true_future, prediction):\n    plt.figure(figsize=(18, 6))\n    num_in = create_time_steps(len(history))\n    num_out = len(true_future)\n    \n    for i, (var, c) in enumerate(zip(features.columns[:2], ['b','r'])):\n        plt.plot(num_in, np.array(history[:, i]), c, label=var)\n        plt.plot(np.arange(num_out)\/STEP, np.array(true_future[:,i]), c+'o', markersize=5, alpha=0.5,\n               label=f\"True {var.title()}\")\n        if prediction.any():\n            plt.plot(np.arange(num_out)\/STEP, np.array(prediction[:,i]), '*', markersize=5, alpha=0.5,\n                     label=f\"Predicted {var.title()}\")\n    \n    plt.legend(loc='upper left')\n    plt.show()","e172d2e7":"future_target = 72\nx_train_multi, y_train_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:,:2], 0,\n                                                 TRAIN_SPLIT, past_history,\n                                                 future_target, STEP)\nx_val_multi, y_val_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:, :2],\n                                             TRAIN_SPLIT, None, past_history,\n                                             future_target, STEP)","6ba13448":"print (x_train_multi.shape,\n       y_train_multi.shape,\n       x_val_multi.shape,\n       y_val_multi.shape,\n       'Single window of past history : {}'.format(x_train_multi[0].shape),\n       'Target temperature to predict : {}'.format(y_train_multi[0].shape),\n       sep='\\n')","00b086de":"BATCH_SIZE = 128\n\ntrain_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))\ntrain_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))\nval_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()","9c446c56":"for x, y in val_data_multi.take(10):\n    multi_step_output_plot(np.squeeze(x[0]), np.squeeze(y[0]), np.array([0]))","24769849":"def build_model(input_timesteps, output_timesteps, num_links, num_inputs):\n    # COPY PASTA\n    # https:\/\/github.com\/niklascp\/bus-arrival-convlstm\/blob\/master\/jupyter\/ConvLSTM_3x15min_10x64-5x64-10x64-5x64-Comparison.ipynb\n    \n    model = Sequential()\n    model.add(BatchNormalization(name = 'batch_norm_0', input_shape = (input_timesteps, num_inputs, 1, 1)))\n    model.add(ConvLSTM2D(name ='conv_lstm_1',\n                         filters = 64, kernel_size = (10, 1),                       \n                         padding = 'same', \n                         return_sequences = True))\n    \n    model.add(Dropout(0.30, name = 'dropout_1'))\n    model.add(BatchNormalization(name = 'batch_norm_1'))\n\n    model.add(ConvLSTM2D(name ='conv_lstm_2',\n                         filters = 64, kernel_size = (5, 1), \n                         padding='same',\n                         return_sequences = False))\n    \n    model.add(Dropout(0.20, name = 'dropout_2'))\n    model.add(BatchNormalization(name = 'batch_norm_2'))\n    \n    model.add(Flatten())\n    model.add(RepeatVector(output_timesteps))\n    model.add(Reshape((output_timesteps, num_inputs, 1, 64)))\n    \n    model.add(ConvLSTM2D(name ='conv_lstm_3',\n                         filters = 64, kernel_size = (10, 1), \n                         padding='same',\n                         return_sequences = True))\n    \n    model.add(Dropout(0.20, name = 'dropout_3'))\n    model.add(BatchNormalization(name = 'batch_norm_3'))\n    \n    model.add(ConvLSTM2D(name ='conv_lstm_4',\n                         filters = 64, kernel_size = (5, 1), \n                         padding='same',\n                         return_sequences = True))\n    \n    model.add(TimeDistributed(Dense(units=1, name = 'dense_1', activation = 'relu')))\n    model.add(Dense(units=1, name = 'dense_2', activation = 'linear'))\n\n#     optimizer = RMSprop() #lr=0.0001, rho=0.9, epsilon=1e-08, decay=0.9)\n#     optimizer = tf.keras.optimizers.Adam(0.1)\n    optimizer = tf.keras.optimizers.RMSprop(lr=0.004, clipvalue=1.0)\n    model.compile(loss = \"mse\", optimizer = optimizer, metrics = ['mae', 'mse'])\n    return model","26b3cfe0":"future_target = 72\nx_train_multi, y_train_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:,:2], 0,\n                                                 TRAIN_SPLIT, past_history,\n                                                 future_target, STEP)\nx_val_multi, y_val_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:, :2],\n                                             TRAIN_SPLIT, None, past_history,\n                                             future_target, STEP)\n\nBATCH_SIZE = 128\n\ntrain_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))\ntrain_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))\nval_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()","120932ba":"EPOCHS = 40\nsteps_per_epoch = 350\nvalidation_steps = 500\n\nmodelstart = time.time()\nearly_stopping = EarlyStopping(monitor='val_loss', patience = PATIENCE, restore_best_weights=True)\nmodel = build_model(x_train_multi.shape[1], future_target, y_train_multi.shape[2], x_train_multi.shape[2])\nprint(model.summary())\n\n# Train\nprint(\"\\nTRAIN MODEL...\")\nhistory = model.fit(train_data_multi,\n                    epochs = EPOCHS,\n                    validation_data=val_data_multi,\n                    steps_per_epoch=steps_per_epoch,\n                    validation_steps=validation_steps,\n                    verbose=1,\n                    callbacks=[early_stopping])\nmodel.save('multi-output-timesteps.h5')\nprint(\"\\nModel Runtime: %0.2f Minutes\"%((time.time() - modelstart)\/60))","ff376af9":"plot_train_history(history, 'Multi-Step, Multi-Output Training and validation loss')","77f785ad":"for x, y in val_data_multi.take(10):\n    multi_step_output_plot(np.squeeze(x[0]), np.squeeze(y[0]), np.squeeze(model.predict(x[0][np.newaxis,:,:,:,:])))","beeb9757":"def build_model(input_timesteps, output_timesteps, num_links, num_inputs):    \n    model = Sequential()\n    model.add(BatchNormalization(name = 'batch_norm_0', input_shape = (input_timesteps, num_inputs, 1, 1)))\n    model.add(ConvLSTM2D(name ='conv_lstm_1',\n                         filters = 64, kernel_size = (10, 1),                       \n                         padding = 'same', \n                         return_sequences = False))\n    \n    model.add(Dropout(0.30, name = 'dropout_1'))\n    model.add(BatchNormalization(name = 'batch_norm_1'))\n\n#     model.add(ConvLSTM2D(name ='conv_lstm_2',\n#                          filters = 64, kernel_size = (5, 1), \n#                          padding='same',\n#                          return_sequences = False))\n    \n#     model.add(Dropout(0.20, name = 'dropout_2'))\n#     model.add(BatchNormalization(name = 'batch_norm_2'))\n    \n    model.add(Flatten())\n    model.add(RepeatVector(output_timesteps))\n    model.add(Reshape((output_timesteps, num_inputs, 1, 64)))\n    \n#     model.add(ConvLSTM2D(name ='conv_lstm_3',\n#                          filters = 64, kernel_size = (10, 1), \n#                          padding='same',\n#                          return_sequences = True))\n    \n#     model.add(Dropout(0.20, name = 'dropout_3'))\n#     model.add(BatchNormalization(name = 'batch_norm_3'))\n    \n    model.add(ConvLSTM2D(name ='conv_lstm_4',\n                         filters = 64, kernel_size = (5, 1), \n                         padding='same',\n                         return_sequences = True))\n    \n    model.add(TimeDistributed(Dense(units=1, name = 'dense_1', activation = 'relu')))\n    model.add(Dense(units=1, name = 'dense_2'))\n\n#     optimizer = RMSprop() #lr=0.0001, rho=0.9, epsilon=1e-08, decay=0.9)\n#     optimizer = tf.keras.optimizers.Adam(0.1)\n    optimizer = tf.keras.optimizers.RMSprop(lr=0.003, clipvalue=1.0)\n    model.compile(loss = \"mse\", optimizer = optimizer, metrics = ['mae', 'mse'])\n    return model","e5f96551":"# Extend Prediction Window..\nfuture_target = 144\nx_train_multi, y_train_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:,:2], 0,\n                                                 TRAIN_SPLIT, past_history,\n                                                 future_target, STEP)\nx_val_multi, y_val_multi = multivariate_multioutput_data(dataset[:,:2], dataset[:, :2],\n                                             TRAIN_SPLIT, None, past_history,\n                                             future_target, STEP)\n\nBATCH_SIZE = 128\n\ntrain_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))\ntrain_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()\n\nval_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))\nval_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()","70ead407":"EPOCHS = 30\nsteps_per_epoch = 350\nvalidation_steps = 500\n\nmodelstart = time.time()\nearly_stopping = EarlyStopping(monitor='val_loss', patience = PATIENCE, restore_best_weights=True)\nmodel = build_model(x_train_multi.shape[1], future_target, y_train_multi.shape[2], x_train_multi.shape[2])\nprint(model.summary())\n\n# Train\nprint(\"\\nTRAIN MODEL...\")\nhistory = model.fit(train_data_multi,\n                    epochs = EPOCHS,\n                    validation_data=val_data_multi,\n                    steps_per_epoch=steps_per_epoch,\n                    validation_steps=validation_steps,\n                    verbose=1,\n                    callbacks=[early_stopping])\nmodel.save('multi-output-timesteps.h5')\nprint(\"\\nModel Runtime: %0.2f Minutes\"%((time.time() - modelstart)\/60))","0cc4f04c":"plot_train_history(history, 'Multi-Step, Multi-Output Training and validation loss')","6f921186":"for x, y in val_data_multi.take(10):\n    multi_step_output_plot(np.squeeze(x[0]), np.squeeze(y[0]), np.squeeze(model.predict(x[0][np.newaxis,:,:,:,:])))","8ec5c5b5":"print(\"Notebook Runtime: %0.2f Minutes\"%((time.time() - notebookstart)\/60))","3ee6e57d":"Let's now create the data for the univariate model. For part 1, the model will be given the last 20 recorded temperature observations, and needs to learn to predict the temperature at the next time step. ","d5d7404b":"You will see the LSTM requires the input shape of the data it is being given.","472bf419":"This is what the `univariate_data` function returns.","1db63db4":"Now that the data has been created, let's take a look at a single example. The information given to the network is given in blue, and it must predict the value at the red cross.","9a8207da":"#### Predict a single step future\nNow that the model is trained, let's make a few sample predictions. The model is given the history of three features over the past five days sampled every hour (120 data-points), since the goal is to predict the temperature, the plot only displays the past temperature. The prediction is made one day into the future (hence the gap between the history and prediction). ","6ba59bfb":"## Part 1: Forecast a univariate time series\nFirst, you will train a model using only a single feature (temperature), and use it to make predictions for that value in the future.\n\nLet's first extract only the temperature from the dataset.","7eb74d94":"# Tensorflow Timeseries LSTM Tutorial\n\nIn this notebook, I explore the the incredible guide by Tensorflow, [**LINK**](https:\/\/www.tensorflow.org\/tutorials\/structured_data\/time_series), and attempt to build off the work by adding Multi-Ouput, Multi-Timestep implimentation.\n\n\n##### Copyright 2019 The TensorFlow Authors.\n\n\n<table class=\"tfo-notebook-buttons\" align=\"left\">\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/www.tensorflow.org\/tutorials\/structured_data\/time_series\"><img src=\"https:\/\/www.tensorflow.org\/images\/tf_logo_32px.png\" \/>View on TensorFlow.org<\/a>\n  <\/td>\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/colab.research.google.com\/github\/tensorflow\/docs\/blob\/master\/site\/en\/tutorials\/structured_data\/time_series.ipynb\"><img src=\"https:\/\/www.tensorflow.org\/images\/colab_logo_32px.png\" \/>Run in Google Colab<\/a>\n  <\/td>\n  <td>\n    <a target=\"_blank\" href=\"https:\/\/github.com\/tensorflow\/docs\/blob\/master\/site\/en\/tutorials\/structured_data\/time_series.ipynb\"><img src=\"https:\/\/www.tensorflow.org\/images\/GitHub-Mark-32px.png\" \/>View source on GitHub<\/a>\n  <\/td>\n  <td>\n    <a href=\"https:\/\/storage.googleapis.com\/tensorflow_docs\/docs\/site\/en\/tutorials\/structured_data\/time_series.ipynb\"><img src=\"https:\/\/www.tensorflow.org\/images\/download_logo_32px.png\" \/>Download notebook<\/a>\n  <\/td>\n<\/table>","191fb4fe":"### Single step model\nIn a single step setup, the model learns to predict a single point in the future based on some history provided.\n\nThe below function performs the same windowing task as below, however, here it samples the past observation based on the step size given.","11464075":"Let's observe how this data looks across time.","fa4f8292":"In this tutorial, the network is shown data from the last five (5) days, i.e. 720 observations that are sampled every hour. The sampling is done every one hour since a drastic change is not expected within 60 minutes. Thus, 120 observation represent history of the last five days.  For the single step prediction model, the label for a datapoint is the temperature 12 hours into the future. In order to create a label for this, the temperature after 72(12*6) observations is used.","3f1ec824":"Since the task here is a bit more complicated than the previous task, the model now consists of two LSTM layers. Finally, since 72 predictions are made, the dense layer outputs 72 predictions.","074708e4":"This looks better than the baseline. Now that you have seen the basics, let's move on to part two, where you will work with a multivariate time series.","96f6af86":"## The weather dataset\nThis tutorial uses a <a href=\"https:\/\/www.bgc-jena.mpg.de\/wetter\/\" class=\"external\">[weather time series dataset<\/a> recorded by the <a href=\"https:\/\/www.bgc-jena.mpg.de\" class=\"external\">Max Planck Institute for Biogeochemistry<\/a>.\n\nThis dataset contains 14 different features such as air temperature, atmospheric pressure, and humidity. These were collected every 10 minutes, beginning in 2003. For efficiency, you will use only the data collected between 2009 and 2016. This section of the dataset was prepared by Fran\u00e7ois Chollet for his book [Deep Learning with Python](https:\/\/www.manning.com\/books\/deep-learning-with-python).","b075ffff":"#### Predict using the simple LSTM model\nNow that you have trained your simple LSTM, let's try and make a few predictions.","cc98b4e4":"Let's see if you can beat this baseline using a recurrent neural network.","cc2db735":"As mentioned, the first step will be to standardize the dataset using the mean and standard deviation of the training data.","d503d256":"Let's check out a sample prediction.","543cb228":"Let's make a sample prediction, to check the output of the model. ","04506241":"Plotting a sample data-point.","041182eb":"Let's look at a single data-point.\n","b38a6fc3":"Let's have a look at how each of these features vary across time.","aa6aec1f":"### Recurrent neural network\n\nA Recurrent Neural Network (RNN) is a type of neural network well-suited to time series data. RNNs process a time series step-by-step, maintaining an internal state summarizing the information they've seen so far. For more details, read the [RNN tutorial](https:\/\/www.tensorflow.org\/tutorials\/sequences\/recurrent). In this tutorial, you will use a specialized RNN layer called Long Short Term Memory ([LSTM](https:\/\/www.tensorflow.org\/versions\/r2.0\/api_docs\/python\/tf\/keras\/layers\/LSTM))\n\nLet's now use `tf.data` to shuffle, batch, and cache the dataset.","db993d73":"Let's see how the model predicts before it trains.","2de25ab9":"In this plot and subsequent similar plots, the history and the future data are sampled every hour.","b4d53a1e":"### Simplified the Convolutional LSTM","c2c94020":"Let's check out a sample data-point.","ec626ac7":"As you can see above, an observation is recorded every 10 mintues. This means that, for a single hour, you will have 6 observations. Similarly, a single day will contain 144 (6x24) observations. \n\nGiven a specific time, let's say you want to predict the temperature 6 hours in the future. In order to make this prediction, you choose to use 5 days of observations. Thus, you would create a window containing the last 720(5x144) observations to train the model. Many such configurations are possible, making this dataset a good one to experiment with.\n\nThe function below returns the above described windows of time for the model to train on. The parameter `history_size` is the size of the past window of information. The `target_size` is how far in the future does the model need to learn to predict. The `target_size` is the label that needs to be predicted.","8e9bef9a":"This tutorial is an introduction to time series forecasting using Recurrent Neural Networks (RNNs). This is covered in two parts: first, you will forecast a univariate time series, then you will forecast a multivariate time series.","ea39edc9":"#### Predict a multi-step future\nLet's now have a look at how well your network has learnt to predict the future.","a49109b9":"### Multi-Step model\nIn a multi-step prediction model, given a past history, the model needs to learn to predict a range of future values. Thus, unlike a single step model, where only a single future point is predicted, a multi-step model predict a sequence of the future.\n\nFor the multi-step model, the training data again consists of recordings over the past five days sampled every hour. However, here, the model needs to learn to predict the temperature for the next 12 hours. Since an obversation is taken every 10 minutes, the output is 72 predictions. For this task, the dataset needs to be prepared accordingly, thus the first step is just to create it again, but with a different target window.","7620eb99":"The original dataset contains fourteen features. For simplicity, this section considers only three of the original fourteen. The features used are air temperature, atmospheric pressure, and air density. \n\nTo use more features, add their names to this list.","80860966":"It is important to scale features before training a neural network. Standardization is a common way of doing this scaling by subtracting the mean and dividing by the standard deviation of each feature.You could also use a `tf.keras.utils.normalize` method that rescales the values into a range of [0,1].","1b43b197":"### Convolutional LSTM\n\nAs taken from the paper.","1f6d2c15":"Let's standardize the data.","cf97f593":"Let's train the model now. Due to the large size of the dataset, in the interest of saving time, each epoch will only run for 200 steps, instead of the complete training data as normally done.","946eb283":"## Part 2: Forecast a multivariate time series","9b52911e":"Note: The mean and standard deviation should only be computed using the training data.","8bd63bf1":"## Multi-Step, Multi-Input, and Multi-Output\n\n_By Nick Brooks, Feb 2020_\n\nInspired by the following paper:\n\n- https:\/\/arxiv.org\/abs\/1903.02791\n- https:\/\/github.com\/niklascp\/bus-arrival-convlstm\/tree\/master\/jupyter","418e03f1":"In both the following tutorials, the first 300,000 rows of the data will be the training dataset, and there remaining will be the validation dataset. This amounts to ~2100 days worth of training data.","4b89aae7":"## Next steps\nThis tutorial was a quick introduction to time series forecasting using an RNN. You may now try to predict the stock market and become a billionaire.\n\nIn addition, you may also write a generator to yield data (instead of the uni\/multivariate_data function), which would be more memory efficient. You may also check out this [time series windowing](https:\/\/www.tensorflow.org\/guide\/data#time_series_windowing) guide and use it in this tutorial.\n\nFor further understanding, you may read Chapter 15 of [Hands-on Machine Learning with Scikit-Learn, Keras, and TensorFlow](https:\/\/www.oreilly.com\/library\/view\/hands-on-machine-learning\/9781492032632\/), 2nd Edition and Chapter 6 of [Deep Learning with Python](https:\/\/www.manning.com\/books\/deep-learning-with-python).","a6da4ec4":"The following visualisation should help you understand how the data is represented after batching.\n\n![Time Series](images\/time_series.png)","2bc4f232":"### Baseline\nBefore proceeding to train a model, let's first set a simple baseline. Given an input point, the baseline method looks at all the history and predicts the next point to be the average of the last 20 observations."}}