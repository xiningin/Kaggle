{"cell_type":{"8fcd667b":"code","25642bc8":"code","26e629e6":"code","2f6ccbcf":"code","bd239de8":"code","b6d750f3":"code","b6992d2e":"code","4550749c":"code","5c6bc853":"code","eb34e6db":"code","8f58cf8e":"code","77db0534":"code","9952543a":"markdown","d886fd2a":"markdown","4ddfeb79":"markdown","ee07a63e":"markdown","25c5ad3c":"markdown","ccbf299c":"markdown","7e9dbae6":"markdown","4d7681c0":"markdown","ba4e6f76":"markdown","71004261":"markdown","6e6e0174":"markdown"},"source":{"8fcd667b":"import pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport os\nimport cv2\n\nfrom tqdm import tqdm\nimport random as rn\nfrom random import shuffle  \nfrom zipfile import ZipFile\nfrom PIL import Image\n\nfrom skimage import feature, color, data\nfrom sklearn.preprocessing import LabelEncoder","25642bc8":"# The training data set is in the \/Users\/macos\/Documents\/Intel Image Classification\/seg_train\ntrn_img_path = \"..\/input\/seg_train\/seg_train\/\"\n\n# The testing data set is in the \/Users\/macos\/Documents\/Intel Image Classification\/seg_test\ntst_img_path = \"..\/input\/seg_test\/seg_test\/\"\n\n# Lets create 2 set of arrays for train & testing data's. One for to store the Image data and anther one for label details\nX_train =[] # Stores the training image hog data\nlabel_train = [] # Stores the training image label\n\nX_test = [] # Stores the testing image hog data\nlabel_test = [] # Stores the testing image label\n\nscene_label=['Buildings','Forest', 'Glacier','Mountain','Sea','Street']","26e629e6":"\ndef hog_data_extractor(jpeg_path):\n    jpeg_data = cv2.imread(jpeg_path)\n    jpeg_data=cv2.resize(jpeg_data,(150,150)) \n    hog_data = feature.hog(jpeg_data)\/255.0\n    return hog_data","2f6ccbcf":"def jpeg_to_array (scene_type, img_root_path,data_type):\n    scene_path = os.path.join(img_root_path,scene_type.lower())\n    print('Loading ' + data_type +' images for scene type '+scene_type)\n    for img in os.listdir(scene_path):\n        img_path = os.path.join(scene_path,img)\n        if img_path.endswith('.jpg'):\n            if(data_type == 'Training'):\n                X_train.append(hog_data_extractor(img_path))\n                label_train.append(str(scene_type))\n            if(data_type =='Testing'):\n                X_test.append(hog_data_extractor(img_path))\n                label_test.append(np.array(str(scene_type)))","bd239de8":"[jpeg_to_array(scene,trn_img_path,'Training')for scene in scene_label]\nlen(X_train)\n[jpeg_to_array(scene,tst_img_path,'Testing')for scene in scene_label]\nlen(X_test)","b6d750f3":"le = LabelEncoder()\ny_train = le.fit_transform(label_train)\ny_test = le.fit_transform(label_test)","b6992d2e":"from sklearn.model_selection import cross_val_score\nfrom sklearn.model_selection import KFold, StratifiedKFold\nfrom sklearn.metrics import confusion_matrix, accuracy_score, classification_report\nfrom sklearn.svm import LinearSVC","4550749c":"lsvc = LinearSVC(random_state=0,tol=1e-5)\nlsvc.fit(X_train,y_train)\nprint('Coef',lsvc.coef_)\nprint('Intercept',lsvc.intercept_)","5c6bc853":"# filter all the warnings\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# 10-fold cross validation\nlsvc_score = lsvc.score(X_test,y_test)\nprint('Score', lsvc_score)\nkfold = KFold(n_splits=10, random_state=9)\ncv_results = cross_val_score(lsvc , X_train, y_train, cv=kfold, scoring=\"accuracy\")\nprint(cv_results)","eb34e6db":"print(cv_results.mean(), cv_results.std())","8f58cf8e":"def scene_predict(img_path):\n    image = cv2.imread(img_path)\n    ip_image = Image.open(img_path)\n    image = cv2.resize(image,(150,150))\n    prd_image_data = hog_data_extractor(img_path)\n    scene_predicted = lsvc.predict(prd_image_data.reshape(1, -1))[0]\n    fig, ax = plt.subplots(1, 2, figsize=(12, 6),\n                       subplot_kw=dict(xticks=[], yticks=[]))\n    ax[0].imshow(ip_image)\n    ax[0].set_title('input image')\n\n    ax[1].imshow(cv2.cvtColor(image,cv2.COLOR_BGR2RGB))\n    ax[1].set_title('Scene predicted :'+ scene_label[scene_predicted]);","77db0534":"ip_img_folder = '..\/input\/seg_pred\/seg_pred\/'\nip_img_files = ['222.jpg','121.jpg','88.jpg','398.jpg','839.jpg', '520.jpg']\nscene_predicted = [scene_predict(os.path.join(ip_img_folder,img_file))for img_file in ip_img_files]","9952543a":"#### Using Label Encoder to encode the scene labels","d886fd2a":"#### Predict the scene classification for some random image","4ddfeb79":"Call the \"jpeg_to_array\" function to load the training & test images","ee07a63e":"####  Score and Cross Value result of the model","25c5ad3c":"### 1. Import the necesassary libraries and  image files","ccbf299c":"### Create a Linear SVM model and train it","7e9dbae6":"#### \"jpeg_to_array\" function will loades the images from the given path and stores the hog features in to X_train_data & X_test_data respectively","4d7681c0":"# Intel Image Classififcation","ba4e6f76":"Import the Training & test images ","71004261":"#### \"hog_data_extractor\" function will get the hog feature from the given jpeg file","6e6e0174":"#### The given dataset has different types of scenes as below\n\n1. Buildings\n2. Forest\n3. Glacier\n4. Mountain\n5. Sea\n6. Street\n\nFor each scenes, it has individual set of images, for to train and the test model. Most of the images are in 150 x 150 pixle size and some where in improper size format. So, all the images will be resized to 100 x 100.\n\n\n#### Below are the steps i had followed for to train & test the model.\n\n1. Import the necesasary libraties and image files\n2. Create a Linear SVM model and train it\n3. Check the accuracy score of the model\n4. Predict some random images\n5. Improve the model using PCA"}}