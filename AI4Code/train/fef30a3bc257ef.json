{"cell_type":{"937ec171":"code","c9e81bc4":"code","cb2a7369":"code","b2f9262e":"code","a4e802fd":"code","53330d41":"code","d7d1798b":"code","c95574f1":"code","e057bbe6":"code","18d7cc78":"code","b7ac0389":"code","266dd68a":"code","ce019615":"code","bd3e5b5b":"code","f8ce7a3d":"code","41446be9":"code","87905e60":"code","c778676c":"code","92d83351":"code","1c375690":"code","e3e5c11d":"code","b47efe1c":"code","35a4deb7":"code","4e19febe":"code","219af19f":"code","dad920fb":"code","e1ffbc16":"code","296609bc":"code","00cb79b2":"code","aa1e5199":"code","700c29bf":"code","ba6bf10b":"code","39aab580":"code","79b7f2cf":"code","7de815de":"code","f245a5f2":"code","33327bc6":"code","44b6553c":"markdown","0c376b46":"markdown","2f3ccf6e":"markdown","7c81a80e":"markdown","08b74a5e":"markdown","635bb86c":"markdown","37bedec7":"markdown","a68aa3aa":"markdown","9d79053b":"markdown","66bbb7e1":"markdown","37bd8d7d":"markdown","1709bd5f":"markdown","fb2f990c":"markdown","ea07c35b":"markdown","b83f1649":"markdown","9afb4e82":"markdown","882e167d":"markdown","735a809d":"markdown","4224d9e2":"markdown","0c200b7d":"markdown","a1c163f4":"markdown","cb07bb9c":"markdown","89b2bd76":"markdown","c0c92e1f":"markdown","fc56fbea":"markdown","6f3a6c66":"markdown","d72aec34":"markdown","a9268799":"markdown","2d7d2345":"markdown","74a16c12":"markdown","c27e4f44":"markdown","e4ddfd9d":"markdown","1df8937a":"markdown","f2f02947":"markdown","64d63ebf":"markdown","3073d638":"markdown","ef46d326":"markdown","89ef418b":"markdown","aff0b771":"markdown","2d85575d":"markdown"},"source":{"937ec171":"import numpy as np\nimport pandas as pd\n\nimport os\nimport random\nfrom operator import itemgetter\nimport copy\nimport time\n\nimport torch\nimport torchvision\nimport torchvision.transforms as transform\nfrom torchvision.datasets import ImageFolder\nfrom torch.utils.data import DataLoader, Dataset, ConcatDataset\nimport torch.nn as nn\nimport torchvision.models as models\nfrom torchvision.utils import make_grid\nimport torch.nn.functional as F\n\nfrom mlxtend.plotting import plot_confusion_matrix\nfrom sklearn.metrics import confusion_matrix, classification_report\n\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom matplotlib.image import imread\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndevice= torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')","c9e81bc4":"example = '..\/input\/final-flowers-course-project-dataset\/Flowers_Dataset_Revised\/Flowers_Dataset_Revised\/newFlowers\/daisy'\npath = '..\/input\/final-flowers-course-project-dataset\/Flowers_Dataset_Revised\/Flowers_Dataset_Revised\/newFlowers'","cb2a7369":"img = mpimg.imread(example + '\/100080576_f52e8ee070_n.jpg')\nprint('Shape:', img.shape)\nplt.imshow(img);","b2f9262e":"def plotHist(img):\n  plt.figure(figsize=(10,5))\n  plt.subplot(1,2,1)\n  plt.imshow(img)\n  plt.axis('off')\n  histo = plt.subplot(1,2,2)\n  histo.set_ylabel('Count')\n  histo.set_xlabel('Pixel Intensity')\n  plt.hist(img.flatten(), bins=10, lw=0, alpha=0.5, color='r')\n\nplotHist(img)","a4e802fd":"transformer = {\n    'original': transform.Compose([\n                                 transform.Resize((220, 220)),\n                                 transform.ToTensor(), \n                                 transform.Normalize((0.4124234616756439, 0.3674212694168091, 0.2578217089176178), \n                                                     (0.3268945515155792, 0.29282665252685547, 0.29053378105163574))\n]), \n   'dataset1': transform.Compose([\n                           transform.Resize((220, 220)),\n                           transform.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2),\n                           transform.RandomRotation(5),\n                           transform.RandomAffine(degrees=11, translate=(0.1,0.1), scale=(0.8,0.8)),\n                           transform.ToTensor(),\n                           transform.Normalize((0.4124234616756439, 0.3674212694168091, 0.2578217089176178), \n                                               (0.3268945515155792, 0.29282665252685547, 0.29053378105163574)),\n]), \n   'dataset2': transform.Compose([\n                                 transform.Resize((220, 220)),\n                                 transform.RandomHorizontalFlip(),\n                                 transform.RandomRotation(10),\n                                 transform.RandomAffine(translate=(0.05,0.05), degrees=0),\n                                 transform.ToTensor(),\n                                 transform.RandomErasing(inplace=True, scale=(0.01, 0.23)),\n                                 transform.Normalize((0.4124234616756439, 0.3674212694168091, 0.2578217089176178), \n                                                     (0.3268945515155792, 0.29282665252685547, 0.29053378105163574))]),\n   'dataset3': transform.Compose([\n                                 transform.Resize((220, 220)),\n                                 transform.RandomHorizontalFlip(p=0.5),\n                                 transform.RandomRotation(15),\n                                 transform.RandomAffine(translate=(0.08,0.1), degrees=15),\n                                 transform.ToTensor(),\n                                 transform.Normalize((0.4124234616756439, 0.3674212694168091, 0.2578217089176178), \n                                                     (0.3268945515155792, 0.29282665252685547, 0.29053378105163574))\n                                                     \n])\n       }","53330d41":"bs = 50\n\noriginal = ImageFolder(path, transform=transformer['original'])\n\n#all_set = train_val + test\ntrain_val, test = train_test_split(original, test_size=0.2, shuffle=True, random_state=43)\n\n#train_val = train + val + dataset1 + dataset2 + dataset3\ntrain_val = ConcatDataset([train_val, \n                           ImageFolder(path, transform=transformer['dataset1']), \n                           ImageFolder(path, transform=transformer['dataset2']),\n                           ImageFolder(path, transform=transformer['dataset3'])])\n\ntrain, val = train_test_split(train_val, test_size=0.1, shuffle=True, random_state=43)\n\nloaders = {\n    'train': DataLoader(train, batch_size=bs, num_workers=4, pin_memory=True),\n    'val': DataLoader(val, batch_size=bs, num_workers=4, pin_memory=True),\n    'test': DataLoader(test, batch_size=bs, num_workers=4, pin_memory=True)\n}\n\ndataset_sizes = {\n    'train': len(train),\n    'val': len(val), \n    'test': len(test),\n}","d7d1798b":"exampleset = ImageFolder(path, transform=transform.Compose([transform.ToTensor(),\n                                                            transform.CenterCrop(255),]))\n\nx, y = next(iter(DataLoader(exampleset)))\n\nchannels = ['Red', 'Green', 'Blue']\ncmaps = [plt.cm.Reds_r, plt.cm.Greens_r, plt.cm.Blues_r]\n\nfig, ax = plt.subplots(1, 4, figsize=(15, 10))\n\nfor i, axs in enumerate(fig.axes[:3]):\n    axs.imshow(x[0][i,:,:], cmap=cmaps[i])\n    axs.set_title(f'{channels[i]} Channel')\n    axs.set_xticks([])\n    axs.set_yticks([])\n    \nax[3].imshow(x[0].permute(1,2,0))\nax[3].set_title('Three Channels')\nax[3].set_xticks([])\nax[3].set_yticks([]);","c95574f1":"channels = 3\n\nfor channel in range(channels):\n    for x in ['train', 'val', 'test']:\n        #number of pixels in the dataset = number of all pixels in one object * number of all objects in the dataset\n        num_pxl = dataset_sizes[x]*255*255\n    \n        #we go through the butches and sum up the pixels of the objects, \n        #which then divide the sum by the number of all pixels to calculate the average\n        total_sum = 0\n        for batch in loaders[x]:\n            layer = list(map(itemgetter(channel), batch[0]))\n            layer = torch.stack(layer, dim=0)\n            total_sum += layer.sum()\n        mean = total_sum \/ num_pxl\n\n        #we calculate the standard deviation using the formula that I indicated above\n        sum_sqrt = 0\n        for batch in loaders[x]: \n            layer = list(map(itemgetter(channel), batch[0]))\n            sum_sqrt += ((torch.stack(layer, dim=0) - mean).pow(2)).sum()\n        std = torch.sqrt(sum_sqrt \/ num_pxl)\n        \n        print(f'|channel:{channel+1}| {x} - mean: {mean}, std: {std}')","e057bbe6":"x, y = next(iter(loaders['train']))\nx.mean(),  x.std()","18d7cc78":"x, y = next(iter(loaders['train']))\nimg_norm = x[0].permute(1,2,0).numpy()\nplotHist(img_norm)","b7ac0389":"print('Classes:', original.classes)\nprint('Number of classes:', len(original.classes))","266dd68a":"dic = {}\n\nfor classes in original.classes:\n  dic[classes] = [len([os.path.join(path+'\/'+classes, filename) for filename in os.listdir(path+'\/'+classes)])]\n\nsamplesize = pd.DataFrame.from_dict(dic)","ce019615":"samplesize","bd3e5b5b":"figure_size = plt.rcParams['figure.figsize']\nfigure_size[0] = 40\nfigure_size[1] = 20\nplt.rcParams['figure.figsize'] = figure_size\n\nsns.barplot(data=samplesize)\n\nindex = np.arange(len(original.classes))\n\nplt.xlabel('Flowers', fontsize=25)\nplt.ylabel('Count of flowers', fontsize=25)\nplt.xticks(index, original.classes, fontsize=25)\nplt.title('Class Distrubution', fontsize=35)\nplt.show()","f8ce7a3d":"# Function for plotting samples\ndef plot_samples(samples):  \n    fig, ax = plt.subplots(nrows=5, ncols=5, figsize=(15,12))\n    i = 0\n    for row in range(5):\n         for col in range(5):\n                img = mpimg.imread(samples[i][0][0])\n                ax[row][col].imshow(img)\n                ax[row][col].axis('off')\n                ax[row][col].set_title(samples[i][1], fontsize=15)\n                i+=1\n  \n\nrand_samples = [] \nfor _ in range(25): \n    classes = random.choice(original.classes)\n    rand_samples.append([random.sample([os.path.join(path+'\/'+classes, filename) for filename in os.listdir(path+'\/'+classes)], 1), classes]) \nrand_samples[0]\nplot_samples(rand_samples)\nplt.suptitle('Samples', fontsize=30)\nplt.show()","41446be9":"def show_batch(dl):\n    for images, labels in dl:\n        fig, ax = plt.subplots(figsize=(25, 25))\n        ax.set_xticks([]); ax.set_yticks([])\n        ax.imshow(make_grid(images[:60], nrow=10).permute(1, 2, 0))\n        ax.set_title('Images with augmentation', fontsize=40)\n        break\n        \nshow_batch(loaders['train'])","87905e60":"def accuracy(outputs, labels):\n    _, preds = torch.max(outputs, dim=1) \n    return torch.tensor(torch.sum(preds == labels).item() \/ len(preds)), preds","c778676c":"#save the losses for further visualization\nlosses = {'train':[], 'val':[]}\naccuracies = {'train':[], 'val':[]}\nlr = []","92d83351":"def train(seed, epochs, model):\n    \n  print('Creating a model {}...'.format(seed))\n\n  model.to(device)  \n  criterion = nn.CrossEntropyLoss()\n  if seed==2 or seed==3:\n    optimizer = torch.optim.Adam(model.fc.parameters(), lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay = 1e-5)\n  else:\n    optimizer = torch.optim.Adam(model.classifier.parameters(), lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)\n  scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', factor=0.1, patience=3, verbose=True)\n  #scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, 0.1, epochs=epochs, steps_per_epoch=len(loaders['train']), cycle_momentum=True)\n  #scheduler = torch.optim.lr_scheduler.StepLR(optimizer, 3, gamma=0.1)\n  since = time.time()\n  best_model = copy.deepcopy(model.state_dict())\n  best_acc = 0.0\n  for epoch in range(epochs):\n    for phase in ['train', 'val']:\n      if phase == 'train':\n        model.train()\n      else:\n        model.eval()\n      \n      running_loss = 0.0\n      running_corrects = 0.0\n\n      for inputs, labels in loaders[phase]:\n        inputs, labels = inputs.to(device), labels.to(device)\n        optimizer.zero_grad()\n\n        with torch.set_grad_enabled(phase=='train'):\n          outp = model(inputs)\n          _, pred = torch.max(outp, 1)\n          loss = criterion(outp, labels)\n        \n          if phase == 'train':\n            loss.backward()\n            optimizer.step()\n#             lr.append(scheduler.get_lr())\n#             scheduler.step()\n\n        running_loss += loss.item()*inputs.size(0)\n        running_corrects += torch.sum(pred == labels.data)\n\n      if phase == 'train':\n          acc = 100. * running_corrects.double() \/ dataset_sizes[phase]\n          scheduler.step(acc)\n\n      epoch_loss = running_loss \/ dataset_sizes[phase]\n      epoch_acc = running_corrects.double()\/dataset_sizes[phase]\n      losses[phase].append(epoch_loss)\n      accuracies[phase].append(epoch_acc)\n      if phase == 'train':\n        print('Epoch: {}\/{}'.format(epoch+1, epochs))\n      print('{} - loss:{}, accuracy{}'.format(phase, epoch_loss, epoch_acc))\n      lr.append(scheduler._last_lr)\n        \n      if phase == 'val':\n        print('Time: {}m {}s'.format((time.time()- since)\/\/60, (time.time()- since)%60))\n        print('=='*31)\n      if phase == 'val' and epoch_acc > best_acc:\n        best_acc = epoch_acc\n        best_model = copy.deepcopy(model.state_dict())\n    #scheduler.step() \n  time_elapsed = time.time() - since\n  print('CLASSIFIER TRAINING TIME {}m {}s'.format(time_elapsed\/\/60, time_elapsed%60))\n  print('=='*31)\n\n\n  model.load_state_dict(best_model)\n\n  for param in model.parameters():\n        param.requires_grad=True\n\n  optimizer = torch.optim.Adam(model.parameters(), lr=0.0001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)  \n  scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, factor=0.1, patience=2, verbose=True)\n  #scheduler = torch.optim.lr_scheduler.StepLR(optimizer, 3, gamma=0.1)\n  #scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, 0.001, epochs=epochs, steps_per_epoch=len(loaders['train']), cycle_momentum=True)\n  for epoch in range(epochs):\n    for phase in ['train', 'val']:\n      if phase == 'train':\n        model.train()\n      else:\n        model.eval()\n      \n      running_loss = 0.0\n      running_corrects = 0.0\n\n      for inputs, labels in loaders[phase]:\n        inputs, labels = inputs.to(device), labels.to(device)\n\n        optimizer.zero_grad()\n\n        with torch.set_grad_enabled(phase=='train'):\n          outp = model(inputs)\n          _, pred = torch.max(outp, 1)\n          loss = criterion(outp, labels)\n        \n          if phase == 'train':\n            loss.backward()\n            optimizer.step()\n#             lr.append(scheduler.get_lr())\n#             scheduler.step()\n\n        running_loss += loss.item()*inputs.size(0)\n        running_corrects += torch.sum(pred == labels.data)\n\n      if phase == 'train':\n        acc = 100. * running_corrects.double() \/ dataset_sizes[phase]\n        scheduler.step(acc)\n\n      epoch_loss = running_loss \/ dataset_sizes[phase]\n      epoch_acc = running_corrects.double()\/dataset_sizes[phase]\n      losses[phase].append(epoch_loss)\n      accuracies[phase].append(epoch_acc)\n      if phase == 'train':\n        print('Epoch: {}\/{}'.format(epoch+1, epochs))\n      print('{} - loss:{}, accuracy{}'.format(phase, epoch_loss, epoch_acc))\n      lr.append(scheduler._last_lr)\n    \n      if phase == 'val':\n        print('Time: {}m {}s'.format((time.time()- since)\/\/60, (time.time()- since)%60))\n        print('=='*31)    \n      if phase == 'val' and epoch_acc > best_acc:\n        best_acc = epoch_acc\n        best_model = copy.deepcopy(model.state_dict())\n    #scheduler.step() \n  time_elapsed = time.time() - since\n  print('ALL NET TRAINING TIME {}m {}s'.format(time_elapsed\/\/60, time_elapsed%60))\n  print('=='*31)\n\n  model.load_state_dict(best_model)\n  return model","1c375690":"densenet121_0 = torchvision.models.densenet121(pretrained=True)\nfor param in densenet121_0.parameters():\n  param.requires_grad=False\n\ndensenet121_0.classifier = nn.Linear(in_features=densenet121_0.classifier.in_features, out_features=len(original.classes), bias=True)","e3e5c11d":"densenet121_1 = torchvision.models.densenet121(pretrained=True)\nfor param in densenet121_1.parameters():\n  param.requires_grad=False\n\ndensenet121_1.classifier = nn.Linear(in_features=densenet121_1.classifier.in_features, out_features=len(original.classes), bias=True)","b47efe1c":"googlenet = torchvision.models.googlenet(pretrained=True)\nfor param in googlenet.parameters():\n  param.grad_requires = False\n\ngooglenet.fc = nn.Linear(in_features=googlenet.fc.in_features, out_features=len(original.classes), bias=True)","35a4deb7":"resnet101 = torchvision.models.resnet101(pretrained=True)\nfor param in resnet101.parameters():\n  param.grad_requires = False\n\nresnet101.fc = nn.Linear(in_features=resnet101.fc.in_features, out_features=len(original.classes), bias=True)","4e19febe":"vgg19_bn = torchvision.models.vgg19_bn(pretrained=True)\nfor param in vgg19_bn.parameters():\n  param.grad_requires = False\n\nvgg19_bn.classifier[6] = nn.Linear(4096, len(original.classes), bias=True)","219af19f":"num_models = 5\nepochs = 10\n\nmodels = [densenet121_0, densenet121_1, googlenet, resnet101, vgg19_bn]\n\nfor seed in range(num_models):\n   train(seed=seed, epochs=epochs, model=models[seed])","dad920fb":"fig, ax = plt.subplots(5, 2, figsize=(15, 15))\nmodelname = ['DenseNet_0', 'DenseNet_1', 'GooglNet', 'ResNet101', 'VGG16 with BN']\n\ni=0\n\nfor row in range(5):\n\n  epoch_list = list(range(1,epochs*2+1))\n\n  ax[row][0].plot(epoch_list, accuracies['train'][i:20+i], '-o', label='Train Accuracy')\n  ax[row][0].plot(epoch_list, accuracies['val'][i:20+i], '-o', label='Validation Accuracy')\n  ax[row][0].plot([epochs for x in range(20)],  np.linspace(min(accuracies['train'][i:20+i]).cpu(), max(accuracies['train'][i:20+i]).cpu(), 20), color='r', label='Unfreeze net')\n  ax[row][0].set_xticks(np.arange(0, epochs*2+1, 5))\n  ax[row][0].set_ylabel('Accuracy Value')\n  ax[row][0].set_xlabel('Epoch')\n  ax[row][0].set_title('Accuracy {}'.format(modelname[row]))\n  ax[row][0].legend(loc=\"best\")\n\n  ax[row][1].plot(epoch_list, losses['train'][i:20+i], '-o', label='Train Loss')\n  ax[row][1].plot(epoch_list, losses['val'][i:20+i], '-o',label='Validation Loss')\n  ax[row][1].plot([epochs for x in range(20)], np.linspace(min(losses['train'][i:20+i]), max(losses['train'][i:20+i]), 20), color='r', label='Unfreeze net')\n  ax[row][1].set_xticks(np.arange(0, epochs*2+1, 5))\n  ax[row][1].set_ylabel('Loss Value')\n  ax[row][1].set_xlabel('Epoch')\n  ax[row][1].set_title('Loss {}'.format(modelname[row]))\n  ax[row][1].legend(loc=\"best\")\n  fig.tight_layout()\n  fig.subplots_adjust(top=1.5, wspace=0.3)\n\n  i+=20","e1ffbc16":"class Ensemble(nn.Module):\n    def __init__(self, device):\n        super(Ensemble,self).__init__()\n        # you should use nn.ModuleList. Optimizer doesn't detect python list as parameters\n        self.models = nn.ModuleList(models)\n        \n    def forward(self, x):\n        # it is super simple. just forward num_ models and concat it.\n        output = torch.zeros([x.size(0), len(original.classes)]).to(device)\n        for model in self.models:\n            output += model(x)\n        return output","296609bc":"model =  Ensemble(device)","00cb79b2":"def validation_step(batch):\n        images,labels = batch\n        images,labels = images.to(device),labels.to(device)\n        out = model(images)                                      \n        loss = F.cross_entropy(out, labels)                    \n        acc,preds = accuracy(out, labels)                       \n        \n        return {'val_loss': loss.detach(), 'val_acc':acc.detach(), \n                'preds':preds.detach(), 'labels':labels.detach()}","aa1e5199":"def test_prediction(outputs):\n        batch_losses = [x['val_loss'] for x in outputs]\n        epoch_loss = torch.stack(batch_losses).mean()           \n        batch_accs = [x['val_acc'] for x in outputs]\n        epoch_acc = torch.stack(batch_accs).mean()             \n        # combine predictions\n        batch_preds = [pred for x in outputs for pred in x['preds'].tolist()] \n        # combine labels\n        batch_labels = [lab for x in outputs for lab in x['labels'].tolist()]  \n        \n        return {'test_loss': epoch_loss.item(), 'test_acc': epoch_acc.item(),\n                'test_preds': batch_preds, 'test_labels': batch_labels}","700c29bf":"@torch.no_grad()\ndef test_predict(model, test_loader):\n    model.eval()\n    # perform testing for each batch\n    outputs = [validation_step(batch) for batch in test_loader] \n    results = test_prediction(outputs)                          \n    print('test_loss: {:.4f}, test_acc: {:.4f}'\n          .format(results['test_loss'], results['test_acc']))\n    \n    return results['test_preds'], results['test_labels']","ba6bf10b":"model.to(device)\npreds,labels = test_predict(model, loaders['test'])","39aab580":"def norm_out(img):\n    \n    img = img.permute(1,2,0)\n    mean = torch.FloatTensor([0.4124234616756439, 0.3674212694168091, 0.2578217089176178])\n    std = torch.FloatTensor([0.3268945515155792, 0.29282665252685547, 0.29053378105163574])\n    \n    img = img*std + mean\n        \n    return np.clip(img,0,1)","79b7f2cf":"fig, ax = plt.subplots(figsize=(8,12), ncols=2, nrows=4)\n\nfor row in range(4):\n    i = np.random.randint(0, high=len(test))\n    img,label = test[i]\n    \n    m = nn.Softmax(dim=1)\n    percent = m(model(img.to(device).unsqueeze(0)))\n    predmax3percent = torch.sort(percent[0])[0]\n    predmax3inds = torch.sort(percent[0])[1]\n    classes = np.array([original.classes[predmax3inds[-5]], original.classes[predmax3inds[-4]], original.classes[predmax3inds[-3]], original.classes[predmax3inds[-2]],original.classes[predmax3inds[-1]]])\n    class_name = original.classes\n\n    ax[row][0].imshow(norm_out(img))\n    ax[row][0].set_title('Real : {}'.format(class_name[label]))\n    ax[row][0].axis('off')\n    ax[row][1].barh(classes, predmax3percent.detach().cpu().numpy())\n    ax[row][1].set_aspect(0.1)\n    ax[row][1].set_yticks(classes)\n    ax[row][1].set_title('Predicted Class: {} ({}%)'.format(original.classes[predmax3inds[-1]], round((predmax3percent[-1]*100).item(), 2)))\n    ax[row][1].set_xlim(0, 1.)\n    plt.tight_layout()","7de815de":"report = classification_report(labels, preds,\n                               output_dict=True,\n                               target_names=original.classes)\nreport_df = pd.DataFrame(report).transpose()","f245a5f2":"pd.set_option(\"display.max_rows\", None)\nreport_df.head(134)","33327bc6":"# Plot confusion matrix\ncm  = confusion_matrix(labels, preds)\nplt.figure()\nplot_confusion_matrix(cm,figsize=(12,8),cmap=plt.cm.Blues)\nplt.xticks(range(len(original.classes)), original.classes, fontsize=16)\nplt.yticks(range(len(original.classes)), original.classes, fontsize=16)\nplt.xlabel('Predicted Label',fontsize=18)\nplt.ylabel('True Label',fontsize=18)\nplt.show()","44b6553c":"**4. ResNet**","0c376b46":"**The imbalance is small and we do not need to handle it in any way, since the ratio of the largest class to the smallest is 1.47, which is not much**","2f3ccf6e":"**Let's take a quick look at the data. I don't know about you, but the first thing I always want to do is look at what our data looks like :)**","7c81a80e":"# MODELS","08b74a5e":"**3. GoogleNet**","635bb86c":"**2. DenseNet(2)**","37bedec7":"**Let's write augmentation and normalization right away. Why are there four datasets?**\n\n**(1)** The \"original\" dataset is the original dataset(wow), which we will split into two parts: test (20%) and training (80%).\n\n**(2)** The dataset \"dataset1\" is a dataset with augmentation, which we will add to the training part of the original dataset to expand the data.\n\n**(3)** The dataset \"dataset2\" is a dataset with augmentation, which we will add to the training part of the original dataset to expand the data.\n\n**(4)** The dataset \"dataset3\" is a dataset with augmentation, which we will add to the training part of the original dataset to expand the data.\n","a68aa3aa":"**This is where we will record the history of learning, so that we can make visualization later. We need visualization to evaluate learning, for example, overfitting or underfitting. Of course, we can analyze with numbers, but it is much easier to perceive information visually**","9d79053b":"Train function structure:\n\n1. **Classifier Training**\n2. **Network-wide Training**","66bbb7e1":"**Let's take a batch from the training dataset and see its mean and standard deviation:**","37bd8d7d":"**pin_memory:** You know how sometimes your GPU memory shows that it\u2019s full but you\u2019re pretty sure that your model isn\u2019t using that much? That overhead is called pinned memory. ie: this memory has been reserved as a type of \u201cworking allocation.\u201d\nWhen you enable pinned_memory in a DataLoader it \u201cautomatically puts the fetched data Tensors in pinned memory, and enables faster data transfer to CUDA-enabled GPUs\u201d\n\n**num_workers:** PyTorch allows loading data on multiple processes simultaneously. A good rule: ***num_worker = 4 * num_GPU***","1709bd5f":"**From the image above, you can understand that they are not normalized (which is very expected), how strong the spread can be seen using the script below:**","fb2f990c":"# **1. Data Loading**","ea07c35b":"**This is how we can look at our classes. There are only five of them, which is not much**","b83f1649":"***I hope you enjoyed it and found something new for yourself!*\n*I am always happy to receive any feedback. What do you think can be changed and what can be removed?***","9afb4e82":"**First, let's write an ensemble class. It's very easy!**","882e167d":"**We have already normalized the data, but at this stage I would like to dwell in more detail, because this is very important.**\n\nIn datasets, we have three-channel images, that is, we need to normalize for each channel separately (!!!). Because of the unnormalized data, problems may appear, for example, regularization during training can work to the detriment, but we do not want this at all. The task of normalization is to make the mean as close to zero as possible, and the standard deviation around 1. \n\nHow each channel looks separately can be seen below:","735a809d":"**Let's take a look at the pixel distribution after normalization. Compared to the distribution at the beginning, the difference is large**","4224d9e2":"**The function below will normalize the image back to its original. It simply multiplies the tensor by the standard deviation and adds the mean**","0c200b7d":"**In random pictures, the network shows 100% accuracy, this is the most confident answer, so you can make the assumption that the networks have learned well**","a1c163f4":"**This might be helpful:**\n\nPredicting pneumonia by X-ray: https:\/\/www.kaggle.com\/georgiisirotenko\/pytorch-x-ray-transfer-learning-densenet\n\nFruit prediction for 131 classes(!!!): https:\/\/www.kaggle.com\/georgiisirotenko\/pytorch-fruits-transferlearing-ensemble-test99-18\n\nFashionMNIST: https:\/\/www.kaggle.com\/georgiisirotenko\/pytorch-fashionmnist-acc-0-94\n\nA similar solution, but with a submission(MNIST top 5%): https:\/\/www.kaggle.com\/georgiisirotenko\/pytorch-mnist-transferlearning-ensemble-99-714","cb07bb9c":"# 7. Metrics","89b2bd76":"**5. VGG19**","c0c92e1f":"**Now let's check how well we managed to normalize the data for each channel for the test, training and validation datasets:**","fc56fbea":"**These functions will help us when calculating the accuracy**","6f3a6c66":"# 6. Predictions in individual images","d72aec34":"**It seems to me that we have achieved good enough accuracy**","a9268799":"**Let's see how the images from the original dataset look like without changes:**","2d7d2345":"# **2. Data preparation**\n","74a16c12":"**As you can see from the graphs, the unfreeze idea worked. We can see that after the red lines, the performance improves!**","c27e4f44":"# 4. Loss and Accuracy Plots","e4ddfd9d":"**Let's check how imbalanced our data is. Since we are working with images, first we need to make a pandas table, and then render the table.**","1df8937a":"**Launching training**","f2f02947":"In order not to count the accuracy many times, we write the function","64d63ebf":"# **0. Importing Libraries**\n","3073d638":"**Paths**","ef46d326":"**1. DenseNet(1)**","89ef418b":"# 5. Test set predictions","aff0b771":"**And this is how images with augmentation look like**","2d85575d":"# 3. Training and Test\n\n**Idea:** I will use an ensemble of pre-trained models. I first train only the classifier on 10 epochs, then unfreeze the network and train all together for another 10 epochs"}}