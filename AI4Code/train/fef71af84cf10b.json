{"cell_type":{"1f50c009":"code","9d17260e":"code","ab16dc10":"code","4e4d2d87":"code","fbfad71f":"code","07fd22f5":"code","5597e5b4":"code","f93ab09f":"code","3889e383":"code","df44a681":"code","2d056717":"code","d1d2e0cd":"code","b2d4bc76":"code","d5f83cdf":"code","0a0803e3":"code","1afd4315":"code","72c595d3":"code","32651df0":"code","ab8c3e74":"code","c21f71d3":"code","d355d70d":"code","0d4536e2":"code","84c72f95":"code","2bb27003":"code","346a3777":"code","70c15236":"code","4e1948cd":"code","daf36fbd":"code","65e479eb":"code","7afdc679":"code","1c54e03e":"code","c7e7d6f8":"code","90ac54f2":"code","4c892f35":"code","d108204f":"code","15b912c0":"markdown","534df8ea":"markdown","e2b237ed":"markdown"},"source":{"1f50c009":"# if you get error while installing fbprophet, follow this - \n# pip install -r https:\/\/raw.githubusercontent.com\/facebook\/prophet\/master\/python\/requirements.txt\n# pip install fbprophet==0.7.1\n\n# fbprophet is from facebook research\n\n# https:\/\/www.nseindia.com\/market-data\/live-market-indices","9d17260e":"# !pip install sklearn\n# !pip install seaborn\n# !pip install plotly\n\n# if pip install doesn;t solve error, try conda \n# !conda install --yes pandas\n# !conda install --yes matplotlib\n\n# please make sure to create COnda env and then do these isntallation\n# conda create -n myenv python=3.7 ","ab16dc10":"from sklearn.metrics import mean_squared_error\nfrom math import sqrt\nfrom datetime import date\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport matplotlib.patches as mpatches\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\n%matplotlib inline\nimport datetime as dt\nimport calendar\nimport warnings\nwarnings.simplefilter('ignore')\nimport math\nfrom fbprophet import Prophet\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\n# plt.style.use('fivethirtyeight')\nfrom fbprophet.plot import plot_plotly, plot_components_plotly\nfrom fbprophet.diagnostics import cross_validation\nfrom datetime import date, datetime, time, timedelta\nfrom dateutil.relativedelta import relativedelta\nimport datetime as dt\n\nimport itertools\nfrom fbprophet.diagnostics import performance_metrics\n\npd.set_option('display.max_rows', 5000)\npd.set_option('display.max_columns', 500)\npd.set_option('display.float_format', lambda x: '%.3f' % x)\n","4e4d2d87":"#!pip install nsepy\nfrom nsepy import get_history","fbfad71f":"name = \"HDFC\" # Hosuing Finance Company\nname = str(name)\nprint(\"You have choosen the company\",name)","07fd22f5":"#data = get_history(symbol=name, start=date(2018,3,1), end=date(2021,2,28)) # Extracting 3 years of the stock data\ndata = pd.read_csv('..\/input\/hdfcusingnsepy\/HDFC.csv')\ndata.head()","5597e5b4":"visual_data = data[[ 'Open', 'High', 'Low', 'Last',\n       'Close','Volume']]\nvisual_data.plot(subplots=True, figsize=(10,12))","f93ab09f":"test_data = get_history(symbol=name, start=date(2021,3,1), end=date(2021,5,27)) # Extracting 3 years of the stock data\ntest_data.head()","3889e383":"'''\ninitials_of_stock = Initials of the Stock as listed on NSE\/BSE\nstarting_date = Date from which we want to train our data\nending_date = Date till which we want to stop trainign our data\nforecasting_date = Date till which we want to forecast\nvalue_on_prediction = On what value of stock do we want to Predict(Open,Close,High,Low). Generally it is done on 'Close' \n'''\n\ndef base_calulate_profit(initials_of_stock,starting_date,ending_date,forecasting_date,value_on_prediction):\n    name = initials_of_stock # Hosuing Finance Company   #INSERT NAME & TIME\n    name = str(name)\n    print(\"You have choosen the company\",name)\n    print('Starting Date is ',starting_date)\n    print('Ending Date is ',ending_date)\n    print('Forecasting Date is ',forecasting_date)\n    \n    data = get_history(symbol=name, start=starting_date, end=ending_date) ##INSERT\n\n    test_data = get_history(symbol=name, start=ending_date, end=forecasting_date) # For comparing later on\n\n    data = data.reset_index()\n    data['Date'] = pd.to_datetime(data['Date'], errors='coerce')\n\n    value_on_prediction = str(value_on_prediction)\n    data[value_on_prediction] = data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n    data2 = data[['Date',value_on_prediction]]\n    data2.columns = ['ds','y']\n\n    test_data = test_data.reset_index()\n    test_data['Date'] = pd.to_datetime(test_data['Date'], errors='coerce')\n    test_data[value_on_prediction] = test_data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n    test_data2 = test_data[['Date',value_on_prediction]]\n    test_data2.columns = ['ds','y']\n\n    rmse=[]\n    num_days = (forecasting_date - ending_date).days\n    num_days= int(num_days)\n    print('Forecasting Period is for',num_days,' days')\n    \n    model = Prophet()\n    model.fit(data2)  # Fit model with basic params\n\n    df_cv = cross_validation(model, horizon='30 days', parallel=\"processes\")\n    df_p = performance_metrics(df_cv, rolling_window=1)\n    rmse.append(df_p['rmse'][0])\n\n#     tuning_results = pd.DataFrame(all_params)\n#     tuning_results['rmse'] = rmses\n    print('RMSE= ',rmse)\n\n    #Prediction of Future Data\n    future = model.make_future_dataframe(periods=num_days)\n    future.tail()\n\n    #using forecasting object\n    forecast = model.predict(future)\n    forecast=forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n    forecasting_values = forecast.tail(num_days)\n    \n    forecast.tail(num_days).plot(figsize=(15,5),x = 'ds',y='yhat')\n    plt.title(('Stock Prediction of '+name))\n    plt.xlabel('Date')\n    plt.ylabel('Stock Price')\n\n\n    opening_value_of_stock = data2['y'].tail(1)\n    opening_value_of_stock = float(opening_value_of_stock)   # Last value of stock on last day of train \n    closing_predicted_value_of_stock = forecasting_values['yhat'].tail(1)\n    closing_predicted_value_of_stock = float(closing_predicted_value_of_stock)  # predicted value  \n    actual_predicted_value_of_stock = test_data2['y'].tail(1)\n    actual_predicted_value_of_stock = float(actual_predicted_value_of_stock)  # Actual Value of stock\n\n    print(opening_value_of_stock)\n    print(closing_predicted_value_of_stock)\n    print(actual_predicted_value_of_stock)  \n    \n    profit_predicted_actual = round((actual_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n    print('Actual Profit of this stock is ',profit_predicted_actual,\"%\")\n    \n    \n    profit_predicted_forecast = round((closing_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n    print('Predicted Profit of this stock is ',profit_predicted_forecast,\"%\")\n\n\n","df44a681":"#base_calulate_profit('BIOCON',date(2018,9,30),date(2021,1,1),date(2021,5,28),'Close')","2d056717":"base_calulate_profit('ITC',date(2018,9,30),date(2021,1,1),date(2021,5,28),'Close')","d1d2e0cd":"base_calulate_profit('HDFC',date(2018,9,30),date(2021,1,30),date(2021,4,30),'Close')","b2d4bc76":"name","d5f83cdf":"## Hyperparameter Tuning using random numbers\nimport itertools\nimport numpy as np\nimport pandas as pd\nfrom fbprophet.diagnostics import performance_metrics\n\ndata = get_history(symbol=name, start=date(2018,3,1), end=date(2021,5,28)) # Extracting 3 years of the stock data\ndata = data.reset_index()\ndata['Date'] = pd.to_datetime(data['Date'], errors='coerce')\ndata['Close'] = data['Close'].apply(lambda x: float(x))\ndata2 = data[['Date','Close']]\ndata2.columns = ['ds','y']\n\nparam_grid = {  \n    'changepoint_prior_scale': [0.05,0.08,0.09,0.1],\n    'seasonality_prior_scale': [1.6,1.7,1.8]\n}\n\n# Generate all combinations of parameters\nall_params = [dict(zip(param_grid.keys(), v)) for v in itertools.product(*param_grid.values())]\nrmses = []  # Store the RMSEs for each params here\n\n# Use cross validation to evaluate all parameters\nfor params in all_params:\n    model = Prophet(**params)\n    model.fit(data2)  # Fit model with basic params\n    \n    df_cv = cross_validation(model, horizon='30 days', parallel=\"processes\")\n    df_p = performance_metrics(df_cv, rolling_window=1)\n    rmses.append(df_p['rmse'].values[0])\n\n# Find the best parameters\ntuning_results = pd.DataFrame(all_params)\ntuning_results['rmse'] = rmses\nprint(tuning_results)\n","0a0803e3":"best_params = all_params[np.argmin(rmses)]\nprint(best_params)","1afd4315":"##Model fitting - 1 \n## In this model we will try to use almost all the important parameters . However we may have to remove a few for a better model\nmodel = Prophet(growth='linear',changepoint_prior_scale=best_params['changepoint_prior_scale'],seasonality_prior_scale=best_params['seasonality_prior_scale'],daily_seasonality=True,weekly_seasonality=True,yearly_seasonality=True)\nmodel.add_seasonality(name='custom_monthly', period=30, fourier_order=10)\nmodel.add_country_holidays(country_name='India')\nmodel.add_seasonality(name = 'daily',period = 1, fourier_order = 10)\nmodel.add_seasonality(name = 'weekly',period = 7, fourier_order = 50)\nmodel.add_seasonality(name = 'yearly',period = 365, fourier_order = 10)\n\nmodel.fit(data2)","72c595d3":"#!pip install ipywidgets\n!jupyter nbextension enable --py widgetsnbextension","32651df0":"# Applying Cross Validation - 1\ncv_stock = cross_validation(model,initial='548 days',period='15 days',horizon=\"30 days\")  \ncv2_stock = cv_stock.groupby(['ds'])['yhat'].mean().reset_index()\ncv3_stock = cv_stock.groupby(['ds'])['y'].mean().reset_index()\ncv4_stock = pd.merge(cv3_stock, cv2_stock, how='inner', on='ds')\nrms = sqrt(mean_squared_error(cv4_stock['y'],cv4_stock['yhat']))\nprint(rms)\n\npd.concat([cv4_stock.set_index('ds')['y'],cv4_stock.set_index('ds')['yhat']],axis=1).plot(figsize = (25,7))\n","ab8c3e74":"## Now our model looks better so we can forecast it\n#Predicting future periods as days\nnum_days = int(31)\nfuture = model.make_future_dataframe(periods=num_days)\nfuture.tail()\n\n#using forecasting object\nforecast = model.predict(future)\nforecast=forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\nforecast.tail(num_days)","c21f71d3":"forecast.tail(num_days).plot(figsize=(15,5),x = 'ds',y='yhat')\nplt.title(('Stock Prediction of '+name))\nplt.xlabel('Date')\nplt.ylabel('Stock Price')\n","d355d70d":"model.plot(forecast)\n# Black Dots --> Data used to train the model \n# Blue Line --> Line fitting through Data or Predictions based on learning \n# Blue Haze --> uncertainty intervals of predictions; lower the better ","0d4536e2":"def make_comparison_dataframe(historical, forecast):\n    \"\"\"Join the history with the forecast.\n    \n       The resulting dataset will contain columns 'yhat', 'yhat_lower', 'yhat_upper' and 'y'.\n    \"\"\"\n    return forecast.set_index(\"ds\")[[\"yhat\", \"yhat_lower\", \"yhat_upper\"]].join(\n        historical.set_index(\"ds\")\n    )","84c72f95":"cmp_df = make_comparison_dataframe(data2, forecast)\ncmp_df.tail(n=10)","2bb27003":"from plotly import graph_objs as go\nfrom plotly.offline import init_notebook_mode, iplot\n\n# Initialize plotly\ninit_notebook_mode(connected=True)","346a3777":"def show_forecast(cmp_df, num_predictions, num_values, title):\n    \"\"\"Visualize the forecast.\"\"\"\n\n    def create_go(name, column, num, **kwargs):\n        points = cmp_df.tail(num)\n        args = dict(name=name, x=points.index, y=points[column], mode=\"lines\")\n        args.update(kwargs)\n        return go.Scatter(**args)\n\n    lower_bound = create_go(\n        \"Lower Bound\",\n        \"yhat_lower\",\n        num_predictions,\n        line=dict(width=0),\n        marker=dict(color=\"gray\"),\n    )\n    upper_bound = create_go(\n        \"Upper Bound\",\n        \"yhat_upper\",\n        num_predictions,\n        line=dict(width=0),\n        marker=dict(color=\"gray\"),\n        fillcolor=\"rgba(68, 68, 68, 0.3)\",\n        fill=\"tonexty\",\n    )\n    forecast = create_go(\n        \"Forecast\", \"yhat\", num_predictions, line=dict(color=\"rgb(31, 119, 180)\")\n    )\n    actual = create_go(\"Actual\", \"y\", num_values, marker=dict(color=\"red\"))\n\n    # In this case the order of the series is important because of the filling\n    data = [lower_bound, upper_bound, forecast, actual]\n\n    layout = go.Layout(yaxis=dict(title=\"Price\"), title=title, showlegend=False)\n    fig = go.Figure(data=data, layout=layout)\n    iplot(fig, show_link=False)\n\n\nprediction_size=30\nshow_forecast(cmp_df, prediction_size, 100, \"Stock Prediction for HDFC\")","70c15236":"'''\ninitials_of_stock = Initials of the Stock as listed on NSE\/BSE\nstarting_date = Date from which we want to train our data\nending_date = Date till which we want to stop trainign our data\nforecasting_date = Date till which we want to forecast\nvalue_on_prediction = On what value of stock do we want to Predict(Open,Close,High,Low). Generally it is done on 'Close' \n'''\n\ndef base_calulate_profit_multi_stock(stock_list,starting_date,ending_date,forecasting_date,value_on_prediction):\n    final_stock_prediction = {}\n    for eachStock in stock_list:\n        name = eachStock # Hosuing Finance Company   #INSERT NAME & TIME\n        name = str(name)\n        print(\"You have choosen the company\",name)\n        print('Starting Date is ',starting_date)\n        print('Ending Date is ',ending_date)\n        print('Forecasting Date is ',forecasting_date)\n\n        data = get_history(symbol=name, start=starting_date, end=ending_date) ##INSERT\n\n        test_data = get_history(symbol=name, start=ending_date, end=forecasting_date) # For comparing later on\n\n        data = data.reset_index()\n        data['Date'] = pd.to_datetime(data['Date'], errors='coerce')\n\n        value_on_prediction = str(value_on_prediction)\n        data[value_on_prediction] = data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n        data2 = data[['Date',value_on_prediction]]\n        data2.columns = ['ds','y']\n\n        test_data = test_data.reset_index()\n        test_data['Date'] = pd.to_datetime(test_data['Date'], errors='coerce')\n        test_data[value_on_prediction] = test_data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n        test_data2 = test_data[['Date',value_on_prediction]]\n        test_data2.columns = ['ds','y']\n\n        rmse=[]\n        num_days = (forecasting_date - ending_date).days\n        num_days= int(num_days)\n        print('Forecasting Period is for',num_days,' days')\n\n        model = Prophet()\n        model.fit(data2)  # Fit model with basic params\n\n        df_cv = cross_validation(model, horizon='30 days', parallel=\"processes\")\n        df_p = performance_metrics(df_cv, rolling_window=1)\n        rmse.append(df_p['rmse'][0])\n\n    #     tuning_results = pd.DataFrame(all_params)\n    #     tuning_results['rmse'] = rmses\n        print('RMSE= ',rmse)\n\n        #Prediction of Future Data\n        future = model.make_future_dataframe(periods=num_days)\n        future.tail()\n\n        #using forecasting object\n        forecast = model.predict(future)\n        forecast=forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n        forecasting_values = forecast.tail(num_days)\n\n#         forecast.tail(num_days).plot(figsize=(15,5),x = 'ds',y='yhat')\n#         plt.title(('Stock Prediction of '+name))\n#         plt.xlabel('Date')\n#         plt.ylabel('Stock Price')\n\n\n        opening_value_of_stock = data2['y'].tail(1)\n        opening_value_of_stock = float(opening_value_of_stock)   # Last value of stock on last day of train \n        closing_predicted_value_of_stock = forecasting_values['yhat'].tail(1)\n        closing_predicted_value_of_stock = float(closing_predicted_value_of_stock)  # predicted value  \n        actual_predicted_value_of_stock = test_data2['y'].tail(1)\n        actual_predicted_value_of_stock = float(actual_predicted_value_of_stock)  # Actual Value of stock\n\n#         print(opening_value_of_stock)\n#         print(closing_predicted_value_of_stock)\n#         print(actual_predicted_value_of_stock)  \n\n        profit_predicted_actual = round((actual_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n#         print('Actual Profit of this stock is ',profit_predicted_actual,\"%\")\n\n\n        profit_predicted_forecast = round((closing_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n#         print('Predicted Profit of this stock is ',profit_predicted_forecast,\"%\")\n\n        final_stock_prediction[eachStock] = [rmse, profit_predicted_actual,profit_predicted_forecast]\n    \n    return final_stock_prediction\n\n\n","4e1948cd":"#starting_date,ending_date,forecasting_date\nstocks = ['HDFC','TCS','RELIANCE','HDFCBANK','KOTAKBANK','ITC']\nstocks = ['HDFC']\n\n#train_data = starting_date,ending_date\n#test_data = ending_date,forecasting_date\n\nresults = base_calulate_profit_multi_stock(stocks,date(2018,9,30),date(2021,1,30),date(2021,4,30),'Close')","daf36fbd":"result_df = pd.DataFrame.from_dict(results).T","65e479eb":"result_df.columns = [\"RMSE\", \"Actual_Profit\",\"Predicted_Profit\"]","7afdc679":"result_df","1c54e03e":"'''\ninitials_of_stock = Initials of the Stock as listed on NSE\/BSE\nstarting_date = Date from which we want to train our data\nending_date = Date till which we want to stop trainign our data\nforecasting_date = Date till which we want to forecast\nvalue_on_prediction = On what value of stock do we want to Predict(Open,Close,High,Low). Generally it is done on 'Close' \n'''\n\ndef base_calulate_profit_multi_stock_tuned(stock_list,starting_date,ending_date,forecasting_date,value_on_prediction):\n    final_stock_prediction = {}\n    for eachStock in stock_list:\n        name = eachStock # Hosuing Finance Company   #INSERT NAME & TIME\n        name = str(name)\n        print(\"You have choosen the company\",name)\n        print('Starting Date is ',starting_date)\n        print('Ending Date is ',ending_date)\n        print('Forecasting Date is ',forecasting_date)\n\n        data = get_history(symbol=name, start=starting_date, end=ending_date) ##INSERT\n\n        test_data = get_history(symbol=name, start=ending_date, end=forecasting_date) # For comparing later on\n\n        data = data.reset_index()\n        data['Date'] = pd.to_datetime(data['Date'], errors='coerce')\n\n        value_on_prediction = str(value_on_prediction)\n        data[value_on_prediction] = data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n        data2 = data[['Date',value_on_prediction]]\n        data2.columns = ['ds','y']\n\n        test_data = test_data.reset_index()\n        test_data['Date'] = pd.to_datetime(test_data['Date'], errors='coerce')\n        test_data[value_on_prediction] = test_data[value_on_prediction].apply(lambda x: float(x)) # INSERT Whether opening or closing\n        test_data2 = test_data[['Date',value_on_prediction]]\n        test_data2.columns = ['ds','y']\n\n        rmse=[]\n        num_days = (forecasting_date - ending_date).days\n        num_days= int(num_days)\n        print('Forecasting Period is for',num_days,' days')\n        \n        param_grid = {  \n            'changepoint_prior_scale': [0.05,0.08,0.09],\n            'seasonality_prior_scale': [1.6,1.7]\n        }\n\n        # Generate all combinations of parameters\n        all_params = [dict(zip(param_grid.keys(), v)) for v in itertools.product(*param_grid.values())]\n        rmses = []  # Store the RMSEs for each params here\n\n        # Use cross validation to evaluate all parameters\n        for params in all_params:\n            model = Prophet(**params)\n            model.fit(data2)  # Fit model with basic params\n\n            df_cv = cross_validation(model, horizon='30 days', parallel=\"processes\")\n            df_p = performance_metrics(df_cv, rolling_window=1)\n            rmses.append(df_p['rmse'].values[0])\n\n        # Find the best parameters\n        tuning_results = pd.DataFrame(all_params)\n        tuning_results['rmse'] = rmses\n        \n        ##Model fitting - 1 \n        ## In this model we will try to use almost all the important parameters . However we may have to remove a few for a better model\n        model = Prophet(growth='linear',changepoint_prior_scale=best_params['changepoint_prior_scale'],seasonality_prior_scale=best_params['seasonality_prior_scale'],daily_seasonality=True,weekly_seasonality=True,yearly_seasonality=True)\n        model.add_seasonality(name='custom_monthly', period=30, fourier_order=10)\n        model.add_country_holidays(country_name='India')\n        model.add_seasonality(name = 'daily',period = 1, fourier_order = 10)\n        model.add_seasonality(name = 'weekly',period = 7, fourier_order = 50)\n        model.add_seasonality(name = 'yearly',period = 365, fourier_order = 10)\n\n        model.fit(data2)\n\n        # Applying Cross Validation - 1\n        cv_stock = cross_validation(model,initial='548 days',period='15 days',horizon=\"30 days\")  \n        cv2_stock = cv_stock.groupby(['ds'])['yhat'].mean().reset_index()\n        cv3_stock = cv_stock.groupby(['ds'])['y'].mean().reset_index()\n        cv4_stock = pd.merge(cv3_stock, cv2_stock, how='inner', on='ds')\n        rms = sqrt(mean_squared_error(cv4_stock['y'],cv4_stock['yhat']))\n        print(rms)\n\n        pd.concat([cv4_stock.set_index('ds')['y'],cv4_stock.set_index('ds')['yhat']],axis=1).plot(figsize = (25,7))\n            \n        future = model.make_future_dataframe(periods=num_days)\n        future.tail()\n\n        #using forecasting object\n        forecast = model.predict(future)\n        forecast=forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n        forecasting_values = forecast.tail(num_days)\n\n        opening_value_of_stock = data2['y'].tail(1)\n        opening_value_of_stock = float(opening_value_of_stock)   # Last value of stock on last day of train \n        closing_predicted_value_of_stock = forecasting_values['yhat'].tail(1)\n        closing_predicted_value_of_stock = float(closing_predicted_value_of_stock)  # predicted value  \n        actual_predicted_value_of_stock = test_data2['y'].tail(1)\n        actual_predicted_value_of_stock = float(actual_predicted_value_of_stock)  # Actual Value of stock\n\n        profit_predicted_actual = round((actual_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n\n        profit_predicted_forecast = round((closing_predicted_value_of_stock-opening_value_of_stock)*100\/opening_value_of_stock,2)\n\n        final_stock_prediction[eachStock] = [rmse, profit_predicted_actual,profit_predicted_forecast]\n    \n    return final_stock_prediction\n\n\n\n","c7e7d6f8":"#starting_date,ending_date,forecasting_date\nstocks = ['HDFC','TCS']\n\n#train_data = starting_date,ending_date\n#test_data = ending_date,forecasting_date\n\nresults = base_calulate_profit_multi_stock_tuned(stocks,date(2018,9,30),date(2021,1,30),date(2021,4,30),'Close')","90ac54f2":"result_df = pd.DataFrame.from_dict(results).T","4c892f35":"result_df.columns = [\"RMSE\", \"Actual_Profit\",\"Predicted_Profit\"]","d108204f":"result_df","15b912c0":"### Defining the parameters in FB Prophet-\n###### 1) growth - It states the growth of our trend . By default it is considered as linear , however if required it can also be changed to logistic. Here it shows if our stock has an upward trend or downward trend over the years\n###### 2) make_future_dataframe - It is a function used to predict or forecast the future output . The period for forecasting has to be speficied in number of days. Here we shall use this to predict the prices of our stock\n###### 3) changepoint_prior_scale - If the trend changes are being overfit (too much flexibility) or underfit (not enough flexibility), you can adjust the strength of the sparse prior using the input argument changepoint_prior_scale. By default, this parameter is set to 0.05. Increasing it will make the trend more flexible. Stock prices are drastically affected due to this is sensitivity to change\n###### 4) seasonality_prior_scale -  A parameter which adjusts the extent to which the seasonality models will fit the data. Again, stock prices are affected here as we are trying to control the change in seasonalities.\n###### 5) daily,weekly,monthly,yearly seasonalities -  Parameters which adjusts the extent to which the daily,weekly,monthly,yearly changes will fit the stock's prices.\n###### 6) fourier order - Seasonalities are estimated using a partial Fourier sum.The number of terms in the partial sum ( or the order) is a parameter that determines how quickly the seasonality can change.","534df8ea":"# Calculating Profit","e2b237ed":"## Base Model"}}