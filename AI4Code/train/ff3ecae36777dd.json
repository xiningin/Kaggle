{"cell_type":{"b00b9d8b":"code","9ca6cb05":"code","6cdfc51a":"code","46f33939":"code","998bc3c2":"code","d2e12626":"code","dd823c1a":"code","448857cb":"code","45e2ad9d":"code","944dd54f":"code","7c42f7ca":"code","6717d469":"code","80f4aa27":"code","88a5275c":"code","e40c278d":"code","447f1c42":"code","c24684c7":"code","cbad8781":"markdown","d24be974":"markdown","8b306add":"markdown","59aaefbd":"markdown","db8d42c5":"markdown","3ad411c6":"markdown","0c065cf0":"markdown","d8a14a62":"markdown","d5d1dfbc":"markdown","e4d9cd5e":"markdown","70c08e8f":"markdown","7bebafa0":"markdown","c08abcc7":"markdown","ab5ded80":"markdown","f79fbddb":"markdown","0a5f5a60":"markdown"},"source":{"b00b9d8b":"import pandas as pd\nimport numpy as np\nfrom timeit import default_timer as timer\nfrom IPython.display import HTML\nfrom sklearn.model_selection import train_test_split","9ca6cb05":"train = pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/train.csv', index_col='Id')\ntest = pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/test.csv', index_col='Id')\nsample_sub = pd.read_csv('..\/input\/tabular-playground-series-dec-2021\/sample_submission.csv')","6cdfc51a":"train.head()","46f33939":"test.head()","998bc3c2":"train.drop(train[train[\"Cover_Type\"] == 5].index, axis=0, inplace=True)","d2e12626":"cols = test.columns\ncategorical_features = cols[10:]\n\ntrain[\"mean\"] = train[cols].mean(axis=1)\ntrain[\"min\"] = train[cols].min(axis=1)\ntrain[\"max\"] = train[cols].max(axis=1)\ntrain[\"cat_feat_cnt\"] = train[categorical_features].sum(axis=1)\n\ntest[\"mean\"] = test[cols].mean(axis=1)\ntest[\"min\"] = test[cols].min(axis=1)\ntest[\"max\"] = test[cols].max(axis=1)\ntest[\"cat_feat_cnt\"] = test[categorical_features].sum(axis=1)","dd823c1a":"X = train.drop(['Cover_Type'], axis=1)\ny = train['Cover_Type']","448857cb":"x_train, _, y_train, _ = train_test_split(X, y, test_size=0.9, random_state=1)\ndel X\ndel y","45e2ad9d":"from sklearn.preprocessing import MinMaxScaler, StandardScaler\n\nscaler_x = MinMaxScaler()\nx_train = scaler_x.fit_transform(x_train)\ntest = scaler_x.transform(test)","944dd54f":"!pip install scikit-learn-intelex -q --progress-bar off","7c42f7ca":"from sklearnex import patch_sklearn\npatch_sklearn()","6717d469":"from sklearn.svm import SVC\n\nstart = timer()\nmodel = SVC(C=0.55, random_state=1).fit(x_train, y_train)\nend = timer()\nfit_time_opt = end - start\nprint(f'Intel\u00ae Extension for Scikit-learn* fit time: {fit_time_opt \/ 60} minutes')","80f4aa27":"start = timer()\ny_pred = model.predict(test)\nend = timer()\npredict_time_opt = end - start\nprint(f'Intel\u00ae Extension for Scikit-learn* prediction time: {predict_time_opt \/ 60} minutes')","88a5275c":"from sklearnex import unpatch_sklearn\nunpatch_sklearn()","e40c278d":"from sklearn.svm import SVC\n\nstart = timer()\nmodel = SVC(C=0.55, random_state=1).fit(x_train, y_train)\nend = timer()\nfit_time_original = end - start\nprint(f'Original Scikit-learn fit time: {fit_time_original \/ 60} minutes')","447f1c42":"start = timer()\ny_pred = model.predict(test)\nend = timer()\npredict_time_original = end - start\nprint(f'Original Scikit-learn prediction time: {predict_time_original \/ 60} minutes')","c24684c7":"HTML(f'<h2>Fit stage speedup: {(fit_time_original\/fit_time_opt):.2f}x<\/h2>'\n     f'(from {(fit_time_original \/ 60):.2f} minutes to {(fit_time_opt \/ 60):.2f} minutes)'\n     f'<h2>Prediction stage speedup: {(predict_time_original\/predict_time_opt):.2f}x<\/h2>'\n     f'(from {(predict_time_original \/ 60):.2f} minutes to {(predict_time_opt \/ 60):.2f} minutes)')","cbad8781":"<big>Normalize the data<\/big>","d24be974":"<big>Delete example with <code>Cover_type = 5<\/code> because only one sample has this cover type.<\/big>","8b306add":"# Train SVC algorithm\n<big>The main idea of the method is to transfer the initial vectors to a space of higher dimension and search for a separating hyperplane with the largest gap in this space. Two parallel hyperplanes are drawn on both sides of the hyperplane separating the classes. The separating hyperplane is the hyperplane that creates the greatest distance to two parallel hyperplanes.<\/big><br><br>\n\n<big>Parameter:<\/big><br>\n<big>* <code>C<\/code> -  Parameter inverse to the regularization coefficient.<br><\/big>","59aaefbd":"# \ud83d\ude80 Fast SVC with Intel\u00ae Extension for Scikit-learn*","db8d42c5":"<big>Split the data into features and target.<\/big>","3ad411c6":"<h2>Installing Intel\u00ae Extension for Scikit-learn<\/h2>\n\n<big>Use Intel\u00ae Extension for Scikit-learn* for fast compute Scikit-learn estimators.<\/big>","0c065cf0":"<big>Add some new features.<\/big>","d8a14a62":"<big>For classical machine learning algorithms, we often use the most popular Python library, Scikit-learn. With Scikit-learn you can fit models and search for optimal parameters, but\u202fit\u202fsometimes works for hours.<\/big><br><br>\n\n<big>I want to show you how to use Scikit-learn library and get the results faster without changing the code. To do this, we will make use of another Python library, <strong>\u202f<a href='https:\/\/github.com\/intel\/scikit-learn-intelex'>Intel\u00ae Extension for Scikit-learn*<\/a><\/strong>.<\/big><br><br>\n\n<big>I will show you how to <strong>speed up your kernel more than 20 times<\/strong> without changing your code!<\/big><big>","d5d1dfbc":"<h2>Conclusions<\/h2>\n<big>We can see that using only one classical machine learning algorithm may give you a pretty hight accuracy score. We also use well-known libraries Scikit-learn and Optuna, as well as the increasingly popular library Intel\u00ae Extension for Scikit-learn. Noted that Intel\u00ae Extension for Scikit-learn gives you opportunities to:<\/big>\n\n* <big>Use your Scikit-learn code for training and inference without modification.<\/big>\n* <big>Speed up training and prediction stages<\/big>.","e4d9cd5e":"<big>Patch original scikit-learn.<\/big>","70c08e8f":"<h2>Importing data<\/h2>","7bebafa0":"<h2>Prediction<\/h2>","c08abcc7":"<big>Let's look at prediction time of original Scikit-learn.<\/big>","ab5ded80":"<h2>Preprocessing<\/h2>","f79fbddb":"<h2>Now we use the same algorithm with original scikit-learn<\/h2>\n<big>Let\u2019s run the same code with original Scikit-learn and compare it's execution time with the execution time of the patched by Intel\u00ae Extension for Scikit-learn.<\/big><br>\n<big>In order to cancel optimizations, we use unpatch_sklearn and reimport the class SVC<\/big>","0a5f5a60":"<big>Let's take 10 percent of the data from the entire dataset for training, because SVC does not have time to train in 9 hours. On the full dataset SVC has a score of about 0.95158.<\/big>"}}