{"cell_type":{"58469ee3":"code","42d4d163":"code","95c5baa3":"code","b5913773":"code","0365d992":"code","8ac58de4":"code","3c888b60":"code","12320806":"code","4a4cb83d":"code","d691ee07":"code","5daf1644":"code","ae81b004":"code","b5732fd1":"code","c451a93d":"code","b7054f52":"code","d41c9982":"code","a0ba3290":"markdown","3e267dd2":"markdown","a7783da0":"markdown","b69880c8":"markdown","a8f17eec":"markdown","51f671fb":"markdown","4a3b6067":"markdown","e27a554a":"markdown","3247b7f5":"markdown","181a0714":"markdown","2218ab25":"markdown","217f828d":"markdown","97e74512":"markdown","31792893":"markdown","a95fa66d":"markdown","17766b41":"markdown"},"source":{"58469ee3":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport os\nimport random\nimport sys\nimport gc\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport cv2\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split \nfrom sklearn.preprocessing import LabelBinarizer\nimport PIL\nfrom PIL import Image\nfrom IPython.display import SVG\nfrom keras.utils.vis_utils import model_to_dot\n\nimport keras\nfrom keras import layers\nfrom keras import metrics\nfrom keras.models import load_model\nfrom keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D, GlobalAveragePooling2D, Dropout\nfrom keras import optimizers\nfrom keras import models\nfrom keras.models import Sequential\nfrom keras import preprocessing\nfrom keras.preprocessing import image\nfrom keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img\nfrom keras.applications import VGG16\nfrom keras.utils import plot_model","42d4d163":"img_size = 224\nbatch_size = 32\nepochs = 100\ntrain_size = 0.7\nval_size = 0.2\ntest_size = 0.1\nseed = 4242\nchannels = 3\nlearning_rate = 0.00001","95c5baa3":"d = '..\/input\/tobacco3482-jpg-balanced\/Tobacco3482-jpg-balanced\/'\nPATH = '..\/'\n\nclasses = (os.listdir(d))\n\npaths = [os.path.join(d, o) for o in os.listdir(d) \n                    if os.path.isdir(os.path.join(d,o))]\n\nnbEntries = []\n\nfor i in range(len(classes)):\n    nbEntries.append(len(os.listdir(paths[i])))\n\n#################################################\n    \nprint(classes)\nprint(nbEntries)\n\ndf = pd.DataFrame({'classes':classes, 'entries':nbEntries})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 classes Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-30))","b5913773":"total_set = []\ntotal_labels = []\n\n\nfor root, dirs, files in os.walk(d):\n    for file in files:\n        if file.endswith(\".jpg\"):\n            path = os.path.join(root, file)\n            total_set.append(path)\n            total_labels.append(root.split(os.path.sep)[-1])\n            \n\n# Return image class based on list entry (path)         \ndef getClass(img):\n    return img.split(os.path.sep)[-2]\n\n\nprint(total_set[0])\nprint('GetClass : ', getClass(total_set[0]))\nprint('Label : ', total_labels[0])","0365d992":"random.Random(seed).shuffle(total_set)\n\nfor ima in total_set[0:3] :\n    print(ima)\n    img = mpimg.imread(ima)\n    plt.figure(figsize=(7,7))\n    imgplot = plt.imshow(img, cmap=\"gray\")\n    plt.show()\n","8ac58de4":"# Get data and separate it in sets\ntotal_len = len(total_set)\nindex = 0\n\ntrain_set = []\ntrain_label = []\n\nval_set = []\nval_label = []\n\ntest_set = []\ntest_label = []\n\n\nfor i in total_set[0: int(total_len*train_size)] :\n    train_set.append(i)\n    train_label.append(getClass(i))\n    \nindex = int(total_len*train_size)+1\n    \nfor i in total_set[index: int(index + total_len*val_size)] :\n    val_set.append(i)\n    val_label.append(getClass(i))\n    \nindex = int(index + total_len*val_size)+1 \n\nfor i in total_set[index: total_len] :\n    test_set.append(i)\n    test_label.append(getClass(i))\n\nprint(val_set[200])\nprint(val_label[200])\n","3c888b60":"#################################################\n# TRAIN SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in train_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TRAIN SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-20))\n\n#################################################\n# VAL SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in val_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 VAL SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-3))\n    \n#################################################\n# TEST SET\ninstances = [0] * len(classes)\nfor index, val in enumerate(classes) :\n    for e in test_set :\n        if(val == getClass(e)) :\n            instances[index] += 1\n\n            \ndf = pd.DataFrame({'classes':classes, 'entries':instances})\nax = df.sort_values(by='entries', ascending=True).plot.bar(x='classes', y='entries', color='cornflowerblue',legend=False, figsize=(12,8))\nax.set_title('Tobacco3482 TEST SET Distribution')\nax.set_ylabel(\"# entries\")\nfor p in ax.patches:\n    ax.annotate(str(p.get_height()), xy=(p.get_x(), p.get_height()-8))","12320806":"def process_images(img_set) : \n    processed_img = []\n\n    for i in range(len(img_set)) :\n        processed_img.append(cv2.resize(cv2.imread(img_set[i], cv2.IMREAD_COLOR), (img_size, img_size)))\n    \n    return processed_img\n    \ndata_train = process_images(train_set)\ndata_test = process_images(test_set)\ndata_val = process_images(val_set)","4a4cb83d":"lb = LabelBinarizer()\nlb.fit(list(classes))\n\nx_train = np.array(data_train)\ny_train =lb.transform(np.array(train_label))\n\nx_test = np.array(data_test)\ny_test = lb.transform(np.array(test_label))\n\nx_val = np.array(data_val)\ny_val = lb.transform(np.array(val_label))\n\nprint(\"train images shape : \", x_train.shape)\nprint(\"train labels shape : \", y_train.shape)\nprint(x_train[0])\n\nprint(\"test shape : \", x_test.shape)\nprint(y_test.shape)\nprint(\"valdiation shape : \", x_val.shape)\nprint(y_val.shape)\n\n\nfor i in range(3) :\n    plt.figure(figsize=(6,6))\n    imgplot = plt.imshow(x_train[i])\n\nprint(train_label[0])\nprint(y_train[0])\nprint(lb.classes_)","d691ee07":"base_model = VGG16(weights = \"imagenet\", include_top=False, input_shape = (img_size, img_size, channels))\n\n#for layer in base_model.layers:\n#    layer.trainable = False\n    \nbase_model.summary()","5daf1644":"model = models.Sequential()\n\nmodel.add(base_model)\nmodel.add(layers.Flatten())\nmodel.add(layers.Dense(128, activation='relu',  name='dense'))\nmodel.add(layers.Dropout(0.5))\nmodel.add(layers.Dense(len(classes), activation='softmax',  name='predictions'))\n\nmodel.summary()\n\nprint('Number of trainable weights : ', len(model.trainable_weights))\n\nplot_model(model, to_file='model.png')\nSVG(model_to_dot(model).create(prog='dot', format='svg'))","ae81b004":"model.compile(optimizer=optimizers.Adam(lr=learning_rate), loss='categorical_crossentropy', metrics=['accuracy'])\n\ntrain_model = model.fit(x_train, y_train,\n                        batch_size=batch_size,\n                        epochs=epochs,\n                        verbose=1,\n                        validation_data=(x_val, y_val))","b5732fd1":"plt.plot(train_model.history['loss'])\nplt.plot(train_model.history['val_loss'])\nplt.title('model loss')\nplt.ylabel('loss')\nplt.xlabel('epoch')\nplt.grid()\nplt.legend(['training loss', 'validation loss'], loc='upper right')\nplt.show()\n\nplt.plot(train_model.history['acc'])\nplt.plot(train_model.history['val_acc'])\nplt.title('model accuracy')\nplt.grid()\nplt.ylabel('accuracy')\nplt.xlabel('epoch')\nplt.legend(['training accuracy', 'validation accuracy'], loc='lower right')\nplt.show()","c451a93d":"# combine predictions + average for better score ? \n\nscore = model.evaluate(x_test, y_test, verbose=1)\nprint('Test loss:', score[0])\nprint('Test accuracy:', score[1])","b7054f52":"model.save('trained_model.h5')","d41c9982":"predictions = model.predict_classes(x_test, verbose=1)\npredictions_list = predictions.tolist()\npredicted_classes = lb.classes_\n\ncount_true = 0;\ncount_false = 0;\n\nfor i, prediction in enumerate(predictions_list):\n    state = True\n    if (predicted_classes[prediction] != test_label[i]) :\n        state = False\n        count_false += 1\n    else :\n        count_true += 1\n    print(\"Prediction : \", predicted_classes[prediction], \"   |   Real class : \", test_label[i],  \"   |   Result : \", state)\n\nprint(\"\\nNumber of success : \", count_true) \nprint(\"Number of error : \", count_false) \nprint(\"Error rate : \", count_true\/len(test_label))\n","a0ba3290":"# Create base model (using pretrained CNN)\n\n[https:\/\/keras.io\/applications\/](https:\/\/keras.io\/applications\/)\n\nTrainable weights : TRUE\n\nTo \"freeze\" a layer means to exclude it from training. Allows to train the whole model and not only the last added layers --> 5\/10% better accuracy. it takes about three to four times longer for training since there are way more parameters to train.\n","3e267dd2":"# Get all images","a7783da0":"# Plot accuracy and loss of trained model (line chart)","b69880c8":"# Visualize classes distribution (bar chart)","a8f17eec":"# Sorting data in usable sets\n![](https:\/\/cdn-images-1.medium.com\/max\/800\/1*HpvpA9pBJXKxaPCl5tKnLg.jpeg)","51f671fb":"# Training the model","4a3b6067":"# Test prediction accuracy on test set","e27a554a":"# Plot data ","3247b7f5":"# Create custom model\nBase is VGG16, adding a flatten layer, a Dense layer and a dropout layer. Last Dense layer specify the number of classes\n\n[https:\/\/keras.io\/getting-started\/sequential-model-guide\/](https:\/\/keras.io\/getting-started\/sequential-model-guide\/)\n\n[https:\/\/keras.io\/layers\/core\/](https:\/\/keras.io\/layers\/core\/)","181a0714":"# Use model on test set","2218ab25":"# Save model\n* the architecture of the model, allowing to re-create the model\n* the weights of the model\n* the training configuration (loss, optimizer)\n* the state of the optimizer, allowing to resume training exactly where you left off.","217f828d":"# Preprocess data (resize, transform to Numpy array and binarize)\n\n[https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelBinarizer.html](https:\/\/scikit-learn.org\/stable\/modules\/generated\/sklearn.preprocessing.LabelBinarizer.html)","97e74512":"# Imports","31792893":"# Global variables","a95fa66d":"**Compile** : Configures the model for training.\n\n**Fit** : Trains the model for a given number of epochs (iterations on a dataset).\n\n[https:\/\/keras.io\/models\/model\/](https:\/\/keras.io\/models\/model\/)","17766b41":"# Get classes and entries per classes"}}