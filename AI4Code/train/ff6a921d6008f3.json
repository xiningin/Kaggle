{"cell_type":{"9a22d615":"code","84447644":"code","907ca092":"code","37b794ee":"code","d82abb4f":"code","4ebae97a":"code","3bc34346":"markdown","00b340f3":"markdown","4874a731":"markdown","ae5a9b2f":"markdown","1eb56769":"markdown"},"source":{"9a22d615":"import os\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom subprocess import check_output\nfrom sklearn import datasets, svm, metrics\nfrom numpy import asarray\nfrom sklearn.model_selection import train_test_split","84447644":"\"\"\"\n    La fonction suivante va cr\u00e9er un maillage de points sur un graphique avec les param\u00e8tres suivants :\n        - x: donn\u00e9e sur l'axe X du maillage\n        - y: donn\u00e9e sur l'axe Y du maillage\n        - h: \"granularit\u00e9\" du maillage. Ce param\u00e8tre est optionnel, car totalement esth\u00e9tique\n\n    Retour :\n        - xx, yy : ndarray (N dimentionnal array : Array \u00e0 N dimensions)\n\"\"\"\n\n\ndef creation_maillage(x, y, h=0.02):\n    \n    x_min, x_max = x.min() - 1, x.max() + 1\n    y_min, y_max = y.min() - 1, y.max() + 1\n    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),\n                         np.arange(y_min, y_max, h))\n    return xx, yy\n\n\ndef plot_contours(ax, clf, xx, yy, **params):\n    \"\"\"\n    Entr\u00e9es :\n        - ax: matplotlib axes object\n        - clf: Classifieur\n        - xx: ndarray de l'axe X du maillage\n        - yy: ndarray de l'axe Y du maillage\n        - params: Ensemble de param\u00e8tres pass\u00e9s, optionnel car c'est un param\u00e8tre esth\u00e9tique-\u00e8(\u00e7_\u00e0ezrt)\n    \"\"\"\n    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n    out = ax.contourf(xx, yy, Z, **params)\n    return out\n\n\n# Importation de la base de donn\u00e9es Iris\niris = datasets.load_iris()\n\nX = iris.data[:, :2] # On prend uniquement les donn\u00e9es qui nous interessent : La longueur et largeur des s\u00e9pales\ny = iris.target # Classe de chaque \u00e9l\u00e9ment : Ici, l'esp\u00e8ce de l'iris\n\n#C : Param\u00e8tre de r\u00e9gularisation du SVM\nmodels = (svm.SVC(kernel='linear', C=1.0),\n          svm.SVC(kernel='poly', degree=3, gamma='auto', C=1.0))\nmodels = (clf.fit(X, y) for clf in models)\n\n# Titres des graphiques\ntitles = ('SVC Avec un noyeau lin\u00e9aire',\n          'SVC avec un noyau polynomial de degr\u00e9 3')\n\nfig, sub = plt.subplots(2, 1,figsize=(15,15))\nplt.subplots_adjust(wspace=0.4, hspace=0.4)\n\nX0, X1 = X[:, 0], X[:, 1]\nxx, yy = creation_maillage(X0, X1)\n\nfor clf, title, ax in zip(models, titles, sub.flatten()):\n    plot_contours(ax, clf, xx, yy,\n                  cmap=plt.cm.coolwarm, alpha=0.8)\n    ax.scatter(X0, X1, c=y, cmap=plt.cm.coolwarm, s=40, edgecolors='k')\n    ax.set_xlim(xx.min(), xx.max())\n    ax.set_ylim(yy.min(), yy.max())\n    ax.set_xlabel('Longueur des s\u00e9pales', fontsize = 20)\n    ax.set_ylabel('Largeur des s\u00e9pales', fontsize = 20)\n    ax.set_xticks(())\n    ax.set_yticks(())\n    ax.set_title(title)\n    ax.title.set_size(20)\n\nplt.show()\n","907ca092":"ref = pd.read_csv('..\/input\/referencesm\/referencesm.csv')\nchiffres = datasets.load_files('..\/input\/datasetf')\nmatrices = np.zeros((16, 16, 1))\n\n# 2 Solutions : \n#On affiche chaque \u00e9l\u00e9ment, manuellement, en passant par os\ndef affichageAppelOS():\n    i = 1\n    for dirname, _, filenames in os.walk('..\/input\/dataset'):\n        for filename in filenames:\n            print(os.path.join(dirname, filename))\n            if(i<10):\n                plt.figure(figsize=(100,100))\n                plt.subplot(1, 10,i)\n                img_array = np.array(Image.open(os.path.join(dirname, filename)))\n                plt.imshow(img_array)\n                plt.title(filename[0]) #Premier caract\u00e8re du nom de fichier : ici, le chiffre correspondant\n                i = i+1\n                \n#Ou on utilise le fichier csv contenant tout ce qu'il faut pour r\u00e9f\u00e9rencer chaque image \ndef affichageAppelRef(matrices):\n    for i in range(len(ref)): #len(ref)\n        if(i<10):\n            plt.figure(figsize=(50,50))\n            plt.subplot(1, 10,i+1)\n            img_array = np.array(Image.open(ref['images'][i]))\n            plt.imshow(img_array)\n            plt.title(ref['target_names'][i])\n            \n        img_array = np.array(Image.open(ref['images'][i]))\n        matrice = asarray(img_array)        \n        temp = []\n        j=0\n        for j in range(256): #On r\u00e9cup\u00e8re la valeur rouge de chaque pixel\n            temp.append(matrice[j\/\/16][j%16][0])\n            \n        matrice = temp\n        matrices = np.append(matrices,matrice)\n\n    return matrices\n\nmatrices = affichageAppelRef(matrices);\nmatrices = matrices[256:] #On retire la premiere image toute noire, ajout\u00e9e lors de l'initialisation    \nprint(matrices.shape)\nprint(matrices)\n\n","37b794ee":"nbImages = len(ref)\ndata_images = matrices.reshape((nbImages),(16*16))\n\ndef affichageSympa(data,j):\n    i=0\n    for i in range(256):\n        if(i%16==0):\n            print(\"\\n\")\n        v = int(data[j][i-1])\n        if(v==0):\n            print(' '+str(v)+' ',end = ' ')\n        else:\n            print(v,end = ' ')\n\n            \naffichageSympa(data_images,0)\nprint(\"\\n\")","d82abb4f":"\nvalues = ref[\"target_names\"].to_list()\nvalues = np.array(values)\n\n\nX_train, X_test, y_train, y_test = train_test_split(data_images,values,test_size=0.10)\nprint(\"Donn\u00e9es d'entrainement et le nombre : \\n{}, {}\".format(X_train.shape,y_train.shape))\nprint(\"Donn\u00e9es de test et le nombre: \\n{}, {}\".format(X_test.shape,y_test.shape))\n\n# Cr\u00e9ation d'un SVC : Support vector classifier\nclassifier = svm.SVC(kernel='linear', C=1.0, gamma=0.001)\nclassifier.fit(X_train,y_train)\n\n#Pr\u00e9dition \u00e0 partir des donn\u00e9es de test\ny_predict = classifier.predict(X_test)\nprint(\"Les donn\u00e9es tests :    \", y_test)\nprint(\"Les donn\u00e9es pr\u00e9dites : \", y_predict)\n\nprint(\"\\nRapport de classification pour le classifieur %s:\\n%s\\n\" % (classifier, metrics.classification_report(y_test, y_predict)))\n\ndef affichageSympa(data,j):\n    i=0\n    for i in range(256):\n        if(i%16==0):\n            print(\"\\n\")\n        v = int(data[j][i-1])\n        if(v==0):\n            print(' '+str(v)+' ',end = ' ')\n        else:\n            print(v,end = ' ')\n\n            \naffichageSympa(X_test,0)\nprint(\"\\n\")","4ebae97a":"labels = np.unique(ref['target_names'])\n\nmatrice = metrics.confusion_matrix(y_test, y_predict,labels = labels)\ndf = pd.DataFrame(matrice,index=labels,columns=labels)\n\n\ndef affichageMatrice(l,df):\n    print(\"La matrice de confusion :\\n\")\n    print(\"\\t\\t     R\u00e9el\")\n    print('\\t  0  1  2  3  4  5  6  7  8  9\\n')\n    switcher={\n        2: \"P   \" + str(df.index[3]) + \"    \" + str(df.iloc[3:4].to_string(index=False,header=False)),\n        3: \"r   \" + str(df.index[3]) + \"    \" + str(df.iloc[3:4].to_string(index=False,header=False)),\n        4: \"\u00e9   \" + str(df.index[4]) + \"    \" + str(df.iloc[4:5].to_string(index=False,header=False)),\n        5: \"d   \" + str(df.index[5]) + \"    \" + str(df.iloc[5:6].to_string(index=False,header=False)),\n        6: \"i   \" + str(df.index[6]) + \"    \" + str(df.iloc[6:7].to_string(index=False,header=False)),\n        7: \"t   \" + str(df.index[3]) + \"    \" + str(df.iloc[3:4].to_string(index=False,header=False)),\n     }\n    \n    for i in range(len(l)) :\n        print(switcher.get(i,\"    \"+ str(df.index[i]) + \"    \"+ str(df.iloc[i:i+1].to_string(index=False,header=False))))\n    \naffichageMatrice(labels,df)","3bc34346":"# 1- Exercices avec les iris\n\nObjectifs : Prendre en main et s'entrainer sur les fonctions","00b340f3":"### Matrice de Confusion","4874a731":"Importation des librairies","ae5a9b2f":"## 2 - Reconnaissance de chiffres\n\n### Importation du jeu de donn\u00e9es et affichage d'une partie des images (10 premi\u00e8res)","1eb56769":"### Division des donn\u00e9es en 2 ensembles : Entrainement et Test"}}