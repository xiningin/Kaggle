{"cell_type":{"d060217e":"code","f6b61b2d":"code","a5520fa0":"code","f9b55b23":"code","49ec68b1":"code","63ac58ee":"code","7fc9444a":"code","c362f328":"code","f0b7f5d3":"code","b2a9b1c0":"code","7eb7aa39":"code","2046a64e":"code","6dbd9d04":"code","8e629782":"code","f84257b9":"code","cadec463":"code","7b5f72b8":"code","2ee19e36":"code","953da8c0":"code","216f5e0d":"code","cab494bc":"code","f3c86e92":"code","211485c5":"code","68edb412":"markdown"},"source":{"d060217e":"import pandas as pd\nimport numpy as np\nimport os\nimport cv2\nfrom PIL import Image, ImageDraw\nfrom ast import literal_eval\nimport matplotlib.pyplot as plt\nimport urllib\nfrom tqdm.notebook import tqdm\n\n","f6b61b2d":"# Install Retinanet\n\n!git clone https:\/\/github.com\/fizyr\/keras-retinanet\n","a5520fa0":"%cd keras-retinanet\/\n\n!pip install .\n!python setup.py build_ext --inplace","f9b55b23":"import numpy as np\nimport shutil\nimport pandas as pd\nimport os, sys, random\nimport xml.etree.ElementTree as ET\nimport pandas as pd\nfrom os import listdir\nfrom os.path import isfile, join\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport requests\nimport urllib\nfrom keras_retinanet.utils.visualization import draw_box, draw_caption , label_color\n\nfrom keras_retinanet.utils.image import preprocess_image, resize_image\n\nimport tensorflow as tf\nfrom keras_retinanet import models\nfrom keras_retinanet.utils.image import read_image_bgr, preprocess_image, resize_image\nfrom keras_retinanet.utils.visualization import draw_box, draw_caption\nfrom keras_retinanet.utils.colors import label_color\nfrom keras_retinanet.utils.compute_overlap import compute_overlap","49ec68b1":"import pandas as pd\n\n\n\npngPath='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/treinoTodas\/'\nannotPath='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/treinoTodas\/'\n\n# ..\/input\/uftp-covid-lung\/Kaggle_LabelImg\/validacaoTodas\npngPath_val='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/validacaoTodas\/'\nannotPath_val='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/validacaoTodas\/'\n\n\ndata=pd.DataFrame(columns=['fileName','xmin','ymin','xmax','ymax','class'])\ndata_val=pd.DataFrame(columns=['fileName','xmin','ymin','xmax','ymax','class'])\n\nos.getcwd()\n#read All files\nallfiles = [f for f in listdir(annotPath) if isfile(join(annotPath, f))]\nallfiles_val = [f for f in listdir(annotPath_val) if isfile(join(annotPath_val, f))]\n\nprint('Train files:'+ str(len(allfiles)))\nprint('Val files:'+ str(len(allfiles_val)))\n\ntotalNormal = 0\ntotalCovid = 0\n\nfor file in allfiles:\n  if \"Normal\" in file:\n    totalNormal += 1\n  if \"COVID\" in file:\n    totalCovid += 1\n\nprint('total normal: ' + str(totalNormal))\nprint('total covid: ' + str(totalCovid))","63ac58ee":"\n#Read all pdf files in images and then in text and store that in temp folder \n#Read all pdf files in images and then in text and store that in temp folder\nfor file in allfiles:\n  #print(file)\n  if (file.split(\".\")[1]=='xml'):\n    fileName='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/treinoTodas\/'+file.replace(\".xml\",'.png')\n    tree = ET.parse(annotPath+file)\n    root = tree.getroot()\n    for obj in root.iter('object'):\n        cls_name = obj.find('name').text\n        xml_box = obj.find('bndbox')\n        xmin = xml_box.find('xmin').text\n        ymin = xml_box.find('ymin').text\n        xmax = xml_box.find('xmax').text\n        ymax = xml_box.find('ymax').text\n        # Append rows in Empty Dataframe by adding dictionaries\n        \n        data = data.append({'fileName': fileName, 'xmin': xmin, 'ymin':ymin,'xmax':xmax,'ymax':ymax,'class':cls_name}, ignore_index=True)\n\ndata.shape\n\n\n#Read all pdf files in images and then in text and store that in temp folder \n#Read all pdf files in images and then in text and store that in temp folder\nfor file in allfiles_val:\n  #print(file)\n  if (file.split(\".\")[1]=='xml'):\n    fileName='\/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/validacaoTodas\/'+file.replace(\".xml\",'.png')\n    tree = ET.parse(annotPath_val+file)\n    root = tree.getroot()\n    for obj in root.iter('object'):\n        cls_name = obj.find('name').text\n        xml_box = obj.find('bndbox')\n        xmin = xml_box.find('xmin').text\n        ymin = xml_box.find('ymin').text\n        xmax = xml_box.find('xmax').text\n        ymax = xml_box.find('ymax').text\n        # Append rows in Empty Dataframe by adding dictionaries\n        \n        data_val = data_val.append({'fileName': fileName, 'xmin': xmin, 'ymin':ymin,'xmax':xmax,'ymax':ymax,'class':cls_name}, ignore_index=True)\n\ndata_val.shape","7fc9444a":"# data.to_csv('\/kaggle\/input\/lungcovid\/ufp\/Kaggle_LabelImg\/treinoTodas\/annotationFormat.csv')\nprint(data.head)","c362f328":"# pick a random image\nfilepath = data.sample()['fileName'].values[0]\n\n# get all rows for this image\ndf2 = data[data['fileName'] == filepath]\nim = np.array(Image.open(filepath))\n\n# if there's a PNG it will have alpha channel\n#im = im[:,:,:3]\n\nfor idx, row in df2.iterrows():\n    box = [\n      row['xmin'],\n      row['ymin'],\n      row['xmax'],\n      row['ymax'],\n    ]\n    print(box)\n    draw_box(im, box, color=(255, 0, 0))\n\nplt.axis('off')\nplt.imshow(im)\nplt.show()                        \n\n#show_image_with_boxes(data)","f0b7f5d3":"#Check few records of data\ndata.head()","b2a9b1c0":"data.to_csv('..\/annotation.csv', header = False, index=False)\ndata_val.to_csv('..\/annotation_val.csv', header = False, index=False)","7eb7aa39":"#Define labels & write them in a file\nclasses = ['Normal','C19']\nwith open('..\/maskDetectorClasses.csv', 'w') as f:\n  for i, class_name in enumerate(classes):\n    f.write(f'{class_name},{i}\\n')         \n\nif not os.path.exists('snapshots'):\n  os.mkdir('snapshots')","2046a64e":"PRETRAINED_MODEL = '.\/snapshots\/_pretrained_model.h5'\n\nURL_MODEL = 'https:\/\/github.com\/fizyr\/keras-retinanet\/releases\/download\/0.5.1\/resnet50_coco_best_v2.1.0.h5'\nurllib.request.urlretrieve(URL_MODEL, PRETRAINED_MODEL)\n\nprint('Downloaded pretrained model to ' + PRETRAINED_MODEL)","6dbd9d04":"from tensorflow.keras import backend\n\n#tf.compat.v1.Session()\n#python keras_retinanet\/bin\/train.py --gpu 0 --snapshot-path .\/snapshots --backbone resnet50 --batch-size 1 --epochs 2000 --steps 1000 --tensorboard-dir=.\/log --weights ~\/.keras\/models\/ResNet-50-model.keras.h5 csv images.train.csv classes.csv\n# total of 4894 images\n\n#Put your training data path & file that has labels for your training data\n!keras_retinanet\/bin\/train.py --freeze-backbone  --random-transform --snapshot-path .\/snapshots  --weights {PRETRAINED_MODEL}  --steps 250 --tensorboard-dir=.\/log --epochs 100 csv ..\/annotation.csv ..\/maskDetectorClasses.csv","8e629782":"from glob import glob\nmodel_paths = glob('.\/snapshots\/resnet50_csv_0*.h5')\n#model_paths = glob('snapshots\/resnet50_csv_15.h5')\nlatest_path = sorted(model_paths)[-1]\nprint(\"path:\", latest_path)\n\n\nfrom keras_retinanet import models\n\nmodel = models.load_model(latest_path, backbone_name='resnet50')\nmodel = models.convert_model(model)\nmodel.save('..\/modelo_11_06.h5')\n\nlabel_map = {}\nfor line in open('..\/maskDetectorClasses.csv'):\n  row = line.rstrip().split(',')\n  label_map[int(row[1])] = row[0]","f84257b9":"# \/kaggle\/input\/uftp-covid-lung\/Kaggle_LabelImg\/validacaoTodas\/annotation.csv\n\n# python .\/bin\/convert_model.py .\/snapshots\/xx.h5 .\/infer_models\/xx.h5\n\n!keras_retinanet\/bin\/evaluate.py csv ..\/annotation_val.csv  ..\/maskDetectorClasses.csv  ..\/modelo_11_06.h5\n","cadec463":"# os.chdir(r'\/kaggle\/working')\n# %cd \/kaggle\/working\/keras-retinanet\/snapshots\n# %ls\n\nfrom IPython.display import FileLink\n# FileLink(r'resnet50_csv_30.h5')\nFileLink(r'\/kaggle\/working\/keras-retinanet\/snapshots\/resnet50_csv_50.h5')","7b5f72b8":"model.summary()","2ee19e36":"import time\n\ndef img_retinaNet_test():\n  # choose a random image\n  row = data.sample()\n  filepath = row['fileName'].values[0]\n  print(\"filepath:\", filepath)\n  # get all rows for this image\n  df2 = data[data['fileName'] == filepath]\n  im = np.array(Image.open(filepath))\n  print(\"im.shape:\", im.shape)\n\n  #plt.imshow(im)\n\n\n  # copy to draw on\n  draw = im.copy()\n  draw = cv2.cvtColor(draw, cv2.COLOR_BGR2RGB)\n\n  # preprocess image for network\n  image = preprocess_image(draw)\n  image, scale = resize_image(image)\n\n  # process image\n  start = time.time()\n  boxes, scores, labels = model.predict_on_batch(np.expand_dims(image, axis=0))\n  print(\"processing time: \", time.time() - start)\n\n\n  # correct for image scale\n  boxes \/= scale\n\n  # visualize detections\n  for box, score, label in zip(boxes[0], scores[0], labels[0]):\n      # scores are sorted so we can break\n      if score < 0.5:\n          break\n          \n      color = label_color(label)\n      \n      b = box.astype(int)\n      draw_box(draw, b, color=color)\n      \n      caption = \"{} {:.3f}\".format(classes[label], score)\n      draw_caption(draw, b, caption)\n      \n  plt.figure(figsize=(15, 15))\n  plt.axis('off')\n  plt.imshow(draw)\n  plt.show()\n\n","953da8c0":"img_retinaNet_test()\n\nimg_retinaNet_test()\n\nimg_retinaNet_test()\n\nimg_retinaNet_test()\n\nimg_retinaNet_test()\n\nimg_retinaNet_test()","216f5e0d":"fig, ax = plt.subplots(nrows=3, ncols=3, figsize=(10, 10))\nfor i in range(3):\n     for j in range(3):\n      row = data.sample()\n      filepath = row['fileName'].values[0]\n      print(\"filepath:\", filepath)\n      # get all rows for this image\n      df2 = data[data['fileName'] == filepath]\n      im = np.array(Image.open(filepath))\n      print(\"im.shape:\", im.shape)\n\n       # copy to draw on\n      draw = im.copy()\n      draw = cv2.cvtColor(draw, cv2.COLOR_BGR2RGB)\n\n      # preprocess image for network\n      image = preprocess_image(draw)\n      image, scale = resize_image(image)\n\n      # process image\n      start = time.time()\n      boxes, scores, labels = model.predict_on_batch(np.expand_dims(image, axis=0))\n      print(\"processing time: \", time.time() - start)\n\n      real = filepath.split('\/')[6]\n\n      # correct for image scale\n      boxes \/= scale\n\n      # visualize detections\n      for box, score, label in zip(boxes[0], scores[0], labels[0]):\n          # scores are sorted so we can break\n          if score < 0.5:\n              break\n              \n          color = label_color(label)\n          \n          b = box.astype(int)\n          draw_box(draw, b, color=color)\n          \n          caption = \"{} {:.3f}\".format('predito: '+ classes[label] + ' Correto:' + real, score)\n          draw_caption(draw, b, caption)\n          \n      \n      ax[i][j].axis('off')\n      ax[i][j].imshow(draw)\n  \n        \n\nplt.show()","cab494bc":"\n\ny_val = list()\npredictions = list()\nos.getcwd()\n  ","f3c86e92":"\n#read All files\nallfilesCovid = [f for f in listdir(pngPath_val) if isfile(join(pngPath_val, f))]\n# print(allfilesCovid)\nprint(len(allfilesCovid))\n\nfor file in allfilesCovid:\n    if (file.split(\".\")[1]=='png'):\n#         y_val.append(1)\n        im = np.array(Image.open(pngPath_val + file))\n         # copy to draw on\n        draw = im.copy()\n        draw = cv2.cvtColor(draw, cv2.COLOR_BGR2RGB)\n\n        # preprocess image for network\n        image = preprocess_image(draw)\n        image, scale = resize_image(image)\n\n\n        boxes, scores, labels = model.predict_on_batch(np.expand_dims(image, axis=0))\n    #     print(\"processing time: \", time.time() - start)\n\n        # correct for image scale\n        boxes \/= scale\n\n        # visualize detections\n        for box, score, label in zip(boxes[0], scores[0], labels[0]):\n            if label == 1:\n                predictions.append(1)\n                if 'COVID' in str(file):\n                    y_val.append(1)\n                else:\n                   y_val.append(0)\n            if label == 0:\n                predictions.append(0)\n                if 'COVID' in str(file):\n                    y_val.append(1)\n                else:\n                   y_val.append(0)\n            break\n\n        \nprint(len(predictions))","211485c5":"\nprint(len(y_val))\nprint(len(predictions))\n\n\n\nimport seaborn as sns\n\ncm = tf.math.confusion_matrix(labels=y_val, predictions=predictions, num_classes=2)\n# Normalize the confusion matrix so that each row sums to 1.\ncm = tf.cast(cm, dtype=tf.float32)\ncm = cm \/ tf.math.reduce_sum(cm, axis=1)[:, np.newaxis]\n\nsns_plot = sns.heatmap(cm, annot=True, xticklabels=classes, yticklabels=classes);\nplt.xlabel(\"Predicted\");\nplt.ylabel(\"True\");\n\nsns_plot.figure.savefig(\"..\/confusion_matrix.png\")","68edb412":"**VALIDATION PART**\n\ni did the download of the h5 file, from the revision (save version 1)\nUpload the file to a new directory and execute the code below.\nThis step is importante because dont need train the model again..."}}