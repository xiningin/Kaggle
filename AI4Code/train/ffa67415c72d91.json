{"cell_type":{"c1c56ff7":"code","8a81a775":"code","adb6a07a":"code","87a9a6d6":"code","2ceb5aca":"code","b6785e65":"code","da97ebf4":"code","67ba6253":"code","ece50f10":"code","02147998":"code","d3704ab0":"code","ebaabc2b":"code","3133727c":"code","e1ca00b4":"code","921691a0":"code","9e46a541":"code","040f5daf":"code","736c59a0":"code","f7bc519d":"code","0782d7f2":"code","acd7abe6":"code","a0800c5b":"code","d7175bcc":"code","37099d37":"code","0714201c":"code","b47ec020":"code","ff687802":"code","5435bcfd":"code","5b59eb1c":"code","85bfe5a9":"code","77e66b2d":"code","a189dba2":"code","dfff4bfd":"code","e4331d04":"code","54b2c26c":"code","bd469f91":"code","373c862d":"code","2753479c":"code","9114ea72":"code","ef3b5a32":"code","a3803f40":"code","f3e79a2b":"code","61e449f5":"code","7bf3f088":"code","7e436d46":"code","f388ee60":"code","3f8b963d":"code","acb3a9a9":"code","a89176ae":"code","da791b1f":"code","4ae00926":"code","53f367ba":"code","3e6a8307":"code","10c1cae1":"code","2be332ac":"code","0bc02bc6":"code","806131a5":"code","4049c17b":"code","4fcdc29d":"code","724360f7":"code","08b04afa":"code","cb5a14e9":"code","a977513e":"code","a2dab54d":"code","63f587f5":"code","a1de68e2":"code","a053ce93":"code","041b2372":"code","dc36db56":"code","2098a79f":"code","54527ebe":"markdown","6cb1ea9f":"markdown","ae42707d":"markdown","f8c04a82":"markdown","a168078c":"markdown","5bb418ac":"markdown","b6acfbc2":"markdown","161f99bb":"markdown","1c2f112f":"markdown","acadf344":"markdown","39c782a7":"markdown","359a4b7a":"markdown","56d52446":"markdown","5a66cf46":"markdown","8bf7989e":"markdown","eab19286":"markdown","56b9346b":"markdown","5de35f15":"markdown","8a5581c4":"markdown","26cd0be8":"markdown","9f7a1eed":"markdown","df2e591e":"markdown","900464b3":"markdown","8d1b1033":"markdown"},"source":{"c1c56ff7":"pip install Pillow","8a81a775":"import PIL\nprint('Pillow Version:', PIL.__version__)","adb6a07a":"from skimage import data\nimport PIL\n# load and show an image with Pillow\nfrom PIL import Image\n# load the image\nimage = data.rocket()\nimage","87a9a6d6":"from matplotlib import pyplot\n# display the array of pixels as an image\npyplot.imshow(image)\npyplot.show()","2ceb5aca":"import matplotlib.pyplot as plt\n\nfrom skimage import data\nfrom skimage.color import rgb2gray\n\noriginal = data.astronaut()\ngrayscale = rgb2gray(original)\n\nfig, axes = plt.subplots(1, 2, figsize=(8, 4))\nax = axes.ravel()\n\nax[0].imshow(original)\nax[0].set_title(\"Original\")\nax[1].imshow(grayscale, cmap=plt.cm.gray)\nax[1].set_title(\"Grayscale\")\n\nfig.tight_layout()\nplt.show()","b6785e65":"# create a Show_image FUnction\ndef show_img(image, title='Image', cmap_type='gray'):\n    plt.imshow(image, cmap=cmap_type)\n    plt.title('Show your image')\n    plt.axis('off')\n    plt.show()","da97ebf4":"# Import the modules from skimage\nfrom skimage import data, color\n\n# Load the rocket image\nrocket = data.rocket()\n\n# Convert the image to grayscale\ngray_scaled_rocket = color.rgb2gray(rocket) \n\n# Show the original image\nshow_img(rocket, 'Original RGB image')\n\n# Show the grayscale image\nshow_img(gray_scaled_rocket, 'Grayscale image')","67ba6253":"# images as nd arrays\ntype(image)","ece50f10":"# obtaining with the \n# obtaining red values of an image\nimport numpy as np\n# Obtain the red channel\n#red_channel = image[:, :, 0]\n\n# Plot the red histogram with bins in a range of 256\n#plt.hist(red_channel.ravel(), bins=256)\n\n# Set title and show\n#plt.title('Red Histogram')\n#plt.show()","02147998":"# flip the image vertically\ngr = image\nv_f =np.flipud(gr)\nshow_img(v_f, 'Vertically Flipped Image')","d3704ab0":"# Flip the image vertically\nseville_vertical_flip = np.flipud(gr)\n\n# Flip the previous image horizontally\nseville_horizontal_flip = np.fliplr(gr)","ebaabc2b":"show_img(seville_horizontal_flip, 'Seville')","3133727c":"show_img(seville_vertical_flip, 'none')","e1ca00b4":"# obtain the optimal threholding value\nthresh = 127\nimage = np.array(image)\n# apply to image\nbinary = image > thresh","921691a0":"# Import the otsu threshold function\nfrom skimage.color import rgb2gray\nfrom skimage.filters import threshold_otsu\n\n# Make the image grayscale using rgb2gray\nimage_gray = color.rgb2gray(image)\n\n# Obtain the optimal threshold value with otsu\nthresh = threshold_otsu(image_gray)\n\n# Apply thresholding to the image\nbinary = image_gray > thresh\n\n# Show the image\nshow_img(binary, 'Binary image')","9e46a541":"# Import the local threshold function\nfrom skimage.filters import threshold_local\n\n# Set the block size to 35\n##block_size = 35\n\n# Obtain the optimal local thresholding\n##local_thresh = threshold_local(page_image, block_size, offset=10)\n\n# Obtain the binary image by applying local thresholding\n##binary_local = page_image > local_thresh\n\n# Show the binary image\n##show_img(binary_local, 'Local thresholding')","040f5daf":"# Import the try all function\nfrom skimage.filters import try_all_threshold\nimage = Image.open(r'C:\\Users\\muham\\Downloads\\france-in-pictures-beautiful-places-to-photograph-eiffel-tower (1).png')\nimage = np.array(image)\n# Import the rgb to gray convertor function \nfrom skimage.color import rgb2gray\n\n# Turn the fruits_image to grayscale\ngrayscale = rgb2gray(image)\n\n# Use the try all method on the resulting grayscale image\nfig, ax = try_all_threshold(grayscale, verbose=False)\n\n# Show the resulting plots\nplt.show()","736c59a0":"# Import the try all function\nfrom skimage.filters import try_all_threshold\n\n# Import the rgb to gray convertor function \nfrom skimage.color import rgb2gray\n\n# Turn the fruits_image to grayscale\ngrayscale = rgb2gray(image)\n\n# Use the try all method on the resulting grayscale image\nfig, ax = try_all_threshold(grayscale, verbose=False)\n\n# Show the resulting plots\nplt.show()","f7bc519d":"def plot_comparison(original, filtered, title_filtered):\n  fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 6), sharex=True, sharey=True)\n  ax1.imshow(original, cmap=plt.cm.gray) \n  ax1.set_title('original') \n  ax1.axis('off')\n  ax2.imshow(filtered, cmap=plt.cm.gray) \n  ax2.set_title(title_filtered) \n  ax2.axis('off')","0782d7f2":"# Edge detection- Sobel\nfrom skimage.filters import sobel\n# Apply edge detection algos\nedge_sobel = sobel(image)\n# Show Image comparison\nplot_comparison(image, edge_sobel, 'Edge with Sobel')","acd7abe6":"# Import the color module\nfrom skimage import color\n\n# Import the filters module and sobel function\nfrom skimage.filters import sobel\n\n# Make the image grayscale\nsoaps_image_gray = color.rgb2gray(image)\n\n# Apply edge detection filter\nedge_sobel = sobel(image)\n\n# Show original and resulting image to compare\nshow_img(soaps_image_gray, \"Original\")\nshow_img(edge_sobel, \"Edges with Sobel\")","a0800c5b":"# Import Gaussian filter \nfrom skimage.filters import gaussian\nimage = Image.open(r'C:\\Users\\muham\\Downloads\\observation-urban-building-business-steel_1127-2397.jpg')\nimage = np.array(image)\n# Apply filter\ngaussian_image = gaussian(image, multichannel=True)\n\n# Show original and resulting image to compare\nshow_img(image, \"Original\")\nshow_img(gaussian_image, \"Reduced sharpness Gaussian\")","d7175bcc":"from skimage import exposure as ex\n# obtain the equalized image\nimg_eq = ex.equalize_hist(image)\n# show Original and result\nshow_img(image, 'Original')\nshow_img(img_eq, 'Histogram equalized')","37099d37":"# Import the required module\nfrom skimage import exposure\nchest_xray_image = Image.open(r'C:\\Users\\muham\\Downloads\\chestray.jpg')\nchest_xray_image = np.array(chest_xray_image)\n# Show original x-ray image and its histogram\nshow_img(chest_xray_image, 'Original x-ray')\n\nplt.title('Histogram of image')\nplt.hist(chest_xray_image.ravel(), bins=256)\nplt.show()","0714201c":"# Import the required module\nfrom skimage import exposure\n\n# Show original x-ray image and its histogram\nshow_img(chest_xray_image, 'Original x-ray')\n\nplt.title('Histogram of image')\nplt.hist(chest_xray_image.ravel(), bins=256)\nplt.show()\n\n# Use histogram equalization to improve the contrast\nxray_image_eq =  exposure.equalize_hist(chest_xray_image)\n\n# Show the resulting image and its stats\nshow_img(xray_image_eq, 'Resulted image')\nplt.title('Histogram of resulting image')\nplt.hist(xray_image_eq.ravel(), bins=256)\nplt.show()","b47ec020":"# Import the required module\nfrom skimage import exposure\nimage_aerial = Image.open(r'C:\\Users\\muham\\Downloads\\Aerial_Survey_in_Action.jpg')\nimage_aerial = np.array(image_aerial)\n# Use histogram equalization to improve the contrast\nimage_eq1 =  exposure.equalize_hist(image_aerial)\n\n# Show the original and resulting image\nshow_img(image_aerial, 'Original')\nshow_img(image_eq1, 'Resulting image')","ff687802":"# Import the necessary modules\nfrom skimage import data, exposure\n\n# Load the image\noriginal_image = data.coffee()\n\n# Apply the adaptive equalization on the original image\nadapthist_eq_image = exposure.equalize_adapthist(original_image, clip_limit=0.03)\n\n# Compare the original image to the equalized\nshow_img(original_image)\nshow_img(adapthist_eq_image, '#ImageProcessingDatacamp')","5435bcfd":"# rotating image clockwise\n#90 degrees\nfrom skimage.transform import rotate as rt\nimge_rotate = rt(original_image, -90)\nshow_img(imge_rotate, 'Rotated image')","5b59eb1c":"from skimage.transform import rescale\nimg_rs = rescale(image, 1\/4, anti_aliasing=True, multichannel=True)\nshow_img(img_rs,'Rescaled')","85bfe5a9":"from skimage.transform import resize\n# set proportional height so its 4 times its size\nheight = image.shape[0] \/4\nwidth = image.shape[1] \/4\n# converted to int as it cannot read in floats\nwidth = int(width)\nheight = int(height)\nimage_resize = resize(image, (height, width), anti_aliasing=True)\nshow_img(image_resize, 'Resized')","77e66b2d":"# Import the data module\nfrom skimage import data\n\n# Load the image from data\nrocket_image = data.rocket()\n\n# Enlarge the image so it is 3 times bigger\nenlarged_rocket_image = rescale(rocket_image, 0.5, anti_aliasing=True, multichannel=True)\n\n# Show original and resulting image\nshow_img(rocket_image)\nshow_img(enlarged_rocket_image, \"0.5 times enlarged image\")","a189dba2":"# Import the module and function\nfrom skimage.transform import resize\n\n# Set proportional height and width so it is half its size\nheight = int(image.shape[0] \/ 2.0)\nwidth = int(image.shape[1] \/ 2.0)\n# Resize using the calculated proportional height and width\nimage_resized = resize(image, (height, width),\n                       anti_aliasing=True)\n\n# Show the original and rotated image\nshow_img(image, 'Original')\nshow_img(image_resized, 'Resized image')","dfff4bfd":"original_image.shape","e4331d04":"from skimage import morphology\nsquare = morphology.square(4)\nrectangle = morphology.rectangle(4,2)\nselem = morphology.rectangle(417, 626) # KNOWN AS EROSION START\n# OBTAIN EROSED IMAGE WITH BINARY EROSION\n#ERODED_IMAGE = morphology.binary_erosion(image, selem=selem)\n# plot_comparison(image, ERODED_IMAGE,'Erosion')","54b2c26c":"# Obtain dilated image\ndil_img = morphology.binary_dilation(image)","bd469f91":"#ERODED_IMAGE = morphology.binary_erosion(dil_img, selem=selem)","373c862d":"# See results\n#show_image(upper_r_image, 'Original')\n#show_image(eroded_image_shape, 'Eroded image')","2753479c":"def get_mask(image):\n    ''' Creates mask with three defect regions '''\n    mask = np.zeros(image.shape[:-1])\n    mask[101:106, 0:240] = 1\n    mask[152:154, 0:60] = 1\n    mask[153:155, 60:100] = 1\n    mask[154:156, 100:120] = 1\n    mask[155:156, 120:140] = 1\n    mask[212:217, 0:150] = 1\n    mask[217:222, 150:256] = 1\n    return mask","9114ea72":"from skimage.restoration import inpaint\n# obtain the image\nmask = get_mask(image)\n# Apply inpainting to the damaged image using the mask\nrestored_image = inpaint.inpaint_biharmonic(image,mask,multichannel=True)\n# Show the resulting image\nshow_img(image)\nshow_img(restored_image)","ef3b5a32":"image_with_logo = Image.open(r'C:\\Users\\muham\\Downloads\\imagelogo.jpg')\nimage_with_logo = np.array(image_with_logo)","a3803f40":"# Initialize the mask\n#mask = np.zeros(image_with_logo.shape[:-1])\n\n# Set the pixels where the logo is to 1\n# mask[210:290, 360:425] = 1\n\n# Apply inpainting to remove the logo\n#image_logo_removed = inpaint.inpaint_biharmonic(image_with_logo, \n                                                #mask[210:290, 360:425], \n                                                #multichannel=True)\n\n# Show the original and logo removed images\n#show_img(image_with_logo, 'Image with logo')\n#show_img(image_logo_removed, 'Image with logo removed')","f3e79a2b":"from skimage.util import random_noise\n# add noise to the image\nn_image = random_noise(image)\n# original vs noise image\nshow_img(image)\nshow_img(n_image)","61e449f5":"from skimage.restoration import denoise_tv_chambolle\n# apply total variation filter denoising\ndenoised_image = denoise_tv_chambolle(n_image, weight=0.1, multichannel=True)\nshow_img(n_image)\nshow_img(denoised_image)","7bf3f088":"from skimage.restoration import denoise_bilateral\ndenoised_img_b = denoise_bilateral(n_image,multichannel=True)\nshow_img(denoised_image)\nshow_img(denoised_img_b)","7e436d46":"# import the modules\nfrom skimage.segmentation import slic \nfrom skimage.color import label2rgb\n# obtain the segments\nsegments = slic(image, start_label = 1)\n# compare segments of the orignal image \nseg_image = label2rgb(segments, image, kind='avg', bg_label=0)\n\nshow_img(image)\nshow_img(seg_image)","f388ee60":"# Finding contours\nimage = color.rgb2gray(image)\n# Binarize the image\nthresh = threshold_otsu(image)\nthresh_image = thresh > image","3f8b963d":"# find  counters\nfrom skimage import measure\ncontours = measure.find_contours(thresh_image, 0.8)\ncontours = np.array(contours)","acb3a9a9":"for contour in contours:\n    print(contours.shape)","a89176ae":"# Import the modules\nfrom skimage import measure, data, filters\n\n# Obtain the horse image\nhorse_image = data.horse()\n\n# Find the contours with a constant level value of 0.8\ncontours = measure.find_contours(horse_image, 0.8)\n\n# Shows the image with contours found\nshow_img(horse_image, contours)","da791b1f":"# function to find image corners\ndef show_img_corners(image, coords, title=\"Corners detected\"): \n  plt.imshow(image, interpolation='nearest', cmap='gray') \n  plt.title(title)\n  plt.plot(coords[:, 1], coords[:, 0], '+r', markersize=15) \n  plt.axis('off')\n  plt.show()","4ae00926":"# A function to show the contour of the image \ndef show_image_contour(image, contours):\n    plt.figure()\n    for n, contour in enumerate(contours):\n        plt.plot(contour[:, 1], contour[:, 0], linewidth=3)\n    plt.imshow(image, interpolation='nearest', cmap='gray_r')\n    plt.title('Contours')\n    plt.axis('off')\n    plt.show()","53f367ba":"# Make the image grayscale\nimage = color.rgb2gray(image)\n\n# Obtain the optimal thresh value\nthresh = filters.threshold_otsu(image)\n# Apply thresholding\nbinary = image > thresh","3e6a8307":"# Find contours at a constant value of 0.8\ncontours = measure.find_contours(binary, 0.8)\n\n# Show the image\nshow_image_contour(image, contours)","10c1cae1":"# Create list with the shape of each contour \nshape_contours = [cnt.shape[0] for cnt in contours]\n\n# Set 50 as the maximum size of the dots shape\nmax_dots_shape = 50\n\n# Count dots in contours excluding bigger than dots size\ndots_contours = [cnt for cnt in contours if np.shape(cnt)[0] < max_dots_shape]\n\n# Shows all contours found \nshow_image_contour(binary, contours)\n\n# Print the dice's number\nprint(\"Dice's dots number: {}. \".format(len(dots_contours)))","2be332ac":"from skimage.feature import canny \n# convert image to grayscale\ncoins = data.coins()\ncoins = rgb2gray(coins)\n# check edges\nedges = canny(coins)\nshow_img(coins)\nshow_img(edges)","0bc02bc6":"# less edges\nedges = canny(coins, sigma=1.8)\nshow_img(edges)","806131a5":"from skimage.feature import corner_harris, corner_peaks\nimage = rgb2gray(image)\nmeasure_image = corner_harris(image)\ncoords = corner_peaks(measure_image, min_distance=5, threshold_rel=0)","4049c17b":"print('total of', '', len(coords), 'were detected')","4fcdc29d":"show_img_corners(image, coords, title='Corners detected')","724360f7":"# Import the corner detector related functions and module\nfrom skimage.feature import corner_harris, corner_peaks\nrocket_image = data.rocket()\n# Convert image from RGB-3 to grayscale\nrocket_image_gray = color.rgb2gray(rocket_image)\n\n# Apply the detector  to measure the possible corners\nmeasure_image = corner_harris(building_image_gray)\n\n# Find the peaks of the corners\ncoords = corner_peaks(measure_image, min_distance=2)\n\n# Show original and resulting image with corners detected\nshow_img(rocket_image, \"Original\")\nshow_img_corners(rocket_image, coords)","08b04afa":"# Find the peaks with a min distance of 2 pixels\ncoords_w_min_2 = corner_peaks(measure_image, min_distance=2, threshold_rel=0)\nprint(\"With a min_distance set to 2, we detect a total\", len(coords_w_min_2), \"corners in the image.\")","cb5a14e9":"# All nessecary functions for face detections\nimport matplotlib.patches as patches\n\ndef crop_face(result, detected, title=\"Face detected\"):\n    for d in detected:\n        print(d)\n        rostro= result[d['r']:d['r']+d['width'], d['c']:d['c']+d['height']]\n    \n        plt.figure(figsize=(8, 6))\n        plt.imshow(rostro)    \n        plt.title(title)\n        plt.axis('off')\n        plt.show()","a977513e":"def show_detect_face(result, detected, title=\"Face image\"):\n    plt.imshow(result)\n    img_desc = plt.gca()\n    plt.set_cmap('gray')\n    plt.title(title)\n    plt.axis('off')\n\n    for patch in detected:\n        \n        img_desc.add_patch(\n            patches.Rectangle(\n                (patch['c'], patch['r']),\n                patch['width'],\n                patch['height'],\n                fill=False, color='r',linewidth=2))\nplt.show()","a2dab54d":"from skimage import data\nfrom skimage.feature import Cascade\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\n\n# Load the trained file from the module root.\ntrained_file = data.lbp_frontal_face_cascade_filename()\n\n# Initialize the detector cascade.\ndetector = Cascade(trained_file)\n\nimg = data.astronaut()\n\ndetected = detector.detect_multi_scale(img=img,\n                                       scale_factor=1.2,\n                                       step_ratio=1,\n                                       min_size=(60, 60),\n                                       max_size=(90, 500))\n\nplt.imshow(img)\nimg_desc = plt.gca()\nplt.set_cmap('gray')\n\nfor patch in detected:\n\n    img_desc.add_patch(\n        patches.Rectangle(\n            (patch['c'], patch['r']),\n            patch['width'],\n            patch['height'],\n            fill=False,\n            color='r',\n            linewidth=2\n        )\n    )\n\nplt.show()","63f587f5":"# Obtain the segmentation with default 100 regions\nsegments = slic(img)\n\n# Obtain segmented image using label2rgb\nsegmented_image = label2rgb(segments, img, kind='avg')\n\n# Detect the faces with multi scale method\ndetected = detector.detect_multi_scale(img=segmented_image, \n                                       scale_factor=1.2, \n                                       step_ratio=1, \n                                       min_size=(10, 10), max_size=(1000, 1000))\n\n# Show the detected faces\nshow_detected_face(segmented_image, detected)","a1de68e2":"# Load the trained file from data\ntrained_file = data.lbp_frontal_face_cascade_filename()\nfriends_image = Image.open(r'C:\\Users\\muham\\Downloads\\frnds.jfif')\nfriends_image = np.array(friends_image)\n# Initialize the detector cascade\ndetector = Cascade(trained_file)\n# Detect faces with scale factor to 1.2 and step ratio to 1\ndetected = detector.detect_multi_scale(img=friends_image,\n                                       scale_factor=1.2,\n                                       step_ratio=1,\n                                       min_size=(10, 10),\n                                       max_size=(300, 300))\n# Show the detected faces\nshow_detected_face(friends_image, detected)","a053ce93":"# functions to merge blurry Faces\ndef merge_blurry_face(original, gaussain_image):\n    # starting points of a face rectangle\n    x, y =d['r'], d['c']\n    # the width and heigh of a face rectangle\n    width, height = d['r'] + d['width'], d['c'] + d['height']\n    \n    original[x:width, y:height] = gaussain_image\n    return original","041b2372":"def getFaceRectangle(image, d):\n    ''' Extracts the face from the image using the coordinates of the detected image '''\n    # X and Y starting points of the face rectangle\n    x, y  = d['r'], d['c']\n    \n    # The width and height of the face rectangle\n    width, height = d['r'] + d['width'],  d['c'] + d['height']\n    \n    # Extract the detected face\n    face= image[ x:width, y:height]\n    return face","dc36db56":"#Privacy protection\n# Detect the faces\nfrom skimage.filters import gaussian\ndetected = detector.detect_multi_scale(img=image, \n                                       scale_factor=1.2, step_ratio=1, \n                                       min_size=(10, 10), max_size=(100, 100))\n# For each detected face\nfor d in detected:  \n    # Obtain the face rectangle from detected coordinates\n    face = getFaceRectangle(image,d)\n    \n    # Apply gaussian filter to extracted face\n    blurred_face = gaussian(face, multichannel=True, sigma = 8)\n    \n    # Merge this blurry face to our final image and show it\n    resulting_image = merge_blurry_face(image, blurred_face) \nshow_img(resulting_image, \"Blurred faces\")","2098a79f":"# Import the necessary modules\nfrom skimage.restoration import denoise_tv_chambolle, inpaint\nfrom skimage.transform import rotate\n\n# Transform the image so it's not rotated\nupright_img = rotate(image, 20)\n\n# Remove noise from the image, using the chambolle method\nupright_img_without_noise = denoise_tv_chambolle(upright_img,weight=0.1, multichannel=True)\n\n# Reconstruct the image missing parts\nmask = get_mask(upright_img)\nresult = inpaint.inpaint_biharmonic(upright_img_without_noise, mask, multichannel=True)\n\nshow_image(result)","54527ebe":"# Resizing Image ","6cb1ea9f":"# Denoising","ae42707d":"# Face detection","f8c04a82":"# Morphology: Filtering, operations\n# Shapes and erosion in Sckit images ","a168078c":"# Find contours of an image that is not binary","5bb418ac":"# Jump into filtering","b6acfbc2":"# Apply detector on images","161f99bb":"# Colors with Numpy","1c2f112f":"# Rescaling","acadf344":"# Numpy for images ","39c782a7":"# Segmentation and face detection","359a4b7a":"# Biltaeral filter","56d52446":"# Real-world applications - all shown above","5a66cf46":"# Image restoration","8bf7989e":"# Finding the edges with Canny","eab19286":"# Noise","56b9346b":"# Getting started with thresholding","5de35f15":"# Make images come alive with scikit-image","8a5581c4":"# Contrast enhancement","26cd0be8":"# Removing logos","9f7a1eed":"# Enlarging Images","df2e591e":"# Superpixels & segmentation - Supervised & Unsupervised","900464b3":"# Rotating","8d1b1033":"# Right around the corner - Harrsi corner detector"}}