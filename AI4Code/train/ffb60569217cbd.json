{"cell_type":{"cd1f14bd":"code","4930fe95":"code","9f1dc65c":"code","92a024de":"code","1a435c6a":"code","305f4595":"code","b59aa5cd":"code","4cea84f4":"code","10a81a1c":"code","f1ec9279":"code","130daf76":"code","2f486ab2":"code","f14fdfe4":"code","b1253243":"markdown","c9a2578b":"markdown","884de055":"markdown","203d7e26":"markdown","66acfe81":"markdown"},"source":{"cd1f14bd":"import numpy as np\nimport pandas as pd\nimport os\nimport xml.etree.ElementTree as ET\nimport zipfile\n\naddl_dir = \"..\/input\/cityofla\/CityofLA\/Additional data\"\n\n# First up: An example of what LA would like our output to look like at the end of the day\nsample_template = pd.read_csv(os.path.join(addl_dir, 'sample job class export template.csv'))\ndisplay(sample_template)","4930fe95":"# The data dictionary for reference:\ndata_dictionary = pd.read_csv(os.path.join(addl_dir, 'kaggle_data_dictionary.csv'))\ndisplay(data_dictionary)","9f1dc65c":"# Job titles listing:\njob_titles = pd.read_csv(os.path.join(addl_dir, 'job_titles.csv'), names=['JOB TITLES'])\ndisplay(job_titles.head())","92a024de":"class Docx(object):\n    '''Helper to pull Docx text into a python notebook.\n    \n    Args:\n        - path (str): where the docx file is stored.\n    Methods:\n        - read: open the doc, return its text.\n    '''\n    \n    def __init__(self, path):\n        self.path = path\n\n    def read(self):\n        '''Open the doc, return its text.'''\n        zipf = zipfile.ZipFile(self.path)\n        filelist = zipf.namelist()\n        text = Docx.xml2text(zipf.read('word\/document.xml'))\n        zipf.close()\n        return text\n\n    @staticmethod\n    def qn(tag):\n        '''Source: docx2txt'''\n        nsmap = {'w': 'http:\/\/schemas.openxmlformats.org\/wordprocessingml\/2006\/main'}\n        prefix, tagroot = tag.split(':')\n        uri = nsmap[prefix]\n        return '{{{}}}{}'.format(uri, tagroot)\n\n    @staticmethod\n    def xml2text(xml, mapping=None, version='new'):\n        '''Source: docx2txt'''\n        if mapping is None:\n            if version == 'default':\n                mapping = {'tab': '\\t',\n                           'break': '\\n',\n                           'page': '\\n\\n'}\n            elif version == 'new':\n                mapping = {'tab':' ', 'break':' ', 'page':' '}\n        text = u''\n        root = ET.fromstring(xml)\n        for child in root.iter():\n            if child.tag == Docx.qn('w:t'):\n                t_text = child.text\n                text += t_text if t_text is not None else ''\n            elif child.tag == Docx.qn('w:tab'):\n                text += mapping['tab']\n            elif child.tag in (Docx.qn('w:br'), Docx.qn('w:cr')):\n                text += mapping['break']\n            elif child.tag == Docx.qn(\"w:p\"):\n                text += mapping['page']\n        return text","1a435c6a":"print('`Description of promotions in job bulletins`.docx contents:\\n')\nprint(Docx(os.path.join(addl_dir, 'Description of promotions in job bulletins.docx')).read())","305f4595":"!apt-get install -y poppler-utils\n# Note: Internet must be enabled on this kernel (under settings on right-hand side)","b59aa5cd":"import tempfile\nimport shlex\nfrom subprocess import Popen, PIPE, STDOUT\n\nclass Pdf(object):\n    '''Parse *Searchable* PDF objects.\n    Args:\n        - path (str): where the docx file is stored.\n    Methods:\n        - read: open the doc, return its text.\n    '''\n    def __init__(self, path):\n        self.path = path\n\n    def read(self):\n        local_filename = tempfile.NamedTemporaryFile(delete=False).name\n        run_command_line(f'pdftotext {self.path} {local_filename} -layout')\n        with open(local_filename, 'r') as f:\n            return '\\n'.join(f.readlines())\n\ndef run_command_line(command_line_args):\n    '''Utility for running command line program via python\n    Args:\n        - command_line_args (str): what should be passed to command line\n    Returns:\n        - Bool: (not process.wait()) == 1 if program exited without error\n    '''\n    process = Popen(shlex.split(command_line_args), stdout=PIPE, stderr=STDOUT)\n    with process.stdout:\n        return parse_subprocess(process.stdout)\n    return not process.wait()\n\ndef parse_subprocess(pipe):\n    '''Parse output from subprocess.'''\n    return [line for line in iter(pipe.readline, b'')]","4cea84f4":"# It doesn't seem like any of these PDFs are searchable, would need to turn to OCR for parsing.\nPdf(os.path.join(addl_dir, 'PDFs\/2014\/September 2014\/09262014\/CHIEF INSPECTOR 4254.pdf')).read()","10a81a1c":"# Code from the starter kernel to iterate over Job Bulletins directory\nbulletin_dir = \"..\/input\/cityofla\/CityofLA\/Job Bulletins\"\ndata_list = []\nfor filename in os.listdir(bulletin_dir):\n    with open(bulletin_dir + \"\/\" + filename, 'r', errors='ignore') as f:\n        raw = []\n        for line in f.readlines():\n            raw.append(line)\n            if \"Open Date:\" in line:\n                job_bulletin_date = line.split(\"Open Date:\")[1].split(\"(\")[0].strip()\n        data_list.append([filename, job_bulletin_date, raw])\n\n# Form a DF \ndf = pd.DataFrame(data_list, columns=[\"FILE_NAME\", \"OPEN_DATE\", \"RAW\"])\ndf.OPEN_DATE = pd.to_datetime(df.OPEN_DATE)\ndf.head()","f1ec9279":"# Example listing for viewing\n# TBD: parsing of this data (!)\ndf.RAW[0]","130daf76":"# Very rough estimate of the number of words via base python\ndf.loc[:,'NUM_WORDS'] = [' '.join(lines).split(' ') for lines in df.loc[:,'RAW']]\ndf.loc[:,'NUM_WORDS'] = [len([word for word in words if word!='' and word!='\\n']) for words in df.loc[:,'NUM_WORDS']]","2f486ab2":"df.NUM_WORDS.describe()","f14fdfe4":"import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.hist(df.loc[:,'NUM_WORDS'], edgecolor='black')\nax.set_xlabel('Number of words in job posting')\n_=ax.set_ylabel('Number of occurrences')","b1253243":"### CSV viewing","c9a2578b":"### Docx conversion","884de055":"### PDF Conversion","203d7e26":"# Getting Started\n\n## Split approach based on filetype\n\n- CSVs: viewed as is, read in and described\n- Docx: parsed and returned as strings\n- PDFs: if a PDF is searchable, we can extract the text directly, otherwise we must use OCR\n- Txts: viewed as is, parsed, etc.","66acfe81":"### Text viewing"}}