{"cell_type":{"4225a541":"code","d1e749d1":"code","73d32c20":"code","566169b2":"code","d96aba89":"code","82489a61":"code","b2c911d3":"code","7f4cfe82":"code","43877574":"code","b9fd8859":"code","b713948c":"code","f83a1cc6":"code","b40ee842":"code","dab4cabb":"code","52b19827":"code","366761c0":"code","b131981a":"code","8f1538c5":"markdown","1356c44a":"markdown","933fb19a":"markdown","3b4f9dac":"markdown","a9ebea33":"markdown","31b8bd5e":"markdown","a3e13915":"markdown","1b4faf0f":"markdown","a1ab456d":"markdown","d4db6752":"markdown"},"source":{"4225a541":"import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom keras import layers, Input, Model\nfrom keras.callbacks import ModelCheckpoint, ReduceLROnPlateau\n\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.model_selection import StratifiedKFold\n\n%matplotlib inline","d1e749d1":"data_dir = '..\/input\/'\n!ls {data_dir}","73d32c20":"train_raw = pd.read_csv(f'{data_dir}train.csv')\ntrain_raw.head()","566169b2":"test_raw = pd.read_csv(f'{data_dir}test.csv')\ntest_raw.head()","d96aba89":"train_raw.shape, test_raw.shape","82489a61":"train_raw.isnull().sum().sum(), test_raw.isnull().sum().sum()","b2c911d3":"sns.countplot(train_raw.target)\nplt.show()","7f4cfe82":"train_raw.target.value_counts()","43877574":"trn_wheezy = pd.get_dummies(train_raw['wheezy-copper-turtle-magic'])\ntest_wheezy = pd.get_dummies(test_raw['wheezy-copper-turtle-magic'])\n\ntrn_wheezy.shape, test_wheezy.shape","b9fd8859":"target = train_raw.target\n\ntrain_raw.drop(['id', 'wheezy-copper-turtle-magic', 'target'], axis=1, inplace=True)\ntest_raw.drop(['id', 'wheezy-copper-turtle-magic'], axis=1, inplace=True)","b713948c":"sc = StandardScaler()\ntrain_x = sc.fit_transform(train_raw)\ntest_x = sc.transform(test_raw)","f83a1cc6":"train_x = np.concatenate([train_x, trn_wheezy.values], axis=1)\ntest_x = np.concatenate([test_x, test_wheezy.values], axis=1)","b40ee842":"def build_model():\n    inp = Input(shape=(train_x.shape[1],), name='input')\n    x = layers.Dense(1500, activation='relu')(inp)\n    x = layers.Dropout(0.6)(x)\n    x = layers.Dense(1000, activation='relu')(x)\n    x = layers.Dropout(0.55)(x)\n    x = layers.Dense(500, activation='relu')(x)\n    x = layers.Dropout(0.55)(x)\n    x = layers.Dense(1, activation='sigmoid')(x)\n    \n    model = Model(inp, x)\n    model.compile(optimizer='adam',\n                 loss='binary_crossentropy', metrics=['acc'])\n    \n    return model\n\nmodel = build_model()\nmodel.summary()","dab4cabb":"NFOLDS = 20\nNEPOCHS = 75\nfolds = StratifiedKFold(n_splits=NFOLDS, shuffle=True, random_state=42)\n\noof = np.zeros(train_raw.shape[0])\npredictions = np.zeros(test_raw.shape[0])\n\nfor fold_, (trn_idx, val_idx) in enumerate(folds.split(train_x, target)):\n    print(f'Fold - {fold_ + 1}')\n    \n    weights_path = f'weights.best.hdf5'\n    val_loss_checkpoint = ModelCheckpoint(weights_path, monitor='val_loss', verbose=0, save_best_only=True, mode='min')\n    reduceLR = ReduceLROnPlateau(monitor='val_loss', patience=5, verbose=0, mode='min', min_lr=1e-6)\n    \n    model = build_model()\n    model.fit(train_x[trn_idx], target.values[trn_idx], epochs=NEPOCHS, validation_data=(train_x[val_idx], target.values[val_idx]),\n         callbacks=[val_loss_checkpoint, reduceLR], batch_size=512, verbose=0)\n    model.load_weights(weights_path)\n    \n    val_preds = model.predict(train_x[val_idx], batch_size=2048, verbose=0)\n    print(f'ROC AUC: {roc_auc_score(target.values[val_idx], val_preds.reshape(-1))}')\n    \n    test_preds = model.predict(test_x, batch_size=2048, verbose=0)\n        \n    oof[val_idx] = val_preds.reshape(-1)\n    predictions += test_preds.reshape(-1)\/folds.n_splits","52b19827":"roc_auc_score(target.values, oof)","366761c0":"sub_df = pd.read_csv(f'{data_dir}sample_submission.csv')\nsub_df.target = predictions\nsub_df.head()","b131981a":"sub_df.to_csv('solution.csv', index=False)","8f1538c5":"### Model","1356c44a":"### Submission","933fb19a":"### Normalize features","3b4f9dac":"### Imports","a9ebea33":"### Target distribution","31b8bd5e":"### Loading data","a3e13915":"Looks like class labels are uniformly distributed in training data.","1b4faf0f":"### Categorical Feature","a1ab456d":"So there are no missing values in either training or test set.","d4db6752":"### Training"}}