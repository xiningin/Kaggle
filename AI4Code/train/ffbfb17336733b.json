{"cell_type":{"41967d64":"code","f402a1db":"code","786ae7c0":"code","81ad257d":"code","4492fd87":"code","879d5bb1":"code","89ad4ea8":"code","dfc66b6d":"code","1232d237":"code","312eb5a5":"code","a753204c":"code","001dc4c7":"code","345bb18e":"code","f3489df4":"code","24009c4f":"code","9b9bb6a2":"code","dbf3d4f0":"code","e7804c2b":"code","b2b5dfdc":"code","1374316f":"code","dbddda82":"code","842d2164":"code","be98bca9":"code","d6be6aa9":"code","a98216d7":"code","4cf4701a":"markdown","ec8fb62e":"markdown","c2286a9d":"markdown","276cdd4e":"markdown","7c1c8981":"markdown","c699cf66":"markdown","9b4926e1":"markdown","78423729":"markdown"},"source":{"41967d64":"import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I\/O (e.g. pd.read_csv)\nimport matplotlib.pyplot as plt\n\nimport geopandas as gpd\n\n\nimport os\nfor dirname, _, filenames in os.walk('\/kaggle\/input'):\n    for filename in filenames:\n        print(os.path.join(dirname, filename))\n","f402a1db":"import geopandas as gpd\n\ngeo_df = gpd.read_file(\"\/kaggle\/input\/map-data\/INDONESIA_PROP.shp\")\n","786ae7c0":"leg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left', 'bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_df.plot(column='Propinsi', cmap='Set1', legend=False, legend_kwds = leg_kwds, figsize = (30,30))\nplt.title('TITIK GEMPA')\nplt.show()","81ad257d":"# get data \ngeo_ = gpd.read_file(\"\/kaggle\/input\/map-data\/INDONESIA_PROP.shp\")\n# data can get \nfilter_sumatra_jawa = [ \"SUMATERA UTARA\", \"SUMATERA BARAT\",\"JAWA TENGAH\",\"PROBANTEN\",\"DI. ACEH\",\"JAWA TIMUR\",\"JAWA BARAT\" ,\"LAMPUNG\" ,\"DKI JAKARTA\",\"RIAU\", \"JAMBI\",\"BANGKA BELITUNG\" ,\"SUMATERA SELATAN\",\"DAERAH ISTIMEWA YOGYAKARTA\"]\n\nori_len = len(geo_)\ngeo_['Wilayah'] = list(range(len(geo_)))\n# filter data \nfor i in range(ori_len):\n    if geo_['Propinsi'][i] in filter_sumatra_jawa :\n        geo_['Wilayah'][i] = 1\n    else:\n        geo_['Wilayah'][i] = 0\ngeo_ = geo_[geo_['Wilayah'] == 1]\ngeo_.head()","4492fd87":"leg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left','bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_.plot(column='Propinsi', cmap='Set1', legend=True, legend_kwds = leg_kwds, figsize = (20,50))\nplt.title('TITIK GEMPA')\nplt.show()","879d5bb1":"train_09 = pd.read_csv('\/kaggle\/input\/data-gempa\/2009.csv')\ntrain_10 = pd.read_csv('\/kaggle\/input\/data-gempa\/2010.csv')\ntrain_11 = pd.read_csv('\/kaggle\/input\/data-gempa\/2011.csv')\ntrain_12 = pd.read_csv('\/kaggle\/input\/data-gempa\/2012.csv')\ntrain_13 = pd.read_csv('\/kaggle\/input\/data-gempa\/2013.csv')\ntrain_14 = pd.read_csv('\/kaggle\/input\/data-gempa\/2014.csv')\ntrain_15 = pd.read_csv('\/kaggle\/input\/data-gempa\/2015.csv')\ntrain_16 = pd.read_csv('\/kaggle\/input\/data-gempa\/2016.csv')\ntrain_17 = pd.read_csv('\/kaggle\/input\/data-gempa\/2017.csv')\ntrain_18 = pd.read_csv('\/kaggle\/input\/data-gempa\/2018.csv')\ntrain_all = [train_09,train_10,train_11,train_12,train_13,train_14,train_15,train_16,train_17,train_18 ]\n\n# me replace name stiap data\nfor i in train_all:\n    i.columns = ['index', 'Date', 'Time', 'Latitude', 'Longitude','Depth',\n              'Magnitude', 'TypeMag', 'smaj', 'smin', 'az', 'rms', 'cPhase',\n               'Region']\n    i.drop(0,axis=0,inplace=True)\n    \n# menyatukan data mendjadi 1 \ntrain = pd.concat(train_all)\n\n# mengsplit data dan membersihkan nilai menjadi number\ntrain[\"Longitude\"] = train.Longitude.apply(lambda x : x.split()[0])\ntrain[\"Depth\"] = train.Depth.apply(lambda x : x.split()[0])\ntrain[\"Magnitude\"] = train.Magnitude.apply(lambda x : x.split()[0])\ntrain[\"Time\"] = train.Time.apply(lambda x : x.split()[0])\n\n# meng ekstrak data \ntrain[\"year\"] = train.Date.apply(lambda x : x.split('\/')[2])\ntrain[\"date\"] = train.Date.apply(lambda x : x.split('\/')[1])\ntrain[\"month\"] = train.Date.apply(lambda x : x.split('\/')[0])\ntrain[\"hour\"] = train.Time.apply(lambda x : x.split(':')[0])\n\n\ntrain[\"Date\"] = train.Date.apply(lambda x : x.split()[0])\ntrain['Date'] = train[['Date', 'Time']].apply(lambda x : ' '.join(x), axis = 1)\ntrain['Date'] = pd.to_datetime(train['Date'])\n\ntrain.index = train['Date']","89ad4ea8":"train_len = len(train)\nfor i in range(train_len):\n    if train['Latitude'][i].split()[1] == 'LS':\n        train['Latitude'][i] = float(train['Latitude'][i].split()[0]) * -1\n    else:\n        train['Latitude'][i] = train['Latitude'][i].split()[0]\n\n#convert type data ke float\ncolumns = ['Latitude','Longitude', 'Depth', 'Magnitude']\nfor var in columns:\n    train[var] = train[var].astype(\"float64\")\n    \n\n","dfc66b6d":"train.head()","1232d237":"# Filter indonesia\ntrain = train.loc[((train['Latitude'] >= -12.5) & (train['Latitude'] <= 7) &  (train['Longitude'] >= 94.31644) & (train['Longitude'] <= 142.71813) )]","312eb5a5":"train.head()","a753204c":"leg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left', 'bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_df.plot(column='Propinsi', cmap='Set1', legend=True, legend_kwds = leg_kwds, figsize = (30,30))\nplt.title('TITIK GEMPA')\n\nplt.scatter(y= train.Latitude, x = train.Longitude , c = train.Magnitude, alpha=0.8);\nplt.show()","001dc4c7":"train5 = train[train['Magnitude'] >= 5.5]","345bb18e":"leg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left', 'bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_df.plot(column='Propinsi', cmap='Set1', legend=True, legend_kwds = leg_kwds, figsize = (30,30))\nplt.title('TITIK GEMPA')\n\nplt.scatter(y= train5.Latitude, x = train5.Longitude , c = train5.Magnitude, alpha=0.8);\nplt.show()","f3489df4":"train_loc = train.copy()\n\ntrain_loc = train_loc[train_loc.smin < 0.3]\n\nleg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left', 'bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_df.plot(column='Propinsi', cmap='Set1', legend=True, legend_kwds = leg_kwds, figsize = (30 ,30))\nplt.title('TITIK GEMPA')\n\nplt.scatter(y= train_loc.Latitude, x = train_loc.Longitude, alpha=0.8);\nplt.show()","24009c4f":"# 164 - 12 = 152\nfrom sklearn.cluster import KMeans\n\ntrain_clus = train_loc[['Latitude', 'Longitude']]\nnum_clusters = 152\n\nkm = KMeans(n_clusters=num_clusters, random_state = 1)\nkm.fit(train_clus)\nclusters = km.labels_.tolist()\n\ntrain_clus['Clustering'] = clusters\n\n\nloc_statiun = train_clus.groupby('Clustering').mean()\nloc_statiun = loc_statiun.reset_index()","9b9bb6a2":"leg_kwds = {'title':'NAMA WILAYAH', 'loc':'upper left', 'bbox_to_anchor':(1,1.05), 'ncol':1}\ngeo_df.plot(column='Propinsi', cmap='Set1', legend=False, legend_kwds = leg_kwds, figsize = (30,30))\nplt.title('Lokasi Statiun Gempa')\n\nplt.scatter(y= loc_statiun.Latitude, x = loc_statiun.Longitude, marker='^', alpha=1, c = '#1f77b4');\nplt.show()","dbf3d4f0":"train.head()","e7804c2b":"statiun_coords = {}\n\nfor dat in loc_statiun.iterrows():\n    row = dat[1]\n    \n    statiun_coords[int(row['Clustering'])] = (float(row['Latitude']), float(row['Longitude']))","b2b5dfdc":"#from pandas.tools.plotting import scatter_matrix\nfrom sklearn.model_selection import StratifiedShuffleSplit\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.preprocessing import StandardScaler\nfrom geopy.distance import vincenty\n\nimport gc","1374316f":"def closest_point(location, location_dict):\n    \"\"\" take a tuple of latitude and longitude and \n        compare to a dictonary of locations where\n        key = location name and value = (lat, long)\n        returns tuple of (closest_location , distance) \"\"\"\n    closest_location = None\n    for city in location_dict.keys():\n        distance = vincenty(location, location_dict[city]).kilometers\n        if closest_location is None:\n            closest_location = (city, distance)\n        elif distance < closest_location[1]:\n            closest_location = (city, distance)\n    return closest_location","dbddda82":"train_clus['close_station'] = train_clus.apply(lambda x: closest_point((x['Latitude'],x['Longitude']), statiun_coords), axis = 1)\n\ntrain_clus['close_station_name'] = [x[0] for x in train_clus['close_station'].values]\ntrain_clus['close_station_dist'] = [x[1] for x in train_clus['close_station'].values]\n\n\ntrain['close_station'] = train.apply(lambda x: closest_point((x['Latitude'],x['Longitude']), statiun_coords), axis = 1)\ntrain['close_station_name'] = [x[0] for x in train['close_station'].values]\ntrain['close_station_dist'] = [x[1] for x in train['close_station'].values]","842d2164":"train.head()","be98bca9":"# graph of vectors connecting points to their nearest city\n\ntrain.plot(kind='scatter', x='Longitude', y='Latitude',  marker='^', alpha=1, c = '#1f77b4', figsize= (30, 10 )\n\t\t\t\t)\n\nfor line in train.iterrows():\n\tdat = line[1]\n\tx1 = dat['Longitude']\n\ty1 = dat['Latitude']\n\tp2 = statiun_coords[dat['close_station_name']]\n\tx2 = p2[1]\n\ty2 = p2[0]\n\tplt.plot([x1,x2],[y1, y2], 'k-',linewidth=0.5)\n    \n    \n#plt.imshow(peta_gempa,  extent=[ 93 , 118.5, -13.3 , 7.7], alpha=0.9)\n#plt.imshow(peta_gempa,  extent=[ 90 , 115.5, -14.7 , 7.9], alpha=1)\nplt.ylabel(\"Latitude\", fontsize=14)\nplt.xlabel(\"Longitude\", fontsize=14)\nplt.title(\"Map Jaringan Lokasi Stasiun dengan Gempa\", fontsize = 20)\nplt.show()","d6be6aa9":"train5 = train[train['Magnitude'] >= 5.5]","a98216d7":"# graph of vectors connecting points to their nearest city\n\ntrain5.plot(kind='scatter', x='Longitude', y='Latitude',  marker='^', alpha=1, c = '#1f77b4', figsize = (30, 10)\n\t\t\t\t)\n\nfor line in train5.iterrows():\n    \n\tdat = line[1]\n\tx1 = dat['Longitude']\n\ty1 = dat['Latitude']\n\tp2 = statiun_coords[dat['close_station_name']]\n\tx2 = p2[1]\n\ty2 = p2[0]\n    \n\tplt.plot([x1,x2],[y1, y2], 'k-',linewidth=0.5)\n    \n    \n#plt.imshow(peta_gempa,  extent=[ 93 , 118.5, -13.3 , 7.7], alpha=0.9)\n#plt.imshow(peta_gempa,  extent=[ 90 , 115.5, -14.7 , 7.9], alpha=1)\nplt.ylabel(\"Latitude\", fontsize=14)\nplt.xlabel(\"Longitude\", fontsize=14)\nplt.title(\"Map Jaringan Lokasi Stasiun dengan Gempa magnitude di atas 5.5 SR\", fontsize = 20)\nplt.show()","4cf4701a":"## Menentukan Lokasi Stasiun gempa,\ndengan mengasumsikan bahwa gempa yang memiliki jarak (smin) kurang dari 0.3 (300) , disitulah daerah sekitar yang dekat dengan stasiun gempa\nsetelah itu kita melakukan clustering menggunakan k-means , untuk menentukan titik yang benar-benar tepat atau mengambil sentorid dari persebaran tersebut","ec8fb62e":"## Praprosesing Data \n\ndata di ambil dari data inatews , pada proses praprosesing ini kita akan membersikan data merubah format dan lain-lian","c2286a9d":"## Menghitung dan menentukan stasiun terdekat dari setiap gempa ","276cdd4e":"## melakukan k-means clustering untuk menentukan ","7c1c8981":"## Visualisation jaringan station seismic dengan titik gempa ","c699cf66":"# Spatial Polygon ","9b4926e1":"# Spatial Point and Spatial Polygon","78423729":"# Analysis Network Station seismik with earthquake"}}